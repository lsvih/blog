<!DOCTYPE html>













<html class="theme-next pisces" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '6U6P1RGK4F',
      apiKey: 'b14e73cdd627eabe947b5decbe14850f',
      indexName: 'lsvih',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="My note">
<meta property="og:url" content="https://lsvih.com/page/7/index.html">
<meta property="og:site_name" content="My note">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My note">



  <link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml">




  <link rel="canonical" href="https://lsvih.com/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>My note – lsvih</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">lsvih</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/09/卷积神经网络/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/09/卷积神经网络/" class="post-title-link" itemprop="url">卷积神经网络</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-09 16:25:34" itemprop="dateCreated datePublished" datetime="2017-08-09T16:25:34+08:00">2017-08-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CNN-是怎么学习的？学习了什么？"><a href="#CNN-是怎么学习的？学习了什么？" class="headerlink" title="CNN 是怎么学习的？学习了什么？"></a>CNN 是怎么学习的？学习了什么？</h2><p><strong>这篇文章是深度学习系列的一部分。你可以在</strong><a href="https://github.com/xitu/gold-miner/blob/master/TODO/deep-learning-1-setting-up-aws-image-recognition.md" target="_blank" rel="noopener"><strong>这里</strong></a><strong>查看第一部分，以及在</strong><a href="https://github.com/xitu/gold-miner/blob/master/TODO/deep-learning-3-more-on-cnns-handling-overfitting.md" target="_blank" rel="noopener"><strong>这里</strong></a><strong>查看第三部分。</strong></p>
<p><img src="/images/pasted-171.png" alt="upload successful"></p>
<p>这一周，我们将探索卷积神经网络（CNN）的内部工作原理。你可能会问：在网络内部究竟发生了什么？它们是怎样学习的？</p>
<p>这门课程遵循自上而下的学习方法与理念。因此一般来说，我们在开始学习的时候就能立即玩到所有的模型，然后我们会逐渐深入其内部的工作原理。因此，本系列也将会逐渐深入探索神经网络的内部工作原理。现在仅仅是第二周，让我们朝着最终的目标迈进吧！</p>
<p>在上周，我在猫狗图像集上训练了 Vgg 16 模型。我想先聊一下为什么说使用预先训练好的模型是一种很好的方法。为了使用这些模型，首先你得要弄清楚这些模型到底学习的是什么。从本质上说，CNN 学习的是过滤器，并将学习到的过滤器应用于图像。当然，这些“过滤器”和你在 Instagram 里用的滤镜（英文也为“filter”）并不是一种东西，但它们其实有一些相同之处。CNN 会使用一个小方块遍历整张图片，通常将这个小方块称为“窗口”。接下来，网络会在图片中查找与过滤器匹配的图片内容。在第一层，网络可能只学习到了一些简单的事物（例如对角线）。在之后的每一层中，网络都将结合前面找到的特征，持续学习更加复杂的概念。单单听这些概念可能会让人比较迷糊，让我们直接来看一些例子。<a href="https://arxiv.org/abs/1311.2901" target="_blank" rel="noopener">Zeiler and Fergus (2013)</a> 为可视化 CNN 学习过程做出了一项很棒的工作。下图是他们在论文中用的 CNN 模型，赢得 Imagenet 竞赛的 Vgg16 模型就是基于这个模型做出来的。</p>
<p><img src="/images/pasted-172.png" alt="upload successful"></p>
<p>CNN，作者：Zeiler &amp; Fergus (2013)</p>
<p>可能你现在会觉得这个图片很难懂，请不要慌！让我们先从我们可以在图中看到的东西说起吧。首先，输入图像是正方形，大小为 224x224 像素。我之前说的过滤器大小是 7x7 像素大小。该模型有一个输入层，7 个隐藏层以及一个输出层。输出层的“C”指的是模型的预测分类数量。现在让我们来了解 CNN 中最有趣的部分：这个神经网络在每一层中都学到了什么！</p>
<p><img src="/images/pasted-173.png" alt="upload successful"></p>
<p>上图为 CNN 的第二层。左边的图像代表了 CNN 的这层网络在右边的真实图片中学习到的内容。<br>在 CNN 的第二层中，你可以发现这个模型已经不仅仅是去提取对角线了，它找到了一些更有意思的形状特征。例如在第二排第二列的方块中，你可以看到模型正在提取圆形；还有，最后一个方块表明模型正在专注于识别图中的一个直角作为特征。</p>
<p><img src="/images/pasted-174.png" alt="upload successful"></p>
<p>上图为 CNN 的第三层。<br>在第三层中，我们可以看到模型已经开始学习一些更具体的东西。第一个方块中的图像表明模型已经能够识别出一些地理特征；第二排第二列的方块表明模型正在识别车轮；倒数第二个方块表明模型正在识别人类。</p>
<p><img src="/images/pasted-175.png" alt="upload successful"></p>
<p>CNN 的第四层与第五层</p>
<p>在最后，第四层与第五层保持前面模型越来越具体的趋势。第五层找到了对解决我们的猫狗问题非常有帮助的特征。与此同时，它还识别出了独轮车，以及鸟类、爬行动物的眼睛。请注意，这些图像仅仅展示了每一层学习到的东西的极小一部分。</p>
<p>希望上面的文字已经告诉了你为什么使用预先训练好的模型是很有用的。如果你想更多的了解这块领域的研究，你可以搜索“迁移学习”（transfer learning）的相关内容。虽然我们的猫狗问题训练集仅仅只有 25000 张图片，一个新的模型可能还无法从这些图片中学习到所有的特征，但我们的 Vgg16 模型已经相当“了解”怎么去识别猫和狗了。最后，通过“微调”（Finetuning） Vgg16 模型的最后一层，让其不再输出 1000 多种分类的概率，而是直接输出二分类 —— 猫和狗。</p>
<p>如果你对深度学习背后的数学知识感兴趣，<a href="http://cs231n.github.io/" target="_blank" rel="noopener">Stanford’s CNN pages</a> 是很好的参考材料。他们首次以“数学之美”解释了浅层神经网络。</p>
<hr>
<h4 id="微调及线性层（全连接层）"><a href="#微调及线性层（全连接层）" class="headerlink" title="微调及线性层（全连接层）"></a>微调及线性层（全连接层）</h4><p>上周，我用这个预先训练好的 Vgg16 模型不能很自然的区分猫和狗这两个分类下的图片，而是提出了 1000 余种分类。此外，这个模型并不会直接输出“猫”和“狗”的分类，而是输出猫和狗的一些特定品种。那我们如何修改这个模型，让它能够有效地对猫和狗进行分类呢？</p>
<p>有种可选方案：手动将这些品种分到猫和狗中去，然后计算其概率之和。但是，这种做法会丢弃一些关键信息。例如，如果图片中只有一根骨头，但它很可能是一张属于狗的照片。如果我们仅查看这些品种分为猫狗的概率，前面提到的这种信息很可能会丢失。因此在模型的最后，我们加入一个线性层（全连接层），它将仅输出两种分类。实际上，Vgg16 模型的最后有 3 层全连接层。我们可以微调这些层，通过反向传播来训练它们。反向传播算法常常被人看成是一种抽象的魔法，但其实它只是简单应用链式求导法则。你可以暂时忽略这些数学上的细节，TensorFlow、Theano 和其它深度学习库已经帮你做好了这些工作。</p>
<p>如果你正在运行 Fast AI 课程 lesson 2 的 notebook，我建议你最好先只使用 notebook 的样例图片。如果你运行 p2 的实例，可能会由于保存、加载 numpy 数组将内存耗尽。</p>
<hr>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>前面我们讨论了网络最后的线性层（全连接层）。然而，神经网络的所有层都不是线性的。在神经网络计算出每个神经元的参数之后，我们需要将它们的计算结果作为参数输入到激活函数中。人工神经网络基本上由矩阵乘法组成，如果我们只使用线性计算的话，我们只能将它们一个个叠加在一起，并不能做成一个很深的网络。因此，我们会经常在网络的各层使用非线性的激活函数。通过将重重线性与非线性函数叠加在一起，理论上我们可以对任何事物进行建模。下面是三种最受欢迎的非线性激活函数：</p>
<ul>
<li>Sigmoid <strong>（将值转换到 0，1 间）</strong></li>
<li>TanH <strong>（将值转换到 -1，1 间）</strong></li>
<li>ReLu <strong>（如果值为负则输出 0，否则输出原值）</strong></li>
</ul>
<p><img src="/images/pasted-176.png" alt="upload successful"></p>
<p>上图为最常用的激活函数：Sigmoid、Tanh 和 ReLu（又名修正线性单元）<br>目前，ReLu 是使用的最多的非线性激活函数，主要原因是它可以减少梯度消失的可能性，以及保持稀疏特征。稍后会讨论这方面的更多详情。因为我们希望模型最后能够输出确定的内容，因此模型的最后一层通常使用一种另外的激活函数 —— softmax。softmax 函数是一种非常受欢迎的分类器。</p>
<p>在微调完 Vgg16 模型的最后一层之后，它总共有 138357544 个参数。谢天谢地，我们不需要手动计算各种梯度 XD。下一周我们将更深入地了解 CNN 的工作原理，讨论主题为欠拟合和过拟合。</p>
<p>如果你喜欢这篇文章，请将它推荐给其他人吧！你也可以关注此系列文章，跟上 Fast AI 课程的进度。下篇文章再会！</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/598ac6a55188257dd366367f" target="_blank" rel="noopener">https://juejin.im/post/598ac6a55188257dd366367f</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/09/如何将时间序列问题用-Python-转换成为监督学习问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/09/如何将时间序列问题用-Python-转换成为监督学习问题/" class="post-title-link" itemprop="url">如何将时间序列问题用 Python 转换成为监督学习问题</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-09 16:23:01" itemprop="dateCreated datePublished" datetime="2017-08-09T16:23:01+08:00">2017-08-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一些机器学习方法（例如深度学习）可以用于进行时间序列预测。</p>
<p>在使用这些机器学习方法前，必须先将时间序列预测问题转化为监督学习问题。也就是说，需要将一个时间序列转换成一组包含成对输入输出的序列。</p>
<p>在这篇教程里，你将了解如何将单变量时间序列预测问题和多变量时间序列预测问题转换成监督学习问题，以使用机器学习算法。</p>
<p>读完这篇教程，你将会了解：</p>
<ul>
<li>如何编写一个将时间序列数据集转换为监督学习数据集的函数。</li>
<li>如何转换一元时间序列数据以使用机器学习。</li>
<li>如何转换多元时间序列数据以使用机器学习。</li>
</ul>
<p>让我们开始吧。</p>
<p><img src="/images/pasted-170.png" alt="upload successful"></p>
<p>题图：如何将时间序列问题用 Python 转换成为监督学习问题</p>
<p><a href="https://www.flickr.com/photos/quimgil/8490510169/" target="_blank" rel="noopener">Quim Gil</a> 拍摄，版权所有。</p>
<h2 id="时间序列-vs-监督学习"><a href="#时间序列-vs-监督学习" class="headerlink" title="时间序列 vs 监督学习"></a>时间序列 vs 监督学习</h2><p>在正式开始之前，让我们先花点时间更好地了解一下时间序列和监督学习的数据集结构。</p>
<p>单个时间序列由一系列按照时间排序的数字序列组成。可以将其理解为一列有序值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>而一个监督学习问题是由一组输入（*X*）和一组输出（*y*）组成，算法可以学会如何通过输入值来预测输出值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X,  y</span><br><span class="line">1 2</span><br><span class="line">2,  3</span><br><span class="line">3,  4</span><br><span class="line">4,  5</span><br><span class="line">5,  6</span><br><span class="line">6,  7</span><br><span class="line">7,  8</span><br><span class="line">8,  9</span><br></pre></td></tr></table></figure>
<p>可以参阅这篇文章，学习更多有关知识：</p>
<ul>
<li><a href="http://machinelearningmastery.com/time-series-forecasting-supervised-learning/" target="_blank" rel="noopener">Time Series Forecasting as Supervised Learning</a></li>
</ul>
<h2 id="Pandas-的-shift-函数"><a href="#Pandas-的-shift-函数" class="headerlink" title="Pandas 的 shift() 函数"></a>Pandas 的 shift() 函数</h2><p>我们将时间序列数据转化为监督学习问题的关键就是使用 Pandas 的 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.shift.html" target="_blank" rel="noopener">shift()</a> 函数。</p>
<p>给定一个 DataFrame，*shift()* 函数会将输入的列复制一份，然后将副本列整体往后移动（最前面的数据空位会用 NaN 填充）或者往前移动（最后面的数据空位会用 NaN 填充）。</p>
<p>这样可以创建一个滞后值列，加上观察列，就能将时间序列数据集变成监督学习数据集的格式。</p>
<p>让我们看看 shift 函数实际用起来效果如何。</p>
<p>我们可以通过下面的代码模拟一个长度为 10 的时间序列数据集，此时它在 DataFrame 中为单独的一列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line">df = DataFrame()</span><br><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<p>运行上面的样例，将时间序列数据输出，其每一行都为带有索引的观察组数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   t</span><br><span class="line">0  0</span><br><span class="line">1  1</span><br><span class="line">2  2</span><br><span class="line">3  3</span><br><span class="line">4  4</span><br><span class="line">5  5</span><br><span class="line">6  6</span><br><span class="line">7  7</span><br><span class="line">8  8</span><br><span class="line">9  9</span><br></pre></td></tr></table></figure></p>
<p>我们可以在数据顶部插入一行，将观察组的数据整体下挪一位。由于最上面插入的新行没有数据，因此我们可以用 NaN 填充来表示这儿“没有数据”。</p>
<p>shift 函数可以完成这些操作。我们可以将 shift 函数“挪动”过的新列插入原始序列的旁边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line">df = DataFrame()</span><br><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">df[<span class="string">'t-1'</span>] = df[<span class="string">'t'</span>].shift(<span class="number">1</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<p>运行上面的样例，你将得到一个包含两列的数据集。第一列是原始的观察组，第二列是经由 shift 函数挪动生成的新列。</p>
<p>可以看到，经过将序列移动一次的操作之后，我们得到了一个原始的监督学习问题（虽然此时的 *X* 和 *y* 的排序明显是错的）。忽略最前面的表头，第一行存在 NaN 值，因此需要将其丢弃。在第二行，我们可以将第二列的 0.0 作为输入值（也就是 *X*），将第一列的 1 作为输出值（或 *y*）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   t  t-1</span><br><span class="line">0  0  NaN</span><br><span class="line">1  1  0.0</span><br><span class="line">2  2  1.0</span><br><span class="line">3  3  2.0</span><br><span class="line">4  4  3.0</span><br><span class="line">5  5  4.0</span><br><span class="line">6  6  5.0</span><br><span class="line">7  7  6.0</span><br><span class="line">8  8  7.0</span><br><span class="line">9  9  8.0</span><br></pre></td></tr></table></figure>
<p>如果我们重复 shift 步骤，让原始列挪动 2 位、3 位或者更多位，我们就能得到一系列的输入数据（*X*），由这些输入值就能去预测输出值（*y*）了。</p>
<p>shift 操作能也能接受负整数作为参数。如果你这么做，它会在列底部插入新行，从而使得原列向上移动。下面是例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line">df = DataFrame()</span><br><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">df[<span class="string">'t+1'</span>] = df[<span class="string">'t'</span>].shift(<span class="number">-1</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<p>运行上面的样例，可以看到新列中的最后一个值为 NaN。</p>
<p>此时可以将预测列作为输入值（*X*），将第二列作为输出值（*y*）。也就是给定输入值 0 可以用于预测输出值 1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   t  t+1</span><br><span class="line">0  0  1.0</span><br><span class="line">1  1  2.0</span><br><span class="line">2  2  3.0</span><br><span class="line">3  3  4.0</span><br><span class="line">4  4  5.0</span><br><span class="line">5  5  6.0</span><br><span class="line">6  6  7.0</span><br><span class="line">7  7  8.0</span><br><span class="line">8  8  9.0</span><br><span class="line">9  9  NaN</span><br></pre></td></tr></table></figure>
<p>从技术上说，在时间序列预测问题的术语中，当前时间（*t*）和未来时间（*t+1, t+n*）为待预测时间，过去时间（*t-1, t-n*）则用于预测。</p>
<p>从上面的例子中，我们可以学会如何使用通过 shift 函数正向或反向移动序列，生成新的 DataFrame，将时间序列问题转变成监督学习问题的输入-输出模式。</p>
<p>这不仅可以解决经典的 *X -> y* 类预测问题，也可以用于输入输出值都是序列的 *X -> Y* 类预测。</p>
<p>另外，shift 函数也能用于多元时间序列问题中。这类问题中包含多列观察组（例如温度、气压等）。时间序列中的所有变量都能用通过向前或向后挪动，生成多元输入值与输出值序列。稍后我们将探讨这类问题。</p>
<h2 id="series-to-supervised-函数"><a href="#series-to-supervised-函数" class="headerlink" title="series_to_supervised() 函数"></a>series_to_supervised() 函数</h2><p>我们可以使用 Pandas 的 *shift()* 函数，在给定希望得到的输入值、输出值序列长度后自动生成时间序列问题的新格式数据。</p>
<p>这是个很有用的工具。我们可以通过机器学习算法研究各种时间序列问题格式，探究哪种格式能够得到效果更佳的模型。</p>
<p>在本节中，我们将创建一个新的 Python 函数，名为 *series_to_supervised()*。它可以将多元时间序列问题与一元时间序列问题转换为监督学习数据集的格式。</p>
<p>这个函数接收以下 4 个参数：</p>
<ul>
<li><strong>data</strong>：必填，待转换的序列，数据类型为 list 或 2 维 NumPy array。</li>
<li><strong>n_in</strong>： 可选，滞后组（作为输入值 X）的数量。范围可以在 [1..len(data)] 之间，默认值为 1。</li>
<li><strong>n_out</strong>： 可选，观察组（作为输出值 y）的数量。范围可以在  [0..len(data)-1] 之间，默认值为 1。</li>
<li><strong>dropnan</strong>：选填，决定是否抛去包含 NaN 的行。类型为 Boolean，默认值为 True。</li>
</ul>
<p>函数将会返回一个值：</p>
<ul>
<li><strong>return</strong>：返回监督学习格式的数据集，数据类型为 Pandas DataFrame。</li>
</ul>
<p>新数据集 DataFrame 格式，每一列都由原变量名称和移动步数命名，让你可以根据给定的一元或多元时间序列问题设计出各种移动步数的序列。</p>
<p>在 DataFrame 返回时，你可以对其行进行分割，根据你的需要决定如何将返回的 DataFrame 分成 X 和 y 两部分。</p>
<p>这个函数的参数都设置了默认值，因此可以直接调用它处理你的数据，这种默认情况它将会返回一个 *t-1* 作为 X，*t* 作为 y 的 DataFrame。</p>
<p>这个函数已确定同时兼容 Python2 和 Python3。</p>
<p>下面为完整代码，并写好了注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br></pre></td></tr></table></figure>
<p>你觉得可以怎样提高这个函数的鲁棒性或者可读性吗？请留言在评论区。</p>
<p>至此我们已经得到了整个函数，接下来探索它的用法。</p>
<h2 id="单步或单变量预测"><a href="#单步或单变量预测" class="headerlink" title="单步或单变量预测"></a>单步或单变量预测</h2><p>在时间序列预测问题中通常使用滞后时间（例如 t-1）作为输入变量来预测当前时间（t）。</p>
<p>这种问题被称为单步预测。</p>
<p>下面展示了使用滞后一个时间步的时间（t-1）来预测当前时间（t）的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br><span class="line">  </span><br><span class="line">  values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">  data = series_to_supervised(values)</span><br><span class="line">  print(data)</span><br></pre></td></tr></table></figure>
<p>运行样例，输出转换后的时间序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var1(t)</span><br><span class="line">1        0.0        1</span><br><span class="line">2        1.0        2</span><br><span class="line">3        2.0        3</span><br><span class="line">4        3.0        4</span><br><span class="line">5        4.0        5</span><br><span class="line">6        5.0        6</span><br><span class="line">7        6.0        7</span><br><span class="line">8        7.0        8</span><br><span class="line">9        8.0        9</span><br></pre></td></tr></table></figure>
<p>可以看到，观察组被命名为“*var1*”，作为输入值的观察组被命名为（*t-1*），输出值组被命名为（*t*）。</p>
<p>此外，可以看到包含 NaN 的行已经被自动从 DataFrame 中移除。</p>
<p>我们可以任意给定输入序列数量的值来重复运行这个例子。例如输入 3，我们事先已经将输入序列的数量定义为了一个参数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>完整样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">data = series_to_supervised(values, <span class="number">3</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>再次运行样例，输出重新构造的序列，可以看到输入序列准确无误地从左至右裴烈，作为预测项的输入值在最右边。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   var1(t-3)  var1(t-2)  var1(t-1)  var1(t)</span><br><span class="line">3        0.0        1.0        2.0        3</span><br><span class="line">4        1.0        2.0        3.0        4</span><br><span class="line">5        2.0        3.0        4.0        5</span><br><span class="line">6        3.0        4.0        5.0        6</span><br><span class="line">7        4.0        5.0        6.0        7</span><br><span class="line">8        5.0        6.0        7.0        8</span><br><span class="line">9        6.0        7.0        8.0        9</span><br></pre></td></tr></table></figure>
<h2 id="多步或序列预测"><a href="#多步或序列预测" class="headerlink" title="多步或序列预测"></a>多步或序列预测</h2><p>还有一类预测问题：使用过去的观察组来对未来的观察组序列做预测。</p>
<p>可以将这类问题成为序列预测问题或者多步预测问题。</p>
<p>我们可以通过规定另一个参数来将序列预测问题的时间序列重新构造。例如，我们可以把 2 个过去的观察组转变为 2 个未来的观察组，从而重新构造预测问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=series_to_supervised(values,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>完整样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br><span class="line"></span><br><span class="line">values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">data = series_to_supervised(values, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>运行样例，可以看到将（*t-n*）作为输入变量、将（*t+n*）作为输出变量时，与将当前观察组（*t*）作为输出的不同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   var1(t-2)  var1(t-1)  var1(t)  var1(t+1)</span><br><span class="line">2        0.0        1.0        2        3.0</span><br><span class="line">3        1.0        2.0        3        4.0</span><br><span class="line">4        2.0        3.0        4        5.0</span><br><span class="line">5        3.0        4.0        5        6.0</span><br><span class="line">6        4.0        5.0        6        7.0</span><br><span class="line">7        5.0        6.0        7        8.0</span><br><span class="line">8        6.0        7.0        8        9.0</span><br></pre></td></tr></table></figure>
<h2 id="多元预测"><a href="#多元预测" class="headerlink" title="多元预测"></a>多元预测</h2><p>还有一种重要的时间序列类型，叫做多元时间序列。</p>
<p>这种情况我们会将多个不同的指标作为观察组，并预测它们中的一个或多个的值。</p>
<p>例如，我们有两组时间序列观察组 obs1 和 obs2，希望预测它们或它们中的一者。</p>
<p>我们同样可以调用 *series_to_supervised()*。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raw = DataFrame()</span><br><span class="line">raw[<span class="string">'ob1'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">raw[<span class="string">'ob2'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>, <span class="number">60</span>)]</span><br><span class="line">values = raw.values</span><br><span class="line">data = series_to_supervised(values)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>运行样例，将会得到经过重新构造后的数据。数据显示了分别处于同一个时间的两组变量作为输入组以及输出组。</p>
<p>与之前一样，根据问题的需要，可以将列分入 *X* 和 *y* 两个子集中，需要注意的是如果放入了 *var1* 做为观察组，那就要放入 *var2* 作为待预测组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var2(t-1)  var1(t)  var2(t)</span><br><span class="line">1        0.0       50.0        1       51</span><br><span class="line">2        1.0       51.0        2       52</span><br><span class="line">3        2.0       52.0        3       53</span><br><span class="line">4        3.0       53.0        4       54</span><br><span class="line">5        4.0       54.0        5       55</span><br><span class="line">6        5.0       55.0        6       56</span><br><span class="line">7        6.0       56.0        7       57</span><br><span class="line">8        7.0       57.0        8       58</span><br><span class="line">9        8.0       58.0        9       59</span><br></pre></td></tr></table></figure>
<p>可以看到，通过上面这样给定输入序列和输出序列的数量生成的新的序列，可以帮助你轻松地完成多元时间序列的预测。</p>
<p>例如，下面将把 1 作为输入列数量，将 2 作为输出列（预测列）数量，重新构造预测序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span><br><span class="line"><span class="string">  参数说明：</span></span><br><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span><br><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span><br><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span><br><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span><br><span class="line"><span class="string">  返回值:</span></span><br><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span><br><span class="line">  df = DataFrame(data)</span><br><span class="line">  cols, names = list(), list()</span><br><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    cols.append(df.shift(i))</span><br><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span><br><span class="line">    cols.append(df.shift(-i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span><br><span class="line">  <span class="comment"># 将所有列拼合</span></span><br><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span><br><span class="line">  agg.columns = names</span><br><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span><br><span class="line">  <span class="keyword">if</span> dropnan:</span><br><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span><br><span class="line">  <span class="keyword">return</span> agg</span><br><span class="line"></span><br><span class="line">raw = DataFrame()</span><br><span class="line">raw[<span class="string">'ob1'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">raw[<span class="string">'ob2'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>, <span class="number">60</span>)]</span><br><span class="line">values = raw.values</span><br><span class="line">data = series_to_supervised(values, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<p>运行样例，将会展示重新构造的很大的 DataFrame。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var2(t-1)  var1(t)  var2(t)  var1(t+1)  var2(t+1)</span><br><span class="line">1        0.0       50.0        1       51        2.0       52.0</span><br><span class="line">2        1.0       51.0        2       52        3.0       53.0</span><br><span class="line">3        2.0       52.0        3       53        4.0       54.0</span><br><span class="line">4        3.0       53.0        4       54        5.0       55.0</span><br><span class="line">5        4.0       54.0        5       55        6.0       56.0</span><br><span class="line">6        5.0       55.0        6       56        7.0       57.0</span><br><span class="line">7        6.0       56.0        7       57        8.0       58.0</span><br><span class="line">8        7.0       57.0        8       58        9.0       59.0</span><br></pre></td></tr></table></figure>
<p>你可以用你自己的数据集多做几次实验，来试试哪种重构的效果更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇教程中，你已经了解了如何使用 Python 将时间序列数据集转换为监督学习问题。</p>
<p>特别的，你了解了：</p>
<ul>
<li>有关 Pandas *shift()* 函数的知识，以及它如何自动将时间序列数据转化为监督学习数据集。</li>
<li>如何将一元时间序列重构成单步或多步监督学习问题。</li>
<li>如何将多元时间序列重构成单步或多步监督学习问题。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/21/使用-Python-spaCy-进行简易自然语言处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/21/使用-Python-spaCy-进行简易自然语言处理/" class="post-title-link" itemprop="url">使用 Python+spaCy 进行简易自然语言处理</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-07-21 22:35:00" itemprop="dateCreated datePublished" datetime="2017-07-21T22:35:00+08:00">2017-07-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自然语言处理（NLP）是人工智能领域最重要的部分之一。它在许多智能应用中担任了关键的角色，例如聊天机器人、正文提取、多语翻译以及观点识别等应用。业界 NLP 相关的公司都意识到了，处理非结构文本数据时，不仅要看正确率，还需要注意是否能快速得到想要的结果。</p>
<p>NLP 是一个很宽泛的领域，它包括了文本分类、实体识别、机器翻译、问答系统、概念识别等子领域。在我最近的一篇<a href="https://www.analyticsvidhya.com/blog/2017/01/ultimate-guide-to-understand-implement-natural-language-processing-codes-in-python/" target="_blank" rel="noopener">文章</a>中，我探讨了许多用于实现 NLP 的工具与组件。在那篇文章中，我更多的是在描述<a href="http://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>（Natural Language Toolkit）这个伟大的库。</p>
<p>在这篇文章中，我会将 spaCy —— 这个现在最强大、最先进的 NLP python 库分享给你们。</p>
<hr>
<h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><ol>
<li>spaCy 简介及安装方法</li>
<li><p>spaCy 的管道与属性</p>
<ul>
<li>Tokenization</li>
<li>词性标注</li>
<li>实体识别</li>
<li>依存句法分析</li>
<li>名词短语</li>
</ul>
</li>
<li><p>集成词向量计算</p>
</li>
<li>使用 spaCy 进行机器学习</li>
<li>与 NLTK 和 CoreNLP 对比</li>
</ol>
<hr>
<h2 id="1-spaCy-简介及安装方法"><a href="#1-spaCy-简介及安装方法" class="headerlink" title="1. spaCy 简介及安装方法"></a>1. spaCy 简介及安装方法</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>spaCy 由 cython（Python 的 C 语言拓展，旨在让 python 程序达到如同 C 程序一样的性能）编写，因此它的运行效率非常高。spaCy 提供了一系列简洁的 API 方便用户使用，并基于已经训练好的机器学习与深度学习模型实现底层。</p>
<hr>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>spaCy 及其数据和模型可以通过 pip 和安装工具轻松地完成安装。使用下面的命令在电脑中安装 spaCy：</p>
<pre><code>sudo pip install spacy
</code></pre><p>如果你使用的是 Python3，请用 “pip3” 代替 “pip”。</p>
<p>或者你也可以在 <a href="https://pypi.python.org/pypi/spacy" target="_blank" rel="noopener">这儿</a> 下载源码，解压后运行下面的命令安装：</p>
<pre><code>python setup.py install
</code></pre><p>在安装好 spacy 之后，请运行下面的命令以下载所有的数据集和模型：</p>
<pre><code>python -m spacy.en.download all
</code></pre><p>一切就绪，现在你可以自由探索、使用 spacy 了。</p>
<h2 id="2-spaCy-的管道（Pipeline）与属性（Properties）"><a href="#2-spaCy-的管道（Pipeline）与属性（Properties）" class="headerlink" title="2. spaCy 的管道（Pipeline）与属性（Properties）"></a>2. spaCy 的管道（Pipeline）与属性（Properties）</h2><p>spaCy 的使用，以及其各种属性，是通过创建管道实现的。在加载模型的时候，spaCy 会将管道创建好。在 spaCy 包中，提供了各种各样的<a href="https://github.com/explosion/spacy-models/" target="_blank" rel="noopener">模块</a>，这些模块中包含了各种关于词汇、训练向量、语法和实体等用于语言处理的信息。</p>
<p>下面，我们会加载默认的模块（english-core-web 模块）。</p>
<pre><code>import spacy
nlp = spacy.load(“en”)
</code></pre><p>“nlp” 对象用于创建 document、获得 linguistic annotation 及其它的 nlp 属性。首先我们要创建一个 document，将文本数据加载进管道中。我使用了来自猫途鹰网的旅店评论数据。这个数据文件可以在<a href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2017/04/04080929/Tripadvisor_hotelreviews_Shivambansal.txt" target="_blank" rel="noopener">这儿</a>下载。</p>
<pre><code>document = unicode(open(filename).read().decode(&#39;utf8&#39;))
document = nlp(document)
</code></pre><p>这个 document 现在是 spacy.english 模型的一个 class，并关联上了许多的属性。可以使用下面的命令列出所有 document（或 token）的属性：</p>
<pre><code>dir(document)
&gt;&gt; [ &#39;doc&#39;, &#39;ents&#39;, … &#39;mem&#39;]
</code></pre><p>它会输出 document 中各种各样的属性，例如：token、token 的 index、词性标注、实体、向量、情感、单词等。下面让我们会对其中的一些属性进行一番探究。</p>
<h3 id="2-1-Tokenization"><a href="#2-1-Tokenization" class="headerlink" title="2.1 Tokenization"></a>2.1 Tokenization</h3><p>spaCy 的 document 可以在 tokenized 过程中被分割成单句，这些单句还可以进一步分割成单词。你可以通过遍历文档来读取这些单词：</p>
<pre><code># document 的首个单词
document[0]
&gt;&gt; Nice

# document 的最后一个单词  
document[len(document)-5]
&gt;&gt; boston

# 列出 document 中的句子
list(document.sents)
&gt;&gt; [ Nice place Better than some reviews give it credit for.,
 Overall, the rooms were a bit small but nice.,
...
Everything was clean, the view was wonderful and it is very well located (the Prudential Center makes shopping and eating easy and the T is nearby for jaunts out and about the city).]
</code></pre><h3 id="2-2-词性标注-POS-Tag"><a href="#2-2-词性标注-POS-Tag" class="headerlink" title="2.2 词性标注(POS Tag)"></a>2.2 词性标注(POS Tag)</h3><p>词性标注即标注语法正确的句子中的词语的词性。这些标注可以用于信息过滤、统计模型，或者基于某些规则进行文本解析。</p>
<p>来看看我们的 document 中所有的词性标注：</p>
<pre><code># 获得所有标注
all_tags = {w.pos: w.pos_ for w in document}
&gt;&gt; {97:  u&#39;SYM&#39;, 98: u&#39;VERB&#39;, 99: u&#39;X&#39;, 101: u&#39;SPACE&#39;, 82: u&#39;ADJ&#39;, 83: u&#39;ADP&#39;, 84: u&#39;ADV&#39;, 87: u&#39;CCONJ&#39;, 88: u&#39;DET&#39;, 89: u&#39;INTJ&#39;, 90: u&#39;NOUN&#39;, 91: u&#39;NUM&#39;, 92: u&#39;PART&#39;, 93: u&#39;PRON&#39;, 94: u&#39;PROPN&#39;, 95: u&#39;PUNCT&#39;}

# document 中第一个句子的词性标注
for word in list(document.sents)[0]:  
    print word, word.tag_
&gt;&gt; ( Nice, u&#39;JJ&#39;) (place, u&#39;NN&#39;) (Better, u&#39;NNP&#39;) (than, u&#39;IN&#39;) (some, u&#39;DT&#39;) (reviews, u&#39;NNS&#39;) (give, u&#39;VBP&#39;) (it, u&#39;PRP&#39;) (creit, u&#39;NN&#39;) (for, u&#39;IN&#39;) (., u&#39;.&#39;)
</code></pre><p>来看一看 document 中的最常用词汇。我已经事先写好了预处理和文本数据清洗的函数。</p>
<pre><code>#一些参数定义
noisy_pos_tags = [“PROP”]
min_token_length = 2

#检查 token 是不是噪音的函数
def isNoise(token):     
    is_noise = False
    if token.pos_ in noisy_pos_tags:
        is_noise = True
    elif token.is_stop == True:
        is_noise = True
    elif len(token.string) &lt;= min_token_length:
        is_noise = True
    return is_noise
def cleanup(token, lower = True):
    if lower:
       token = token.lower()
    return token.strip()

# 评论中最常用的单词
from collections import Counter
cleaned_list = [cleanup(word.string) for word in document if not isNoise(word)]
Counter(cleaned_list) .most_common(5)
&gt;&gt; [( u&#39;hotel&#39;, 683), (u&#39;room&#39;, 652), (u&#39;great&#39;, 300),  (u&#39;sheraton&#39;, 285), (u&#39;location&#39;, 271)]
</code></pre><h3 id="2-3-实体识别"><a href="#2-3-实体识别" class="headerlink" title="2.3 实体识别"></a>2.3 实体识别</h3><p>spaCy 拥有一个快速实体识别模型，这个实体识别模型能够从 document 中找出实体短语。它能识别各种类型的实体，例如人名、位置、机构、日期、数字等。你可以通过“.ents”属性来读取这些实体。</p>
<p>下面让我们来获取我们 document 中所有类型的命名实体：</p>
<pre><code>labels = set([w.label_ for w in document.ents])
for label in labels:
    entities = [cleanup(e.string, lower=False) for e in document.ents if label==e.label_]
    entities = list(set(entities))
    print label,entities
</code></pre><h3 id="2-4-依存句法分析"><a href="#2-4-依存句法分析" class="headerlink" title="2.4 依存句法分析"></a>2.4 依存句法分析</h3><p>spaCy 最强大的功能之一就是它可以通过调用轻量级的 API 来实现又快又准确的依存分析。这个分析器也可以用于句子边界检测以及区分短语块。依存关系可以通过“.children”、“.root”、“.ancestor”等属性读取。</p>
<pre><code># 取出所有句中包含“hotel”单词的评论
hotel = [sent for sent in document.sents if &#39;hotel&#39; in sent.string.lower()]

# 创建依存树
sentence = hotel[2] for word in sentence:
print word, &#39;: &#39;, str(list(word.children))
&gt;&gt; A :  []  cab :  [A, from]
from :  [airport, to]
the :  []
airport :  [the]
to :  [hotel]
the :  [] hotel :  
[the] can :  []
be :  [cab, can, cheaper, .]
cheaper :  [than] than :  
[shuttles]
the :  []
shuttles :  [the, depending]
depending :  [time] what :  []
time :  [what, of] of :  [day]
the :  [] day :  
[the, go] you :  
[]
go :  [you]
. :  []
</code></pre><p>解析所有居中包含“hotel”单词的句子的依存关系，并检查对于 hotel 人们用了哪些形容词。我创建了一个自定义函数，用于分析依存关系并进行相关的词性标注。</p>
<pre><code># 检查修饰某个单词的所有形容词
def pos_words (sentence, token, ptag):
    sentences = [sent for sent in sentence.sents if token in sent.string]     
    pwrds = []
    for sent in sentences:
        for word in sent:
            if character in word.string:
                   pwrds.extend([child.string.strip() for child in word.children
                                                      if child.pos_ == ptag] )
    return Counter(pwrds).most_common(10)

pos_words(document, &#39;hotel&#39;, “ADJ”)
&gt;&gt; [(u&#39;other&#39;, 20), (u&#39;great&#39;, 10), (u&#39;good&#39;, 7), (u&#39;better&#39;, 6), (u&#39;nice&#39;, 6), (u&#39;different&#39;, 5), (u&#39;many&#39;, 5), (u&#39;best&#39;, 4), (u&#39;my&#39;, 4), (u&#39;wonderful&#39;, 3)]
</code></pre><h3 id="2-5-名词短语（NP）"><a href="#2-5-名词短语（NP）" class="headerlink" title="2.5 名词短语（NP）"></a>2.5 名词短语（NP）</h3><p>依存树也可以用来生成名词短语：</p>
<pre><code># 生成名词短语
doc = nlp(u&#39;I love data science on analytics vidhya&#39;)
for np in doc.noun_chunks:
    print np.text, np.root.dep_, np.root.head.text
&gt;&gt; I nsubj love
   data science dobj love
   analytics pobj on
</code></pre><h2 id="3-集成词向量"><a href="#3-集成词向量" class="headerlink" title="3. 集成词向量"></a>3. 集成词向量</h2><p>spaCy 提供了内置整合的向量值算法，这些向量值可以反映词中的真正表达信息。它使用 <a href="https://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">GloVe</a> 来生成向量。GloVe 是一种用于获取表示单词的向量的无监督学习算法。</p>
<p>让我们创建一些词向量，然后对其做一些有趣的操作吧：</p>
<pre><code>from numpy import dot
from numpy.linalg import norm
from spacy.en import English
parser = English()

# 生成“apple”的词向量 
apple = parser.vocab[u&#39;apple&#39;]

# 余弦相似性计算函数
cosine = lambda v1, v2: dot(v1, v2) / (norm(v1) * norm(v2))
others = list({w for w in parser.vocab if w.has_vector and w.orth_.islower() and w.lower_ != unicode(&quot;apple&quot;)})

# 根据相似性值进行排序
others.sort(key=lambda w: cosine(w.vector, apple.vector))
others.reverse()


print &quot;top most similar words to apple:&quot;
for word in others[:10]:
    print word.orth_
&gt;&gt; apples iphone f ruit juice cherry lemon banana pie mac orange
</code></pre><h2 id="4-使用-spaCy-对文本进行机器学习"><a href="#4-使用-spaCy-对文本进行机器学习" class="headerlink" title="4. 使用 spaCy 对文本进行机器学习"></a>4. 使用 spaCy 对文本进行机器学习</h2><p>将 spaCy 集成进机器学习模型是非常简单、直接的。让我们使用 sklearn 做一个自定义的文本分类器。我们将使用 cleaner、tokenizer、vectorizer、classifier 组件来创建一个 sklearn 管道。其中的 tokenizer 和 vectorizer 会使用我们用 spaCy 自定义的模块构建。</p>
<pre><code>from sklearn.feature_extraction.stop_words import ENGLISH_STOP_WORDS as stopwords
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics import accuracy_score
from sklearn.base import TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.svm import LinearSVC

import string
punctuations = string.punctuation

from spacy.en import English
parser = English()

# 使用 spaCy 自定义 transformer
class predictors(TransformerMixin):
    def transform(self, X, **transform_params):
        return [clean_text(text) for text in X]
    def fit(self, X, y=None, **fit_params):
        return self
    def get_params(self, deep=True):
        return {}

# 进行文本清洗的实用的基本函数
def clean_text(text):     
    return text.strip().lower()
</code></pre><p>现在让我们使用 spaCy 的解析器和一些基本的数据清洗函数来创建一个自定义的 tokenizer 函数。值得一提的是，你可以用词向量来代替文本特征（使用深度学习模型效果会有较大的提升）</p>
<pre><code>#创建 spaCy tokenizer，解析句子并生成 token
#也可以用词向量函数来代替它
def spacy_tokenizer(sentence):
    tokens = parser(sentence)
    tokens = [tok.lemma_.lower().strip() if tok.lemma_ != &quot;-PRON-&quot; else tok.lower_ for tok in tokens]
    tokens = [tok for tok in tokens if (tok not in stopwords and tok not in punctuations)]     return tokens

#创建 vectorizer 对象，生成特征向量，以此可以自定义 spaCy 的 tokenizer
vectorizer = CountVectorizer(tokenizer = spacy_tokenizer, ngram_range=(1,1)) classifier = LinearSVC()
</code></pre><p>现在可以创建管道，加载数据，然后运行分类模型了。</p>
<pre><code># 创建管道，进行文本清洗、tokenize、向量化、分类操作
pipe = Pipeline([(&quot;cleaner&quot;, predictors()),
                 (&#39;vectorizer&#39;, vectorizer),
                 (&#39;classifier&#39;, classifier)])

# Load sample data
train = [(&#39;I love this sandwich.&#39;, &#39;pos&#39;),          
         (&#39;this is an amazing place!&#39;, &#39;pos&#39;),
         (&#39;I feel very good about these beers.&#39;, &#39;pos&#39;),
         (&#39;this is my best work.&#39;, &#39;pos&#39;),
         (&quot;what an awesome view&quot;, &#39;pos&#39;),
         (&#39;I do not like this restaurant&#39;, &#39;neg&#39;),
         (&#39;I am tired of this stuff.&#39;, &#39;neg&#39;),
         (&quot;I can&#39;t deal with this&quot;, &#39;neg&#39;),
         (&#39;he is my sworn enemy!&#39;, &#39;neg&#39;),          
         (&#39;my boss is horrible.&#39;, &#39;neg&#39;)]
test =   [(&#39;the beer was good.&#39;, &#39;pos&#39;),     
         (&#39;I do not enjoy my job&#39;, &#39;neg&#39;),
         (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;),
         (&quot;I feel amazing!&quot;, &#39;pos&#39;),
         (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;),
         (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;)]

# 创建模型并计算准确率
pipe.fit([x[0] for x in train], [x[1] for x in train])
pred_data = pipe.predict([x[0] for x in test])
for (sample, pred) in zip(test, pred_data):
    print sample, pred
print &quot;Accuracy:&quot;, accuracy_score([x[1] for x in test], pred_data)

&gt;&gt;    (&#39;the beer was good.&#39;, &#39;pos&#39;) pos
      (&#39;I do not enjoy my job&#39;, &#39;neg&#39;) neg
      (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;) neg
      (&#39;I feel amazing!&#39;, &#39;pos&#39;) pos
      (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;) pos
      (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;) neg
      Accuracy: 1.0
</code></pre><h2 id="5-和其它库的对比"><a href="#5-和其它库的对比" class="headerlink" title="5. 和其它库的对比"></a>5. 和其它库的对比</h2><p>Spacy 是一个非常强大且具备工业级能力的 NLP 包，它能满足大多数 NLP 任务的需求。可能你会思考：为什么会这样呢？</p>
<p>让我们把 Spacy 和另外两个 python 中有名的实现 NLP 的工具 —— CoreNLP 和 NLTK 进行对比吧！</p>
<h3 id="支持功能表"><a href="#支持功能表" class="headerlink" title="支持功能表"></a>支持功能表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>Spacy</th>
<th>NLTK</th>
<th>Core NLP</th>
</tr>
</thead>
<tbody>
<tr>
<td>简易的安装方式</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Python API</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>多语种支持</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>分词</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>词性标注</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>分句</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>依存性分析</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>实体识别</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>词向量计算集成</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>情感分析</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>共指消解</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
</div>
<h3 id="速度：主要功能（Tokenizer、Tagging、Parsing）速度"><a href="#速度：主要功能（Tokenizer、Tagging、Parsing）速度" class="headerlink" title="速度：主要功能（Tokenizer、Tagging、Parsing）速度"></a>速度：主要功能（Tokenizer、Tagging、Parsing）速度</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>库</strong></th>
<th><strong>Tokenizer</strong></th>
<th><strong>Tagging</strong></th>
<th><strong>Parsing</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>spaCy</td>
<td>0.2ms</td>
<td>1ms</td>
<td>19ms</td>
</tr>
<tr>
<td>CoreNLP</td>
<td>2ms</td>
<td>10ms</td>
<td>49ms</td>
</tr>
<tr>
<td>NLTK</td>
<td>4ms</td>
<td>443ms</td>
<td>–</td>
</tr>
</tbody>
</table>
</div>
<h3 id="准确性：实体抽取结果"><a href="#准确性：实体抽取结果" class="headerlink" title="准确性：实体抽取结果"></a>准确性：实体抽取结果</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>库</strong></th>
<th><strong>准确率</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F-Score</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>spaCy</td>
<td>0.72</td>
<td>0.65</td>
<td>0.69</td>
</tr>
<tr>
<td>CoreNLP</td>
<td>0.79</td>
<td>0.73</td>
<td>0.76</td>
</tr>
<tr>
<td>NLTK</td>
<td>0.51</td>
<td>0.65</td>
<td>0.58</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文讨论了 spaCy —— 这个基于 python，完全用于实现 NLP 的库。我们通过许多用例展示了 spaCy 的可用性、速度及准确性。最后我们还将其余其它几个著名的 NLP 库 —— CoreNLP 与 NLTK 进行了对比。</p>
<p>如果你能真正理解这篇文章要表达的内容，那你一定可以去实现各种有挑战的文本数据与 NLP 问题。</p>
<p>希望你能喜欢这篇文章，如果你有疑问、问题或者别的想法，请在评论中留言。</p>
<p>作者介绍：</p>
<p><a href="https://www.analyticsvidhya.com/blog/author/shivam5992/" target="_blank" rel="noopener">Shivam Bansal</a></p>
<p>Shivam Bansal 是一位数据科学家，在 NLP 与机器学习领域有着丰富的经验。他乐于学习，希望能解决一些富有挑战性的分析类问题。</p>
<ul>
<li><a href="https://twitter.com/shivamshaz" target="_blank" rel="noopener">https://twitter.com/shivamshaz</a></li>
<li><a href="https://www.linkedin.com/in/shivambansal1" target="_blank" rel="noopener">https://www.linkedin.com/in/shivambansal1</a></li>
<li><a href="https://github.com/shivam5992" target="_blank" rel="noopener">https://github.com/shivam5992</a></li>
</ul>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/5971a4b9f265da6c42353332" target="_blank" rel="noopener">https://juejin.im/post/5971a4b9f265da6c42353332</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/10/你会给想学习机器学习的软件工程师提出什么建议？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/10/你会给想学习机器学习的软件工程师提出什么建议？/" class="post-title-link" itemprop="url">你会给想学习机器学习的软件工程师提出什么建议？</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-07-10 14:51:00" itemprop="dateCreated datePublished" datetime="2017-07-10T14:51:00+08:00">2017-07-10</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这很大一部分都取决于这名软件工程师的背景，以及他希望掌握机器学习的哪一部分。为了具体讨论，现在假设这是一名初级工程师，他读了 4 年本科，从业 2 年，现在想从事计算广告学（CA）、自然语言处理（NLP）、图像分析、社交网络分析、搜索、推荐排名相关领域。现在，让我们从机器学习的必要课程开始讨论（声明：下面的清单很不完整，如果您的论文没有被包括在内，提前向您抱歉）。</p>
<ul>
<li><p>线性代数<br>很多的机器学习算法、统计学原理、模型优化都依赖线性代数。这也解释了为何在深度学习领域 GPU 要优于 CPU。在线性代数方面，你至少得熟练掌握以下内容：</p>
<ul>
<li>标量、向量、矩阵、张量。你可以将它们看成零维、一维、二维、三维与更高维的对象，可以对它们进行各种组合、变换，就像乐高玩具一样。它们为数据变换提供了最基础的处理方法。</li>
<li>特征向量、标准化、矩阵近似、分解。实质上这些方法都是为了方便线性代数的运算。如果你想分析一个矩阵是如何运算的（例如检查神经网络中梯度消失问题，或者检查强化学习算法发散的问题），你得了解矩阵与向量应用了多少种缩放方法。而低阶矩阵近似与 Cholesky 分解可以帮你写出性能更好、稳定性更强的代码。</li>
<li>数值线性代数<br>如果你想进一步优化算法的话，这是必修课。它对于理解核方法与深度学习很有帮助，不过对于图模型及采样来说它并不重要。</li>
<li>推荐书籍<br><a href="http://www.amazon.com/Linear-Algebra-Undergraduate-Texts-Mathematics/dp/0387964126" target="_blank" rel="noopener">《Serge Lang, Linear Algebra》</a><br>很基础的线代书籍，很适合在校学生。<br><a href="http://www.amazon.com/Linear-Analysis-Introductory-Cambridge-Mathematical/dp/0521655773" target="_blank" rel="noopener">《Bela Bolobas, Linear Analysis》</a><br>这本书目标人群是那些想做数学分析、泛函分析的人。当然它的内容更加晦涩难懂，但更有意义。如果你攻读 PhD，值得一读。<br><a href="http://www.amazon.com/Numerical-Linear-Algebra-Lloyd-Trefethen/dp/0898713617" target="_blank" rel="noopener">《Lloyd Trefethen and David Bau, Numerical Linear Algebra》</a><br>这本书是同类书籍中较为推荐的一本。<a href="http://www.amazon.com/Numerical-Recipes-Scientific-Computing-Second/dp/0521431085/" target="_blank" rel="noopener">《Numerical Recipes》</a>也是一本不错的书，但是里面的算法略为过时了。另外，推荐 Golub 和 van Loan 合著的书<a href="http://www.amazon.com/Computations-Hopkins-Studies-Mathematical-Sciences/dp/1421407949/" target="_blank" rel="noopener">《Matrix Computations》</a>。</li>
</ul>
</li>
<li><p>优化与基础运算</p>
<p>大多数时候提出问题是很简单的，而解答问题则是很困难的。例如，你想对一组数据使用线性回归（即线性拟合），那么你应该希望数据点与拟合线的距离平方和最小；又或者，你想做一个良好的点击预测模型，那么你应该希望最大程度地提高用户点击广告概率估计的准确性。也就是说，在一般情况下，我们会得到一个客观问题、一些参数、一堆数据，我们要做的就是找到通过它们解决问题的方法。找到这种方法是很重要的，因为我们一般得不到闭式解。</p>
<ul>
<li><p>凸优化</p>
<p>在大多情况下，优化问题不会存在太多的局部最优解，因此这类问题会比较好解决。这种“局部最优即全局最优”的问题就是凸优化问题。</p>
<p>（如果你在集合的任意两点间画一条直线，整条线始终在集合范围内，则这个集合是一个凸集合；如果你在一条函数曲线的任意两点间画一条直线，这两点间的函数曲线始终在这条直线之下，则这个函数是一个凸函数）</p>
<p>Steven Boyd 与 Lieven Vandenberghe <a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">合著的书</a>可以说是这个领域的规范书籍了，这本书非常棒，而且是免费的，值得一读；此外，你可以在 <a href="http://web.stanford.edu/~boyd/" target="_blank" rel="noopener">Boyd 的课程</a>中找到很多很棒的幻灯片；<a href="http://www.mit.edu/~dimitrib/home.html" target="_blank" rel="noopener">Dimitri Bertsekas</a> 写了一系列关于优化、控制方面的书籍。读通这些书足以让任何一个人在这个领域立足。</p>
</li>
<li><p>随机梯度下降（SGD）</p>
<p>大多数问题其实最开始都是凸优化问题的特殊情况（至少早期定理如此），但是随着数据的增加，凸优化问题的占比会逐渐减少。因此，假设你现在得到了一些数据，你的算法将会需要在每一个更新步骤前将所有的数据都检查一遍。</p>
<p>现在，我不怀好意地给了你 10 份相同的数据，你将不得不重复 10 次没有任何帮助的工作。不过在现实中并不会这么糟糕，你可以设置很小的更新迭代步长，每次更新前都将所有的数据检查一遍，这种方法将会帮你解决这类问题。小步长计算在机器学习中已经有了很大的转型，配合上一些相关的算法会使得解决问题更加地简单。</p>
<p>不过，这样的做法对并行化计算提出了挑战。我们于 2009 年发表的<a href="http://arxiv.org/abs/0911.0491" target="_blank" rel="noopener">《Slow Learners are Fast》</a>论文可能就是这个方向的先导者之一。2013 年牛峰等人发表的<a href="https://www.eecs.berkeley.edu/~brecht/papers/hogwildTR.pdf" target="_blank" rel="noopener">《Hogwild》</a>论文给出了一种相当优雅的无锁版本变体。简而言之，这类各种各样的算法都是通过在单机计算局部梯度，并异步更新共有的参数集实现并行快速迭代运算。</p>
<p>随机梯度下降的另一个难题就是如何控制过拟合（例如可以通过正则化加以控制）。另外还有一种解决凸优化的惩罚方式叫近端梯度算法（PGD）。最流行的当属 Amir Beck 和 Marc Teboulle 提出的 <a href="http://people.rennes.inria.fr/Cedric.Herzet/Cedric.Herzet/Sparse_Seminar/Entrees/2012/11/12_A_Fast_Iterative_Shrinkage-Thresholding_Algorithmfor_Linear_Inverse_Problems_(A._Beck,_M._Teboulle" target="_blank" rel="noopener">FISTA 算法</a>_files/Breck_2009.pdf)了。相关代码可以参考 Francis Bach 的 <a href="http://spams-devel.gforge.inria.fr/" target="_blank" rel="noopener">SPAM toolbox</a>。</p>
</li>
<li><p>非凸优化方法</p>
<p>许多的机器学习问题是非凸的。尤其是与深度学习相关的问题几乎都是非凸的，聚类、主题模型（topic model）、潜变量方法（latent variable method）等各种有趣的机器学习方法也是如此。一些最新的加速技术将对此有所帮助。例如我的学生 <a href="http://www.cs.cmu.edu/~sjakkamr/" target="_blank" rel="noopener">Sashank Reddy</a> 最近展示了如何在这种情况下得到良好的<a href="http://arxiv.org/abs/1603.06160" target="_blank" rel="noopener">收敛</a><a href="http://arxiv.org/abs/1603.06159" target="_blank" rel="noopener">速率</a>。</p>
<p>也可以用一种叫做谱学习算法（Spectral Method）的技术。<a href="http://newport.eecs.uci.edu/anandkumar/" target="_blank" rel="noopener">Anima Anandkumar</a> 在最近的 <a href="/profile/Anima-Anandkumar-1">Quora session</a> 中详细地描述了这项技术的细节。请仔细阅读她的文章，因为里面干货满满。简而言之，凸优化问题并不是唯一能够可靠解决的问题。在某些情况中你可以试着找出其问题的数学等价形式，通过这样找到能够真正反映数据中聚类、主题、相关维度、神经元等一切信息的参数。如果你愿意且能够将一切托付给数学解决，那是一件无比伟大的事。</p>
<p>最近，在深度神经网络训练方面涌现出了各种各样的新技巧。我将会在下面介绍它们，但是在一些情况中，我们的目标不仅仅是优化模型，而是找到一种特定的解决方案（就好像旅途的重点其实是过程一样）。</p>
</li>
</ul>
</li>
<li><p>（分布式）系统</p>
<p>机器学习之所以现在成为了人类、测量学、传感器及数据相关领域几乎是最常用的工具，和过去 10 年规模化算法的发展密不可分。<a href="http://research.google.com/pubs/jeff.html" target="_blank" rel="noopener">Jeff Dean</a> 过去的一年发了 6 篇机器学习教程并不是巧合。在此简单介绍一下他：<a href="http://www.informatika.bg/jeffdean" target="_blank" rel="noopener">点击查看</a>，他是 MapReduce、GFS 及 BigTable 等技术背后的创造者，正是这些技术让 Google 成为了伟大的公司。</p>
<p>言归正传，（分布式）系统研究为我们提供了分布式、异步、容错、规模化、简单（Simplicity）的宝贵工具。最后一条“简单”是机器学习研究者们常常忽视的一件事。简单（Simplicity）不是 bug，而是一种特征。下面这些技术会让你受益良多：</p>
<ul>
<li><p>分布式哈希表</p>
<p>它是 <a href="https://memcached.org/" target="_blank" rel="noopener">memcached</a>、<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">dynamo</a>、<a href="http://research.microsoft.com/en-us/um/people/antr/PAST/pastry.pdf" target="_blank" rel="noopener">pastry</a> 以及 <a href="http://docs.ceph.com/docs/hammer/rados/" target="_blank" rel="noopener">ceph</a> 等的技术基础。它们所解决的都是同一件事情 —— 如何将对象分发到多台机器上，从而避免向中央存储区提出请求。为了达到这个目的，你必须将数据位置进行随机但确定的编码（即哈希）。另外，你需要考虑到当有机器出现故障时的处理方式。</p>
<p>我们自己的参数服务器就是使用这种<a href="https://www.cs.cmu.edu/~dga/papers/osdi14-paper-li_mu.pdf" target="_blank" rel="noopener">数据布局</a>。这个项目的幕后大脑是我的学生 <a href="http://www.cs.cmu.edu/~muli/" target="_blank" rel="noopener">Mu Li</a> 。请参阅 <a href="http://dmlc.ml/" target="_blank" rel="noopener">DMLC</a> 查看相关的工具集。</p>
</li>
<li><p>一致性与通信</p>
<p>这一切的基础都是 Leslie Lamport 的 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">PAXOS</a> 协议。它解决了不同机器（甚至部分机器不可用）的一致性问题。如果你曾经使用过版本控制工具，你应该可以直观地明白它是如何运行的——比如你有很多机器（或者很多开发者）都在进行数据更新（或更新代码），在它们（他们）不随时进行交流的情况下，你会如何将它们（他们）结合起来（不靠反复地求 diff）?</p>
<p>在（分布式）系统中，解决方案是一个叫做向量时钟的东西（请参考 Google 的 <a href="http://blogoscoped.com/archive/2008-07-24-n69.html" target="_blank" rel="noopener">Chubby</a>）。我们也在参数服务器上使用了这种向量时钟的变体，这个变体与本体的区别就是我们仅使用向量时钟来限制参数的范围（Mu Li 做的），这样可以确保内存不会被无限增长的向量时钟时间戳给撑爆，正如文件系统不需要给每个字节都打上时间戳。</p>
</li>
<li><p>容错机制、规模化与云</p>
<p>学习这些内容最简单的方法就是在云服务器上运行各种算法，至于云服务可以找 <a href="http://aws.amazon.com" target="_blank" rel="noopener">Amazon AWS</a>、<a href="http://console.google.com" target="_blank" rel="noopener">Google GWC</a>、<a href="http://azure.microsoft.com" target="_blank" rel="noopener">Microsoft Azure</a> 或者 <a href="http://serverbear.com/" target="_blank" rel="noopener">其它各种各样的服务商</a>。一次性启动 1,000 台服务器，意识到自己坐拥如此之大的合法“僵尸网络”是多么的让人兴奋！之前我在 Google 工作，曾在欧洲某处接手 5,000 余台高端主机作为主题模型计算终端，它们是我们通过能源法案获益的核电厂相当可观的一部分资源。我的经理把我带到一旁，偷偷告诉我这个实验是多么的昂贵……</p>
<p>可能入门这块最简单的方法就是去了解 <a href="http://www.docker.com" target="_blank" rel="noopener">docker</a> 了吧。现在 docker 团队已经开发了大量的规模化工具。特别是他们最近加上的 <a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">Docker Machine</a> 和 <a href="https://docs.docker.com/cloud/" target="_blank" rel="noopener">Docker Cloud</a>，可以让你就像使用打印机驱动一样连接云服务。</p>
</li>
<li><p>硬件</p>
<p>说道硬件可能会让人迷惑，但是如果你了解你的算法会在什么硬件上运行，对优化算法是很有帮助的。这可以让你知道你的算法是否能在任何条件下保持巅峰性能。我认为每个入门者都应该看看 Jeff Dean 的 <a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">《每个工程师都需要记住的数值》</a>。我在面试时最喜欢的问题（至少现在最喜欢）就是“请问你的笔记本电脑有多快”。了解是什么限制了算法的性能是很有用的：是缓存？是内存带宽？延迟？还是磁盘？或者别的什么？<a href="http://www.anandtech.com" target="_blank" rel="noopener">Anandtech</a> 在微处理器架构与相关方面写了很多很好的文章与评论，在 Intel、ARM、AMD 发布新硬件的时候不妨去看一看他的评论。</p>
</li>
</ul>
</li>
<li><p>统计学</p>
<p>我故意把这块内容放在文章的末尾，因为几乎所有人都认为它是（它的确是）机器学习的关键因而忽视了其它内容。统计学可以帮你问出好的问题，也能帮你理解你的建模与实际数据有多接近。</p>
<p>大多数图模型、核方法、深度学习等都能从“问一个好的问题”得到改进，或者说能够定义一个合理的可优化的目标函数。</p>
<ul>
<li><p>统计学相关资料<br><a href="http://www.stat.cmu.edu/~larry/" target="_blank" rel="noopener">Larry Wasserman</a> 的书<a href="http://www.stat.cmu.edu/~larry/all-of-statistics/" target="_blank" rel="noopener">《All of Statistics》</a>很好地介绍了统计学。或者你也可以看看 David McKay 的 <a href="http://www.inference.phy.cam.ac.uk/itprnn/book.pdf" target="_blank" rel="noopener">《Machine Learning》</a>一书，它是免费的，内容丰富而全面。此外还有很多好书值得一看，例如 <a href="https://mitpress.mit.edu/books/machine-learning-0" target="_blank" rel="noopener">Kevin Murphy</a> 的、<a href="http://research.microsoft.com/en-us/um/people/cmbishop/prml/" target="_blank" rel="noopener">Chris Bishop</a> 的、以及 <a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/" target="_blank" rel="noopener">Trevor Hastie、Rob Tibshirani 与 Jerome Friedman</a> 合著的书。还有，Bernhard Scholkopf 和我也<a href="https://mitpress.mit.edu/books/learning-kernels" target="_blank" rel="noopener">写了一本</a>。</p>
</li>
<li><p>随机算法与概率计算</p>
<p>统计学算法本质上也是个计算机科学方面的问题。但是统计学的算法与计算机科学的最大区别在于，统计学是将计算机作为一个工具来设计算法，而不是作为一个黑箱进行调参。我很喜欢<a href="http://www.amazon.com/Probability-Computing-Randomized-Algorithms-Probabilistic/dp/0521835402" target="_blank" rel="noopener">这本 Michael Mitzenmacher 与 Eli Upfal 合著的书</a>，它涵盖了很多方面的问题，并且很容易读懂。另外如果你想更深入地了解这个“工具”，请阅读<a href="http://www.amazon.com/Randomized-Algorithms-Rajeev-Motwani/dp/0521474655" target="_blank" rel="noopener">这本 Rajeev Motwani 和 Prabhakar Raghavan 合著的书籍</a>。这本书写的很棒，但是没有统计学背景很难理解它。</p>
</li>
</ul>
</li>
</ul>
<p>这篇文章已经写的够久了，不知道有没有人能读到这里，我要去休息啦。现在网上有很多很棒的视频内容可以帮助你学习，许多教师现在都开通了他们的 Youtube 频道，上传他们的上课内容。这些课程有时可以帮你解决一些复杂的问题。这儿是<a href="https://www.youtube.com/user/smolix/playlists" target="_blank" rel="noopener">我的 Youtube 频道</a>欢迎订阅。顺便推荐 <a href="https://www.youtube.com/user/ProfNandoDF" target="_blank" rel="noopener">Nando de Freitas 的 Youtube 频道</a>，他比我讲得好多了。</p>
<p>最后推荐一个非常好用的工具：<a href="http://www.dmlc.ml" target="_blank" rel="noopener">DMLC</a>。它很适合入门，包含了大量的分布式、规模化的机器学习算法，还包括了通过 MXNET 实现的神经网络。</p>
<p>虽然本文还有很多方面没有提到（例如编程语言、数据来源等），但是这篇文章已经太长了，这些内容请参考其他文章吧~</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/596323416fb9a06bae1dff63" target="_blank" rel="noopener">https://juejin.im/post/596323416fb9a06bae1dff63</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/04/V8-性能优化杀手/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/04/V8-性能优化杀手/" class="post-title-link" itemprop="url">V8 性能优化杀手</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-07-04 12:58:00" itemprop="dateCreated datePublished" datetime="2017-07-04T12:58:00+08:00">2017-07-04</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章将会给你一些建议，让你避免写出性能远低于期望值的代码。在此特别指出有一些代码会导致 V8 引擎（涉及到 Node.JS、Opera、Chromium 等）无法对相关函数进行优化。</p>
<p>vhf 正在做一个类似的项目，试图将 V8 引擎的性能杀手全部列出来：<a href="https://github.com/vhf/v8-bailout-reasons" target="_blank" rel="noopener">V8 Bailout Reasons</a>。</p>
<h3 id="V8-引擎背景知识"><a href="#V8-引擎背景知识" class="headerlink" title="V8 引擎背景知识"></a>V8 引擎背景知识</h3><p>V8 引擎中没有解释器，但有 2 种不同的编译器：普通编译器与优化编译器。编译器会将你的 JavaScript 代码编译成汇编语言后直接运行。但这并不意味着运行速度会很快。被编译成汇编语言后的代码并不能显著地提高其性能，它只能省去解释器的性能开销，如果你的代码没有被优化的话速度依然会很慢。</p>
<p>例如，在普通编译器中 <code>a + b</code> 将会被编译成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">call RuntimeAdd</span><br></pre></td></tr></table></figure>
<p>换句话说，其实它仅仅调用了 runtime 函数。但如果 <code>a</code> 和 <code>b</code> 能确定都是整型变量，那么编译结果会是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">add eax, ebx</span><br></pre></td></tr></table></figure>
<p>它的执行速度会比前面那种去在 runtime 中调用复杂的 JavaScript 加法算法快得多。</p>
<p>通常来说，使用普通编译器将会得到前面那种代码，使用优化编译器将会得到后面那种代码。走优化编译器的代码可以说比走普通编译器的代码性能好上 100 倍。但是请注意，并不是任何类型的 JavaScript 代码都能被优化。在 JS 中，有很多种情况（甚至包括一些我们常用的语法）是不能被优化编译器优化的（这种情况被称为“bailout”，从优化编译器降级到普通编译器）。</p>
<p>记住一些会导致整个函数无法被优化的情况是很重要的。JS 代码被优化时，将会逐个优化函数，在优化各个函数的时候不会关心其它的代码做了什么（除非那些代码被内联在即将优化的函数中。）。</p>
<p>这篇文章涵盖了大多数会导致函数坠入“无法被优化的深渊”的情况。不过在未来，优化编译器进行更新后能够识别越来越多的情况时，下面给出的建议与各种变通方法可能也会变的不再必要或者需要修改。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ol>
<li><a href="#1-工具">工具</a></li>
<li><a href="#2-不支持的语法">不支持的语法</a></li>
<li><a href="#3-使用-arguments">使用 <code>arguments</code></a></li>
<li><a href="#4-switch-case">Switch-case</a></li>
<li><a href="#5-for-in">For-in</a></li>
<li><a href="#6-退出条件藏的很深-或者没有定义明确出口的无限循环">退出条件藏的很深，或者没有定义明确出口的无限循环</a></li>
</ol>
<h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><p>你可以在 node.js 中使用一些 V8 自带的标记来验证不同的代码用法对优化的影响。通常来说你可以创建一个包括特定模式的函数，然后使用所有允许的参数类型去调用它，再使用 V8 的内部去优化与检查它：</p>
<p>test.js:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建包含需要检查的情况的函数（检查使用 `eval` 语句是否能被优化）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStatus</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(%GetOptimizationStatus(fn)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(<span class="string">"Function is not optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(<span class="string">"Function is always optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(<span class="string">"Function is never optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(<span class="string">"Function is maybe deoptimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized by TurboFan"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">"Unknown optimization status"</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别类型信息</span></span><br><span class="line">exampleFunction();</span><br><span class="line"><span class="comment">//这里调用 2 次是为了让这个函数状态从 uninitialized -&gt; pre-monomorphic -&gt; monomorphic</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line">%OptimizeFunctionOnNextCall(exampleFunction);</span><br><span class="line"><span class="comment">//再次调用</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查</span></span><br><span class="line">printStatus(exampleFunction);</span><br></pre></td></tr></table></figure>
<p>运行它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">(v0.12.7) Function is not optimized</span><br><span class="line">(v4.0.0) Function is optimized by TurboFan</span><br></pre></td></tr></table></figure>
<p><a href="https://codereview.chromium.org/1962103003" target="_blank" rel="noopener">https://codereview.chromium.org/1962103003</a></p>
<p>为了检验我们做的这个工具是否真的有用，注释掉 <code>eval</code> 语句然后再运行一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">[optimizing 000003FFCBF74231 &lt;JS Function exampleFunction (SharedFunctionInfo 00000000FE1389E1)&gt; - took 0.345, 0.042, 0.010 ms]</span><br><span class="line">Function is optimized</span><br></pre></td></tr></table></figure>
<p>事实证明，使用这个工具来验证处理方法是可行且必要的。</p>
<h2 id="2-不支持的语法"><a href="#2-不支持的语法" class="headerlink" title="2. 不支持的语法"></a>2. 不支持的语法</h2><p>有一些语法结构是不支持被编译器优化的，用这类语法将会导致包含在其中的函数不能被优化。</p>
<p><strong>请注意</strong>，即使这些语句不会被访问到或者不会被执行，它仍然会导致整个函数不能被优化。</p>
<p>例如下面这样做是没用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEVELOPMENT) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使 debugger 语句根本不会被执行到，上面的代码将会导致包含它的整个函数都不能被优化。</p>
<p>目前不可被优化的语法有：</p>
<ul>
<li><del>Generator 函数</del> （<a href="https://v8project.blogspot.de/2017/02/v8-release-57.html" target="_blank" rel="noopener">V8 5.7</a> 对其做了优化）</li>
<li><del>包含 for of 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/11e1e20" target="_blank" rel="noopener">11e1e20</a> 对其做了优化）</li>
<li><del>包含 try catch 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li>
<li><del>包含 try finally 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li>
<li><del>包含<a href="http://stackoverflow.com/q/34595356/504611" target="_blank" rel="noopener"><code>let</code> 复合赋值</a>的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li>
<li><del>包含 <code>const</code> 复合赋值的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li>
<li>包含 <code>__proto__</code> 对象字面量、<code>get</code> 声明、<code>set</code> 声明的函数</li>
</ul>
<p>看起来永远不会被优化的语法有：</p>
<ul>
<li>包含 <code>debugger</code> 语句的函数</li>
<li>包含字面调用 <code>eval()</code> 的函数</li>
<li>包含 <code>with</code> 语句的函数</li>
</ul>
<p>最后明确一下：如果你用了下面任何一种情况，整个函数将不能被优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithProto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__proto__</span>: <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get prop() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithSetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        set prop(val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在此要特别提一下 <code>eval</code> 和 <code>with</code>，它们会导致它们的调用栈链变成动态作用域，可能会导致其它的函数也受到影响，因为这种情况无法从字面上判断各个变量的有效范围。</p>
<p><strong>变通办法</strong></p>
<p>前面提到的不能被优化的语句用在生产环境代码中是无法避免的，例如 <code>try-finally</code> 和 <code>try-catch</code>。为了让使用这些语句的影响尽量减小，它们需要被隔离在一个最小化的函数中，这样主要的函数就不会被影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorObject = &#123;<span class="attr">value</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">fn, ctx, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        errorObject.value = e;</span><br><span class="line">        <span class="keyword">return</span> errorObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = tryCatch(mightThrow, <span class="keyword">void</span> <span class="number">0</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//明确地报出 try-catch 会抛出什么</span></span><br><span class="line"><span class="keyword">if</span>(result === errorObject) &#123;</span><br><span class="line">    <span class="keyword">var</span> error = errorObject.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//result 是返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-使用-arguments"><a href="#3-使用-arguments" class="headerlink" title="3. 使用 arguments"></a>3. 使用 <code>arguments</code></h2><p>有许多种使用 <code>arguments</code> 的方式会导致函数不能被优化。因此当使用 <code>arguments</code> 的时候需要格外小心。</p>
<h4 id="3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例："><a href="#3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例：" class="headerlink" title="3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 arguments 引用的参数重新赋值。典型案例："></a>3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 <code>arguments</code> 引用的参数重新赋值。典型案例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultArgsReassign</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变通方法</strong> 是将参数值保存在一个新的变量中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = b_;</span><br><span class="line">    <span class="comment">//与 b_ 不同，可以安全地对 b 进行重新赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅仅是像上面这样用 <code>arguments</code>（上面代码作用为检测第二个参数是否存在，如果不存在则赋值为 5），也可以用 <code>undefined</code> 检测来代替这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="keyword">void</span> <span class="number">0</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是之后如果需要用到 <code>arguments</code>，很容易忘记需要在这儿加上重新赋值的语句。</p>
<p><strong>变通方法 2</strong>：为整个文件或者整个函数开启严格模式 （<code>&#39;use strict&#39;</code>）。</p>
<h4 id="3-2-arguments-泄露："><a href="#3-2-arguments-泄露：" class="headerlink" title="3.2. arguments 泄露："></a>3.2. arguments 泄露：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arguments</code> 对象在任何地方都不允许被传递或者被泄露。</p>
<p><strong>变通方法</strong> 可以通过创建一个数组来代理 <code>arguments</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//.length 仅仅是一个整数，不存在泄露</span></span><br><span class="line">                    <span class="comment">//arguments 对象本身的问题</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">                <span class="comment">//i 是 arguments 对象的合法索引值</span></span><br><span class="line">        args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherNotLeakingExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">while</span> (i--) args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样要写很多让人烦的代码，因此得判断是否真的值得这么做。后面一次又一次的优化会代理更多的代码，越来越多的代码意味着代码本身的意义会被逐渐淹没。</p>
<p>不过，如果你有 build 这个过程，可以将上面这一系列过程由一个不需要 source map 的宏来实现，保证代码为合法的 JavaScript：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    INLINE_SLICE(args, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bluebird 就使用了这个技术，上面的代码经过 build 之后会被拓展成下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $_len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>($_len); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> $_i = <span class="number">0</span>; $_i &lt; $_len; ++$_i) &#123;</span><br><span class="line">        args[$_i] = <span class="built_in">arguments</span>[$_i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-对-arguments-进行赋值："><a href="#3-3-对-arguments-进行赋值：" class="headerlink" title="3.3. 对 arguments 进行赋值："></a>3.3. 对 arguments 进行赋值：</h4><p>在非严格模式下可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignToArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变通方法</strong>：犯不着写这么蠢的代码。另外，在严格模式下它会报错。</p>
<h4 id="那么如何安全地使用-arguments-呢？"><a href="#那么如何安全地使用-arguments-呢？" class="headerlink" title="那么如何安全地使用 arguments 呢？"></a>那么如何安全地使用 <code>arguments</code> 呢？</h4><p>只使用：</p>
<ul>
<li><code>arguments.length</code></li>
<li><code>arguments[i]</code> <strong><code>i</code> 需要始终为 arguments 的合法整型索引，且不允许越界</strong></li>
<li>除了 <code>.length</code> 和 <code>[i]</code>，不要直接使用 <code>arguments</code></li>
<li>严格来说用 <code>fn.apply(y, arguments)</code> 是没问题的，但除此之外都不行（例如 <code>.slice</code>）。 <code>Function#apply</code> 是特别的存在。</li>
<li>请注意，给函数添加属性值（例如 <code>fn.$inject = ...</code>）和绑定函数（即 <code>Function#bind</code> 的结果）会生成隐藏类，因此此时使用 <code>#apply</code> 不安全。</li>
</ul>
<p>如果你按照上面的安全方式做，毋需担心使用 <code>arguments</code> 导致不确定 arguments 对象的分配。</p>
<h2 id="4-Switch-case"><a href="#4-Switch-case" class="headerlink" title="4. Switch-case"></a>4. Switch-case</h2><p>在以前，一个 switch-case 语句最多只能包含 128 个 case 代码块，超过这个限制的 switch-case 语句以及包含这种语句的函数将不能被优化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">over128Cases</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="number">128</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">129</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要让 case 代码块的数量保持在 128 个之内，否则应使用函数数组或者 if-else。</p>
<p>这个限制现在已经被解除了，请参阅此 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=2275#c9" target="_blank" rel="noopener">comment</a>。</p>
<h2 id="5-For-in"><a href="#5-For-in" class="headerlink" title="5. For-in"></a>5. For-in</h2><p>For-in 语句在某些情况下会导致整个函数无法被优化。</p>
<p>这也解释了”For-in 速度不快“之类的说法。</p>
<h4 id="5-1-键不是局部变量："><a href="#5-1-键不是局部变量：" class="headerlink" title="5.1. 键不是局部变量："></a>5.1. 键不是局部变量：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种用法db都将会导致函数不能被优化的问题。因此键不能在上级作用域定义，也不能在下级作用域被引用。它必须是一个局部变量。</p>
<h4 id="5-2-被遍历的对象不是一个”简单可枚举对象“"><a href="#5-2-被遍历的对象不是一个”简单可枚举对象“" class="headerlink" title="5.2. 被遍历的对象不是一个”简单可枚举对象“"></a>5.2. 被遍历的对象不是一个”简单可枚举对象“</h4><h5 id="5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"><a href="#5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。" class="headerlink" title="5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"></a>5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashTableIteration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashTable = &#123;<span class="string">"-"</span>: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> hashTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你给一个对象动态增加了很多的属性（在构造函数外）、<code>delete</code> 属性或者使用不合法的标识符作为属性，这个对象将会变成哈希表模式。换句话说，当你把一个对象当做哈希表来用，它就真的会变成哈希表。请不要对这种对象使用 <code>for-in</code>。你可以用过开启 Node.JS 的 <code>--allow-natives-syntax</code>，调用 <code>console.log(%HasFastProperties(obj))</code> 来判断一个对象是否为哈希表模式。</p>
<hr>

<h5 id="5-2-2-对象的原型链中存在可枚举属性"><a href="#5-2-2-对象的原型链中存在可枚举属性" class="headerlink" title="5.2.2. 对象的原型链中存在可枚举属性"></a>5.2.2. 对象的原型链中存在可枚举属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这么做会给所有对象（除了用 <code>Object.create(null)</code> 创建的对象）的原型链中添加一个可枚举属性。此时任何包含了 <code>for-in</code> 语法的函数都不会被优化（除非仅遍历 <code>Object.create(null)</code> 创建的对象）。</p>
<p>你可以使用 <code>Object.defineProperty</code> 创建不可枚举属性（不推荐在 runtime 中调用，但是在定义一些例如原型属性之类的静态数据的时候它很高效）。</p>
<hr>

<h5 id="5-2-3-对象中包含可枚举数组索引"><a href="#5-2-3-对象中包含可枚举数组索引" class="headerlink" title="5.2.3. 对象中包含可枚举数组索引"></a>5.2.3. 对象中包含可枚举数组索引</h5><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4" target="_blank" rel="noopener">ECMAScript 262 规范</a> 定义了一个属性是否有数组索引：</p>
<blockquote>
<p>数组对象会给予一些种类的属性名特殊待遇。对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 2<sup>32</sup>−1 时，它是个 数组索引 。一个属性名是数组索引的属性也叫做元素 。</p>
</blockquote>
<p>一般只有数组有数组索引，但是有时候一般的对象也可能拥有数组索引： <code>normalObj[0] = value;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratesOverArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此使用 <code>for-in</code> 进行数组遍历不仅会比 for 循环要慢，还会导致整个包含 <code>for-in</code> 语句的函数不能被优化。</p>
<hr>

<p>如果你试图使用 <code>for-in</code> 遍历一个非简单可枚举对象，它会导致包含它的整个函数不能被优化。 </p>
<p><strong>变通方法</strong>：只对 <code>Object.keys</code> 使用 <code>for-in</code>，如果要遍历数组需使用 for 循环。如果非要遍历整个原型链上的属性，需要将 <code>for-in</code> 隔离在一个辅助函数中以降低影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        ret.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-退出条件藏的很深，或者没有定义明确出口的无限循环"><a href="#6-退出条件藏的很深，或者没有定义明确出口的无限循环" class="headerlink" title="6. 退出条件藏的很深，或者没有定义明确出口的无限循环"></a>6. 退出条件藏的很深，或者没有定义明确出口的无限循环</h2><p>有时候在你写代码的时候，你需要用到循环，但是不确定循环体内的代码之后会是什么样子。所以这时候你用了一个 <code>while (true) {</code> 或者 <code>for (;;) {</code>，在之后将终止条件放在循环体中，打断循环进行后面的代码。然而你写完这些之后就忘了这回事。在重构时，你发现这个函数很慢，出现了反优化情况 - 上面的循环很可能就是罪魁祸首。</p>
<p>重构时将循环内的退出条件放到循环的条件部分并不是那么简单。</p>
<ol>
<li>如果代码中的退出条件是循环最后的 if 语句的一部分，且代码至少要运行一轮，那么你可以将这个循环重构为 <code>do{} while ();</code>。</li>
<li>如果退出条件在循环的开头，请将它放在循环的条件部分中去。</li>
<li>如果退出条件在循环体中部，你可以尝试”滚动“代码：试着依次将一部分退出条件前的代码移到后面去，然后在之前的位置留下它的引用。当退出条件可以放在循环条件部分，或者至少变成一个浅显的逻辑判断时，这个循环就不再会出现反优化的情况了。</li>
</ol>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/5959edfc5188250d83241399" target="_blank" rel="noopener">https://juejin.im/post/5959edfc5188250d83241399</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/30/在html中使用背景透明的video视频/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/30/在html中使用背景透明的video视频/" class="post-title-link" itemprop="url">在html中使用背景透明的video视频</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-30 16:53:24" itemprop="dateCreated datePublished" datetime="2017-06-30T16:53:24+08:00">2017-06-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于对效果的要求，需要加入透明背景的video。经过了解，现代浏览器（新版 Chrome、Firefox、Safari 等）已经全面支持 webM 格式的视频了，因此可以使用带 alpha 通道的 webM 格式视频满足要求。</p>
<p>要得到透明 webM 格式视频，则需要来源视频已经带有透明通道。</p>
<p>目前有几种方法：</p>
<p>1、使用 blander 进行绿幕抠图，将 green screen 扣去，生成背景透明的 png 帧序列，然后使用 ffmpeg 之类的工具将其生成 webM 文件。</p>
<p>2、使用 Adobe After Effect 之类的软件，在渲染时直接输出 Alpha + RGB 通道文件，然后使用 ffmpeg 之类的工具将其转换为 webM 文件。</p>
<blockquote>
<p>ffmpeg 软件下载：<a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener">https://ffmpeg.org/download.html</a> </p>
</blockquote>
<p>由于视频是自己用 AE 做的，因此直接选用第二种方法很方便。</p>
<p>首先，将视频背景颜色改成透明的：</p>
<p><img src="/images/pasted-166.png" alt="upload successful"></p>
<p>模式选择 Alpha 添加。在工作区下方将网络切换为透明网络</p>
<p><img src="/images/pasted-167.png" alt="upload successful"></p>
<p>如果改成功了，此时应该看到工作区的背景是灰白两色栅格。</p>
<p>将合成添加到渲染队列，进行设置：</p>
<p><img src="/images/pasted-168.png" alt="upload successful"></p>
<p>将输出模块改为“使用 Alpha 无损耗”，此时详情应该可以看到格式为 QuickTime，通道是 RGB + Alpha</p>
<p><img src="/images/pasted-169.png" alt="upload successful"></p>
<p>渲染输出，得到 .mov 文件，使用 ffmpeg 对其进行压缩编码。</p>
<p>执行命令：</p>
<pre><code>ffmpeg -i in.mov -c:a libvorbis -ac 1 -b:a 96k -ar 48000 -b:v 1100k -maxrate 1100k -bufsize 1835k out.webm
</code></pre><p>得到 out.webm，它就是所需要的透明背景的 webM 文件了，可以在网页中使用 <code>&lt;video&gt;</code> tag 引用。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/15/用-Go-语言理解-Tensorflow/" class="post-title-link" itemprop="url">用 Go 语言理解 Tensorflow</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-15 15:41:00" itemprop="dateCreated datePublished" datetime="2017-06-15T15:41:00+08:00">2017-06-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>根据官方说明，Tensorflow 开发者发布了以下内容：</p>
<ul>
<li><p>C++ 源码：底层和高层的具体功能由 C ++ 源码实现，它是真正 Tensorflow 的核心。</p>
</li>
<li><p>Python 封装与Python 库：由 C++ 实现自动生成的封装版本，通过这种方式我们可以直接用 Python 来调用 C++ 函数：这也是 numpy 的核心实现方式。</p>
<p>Python 库通过将 Python 封装版的各种调用结合起来，组成了各种广为人知的高层 API。</p>
</li>
<li><p>Java 封装</p>
</li>
<li><p>Go 封装</p>
</li>
</ul>
<p>作为一名 Gopher 而非一名 java 爱好者，我对 Go 封装给予了极大的关注，希望了解其适用于何种任务。</p>
<blockquote>
<p>译注，这里说的”封装“也有说法叫做”语言界面“</p>
</blockquote>
<h2 id="Go-封装"><a href="#Go-封装" class="headerlink" title="Go 封装"></a>Go 封装</h2><p><img src="/images/pasted-165.png" alt="upload successful"></p>
<p>图为 Gopher（由 Takuya Ueda <a href="https://twitter.com/tenntenn" target="_blank" rel="noopener">@tenntenn</a> 创建，遵循 CC 3.0 协议）与 Tensorflow 的 Logo 结合在一起。</p>
<hr>
<p>首先要注意的是，代码维护者自己也承认了，Go API 缺少 <code>Variable</code> 支持，因此这个 API 仅用于<strong>使用</strong>训练好的模型，而<strong>不能用于</strong>进行模型训练。</p>
<p>在文档 <a href="https://www.tensorflow.org/versions/master/install/install_go" target="_blank" rel="noopener">Installing Tensorflow for Go</a> 中已经明确提到：</p>
<blockquote>
<p>TensorFlow 为 Go 编程提供了一些 API。这些 API 特别适合加载在 Python 中创建的模型，让其在 Go 应用 中运行。</p>
</blockquote>
<p>如果我们对训练机器学习模型没兴趣，那这个限制是 OK 的。</p>
<p>但是，如果你打算自己训练模型，请看下面给的建议：</p>
<blockquote>
<p>作为一名 Gopher，请让 Go 保持简洁！使用 Python 去定义、训练模型，在这之后你随时都可以用 Go 来加载训练好的模型！（意思就是他们懒得开发呗）</p>
</blockquote>
<p>简而言之，golang 版 tensorflow 可以<strong>导入与定义</strong>常数图（constant graph）。这个常数图指的是在图中没有训练过程，也没有需要训练的变量。</p>
<p>让我们用 Golang 深入研究 Tensorflow 吧！首先创建我们的第一个应用。</p>
<p>我建议读者在阅读下面的内容前，先准备好 Go 环境，以及编译、安装好 Tensorflow Go 版（编译、安装过程参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/go/README.md" target="_blank" rel="noopener">README</a>）。</p>
<h2 id="理解-Tensorflow-的结构"><a href="#理解-Tensorflow-的结构" class="headerlink" title="理解 Tensorflow 的结构"></a>理解 Tensorflow 的结构</h2><p>先复习一下什么是 Tensorflow 吧！（这是我个人的理解，和<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">官网</a>的有所不同）</p>
<blockquote>
<p>TensorFlow™ 是一个采用数据流图(data flow graphs),用于数值计算的开源软件库。节点（Nodes）在图中<strong>表示</strong>数学操作，图中的线（edges）则<strong>表示</strong>在节点间相互联系的多维数据数组，即张量（tensor）。</p>
</blockquote>
<p>我们可以把 Tensorflow 看做一种类似于 SQL 的描述性语言，首先你得确定你需要什么数据，它会通过底层引擎（数据库）分析你的查询语句，检查你的句法错误和语法错误，将查询语句转换为私有语言表达式，进行优化之后运算得出计算结果。这样，它能保证将正确的结果传达给你。</p>
<p>因此，我们无论使用什么 API 实质上都是在描述一个图。我们将它放在 <code>Session</code> 中作为求值的起点，这样做确定了这个图将会在这个 Session 中运行。</p>
<p>了解这一点，我们可以试着定义一个计算操作的图，并将其放在一个 <code>Session</code> 中进行求值。</p>
<p> <a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go" target="_blank" rel="noopener">API 文档</a>中明确告知了 <code>tensorflow</code>（简称 <code>tf</code>）包与 <code>op</code> 包中的可用方法列表。</p>
<p>在这个列表中我们可以看到，这两个包中包含了一切我们需要用来定义与评价图的方法。</p>
<p><code>tf</code> 包中包含了各种构建基础结构的函数，例如 <code>Graph</code>（图）。<code>op</code> 包是最重要的包，它包含了由 C++ 实现自动生成的绑定等功能。</p>
<p>现在，假设我们要计算 AAA 与 xxx 的矩阵乘法：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fg9itnbsc7j31au06274m.jpg" alt=""></p>
<p>我假定你们都熟悉 tensorflow 图的定义，都了解 placeholder 并知道它们的工作原理。</p>
<p>下面的代码是一位 Tensorflow Python 用户第一次尝试时会写的代码。让我们给这个文件取名为 <code>attempt1.go</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span></span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">	x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line"></span><br><span class="line">	graph, err := root.Finalize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session</span><br><span class="line">	sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量</span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]</span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]</span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor</span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;</span><br><span class="line">		A: matrix,</span><br><span class="line">		x: column,</span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int64</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码写好了注释，我建议读者阅读上面的每一条注释。</p>
<p>现在，这位 Tensorflow Python 用户自我感觉良好，认为他的代码能够成功编译与运行。让我们试一试吧：</p>
<p><code>go run attempt1.go</code></p>
<p>然后他会看到：</p>
<p><code>panic: failed to add operation &quot;Placeholder&quot;: Duplicate node name in graph: &#39;Placeholder&#39;</code></p>
<p>等等，为什么会这样呢？</p>
<p>问题很明显。上面代码里出现了 2 个重名的“Placeholder”操作。</p>
<h2 id="第-1-课：node-IDs"><a href="#第-1-课：node-IDs" class="headerlink" title="第 1 课：node IDs"></a>第 1 课：node IDs</h2><p><strong>每次在我们调用方法定义一个操作的时候，不管他是否在之前被调用过，Python API 都会生成不同的节点</strong>。</p>
<p>所以，下面的代码没有任何问题，会返回 3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.placeholder(tf.int32, shape=())</span><br><span class="line">b = tf.placeholder(tf.int32, shape=())</span><br><span class="line">add = tf.add(a,b)</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(sess.run(add, feed_dict=&#123;a: <span class="number">1</span>,b: <span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure>
<p>我们可以验证一下这个问题，看看程序是否创建了两个不同的 placeholder 节点： <code>print(a.name, b.name)</code> </p>
<p>它打印出 <code>Placeholder:0 Placeholder_1:0</code>。</p>
<p>这样就清楚了，<code>a</code> placeholder 是 <code>Placeholder:0</code> 而 <code>b</code> placeholder 是 <code>Placeholder_1:0</code>。</p>
<p>但是在 Go 中，上面的程序会报错，因为 <code>A</code> 与 <code>x</code> 都叫做 <code>Placeholder</code>。我们可以由此得出结论：</p>
<p><strong>每次我们调用定义操作的函数时，Go API 并不会自动生成新的名称</strong>。因此，它的操作名是固定的，我们没法修改。</p>
<h4 id="提问时间："><a href="#提问时间：" class="headerlink" title="提问时间："></a>提问时间：</h4><ul>
<li><p>关于 Tensorflow 的架构我们学到了什么？</p>
<p><strong>图中的每个节点都必须有唯一的名称。所有节点都是通过名称进行辨认。</strong></p>
</li>
<li><p>节点名称与定义操作符的名称是否相同？</p>
<p><strong>是的，也可说节点名称是操作符名称的最后一段。</strong></p>
</li>
</ul>
<p>接下来让我们修复节点名称重复的问题，来弄明白上面的第二个提问。</p>
<h2 id="第-2-课：作用域"><a href="#第-2-课：作用域" class="headerlink" title="第 2 课：作用域"></a>第 2 课：作用域</h2><p>正如我们所见，Python API 在定义操作时会自动创建新的名称。如果研究底层会发现，Python API 调用了 C++ <code>Scope</code> 类中的 <code>WithOpName</code> 方法。</p>
<p>下面是该方法的文档及特性，参考 <a href="https://github.com/tensorflow/tensorflow/blob/a5b1fb8e56ceda0ee2794ee05f5a7642157875c5/tensorflow/cc/framework/scope.h" target="_blank" rel="noopener">scope.h</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回新的作用域。所有在返回的作用域中的 op 都会被命名为</span></span><br><span class="line"><span class="comment">/// &lt;name&gt;/&lt;op_name&gt;[_&lt;suffix].</span></span><br><span class="line">Scope WithOpName(<span class="keyword">const</span> <span class="keyword">string</span>&amp; op_name) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>注意这个方法，返回一个作用域 <code>Scope</code> 来对节点进行命名，因此节点名称事实上就是作用域 <code>Scope</code>。</p>
<p><code>Scope</code> 就是从根 <code>/</code>（空图）追溯至 <code>op_name</code> 的<strong>完整路径</strong>。</p>
<p><code>WithOpName</code> 方法在我们尝试添加一个有着相同的 <code>/</code> 到 <code>op_name</code> 路径的节点时，为了避免在相同作用域下有重复的节点，会为其加上一个后缀 <code>_&lt;suffix&gt;</code>（<code>&lt;suffix&gt;</code> 是一个计数器）。</p>
<p>了解了以上内容，我们可以通过在 <code>type Scope</code> 中寻找 <code>WithOpName</code> 来解决重复节点名称的问题。然而，Go tf API  中没有这个方法。</p>
<p>如果查阅 <a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope" target="_blank" rel="noopener">type Scope 的文档</a>，我们可以看到唯一能返回新 <code>Scope</code> 的方法只有 <code>SubScope(namespace string)</code>。</p>
<p>下面引用文档中的内容：</p>
<blockquote>
<p>SubScope 将会返回一个新的 Scope，这个 Scope 能确保所有的被加入图中的操作都被放置在 ‘namespace’ 的命名空间下。如果这个命名空间和作用域中已经存在的命名空间冲突，将会给它加上后缀。</p>
</blockquote>
<p>这种加后缀的冲突处理和 C++ 中的 <code>WithOpName</code> 方法<strong>不同</strong>，<code>WithOpName</code> 是在<strong>操作名后面</strong>加<code>suffix</code>，它们都在同样的作用域内（例如 <code>Placeholder</code> 变成 <code>Placeholder_1</code>），而 Go 的 <code>SubScope</code> 是在<strong>作用域名称后面</strong>加 <code>suffix</code>。</p>
<p>这将导致这两种方法会生成完全不同的图（节点在不同的作用域中了），但是它们的计算结果却是一样的。</p>
<p>让我们试着改一改 placeholder 定义，让它们定义两个不同的节点，然后打印 <code>Scope</code> 名称。</p>
<p>让我们创建 <code>attempt2.go</code> ，将下面几行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line"><span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">fmt.Println(A.Op.Name(), x.Op.Name())</span><br></pre></td></tr></table></figure>
<p>编译、运行： <code>go run attempt2.go</code>，输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br></pre></td></tr></table></figure>
<h4 id="提问时间：-1"><a href="#提问时间：-1" class="headerlink" title="提问时间："></a>提问时间：</h4><ul>
<li><p>关于 Tensorflow 的架构我们学到了什么？</p>
<p><strong>节点完全由其定义所在的作用域标识。这个”作用域“是我们从图的根节点追溯到指定节点的一条路径。有两种方法来定义执行同一种操作的节点：1、将其定义放在不同的作用域中（Go 风格）2、改变操作名称（我们在 C++ 中可以这么做，Python 版会自动这么做）</strong></p>
</li>
</ul>
<p>现在，我们已经解决了节点命名重复的问题，但是现在我们的控制台中出现了另一个问题：</p>
<pre><code>panic: failed to add operation &quot;MatMul&quot;: Value for attr &#39;T&#39; of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128
</code></pre><p>为什么 <code>MatMul</code> 节点的定义出错了？我们要做的仅仅是计算两个 <code>tf.int64</code> 矩阵的乘积而已！似乎 <code>MatMul</code> 偏偏不能接受 <code>int64</code> 的类型。</p>
<blockquote>
<p>Value for attr ‘T’ of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128</p>
</blockquote>
<p>上面这个列表是什么？为什么我们能计算 2 个 <code>int32</code> 矩阵的乘积却不能计算 <code>int64</code> 的乘积？</p>
<p>下面我们将解决这个问题。</p>
<h2 id="第-3-课：Tensorflow-类型系统"><a href="#第-3-课：Tensorflow-类型系统" class="headerlink" title="第 3 课：Tensorflow 类型系统"></a>第 3 课：Tensorflow 类型系统</h2><p>让我们深入研究 <a href="https://github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/core/ops/math_ops.cc#L1048" target="_blank" rel="noopener">源代码</a> 来看 C++ 是如何定义 <code>MatMul</code> 操作的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_OP(<span class="string">"MatMul"</span>)</span><br><span class="line">    .Input(<span class="string">"a: T"</span>)</span><br><span class="line">    .Input(<span class="string">"b: T"</span>)</span><br><span class="line">    .Output(<span class="string">"product: T"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_a: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_b: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"T: &#123;half, float, double, int32, complex64, complex128&#125;"</span>)</span><br><span class="line">    .SetShapeFn(shape_inference::MatMulShape)</span><br><span class="line">    .Doc(R<span class="string">"doc(</span></span><br><span class="line"><span class="string">Multiply the matrix "</span>a<span class="string">" by the matrix "</span>b<span class="string">".</span></span><br><span class="line"><span class="string">The inputs must be two-dimensional matrices and the inner dimension of</span></span><br><span class="line"><span class="string">"</span>a<span class="string">" (after being transposed if transpose_a is true) must match the</span></span><br><span class="line"><span class="string">outer dimension of "</span>b<span class="string">" (after being transposed if transposed_b is</span></span><br><span class="line"><span class="string">true).</span></span><br><span class="line"><span class="string">*Note*: The default kernel implementation for MatMul on GPUs uses</span></span><br><span class="line"><span class="string">cublas.</span></span><br><span class="line"><span class="string">transpose_a: If true, "</span>a<span class="string">" is transposed before multiplication.</span></span><br><span class="line"><span class="string">transpose_b: If true, "</span>b<span class="string">" is transposed before multiplication.</span></span><br></pre></td></tr></table></figure>
<p>这几行代码为 <code>MatMul</code> 操作定义了一个接口，由 <code>REGISTER_OP</code> 宏对此操作做出了如下描述：</p>
<ul>
<li>名称: <code>MatMul</code></li>
<li>参数: <code>a</code>, <code>b</code></li>
<li>属性（可选参数）: <code>transpose_a</code>, <code>transpose_b</code></li>
<li>模版 <code>T</code> 支持的类型: <code>half, float, double, int32, complex64, complex128</code></li>
<li>输出类型: 自动识别</li>
<li>文档</li>
</ul>
<p>这个宏没有包含任何 C++ 代码，但是它告诉了我们<strong>当在定义一个操作的时候，即使它使用模版定义，我们也需要指定特定类型 <code>T</code> 支持的类型（或属性）列表。</strong></p>
<p>实际上，属性 <code>.Attr(&quot;T: {half, float, double, int32, complex64, complex128}&quot;)</code> 将 <code>T</code> 的类型限制在了这个类型列表中。<br><a href="https://www.tensorflow.org/extend/adding_an_op" target="_blank" rel="noopener">tensorflow 教程</a>中提到，当时模版 <code>T</code> 时，我们需要对所有支持的重载运算在内核进行注册。这个内核会使用 CUDA 方式引用 C/C++ 函数，进行并发执行。</p>
<p><code>MatMul</code> 的作者可能是出于以下 2 个原因仅支持上述类型而将 <code>int64</code> 排除在外的：</p>
<ol>
<li>疏忽：这个是有可能的，毕竟 Tensorflow 的作者也是人类呀！</li>
<li>为了支持不能使用 <code>int64</code> 的设备，可能这个特性的内核实现不能在各种支持的硬件上运行。</li>
</ol>
<p>回到我们的问题中，已经很清楚如何解决问题了。我们需要将 <code>MatMul</code> 支持类型的参数传给它。</p>
<p>让我们创建 <code>attempt3.go</code> ，将所有 <code>int64</code> 的地方都改成 <code>int32</code>。</p>
<p>有一点需要注意：<strong>Go 封装版 tf 有自己的一套类型，基本与 Go 本身的类型 1:1 相映射。当我们要将值传入图中时，我们必须遵循这种映射关系（例如定义 <code>tf.Int32</code> 类型的 placeholder 时要传入 <code>int32</code>）。从图中取值同理。</strong></p>
<p><code>*tf.Tensor</code> 类型将会返回一个张量 evaluation，它包含一个 <code>Value()</code> 方法，此方法将返回一个必须转换为正确类型的 <code>interface{}</code>（这是从图的结构了解到的）。</p>
<p>运行 <code>go run attempt3.go</code>，得到结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br><span class="line">[[210] [-210]]</span><br></pre></td></tr></table></figure>
<p>成功了！</p>
<p>下面是 <code>attempt3</code> 的完整代码，你可以编译并运行它。（这是一个 Gist，如果你发现有啥可以改进的话欢迎来<a href="https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）" target="_blank" rel="noopener">https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                        </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (                                            </span><br><span class="line">	<span class="string">"fmt"</span>                                       </span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span>                                              </span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span>                                              </span><br><span class="line">)                                                   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                       </span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()                       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	<span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line">	<span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">	A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))   </span><br><span class="line">	x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))   </span><br><span class="line">	fmt.Println(A.Op.Name(), x.Op.Name())       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)            </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line">	graph, err := root.Finalize()               </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session                        </span><br><span class="line">        sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)                                           </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量             </span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor               </span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]                 </span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                       </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]                      </span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                            </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor                    </span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;                                             </span><br><span class="line">		A: matrix,                          </span><br><span class="line">		x: column,                          </span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;            </span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int32</span>))                                            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提问时间：-2"><a href="#提问时间：-2" class="headerlink" title="提问时间："></a>提问时间：</h4><p>关于 Tensorflow 的架构我们学到了什么？</p>
<p><strong>每个操作都有自己的一组关联内核。Tensorflow 是一种强类型的描述性语言，它不仅遵循 C++ 类型规则，同时要求在 op 注册时需定义好类型才能实现其功能。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Go 来定义与处理一个图让我们能够更好地理解 Tensorflow 的底层结构。通过不断地试错，我们最终解决了这个简单的问题，一步一步地掌握了图、节点以及类型系统的知识。</p>
<p>如果你觉得这篇文章有用，请点个赞或者分享给别人吧~</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/59420951128fe1006a1960f8" target="_blank" rel="noopener">https://juejin.im/post/59420951128fe1006a1960f8</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/11/Reinforcement-Learning-notes-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/11/Reinforcement-Learning-notes-1/" class="post-title-link" itemprop="url">Reinforcement Learning notes(1)</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-11 14:33:00" itemprop="dateCreated datePublished" datetime="2017-06-11T14:33:00+08:00">2017-06-11</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Stanford CS229 notes 12: <a href="http://cs229.stanford.edu/notes/cs229-notes12.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes12.pdf</a></p>
<p><a href="//lsivh.com/img/1496555948888450.pdf">cs229-notes12.pdf</a></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>在CS229 notes 中提到了强化学习的意义：</p>
<p>In the reinforcement learning framework, we will instead provide our algorithms only a reward function, which indicates to the learning agent when it is doing well, and when it is doing poorly.</p>
<p>个人的理解就是强化学习就是让 agent 根据环境包含的信息与强化信号量判断策略的选择，同时策略的不同造成的结果会以反馈的形式产生强化信号量给 agent，最终 agent 以“得到最大化的正强化信号量”为标准，做出最佳的策略选择。</p>
<p>换句话说，强化学习不会给模型提供任何“正确的决策”规则，只会给 agent 从环境状态得来的强化信号量，通过这种方式，agent 在行动=&gt;评价=&gt;学习的过程中学习到了知识，学到了如何做出让评价最好的决策方式。</p>
<h3 id="Markov-decision-processes-MDP"><a href="#Markov-decision-processes-MDP" class="headerlink" title="Markov decision processes (MDP)"></a>Markov decision processes (MDP)</h3><p>马尔科夫决策过程为一个包含5个元素的元组</p>
<script type="math/tex; mode=display">MDP = (S,A,{P_{sa}},\gamma,R)</script><p>其中：</p>
<p>S 为 states，状态集，包含所有 agent 可能处于的状态。</p>
<p>A 为 actions，行动集，包含了所有 agent 在各种状态下可以采取的行动。</p>
<p>$P_{sa}$ 为概率，代表了 agent 在 s 状态下做出 a 行动的概率</p>
<p>$\gamma$ 的值 $\gamma in [0,1)$，称为“discount factor”，可以理解为“折算率”</p>
<p>R 为奖励函数（reward function），其值由$S\times A \mapsto R$或$S \mapsto R$决定。</p>
<p>马尔科夫决策过程即为 agent 从初状态$s_0$开始行动，在马尔科夫决策的 A（行动集）中选择一种行动方式 $a_0 \in A$，到达第二个状态$s_1$，接着选择$a_1$……</p>
<script type="math/tex; mode=display">s_0 \overset{a_0}{\rightarrow} s_1\overset{a_1}{\rightarrow} s_2\overset{a_2}{\rightarrow} s_3\overset{a_3}{\rightarrow} ...</script><p>这个过程的价值（payoff）记作</p>
<script type="math/tex; mode=display">R(s_0,a_0) + \gamma R(s_1,a_1)+\gamma^2 R(s_2,a_2) + ...</script><p>简写为</p>
<script type="math/tex; mode=display">r_0 + \gamma r_1 + \gamma^2 r_2 + ...</script><p>$\gamma^i$会越来越小，因此越后面的 R 权值越小。</p>
<p>当 MDP 确定后，每次决策时的状态、行为都是确定的，为了让 agent 在任意状态做出最佳的行为让状态尽量达到最好的情况（即获得最大的奖励值），需要确定一组策略，让整个过程的价值尽量最大化。</p>
<p>整个过程的期望记为：</p>
<script type="math/tex; mode=display">E[r_0 + \gamma r_1+\gamma^2 r_2 + ...]</script><p>将策略记为$\pi$，规定了任意情况下的$s \rightarrow a$，因此可以记为：</p>
<script type="math/tex; mode=display">a = \pi (s)</script><p>这个策略的价值函数（value function）记为</p>
<script type="math/tex; mode=display">V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2 + ...| r_0=R(s),\pi]</script><p>上式表示的是在起点为$s$、使用策略[latex]pi[/latex]的情况下的价值函数值。</p>
<h4 id="状态值函数"><a href="#状态值函数" class="headerlink" title="状态值函数"></a>状态值函数</h4><h5 id="策略评价"><a href="#策略评价" class="headerlink" title="策略评价"></a>策略评价</h5><p>对上式变换：</p>
<script type="math/tex; mode=display">V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2+ ...| r_0=R(s),\pi]</script><script type="math/tex; mode=display">V^pi(s_t)=E_\pi[r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + ...]</script><script type="math/tex; mode=display">V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]</script><p>上式的$s_{t+1}$指的是$s_t$状态经过策略$\pi$之后到达的下一个状态。根据$P_{s\pi(s)}$对上式期望值进行展开，同时考虑在状态$s_t$下的所有策略动作情况：</p>
<script type="math/tex; mode=display">V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]</script><script type="math/tex; mode=display">=\sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^\pi(s_{t+1})]</script><p>上式中的$P(s_{t+1}|s_t,\pi(s))$指的是在$s_t$状态下进行策略$\pi(s)$到达状态 $s_{t+1}$的概率，$R(s_t,\pi(s),s_{t+1})$为从状态 $s_t$ 转移到状态 $s_{t+1}$ 的期望回报值（其实就是之前的$s_t$）。</p>
<p>根据贝尔曼最优化方程，有</p>
<script type="math/tex; mode=display">V^*(s_t) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^*(s_{t+1})]</script><p>因此，对于任意一种策略$\pi$，我们都能通过这种方法对各个动作得到的价值函数值进行最大化迭代，逐渐逼近最大价值函数值。</p>
<script type="math/tex; mode=display">
\text{input pi} \\
\text{While }\Delta < \theta \{\\
\text{tmp} = V(s)\\
V(s) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s))[R(s_t,\pi(s),s_{t+1}) +\gamma V^*(s_{t+1})\\
\Delta = \max(\Delta,|V(s) - \text{tmp}|)\\
\} \\
\text{output } V(s) \approx V^\pi(s)</script><h5 id="策略改进"><a href="#策略改进" class="headerlink" title="策略改进"></a>策略改进</h5><p>假设有$\pi$与$\pi_1$两种策略，如果$Q^\pi(s,\pi_1(s)) \geq V^\pi(s)$（也就是$V^\pi_1(s) \geq V^\pi$），那么说明$\pi_1$的效果一定比$\pi$要好。</p>
<p>以此为依据，可以在每个状态 s 下对决策允许集进行遍历，计算所有决策会产生的价值函数值，根据贪心策略找到产生做大价值函数值的策略$\pi^*$，它即为效果最好的策略。</p>
<script type="math/tex; mode=display">\pi_1 = \arg \max_a Q^\pi(s,a)</script><script type="math/tex; mode=display">=\arg \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,a) [R(s_t,a,s_{t+1}) + \gamma V^*(s_{t+1})]</script><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><p>由上面的策略评价进行计算，能够得到当前策略下最大的价值函数值，接着使用策略改进，得到更好的策略$\pi_1$，再接着对这个$\pi_1$再次使用策略评估……这样一遍又一遍地迭代计算，最终能得到趋近最佳值的策略价值函数值与对应的策略。</p>
<p><img src="/images/pasted-163.png" alt="upload successful"></p>
<h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p><img src="/images/pasted-164.png" alt="upload successful"></p>
<h3 id="值迭代与策略迭代的区别"><a href="#值迭代与策略迭代的区别" class="headerlink" title="值迭代与策略迭代的区别"></a>值迭代与策略迭代的区别</h3><p><a href="https://www.zhihu.com/question/41477987" target="_blank" rel="noopener">https://www.zhihu.com/question/41477987</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/" class="post-title-link" itemprop="url">解决flask慢的问题,以及开启多线程之后jpype的错误</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-09 15:54:00" itemprop="dateCreated datePublished" datetime="2017-06-09T15:54:00+08:00">2017-06-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Back-End/" itemprop="url" rel="index"><span itemprop="name">Back End</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用 flask 做 API 时，发现在 client 的请求需要很长的时间才能得到响应（差不多要 20 多秒）。Google 之后得到解决方案，使用配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(threaded=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>开启多线程模式。</p>
<p>然而这个服务是使用 java 做的底层，用 jpype 让 python 能调用 java 的方法。flask 开启多线程之后服务报错。经过研究发现是 JVM 并没有能为新开启的线程提供服务。查阅 jpype 的文档，找到 python 线程相关部分：<a href="http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads" target="_blank" rel="noopener">http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads</a></p>
<p>因此可在调用 java class 前加上一个判断语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> jpype.isThreadAttachedToJVM():</span><br><span class="line">    jpype.attachThreadToJVM()</span><br></pre></td></tr></table></figure>
<p>使用 isTreadAttachedToJVM 先做出判断，然后使用 attachThreadToJVM 让 JVM 能为新线程提供服务。</p>
<p>完成上述步骤之后，发现已经没有报错了，但是相应速度依然很慢。从服务端控制台看，早已返回了 200，但是在浏览器中迟迟收不到数据，一直是 Pending 状态。查阅资料发现 flask 默认开启 Debug 模式，会对 response 做大量分析记录，使用配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(debug=False)</span><br></pre></td></tr></table></figure>
<p>关闭 Debug 模式，再连接发现响应时间大大减小了，从 20 多秒减到了几百毫秒。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/" class="post-title-link" itemprop="url">RxJS 简介：可观察对象、观察者与操作符</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-05 11:41:47" itemprop="dateCreated datePublished" datetime="2017-06-05T11:41:47+08:00">2017-06-05</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于响应式编程来说，RxJS 是一个不可思议的工具。今天我们将深入探讨什么是 Observable（可观察对象）和 observer（观察者），然后了解如何创建自己的 operator（操作符）。</p>
<p>如果你之前用过 RxJS，想了解它的内部工作原理，以及 Observable、operator 是如何运作的，这篇文章将很适合你阅读。</p>
<h3 id="什么是-Observable（可观察对象）？"><a href="#什么是-Observable（可观察对象）？" class="headerlink" title="什么是 Observable（可观察对象）？"></a>什么是 Observable（可观察对象）？</h3><p>可观察对象其实就是一个比较特别的函数，它接受一个“观察者”（observer）对象作为参数（在这个观察者对象中有 “next”、“error”、“complete”等方法），以及它会返回一种解除与观察者关系的逻辑。例如我们自己实现的时候会使用一个简单的 “unsubscribe” 函数来实现退订功能（即解除与观察者绑定关系的逻辑）。而在 RxJS 中， 它是一个包含 <code>unsubsribe</code> 方法的订阅对象（Subscription）。</p>
<p>可观察对象会创建观察者对象（稍后我们将详细介绍它），并将它和我们希望获取数据值的“东西”连接起来。这个“东西”就是生产者（producer），它可能来自于 <code>click</code> 或者 <code>input</code> 之类的 DOM 事件，是数据值的来源。当然，它也可以是一些更复杂的情况，比如通过 HTTP 与服务器交流的事件。</p>
<p>我们稍后将要自己写一个可观察对象，以便更好地理解它！在此之前，让我们先看看一个订阅对象的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input[type=text]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`你刚刚输入了 <span class="subst">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class="line">  error: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Oops... <span class="subst">$&#123;err&#125;</span>`</span>),</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`完成!`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个例子使用了一个 <code>&lt;input type=&quot;text&quot;&gt;</code> 节点，并将其传入 <code>Rx.Observable.fromEvent()</code> 中。当我们触发指定的事件名时，它将会返回一个输入的 <code>Event</code> 的可观察对象。（因此我们在 console.log 中用  <code>${event.target.value}</code> 可以获取输入值）</p>
<p>当输入事件被触发的时候，可观察对象会将它的值传给观察者。</p>
<h3 id="什么是-Observer（观察者）？"><a href="#什么是-Observer（观察者）？" class="headerlink" title="什么是 Observer（观察者）？"></a>什么是 Observer（观察者）？</h3><p>观察者相当容易理解。在前面的例子中，我们传入 <code>.subscribe()</code> 中的对象字面量就是观察者（订阅对象将会调用我们的可观察对象）。</p>
<blockquote>
<p><code>.subscribe(next, error, complete)</code> 也是一种合法的语法，但是我们现在研究的是对象字面量的情况。</p>
</blockquote>
<p>当一个可观察对象产生数据值的时候，它会通知观察者，当新的值被成功捕获的时候调用 <code>.next()</code>，发生错误的时候调用 <code>.error()</code>。</p>
<p>当我们订阅一个可观察对象的时候，它会持续不断地将值传递给观察者，直到发生以下两件事：一种是生产者告知没有更多的值需要传递了，这种情况它会调用观察者的 <code>.complete()</code> ；一种是我们（“消费者”）对之后的值不再感兴趣，决定取消订阅（unsubsribe）。</p>
<p>如果我们想要对可观察对象传来的值进行组成构建（compose），那么在值传达最终的 <code>.subscribe()</code> 代码块之前，需要经过一连串的可观察对象（也就是操作符）处理。这个一连串的“链”也就是我们所说的可观察对象序列。链中的每个操作符都会返回一个新的可观察对象，让我们的序列能够持续进行下去——这也就是我们所熟知的“流”。</p>
<h3 id="什么是-Operator（操作符）？"><a href="#什么是-Operator（操作符）？" class="headerlink" title="什么是 Operator（操作符）？"></a>什么是 Operator（操作符）？</h3><p>我们前面提到，可观察对象能够进行链式调用，也就是说我们可以像这样写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">  .filter(<span class="function"><span class="params">value</span> =&gt;</span> value.length &gt;= <span class="number">2</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use the `value`</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码做了下面一系列事情：</p>
<ul>
<li>我们先假定用户输入了一个“a”</li>
<li>可观察对象将会对这个输入事件作出反应，将值传给下一个观察者</li>
<li>“a”被传给了订阅了我们<strong>初始</strong>可观察对象的 <code>.map()</code></li>
<li><code>.map()</code> 会返回一个 <code>event.target.value</code> 的新可观察对象，然后调用它观察者对象中的 <code>.next()</code></li>
<li><code>.next()</code> 将会调用订阅了 <code>.map()</code> 的 <code>.filter()</code>，并将 <code>.map()</code> 处理后的值传递给它</li>
<li><code>.filter()</code> 将会返回另一个可观察对象，<code>.filter()</code> 过滤后留下 <code>.length</code> 大于等于 2 的值，并将其传给 <code>.next()</code></li>
<li>我们通过 <code>.subscribe()</code> 获得了最终的数据值</li>
</ul>
<p>这短短的几行代码做了这么多的事！如果你还觉得弄不清，只需要记住：</p>
<p>每当返回一个新的可观察对象，都会有一个新的<strong>观察者</strong>挂载到前一个<strong>可观察对象</strong>上，这样就能通过观察者的“流”进行传值，对观察者生产的值进行处理，然后调用 <code>.next()</code> 方法将处理后的值传递给下一个观察者。</p>
<p>简单来说，操作符将会不断地依次返回新的可观察对象，让我们的流能够持续进行。作为用户而言，我们不需要关心什么时候、什么情况下需要创建与使用可观察对象与观察者，我们只需要用我们的订阅对象进行链式调用就行了。</p>
<h3 id="创建我们自己的-Observable（可观察对象）"><a href="#创建我们自己的-Observable（可观察对象）" class="headerlink" title="创建我们自己的 Observable（可观察对象）"></a>创建我们自己的 Observable（可观察对象）</h3><p>现在，让我们开始写自己的可观察对象的实现吧。尽管它不会像 Rx 的实现那么高级，但我们还是对完善它充满信心。</p>
<h4 id="Observable-构造器"><a href="#Observable-构造器" class="headerlink" title="Observable 构造器"></a>Observable 构造器</h4><p>首先，我们需要创建一个 Observable 构造函数，此构造函数接受且仅接受 <code>subscribe</code> 函数作为其唯一的参数。每个 Observable 实例都存储 subscribe 属性，稍后可以由观察者对象调用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observable</span>(<span class="params">subscribe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subscribe = subscribe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个分配给 <code>this.subscribe</code> 的 <code>subscribe</code> 回调都将会被我们或者其它的可观察对象调用。这样我们下面做的事情就有意义了。</p>
<h4 id="Observer-示例"><a href="#Observer-示例" class="headerlink" title="Observer 示例"></a>Observer 示例</h4><p>在深入探讨实际情况之前，我们先看一看基础的例子。</p>
<p>现在我们已经配好了可观察对象函数，可以调用我们的观察者，将 <code>1</code> 这个值传给它并订阅它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one$ = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">one$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们订阅了 Observable 实例，将我们的 observer（对象字面量）传入构造器中（之后它会被分配给 <code>this.subscribe</code>）。</p>
<h4 id="Observable-fromEvent"><a href="#Observable-fromEvent" class="headerlink" title="Observable.fromEvent"></a>Observable.fromEvent</h4><p>现在我们已经完成了创建自己的 Observable 的基础步骤。下一步是为 Observable 添加 <code>static</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将像使用 RxJS 一样使用我们的 Observable：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>);</span><br></pre></td></tr></table></figure>
<p>这意味着我们需要返回一个新的 Observable，然后将函数作为参数传递给它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码将我们的函数传入了构造器中的 <code>this.subscribe</code>。接下来，我们需要将事件监听设置好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么这个 <code>observer</code> 参数是什么呢？它又是从哪里来的呢？</p>
<p>这个 <code>observer</code> 其实就是携带 <code>next</code>、<code>error</code>、<code>complete</code> 的对象字面量。</p>
<blockquote>
<p>这块其实很有意思。<code>observer</code> 在 <code>.subscribe()</code> 被调用之前都不会被传递，因此 <code>addEventListener</code> 在 Observable 被“订阅”之前都不会被执行。</p>
</blockquote>
<p>一旦调用 subscribe，也就会调用 Observable 构造器内的 <code>this.subscribe</code> 。它将会调用我们传入 <code>new Observable(callback)</code> 的 callback，同时也会依次将值传给我们的观察者。这样，当 Observable 做完一件事的时候，它就会用更新过的值调用我们观察者中的 <code>.next()</code> 方法。</p>
<p>那么之后呢？我们已经得到了初始化好的事件监听器，但是还没有调用 <code>.next()</code>。下面完成它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;</span><br><span class="line">      observer.next(event);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们都知道，可观察对象在被销毁前需要一个“处理后事”的函数，在我们这个例子中，我们需要移除事件监听：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="function">(<span class="params">event</span>) =&gt;</span> observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> element.removeEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为这个 Observable 还在处理 DOM API 和事件，因此我们还不会去调用 <code>.complete()</code>。这样在技术上就有无限的可用性。</p>
<p>试一试吧！下面是我们已经写好的完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const node = document.querySelector(&apos;input&apos;);</span><br><span class="line">const p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">function Observable(subscribe) &#123;</span><br><span class="line">  this.subscribe = subscribe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.fromEvent = (element, name) =&gt; &#123;</span><br><span class="line">  return new Observable((observer) =&gt; &#123;</span><br><span class="line">    const callback = (event) =&gt; observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, false);</span><br><span class="line">    return () =&gt; element.removeEventListener(name, callback, false);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;);</span><br><span class="line"></span><br><span class="line">const unsubscribe = input$.subscribe(&#123;</span><br><span class="line">  next: (event) =&gt; &#123;</span><br><span class="line">    p.innerHTML = event.target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 5 秒之后自动取消订阅</span><br><span class="line">setTimeout(unsubscribe, 5000);</span><br></pre></td></tr></table></figure>
<p>在线示例：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/3zgv7q2g/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="创造我们自己的-Operator（操作符）"><a href="#创造我们自己的-Operator（操作符）" class="headerlink" title="创造我们自己的 Operator（操作符）"></a>创造我们自己的 Operator（操作符）</h3><p>在我们理解了可观察对象与观察者对象的概念之后，我们可以更轻松地去创造我们自己的操作符了。我们在 <code>Observable</code> 对象原型中加上一个新的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map=function(mapFn)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法将会像 JavaScript 中的 <code>Array.prototype.map</code> 一样使用，不过它可以对任何值用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;)</span><br><span class="line">	.map(event =&gt; event.target.value);</span><br></pre></td></tr></table></figure>
<p>所以我们要取得回调函数，并调用它，返回我们期望得到的数据。在这之前，我们需要拿到流中最新的数据值。</p>
<p>下面该做什么就比较明了了，我们要得到调用了这个 <code>.map()</code> 操作符的 Observable 实例的引用入口。我们是在原型链上编程，因此可以直接这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = function (mapFn) &#123;</span><br><span class="line">  const input = this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>找找乐子吧！现在我们可以在返回的 Obeservable 中调用 subscribe：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> input.subscribe();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们要返回 <code>input.subscribe()</code> ，因为在我们退订的时候，非订阅对象将会顺着链一直转下去，解除每个 Observable 的订阅。</p>
</blockquote>
<p>这个订阅对象将允许我们把之前 <code>Observable.fromEvent</code> 传来的值传递下去，因为它返回了构造器中含有 <code>subscribe</code> 原型的新的 Observable 对象。我们可以轻松地订阅它对数据值做出的任何更新！最后，完成通过 map 调用我们的 <code>mapFn()</code> 的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input.subscribe(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">value</span>) =&gt;</span> observer.next(mapFn(value)),</span><br><span class="line">      error: <span class="function">(<span class="params">err</span>) =&gt;</span> observer.error(err),</span><br><span class="line">      complete: <span class="function"><span class="params">()</span> =&gt;</span> observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们可以进行链式调用了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    p.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意到最后一个 <code>.subscribe()</code> 不再和之前一样传入 <code>Event</code> 对象，而是传入了一个 <code>value</code> 了吗？这说明你成功地创建了一个可观察对象流。</p>
<p>再试试：</p>
<iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/0rpkchm8/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>希望这篇文章对你来说还算有趣~:)</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/5934d2532f301e00585ea5f3" target="_blank" rel="noopener">https://juejin.im/post/5934d2532f301e00585ea5f3</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lsvih</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">152</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">187</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">京ICP备18029472号 </a>&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsvih</span>

  

  
</div>






  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  



  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.7.0"></script>



  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow: auto hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

</body>
</html>
