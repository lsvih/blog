<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://lsvih.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '6U6P1RGK4F',
      apiKey: 'b14e73cdd627eabe947b5decbe14850f',
      indexName: 'lsvih',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="My note">
<meta property="og:url" content="https:&#x2F;&#x2F;lsvih.com&#x2F;page&#x2F;7&#x2F;index.html">
<meta property="og:site_name" content="My note">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lsvih.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>My note - lsvih</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142893470-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-142893470-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">lsvih</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="https://cv.lsvih.com/" rel="noopener" target="_blank"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/02/%E5%9C%A8-Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A2%9E%E5%BC%BA-Cookie-%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/02/%E5%9C%A8-Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A2%9E%E5%BC%BA-Cookie-%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/" class="post-title-link" itemprop="url">在 Go 语言中增强 Cookie 的安全性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-02 17:32:00" itemprop="dateCreated datePublished" datetime="2017-09-02T17:32:00+08:00">2017-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我开始学习 Go 语言时已经有一些 Web 开发经验了，但是并没有直接操作 Cookie 的经验。我之前做过 Rails 开发，当我不得不需要在 Rails 中读写 Cookie 时，并不需要自己去实现各种安全措施。</p>
<p>瞧瞧，Rails 默认就自己完成了大多数的事情。你不需要设置任何 CSRF 策略，也无需特别去加密你的 Cookie。在新版的 Rails 中，这些事情都是它默认帮你完成的。</p>
<p>而使用 Go 语言开发则完全不同。在 Golang 的默认设置中，这些事都不会帮你完成。因此，当你想要开始使用 Cookie 时，了解各种安全措施、为什么要使用这些措施、以及如何将这些安全措施集成到你的应用中是非常重要的事。希望本文能帮助你做到这一点。</p>
<p><strong>注意：我并不想引起关于 Go 与 Reils 两者哪种更好的论战。两者各有优点，但在本文中我希望能着重讨论 Cookie 的防护，而不是去争论 Rails 和 Go 哪个好。</strong></p>
<h2 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h2><p>在进入 Cookie 防护相关的内容前，我们必须要理解 Cookie 究竟是什么。从本质上说，Cookie 就是存储在终端用户计算机中的键值对。因此，使用 Go 创建一个 Cookie 需要做的事就是创建一个包含键名、键值的 <a href="https://golang.org/pkg/net/http/#Cookie" target="_blank" rel="noopener">http.Cookie</a> 类型字段，然后调用 <a href="https://golang.org/pkg/net/http/#SetCookie" target="_blank" rel="noopener">http.SetCookie</a> 函数通知终端用户的浏览器设置该 Cookie。</p>
<p>写成代码之后，它看起来类似于这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func someHandler(w http.ResponseWriter, r *http.Request) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  c :&#x3D; http.Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Name: &quot;theme&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Value: &quot;dark&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  http.SetCookie(w, &amp;c)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p><code>http.SetCookie</code> 函数并不会返回错误，但它可能会静默地移除无效的 Cookie，因此使用它并不是什么美好的经历。但它既然这么设计了，就请你在使用这个函数的时候一定要牢记它的特性。</p>
</blockquote>
<p>虽然这好像是在代码中“设定”了一个 Cookie，但其实我们只是在我们返回 Response 时发送了一个 <code>&quot;Set-Cookie&quot;</code> 的 Header，从而定义需要设置的 Cookie。我们不会在服务器上存储 Cookie，而是依靠终端用户的计算机创建与存储 Cookie。</p>
<p>我要强调上面这一点，因为它存在非常严重的安全隐患：我们<strong>不能</strong>控制这些数据，而终端用户的计算机（以及用户）才能控制这些数据。</p>
<p>当读取与写入终端用户控制的数据时，我们都需要十分谨慎地对数据进行处理。恶意用户可以删除 Cookie、修改存储在 Cookie 中的数据，甚至我们可能会遇到<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">中间人攻击</a>，即当用户向服务器发送数据时，另有人试图窃取 Cookie。</p>
<h2 id="Cookie-的潜在安全问题"><a href="#Cookie-的潜在安全问题" class="headerlink" title="Cookie 的潜在安全问题"></a>Cookie 的潜在安全问题</h2><p>根据我的经验，Cookie 相关的安全性问题大致分为以下五大类。下面我们先简单地看一看，本文的剩余部分将详细讨论每个分类的细节问题与解决对策。</p>
<p><strong>1. Cookie 窃取</strong> - 攻击者会通过各种方式来试图窃取 Cookie。我们将讨论如何防范、规避这些方式，但是归根结底我们并不能完全阻止设备上的物理类接触。</p>
<p><strong>2. Cookie 篡改</strong> - Cookie 中存储的数据可以被用户有意或无意地修改。我们将讨论如何验证存储在 Cookie 中的数据确实是我们写入的合法数据</p>
<p><strong>3. 数据泄露</strong> - Cookie 存储在终端用户的计算机上，因此我们需要清楚地意识到什么数据是能存储在 Cookie 中的，什么数据是不能存储在 Cookie 中的，以防其发生数据泄露。</p>
<p><strong>4. 跨站脚本攻击（XSS）</strong> - 虽然这条与 Cookie 没有直接关系，但是 XSS 攻击在攻击者能获取 Cookie 时危害更大。我们应该考虑在非必须的时候限制脚本访问 Cookie。</p>
<p><strong>5. 跨站请求伪造（CSRF）</strong> - 这种攻击常常是由于使用 Cookie 存储用户登录会话造成的。因此我们将讨论在这种情景下如何防范这种攻击。</p>
<p>如我前面所说，在下文中我们将分别解决这些问题，让你最终能够专业地将你的 Cookie 装进保险柜。</p>
<h2 id="Cookie-窃取"><a href="#Cookie-窃取" class="headerlink" title="Cookie 窃取"></a>Cookie 窃取</h2><p>Cookie 窃取攻击就和它字面意思一样 —— 某人窃取了正常用户的 Cookie，然后一般用来将自己伪装成那个正常用户。</p>
<p>Cookie 通常是被以下方式中的某种窃取：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">中间人攻击</a>，或者是类似的其它攻击方式，归纳一下就是攻击者拦截你的 Web 请求，从中窃取 Cookie。</li>
<li>取得硬件的访问权限。</li>
</ol>
<p>阻止中间人攻击的终极方式就是当你的网站使用 Cookie 时，使用 SSL。使用 SSL 时，由于中间人无法对数据进行解密，因此外人基本上没可能在请求的中途获取 Cookie。</p>
<p>可能你会觉得“哈哈，中间人攻击不太可能…”，我建议你看看 <a href="http://codebutler.com/firesheep" target="_blank" rel="noopener">firesheep</a>，这个简单的工具，它足以说明在使用公共 wifi 时窃取未加密的 Cookie 是一件很轻松的事情。</p>
<p>如果你想确保这种事情不发生在你的用户中，<strong>请使用 SSL！</strong>试试使用 <a href="https://caddyserver.com/" target="_blank" rel="noopener">Caddy Server</a> 进行加密吧。它经过简单的配置就能投入生产环境中。例如，你可以使用下面四行代码轻松让你的 Go 应用使用代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">calhoun.io &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  gzip</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  proxy &#x2F; localhost:3000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>然后 Caddy 会为你自动处理所有与 SSL 有关的事务。</p>
<p>防范通过访问硬件来窃取 Cookie 是十分棘手的事情。我们不能强制我们的用户使用高安全性系统，也不能逼他们为电脑设置密码，所以总会有他人坐在电脑前偷走 Cookie 的风险。此外，Cookie 也可能被病毒窃取，比如用户打开了某些钓鱼邮件时就会出现这种情况。</p>
<p>不过这些都容易被发现。例如，如果有人偷了你的手表，当你发现表不在手上时你立马就会注意到它被偷了。然而 Cookie 还可以被复制，这样任何人都不会意识到它已经丢了。</p>
<p>虽然不是万无一失，但你还是可以用一些技术来猜测 Cookie 是否被盗了。例如，你可以追踪用户的登录设备，要求他们重新输入密码。你还可以跟踪用户的 IP 地址，当其在可疑地点登录时通知用户。</p>
<p>所有的这些解决方案都需要后端做更多的工作来追踪数据，如果你的应用需要处理一些敏感信息、金钱，或者它的收益可观的话，请在安全方面投入更多精力。</p>
<p>也就是说，对于大多数只是作为过渡版本的应用来说，使用 SSL 就足够了。</p>
<h2 id="Cookie-篡改（也叫用户伪造数据）"><a href="#Cookie-篡改（也叫用户伪造数据）" class="headerlink" title="Cookie 篡改（也叫用户伪造数据）"></a>Cookie 篡改（也叫用户伪造数据）</h2><p>请直面这种情况 —— 可能有一些混蛋突然就想看看你设的 Cookie，然后修改它的值。也可能他是出于好奇才这么做的，但是还是请你为这种可能发生的情况做好准备。</p>
<p>在一些情景中，我们对此并不在意。例如，我们给用户定义一种主题设置时，并不会关心用户是否改变了这个设置。当这个 Cookie 过期时，就会恢复默认的主题设置，并且如果用户设置其为另一个有效的主题时我们可以让他正常使用那个主题，这并不会对系统造成任何损失。</p>
<p>但是在另一些情况下，我们需要格外小心。编辑会话 Cookie 冒充另一个用户产生的危害比改个主题大得多。我们绝不想看到张三假装自己是李四。</p>
<p>我们将介绍两种策略来检测与防止 Cookie 被篡改。</p>
<h4 id="1-对数据进行数字签名"><a href="#1-对数据进行数字签名" class="headerlink" title="1. 对数据进行数字签名"></a>1. 对数据进行数字签名</h4><p>对数据进行数字签名，即对数据增加一个“签名”，这样能让你校验数据的可靠性。这种方法并不需要对终端用户的数据进行加密或隐藏，只要对 Cookie 增加必要的签名数据，我们就能检测到用户是否修改数据。</p>
<p>这种保护 Cookie 的方法原理是哈希编码 —— 我们对数据进行哈希编码，接着将数据与它的哈希编码同时存入 Cookie 中。当用户发送 Cookie 给我们时，再对数据进行哈希计算，验证此时的哈希值与原始哈希值是否匹配。</p>
<p>我们当然不会想看到用户也创建一个新的哈希来欺骗我们，因此你可以使用一些类似 HMAC 的哈希算法来使用秘钥对数据进行哈希编码。这样就能防范用户同时编辑数据与数字签名（即哈希值）。</p>
<blockquote>
<p><a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Tokens(JWT)</a> 默认内置了数字签名功能，因此你可能对这种方法比较熟悉。</p>
</blockquote>
<p>在 Go 中，可以使用类似 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">securecookie</a> 之类的 package，你可以在创建 <code>SecureCookie</code> 时使用它来保护你的 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐使用 32 字节或 64 字节的 hashKey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此处为了简洁故设为了 “very-secret”</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">var hashKey &#x3D; []byte(&quot;very-secret&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var s &#x3D; securecookie.New(hashKey, nil)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">func SetCookieHandler(w http.ResponseWriter, r *http.Request) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  encoded, err :&#x3D; s.Encode(&quot;cookie-name&quot;, &quot;cookie-value&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  if err &#x3D;&#x3D; nil &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    cookie :&#x3D; &amp;http.Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      Name:  &quot;cookie-name&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      Value: encoded,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      Path:  &quot;&#x2F;&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    http.SetCookie(w, cookie)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    fmt.Fprintln(w, encoded)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>然后你可以在另一个处理 Cookie 的函数中同样使用 SecureCookie 对象来读取 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func ReadCookieHandler(w http.ResponseWriter, r *http.Request) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  if cookie, err :&#x3D; r.Cookie(&quot;cookie-name&quot;); err &#x3D;&#x3D; nil &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    var value string</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    if err &#x3D; s.Decode(&quot;cookie-name&quot;, cookie.Value, &amp;value); err &#x3D;&#x3D; nil &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      fmt.Fprintln(w, value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>以上样例来源于 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">http://www.gorillatoolkit.org/pkg/securecookie</a>.</strong></p>
<blockquote>
<p>注意：这儿的数据并不是进行了加密，而只是进行了编码。我们会在“数据泄露”一章讨论如何对数据进行加密。</p>
</blockquote>
<p>这种模式还需要注意的是，如果你使用这种方式进行身份验证，请遵循 JWT 的模式，将登录过期日期和用户数据同时进行签名。你不能只凭 Cookie 的过期日期来判断登录是否有效，因为存储在 Cookie 上的日期并未经过签名，且用户可以创建一个永不过期的新 Cookie，将原 Cookie 的内容复制进去就得到了一个永远处于登录状态的 Cookie。</p>
<h4 id="2-进行数据混淆"><a href="#2-进行数据混淆" class="headerlink" title="2. 进行数据混淆"></a>2. 进行数据混淆</h4><p>还有一种解决方案可以隐藏数据并防止用户造假。例如，不要这样存储 Cookie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 别这么做</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">http.Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  Name: &quot;user_id&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  Value: &quot;123&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我们可以存储一个值来映射存在数据库中的真实数据。通常使用 Session ID 或者 remember token 来作为这个值。例如我们有一个名为 <code>remember_tokens</code> 的表，这样存储数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">remember_token: LAKJFD098afj0jasdf08jad08AJFs9aj2ASfd1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">user_id: 123</span></pre></td></tr></table></figure>
<p>在 Cookie 中，我们仅存储这个 remember token。如果用户想伪造 Cookie 也会无从下手。它看上去就是一堆乱码。</p>
<p>之后当用户要登陆我们的应用时，再根据 remember token 在数据库中查询，确定用户具体的登录状态。</p>
<p>为了让此措施正常工作，你需要确保你的混淆值有以下特性：</p>
<ul>
<li>能映射到用户数据（或其它资源）</li>
<li>随机</li>
<li>熵值高</li>
<li>可被无效化（例如在数据库中删除、修改 token 值）</li>
</ul>
<p>这种方法也有一个缺点，就是在用户访问每个需要校验权限的页面时都得进行数据库查询。不过这个缺点很少有人注意，而且可以通过缓存等技术来减小数据库查询的开销。这种方法的升级版就是 JWT，应用这种方法你可以随时使会话无效化。</p>
<p><strong>注意：尽管目前 JWT 收到了大多数 JS 框架的追捧，但上文这种方法是我了解的最常用的身份验证策略。</strong></p>
<h2 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h2><p>在真正出现数据泄露前，通常需要另一种攻击向量 —— 例如 Cookie 窃取。然而还是很难去正确地判断并提防数据泄露的发生。因为仅仅是 Cookie 发生了泄露并不意味着攻击者也得到了用户的账户密码。</p>
<p>无论何时，都应当减少存储在 Cookie 中的敏感数据。绝不要将用户密码之类的东西存在 Cookie 中，即使密码已经经过了编码也不要这么做。<a href="https://hackernoon.com/your-node-js-authentication-tutorial-is-wrong-f1a3bf831a46#2491" target="_blank" rel="noopener">这篇文章</a> 给出了几个开发者无意间将敏感数据存储在 Cookie 或 JWT 中的实例，由于（JWT 的 payload）是 base64 编码，没有经过任何加密，因此任何人都可以对其进行解码。</p>
<p>出现数据泄露可是犯了大错。如果你担心你不小心存储了一些敏感数据，我建议你使用如 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">securecookie</a> 之类的 package。</p>
<p>前面我们讨论了如何对你的 Cookie 进行数字签名，其实 <code>securecookie</code> 也可以用于加密与解密你的 Cookie 数据，让你的数据不能被轻易地解码并读取。</p>
<p>使用这个 package 进行加密，你只需要在创建 <code>SecureCookie</code> 实例时传入一个“块秘钥”（blockKey）即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var hashKey &#x3D; []byte(&quot;very-secret&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 增加这一部分进行加密</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">var blockKey &#x3D; []byte(&quot;a-lot-secret&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">var s &#x3D; securecookie.New(hashKey, blockKey)</span></pre></td></tr></table></figure>
<p>其它所有东西都和前面章节的数字签名中的样例一致。</p>
<p>再次提醒，你<strong>不应该</strong>在 Cookie 中存储任何敏感数据，尤其不能存储密码之类的东西。加密仅仅是一项为数据增加一部分安全性，使其成为”半敏感数据“数据的技术而已。</p>
<h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">跨站脚本（Cross-site scripting）</a>也经常被记为 XSS，及有人试图将一些不是你写的 JavaScript 代码注入你的网站中。但由于其攻击的机理，你无法知道正在浏览器中运行的 JavaScript 代码到底是不是你的服务器提供的代码。</p>
<p>无论何时，你都应该尽量去阻止 XSS 攻击。在本文中我们不会深入探讨这种攻击的具体细节，但是<strong>以防万一</strong>我建议你在非必要的情况下禁止 JavaScript 访问 Cookie 的权限。在你需要这个权限的时候你可以随时开启它，所以不要让它成为你的网站安全性脆弱的理由。</p>
<p>在 Go 中完成这点很简单，只需要在创建 Cookie 时设置 <code>HttpOnly</code> 字段为 true 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cookie :&#x3D; http.Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; true 表示脚本无权限，只允许 http request 使用 Cookie。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 这与 Http 与 Https 无关。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  HttpOnly: true,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h2><p>CSRF 发生的情况为某个用户访问别人的站点，但那个站点有一个能提交到你的 web 应用的表单。由于终端用户提交表单时的操作不经由脚本，因此浏览器会将此请求设为用户进行的操作，将 Cookie 附上表单数据同时发送。</p>
<p>乍一看似乎这没什么问题，但是如果外部网站发送一些用户不希望发送的数据时会发生什么呢？例如，badsite.com 中有个表单，会提交请求将你的 100 美元转到他们的账户中，而 chase.com 希望你在它这儿登录你的银行账户。这可能会导致在终端用户不知情的情况下钱被转走。</p>
<p>Cookie 不会直接导致这样的问题，不过如果你使用 Cookie 作为身份验证的依据，那你需要使用 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/csrf" target="_blank" rel="noopener">csrf</a> 之类的 package 来避免 CSRF 攻击。</p>
<p>这个 package 将会提供一个 CSRF token，插入你网站的每个表单中，当表单中不含 token 时，<code>csrf</code> package 中间件将会阻止表单的提交，使得别的网站不能欺骗用户在他们那儿向你的网站提交表单。</p>
<p><strong>更多关于 CSRF 攻击的资料请参阅：</strong></p>
<ul>
<li><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank" rel="noopener">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a></li>
</ul>
<h2 id="在非必要时限制-Cookie-的访问权限"><a href="#在非必要时限制-Cookie-的访问权限" class="headerlink" title="在非必要时限制 Cookie 的访问权限"></a>在非必要时限制 Cookie 的访问权限</h2><p>我们要讨论的最后一件事与特定的攻击无关，更像是一种指导原则。我建议在使用 Cookie 时尽量限制其权限，仅在你需要时开发相关权限。</p>
<p>前面讨论 XSS 时我也简单的提到过这点，但一般的观点是你需要尽可能限制对 Cookie 的访问。例如，如果你的 Web 应用没有使用子域名，那你就不应该赋予 Cookie 所有子域的权限。不过这是 Cookie 的默认值，因此其实你什么都不用做就能将 Cookie 的权限限制在某个特定域中。</p>
<p>但是，如果你需要与子域共享 Cookie，你可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">c :&#x3D; Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 根据主机模式的默认设置，Cookie 进行的是精确域名匹配。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 因此请仅在需要的时候开启子域名权限！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 下面的代码可以让 Cookie 在 yoursite.com 的任何子域下工作：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  Domain: &quot;yoursite.com&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>欲了解更多有关域的信息，请参阅 <a href="https://tools.ietf.org/html/rfc6265#section-5.1.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6265#section-5.1.3</a>。你也可以在这儿阅读源码，参阅其默认设置：<a href="https://golang.org/src/net/http/cookie.go#L157" target="_blank" rel="noopener">https://golang.org/src/net/http/cookie.go#L157</a>.</strong></p>
<p><strong>你可以参阅 <a href="https://stackoverflow.com/questions/18492576/share-cookie-between-subdomain-and-domain" target="_blank" rel="noopener">这个 stackoverflow 的问题</a> 了解更多信息，弄明白为什么在为子域使用 Cookie 时不需要提供子域前缀.此外 Go 源码链接中也可以看到如果你提供前缀名的话会被自动去除。</strong></p>
<p>除了将 Cookie 的权限限制在特定域上之外，你还可以将 Cookie 限制于某个特定的目录路径中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">c :&#x3D; Cookie&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Defaults 设置为可访问应用的任何路径，但你也可以</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 进行如下设置将其限制在特定子目录下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  Path: &quot;&#x2F;app&#x2F;&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>还有你也可以对其设置路径前缀，例如 <code>/blah/</code>，你可以参阅下面这篇文章了解更多这个字段的使用方法：<a href="https://tools.ietf.org/html/rfc6265#section-5.1.4" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6265#section-5.1.4</a>.</p>
<h2 id="为什么我不使用-JWT？"><a href="#为什么我不使用-JWT？" class="headerlink" title="为什么我不使用 JWT？"></a>为什么我不使用 JWT？</h2><p>就知道肯定会有人提出这个问题，下面让我简单解释一下。</p>
<p>可能有很多人和你说过，Cookie 的安全性与 JWT 一样。但实际上，Cookie 与 JWT 解决的并不是相同的问题。比如 JWT 可以存储在 Cookie 中，这和将其放在 Header 中的实际效果是一样的。</p>
<p>另外，Cookie 可用于无需验证的数据，在这种情况下了解如何增加 Cookie 的安全性也是必要的。</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/59aa7a4d6fb9a0249c007e16" target="_blank" rel="noopener">https://juejin.im/post/59aa7a4d6fb9a0249c007e16</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/29/Solution-Ionic-cordova-resources-couldn-t-generate-splash-and-icon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/29/Solution-Ionic-cordova-resources-couldn-t-generate-splash-and-icon/" class="post-title-link" itemprop="url">[Solution] 'Ionic cordova resources' couldn't generate splash and icon</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-29 17:48:00" itemprop="dateCreated datePublished" datetime="2017-08-29T17:48:00+08:00">2017-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Front-End/" itemprop="url" rel="index">
                    <span itemprop="name">Front End</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Version:</p>
<p>Ionic: 3.9.2</p>
<p>Cordova: 7.0.1</p>
</blockquote>
<p>Using ‘ionic cordova resources’ will generate all-size splashs and icons for selected platforms automatically.</p>
<p>But this method depends on cloud service of ionic, so that when you can’t connect to network, this method would be failed.</p>
<p>There is a awesome tool can deal with these problem: cordova-resgen.</p>
<p><a href="https://github.com/helixhuang/ionic-resources" target="_blank" rel="noopener">https://github.com/helixhuang/ionic-resources</a> </p>
<p>This tool base on cordova-splash and cordova-icon, using graphicsmagic to cut pictures.</p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage:"></a>Usage:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">brew install graphicsmagick</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sudo npm install cordova-resgen -g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-project</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cordova-resgen</span></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/29/%E4%BD%BF%E7%94%A8-AI-%E4%B8%BA-Web-%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%8A%A0%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/29/%E4%BD%BF%E7%94%A8-AI-%E4%B8%BA-Web-%E7%BD%91%E9%A1%B5%E5%A2%9E%E5%8A%A0%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">使用 AI 为 Web 网页增加无障碍功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-29 16:55:00" itemprop="dateCreated datePublished" datetime="2017-08-29T16:55:00+08:00">2017-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/pasted-183.png" alt="upload successful"></p>
<p>图为一位盲人正在阅读盲文（<a href="http://usabilitygeek.com/wp-content/uploads/2012/07/Software-For-Visually-Impaired-Blind-Users.jpg" target="_blank" rel="noopener">图片链接</a>）</p>
<p><a href="http://www.who.int/mediacentre/factsheets/fs282/en/" target="_blank" rel="noopener">根据世界健康组织的统计</a>，全球约有 2.85 亿位视力障碍人士，仅美国就有 810 万网民患视力障碍。</p>
<p>在我们视力正常的人看来，互联网是一个充满了文字、图片、视频等事物的地方，然而对于视力障碍人士来说却并不是这样的。有一种可以读出网页中文字和元数据的工具叫做屏幕阅读器，然而这种工具的作用十分有限，仅能让人看到网页的一部分文本。虽然一些开发人员花时间去改进他们的网站，为视障人士添加图片的描述性文字，但是绝大多数程序员都不会花时间去做这件公认冗长乏味的事情。</p>
<p>所以，我决定做这么一个工具，来帮助视障人士通过 AI 的力量来“看”互联网。我给它起名为“Auto Alt Text”（自动 Alt 文本添加器），是一个 Chrome 拓展插件，可以让用户在图片上点击右键后得到场景描述 —— 最开始是要这么做的。</p>
<p>您可以观看 <a href="https://www.youtube.com/embed/c1S4iB360m8" target="_blank" rel="noopener">这个视频</a>，了解它是如何运作的，然后 <a href="http://abhinavsuri.com/aat" target="_blank" rel="noopener">下载它并亲自试一试吧！</a>！</p>
<h4 id="为什么我想做-Auto-Alt-Text："><a href="#为什么我想做-Auto-Alt-Text：" class="headerlink" title="为什么我想做 Auto Alt Text："></a>为什么我想做 Auto Alt Text：</h4><p>我曾经是不想花时间为图片添加描述的开发者中的一员。对那时的我来说，无障碍永远是“考虑考虑”的事，直到有一天我收到了来自<a href="https://github.com/hack4impact/flask-base" target="_blank" rel="noopener">我的一个项目</a>的用户的邮件。</p>
<p><img src="/images/pasted-184.png" alt="upload successful"></p>
<p>邮件内容如下：“你好，Abhinav，我看了你的 flask-base 项目，我觉得它非常适合我的下个工程。感谢你开发了它。不过我想让你知道，你应该为你 README 中的图片加上 alt 描述。我是盲人，用了很长一段时间才弄清楚它们的内容 :/来自某人”</p>
<p>在收到邮件的时候，无障碍功能的开发是放在我开发队列的最后面的，基本上它就是个“事后有空再添加”的想法而已。但是，这封邮件唤醒了我。在互联网中，有许多的人需要无障碍阅读功能来理解网站、应用、项目等事物的用途。</p>
<blockquote>
<p>“现在 Web 中充满了缺失、错误或者没有替代文本的图片” —— WebAIM（犹他州立大学残疾人中心）</p>
</blockquote>
<h4 id="用-AI（人工智能）来挽救："><a href="#用-AI（人工智能）来挽救：" class="headerlink" title="用 AI（人工智能）来挽救："></a>用 AI（人工智能）来挽救：</h4><p>现在其实有一些方法来给图像加描述文字；但是，大多数方法都有一些缺点：</p>
<ol>
<li>它们反应很慢，要很长时间才能返回描述文字。</li>
<li>它们是半自动化的（即需要人类手动按需标记描述文字）。</li>
<li>制作、维护它们需要高昂的代价。</li>
</ol>
<p>现在，通过创建神经网络，这些问题都能得到解决。最近我接触、学习了 Tensorflow —— 一个用于机器学习开发的开源库，开始深入研究机器学习与 AI。Tensorflow 使开发人员能够构建可用于完成从对象检测到图像识别的各种任务的高鲁棒模型。</p>
<p>在做了一些研究之后，我找到了一篇 Vinyals 写的论文<a href="https://arxiv.org/abs/1609.06647" target="_blank" rel="noopener">《Show and Tell: Lessons learned from the 2015 MSCOCO Image Captioning Challenge》</a>。这些研究者们创建了一个深度神经网络，可以以语义化方式描述图片的内容。</p>
<p><img src="/images/pasted-185.png" alt="upload successful"></p>
<p>im2txt 的实例来自 <a href="https://github.com/tensorflow/models/tree/master/im2txt" target="_blank" rel="noopener">im2txt Github Repository</a></p>
<h4 id="im2txt-的技术细节："><a href="#im2txt-的技术细节：" class="headerlink" title="im2txt 的技术细节："></a>im2txt 的技术细节：</h4><p>这个模型的机制相当的精致，但是它基本上是一个“编码器 - 解码器”的方案。首先图片会传入一个名为 Inception v3 的卷积神经网络进行图片分类，接着编码好的图片送入 LSTM 网络中。LSTM 是一种专门用于序列模型/时间敏感信息的神经网络层。最后 LSTM 通过组合设定好的单词，形成一句描述图片内容的句子。LSTM 通过求单词集中每个单词在句子中出现的似然性，分别计算第一个词出现的概率分布、第二个词出现的概率分布……直到出现概率最大的字符为“.”，为句子加上最后的句号。</p>
<p><img src="/images/pasted-186.png" alt="upload successful"></p>
<p>图为此神经网络的概况（图片来自 <a href="https://github.com/tensorflow/models/tree/master/im2txt" target="_blank" rel="noopener">im2txt Github repository</a>）</p>
<p>根据 Github 库中的说明，这个模型在 Tesla k20m GPU 上的训练时间大约为 1-2 周（在我笔记本的标准 CPU 上计算需要更多的时间）。不过值得庆幸的是，Tensorflow 社区提供了一个已经训练好的模型。</p>
<h4 id="使用-box-Lamdba-解决问题："><a href="#使用-box-Lamdba-解决问题：" class="headerlink" title="使用 box + Lamdba 解决问题："></a>使用 box + Lamdba 解决问题：</h4><p>在运行模型时，我试图使用 Bazel 来运行模型（Bazel 是一个用于将 tensorflow 模型解包成可运行脚本的工具）。但是，当命令行运行时，它需要大约 15 秒钟的时间才能从获取一张图片的结果！解决问题的唯一办法就是让 Tensorflow 的整个 Graph 都常驻内存，但是这样需要这个程序全天候运行。我计划将这个模型挂在 AWS Elasticbeanstalk 上，在这个平台上是以小时为单位为计算时间计费的，而我们要维持应用程序常驻，因此并不合适（它完全匹配了前面章节所说的图片描述软件缺点的第三条缺点）。因此，我决定使用 AWS Lambda 来完成所有工作。</p>
<p>Lambda 是一种无服务器计算服务，价格很低。此外，它会在计算服务激活时按秒收费。Lambda 的工作原理很简单，一旦应用收到了用户的请求，Lambda 就会将应用程序的映象激活，返回 response，然后再停止应用映象。如果收到多个并发请求，它会唤起多个实例以拓展负载。另外，如果某个小时内应用不断收到请求，它将会保持应用程序的激活状态。因此，Lambda 服务非常符合我的这个用例。</p>
<p><img src="/images/pasted-187.png" alt="upload successful"></p>
<p>图为 AWS API Gateway + AWS = ❤️ (<a href="https://cdn-images-1.medium.com/max/700/1*SzOPXTf_YQNtFejG0e4HPg.png" target="_blank" rel="noopener">图片链接</a>)</p>
<p>使用 Lambda 的问题就在于，我必须要为 im2txt 模型创建一个 API。另外，Lambda 对于以功能形式加载的应用有空间限制。上传整个应用程序的 zip 包时，最终文件大小不能超过 250 MB。这个限制是一个麻烦事，因为 im2txt 的模型就已经超过 180 MB 了，再加上它运行需要的依赖文件就已经超过 350 MB 了。我尝试将程序的一部分传到 S3 服务上，然后在 Lambda 实例运行再去下载相关文件。然而，Lambda 上一个应用的总存储限制为 512 MB，而我的应用程序已经超过限制了（总共约 530 MB）。</p>
<p>为了减小项目的大小，我重新配置了 im2txt，只下载精简过的模型，去掉了没用的一些元数据。这样做之后，我的模型大小减小到了 120 MB。接着，我找到了一个最小依赖的 <a href="https://github.com/ryfeus/lambda-packs" target="_blank" rel="noopener">lambda-packs</a>，不过它仅有早期版本的 python 和 tensorflow。我将 python 3.6 语法和 tensorflow 1.2 的代码进行了降级，经过痛苦的降级过程后，我最终得到了一个总大小约为 480 MB 的包，小于 512 MB 的限制。</p>
<p>为了保持应用的快速响应，我创建了一个 CloudWatch 函数，让 Lambda 实例保持”热“状态，使应用始终处于激活态。接着，我添加了一些函数用于处理不是 JPG 格式的图片，在最后，我做好了一个能提供服务的 API。这些精简工作让应用在大多数情况下能够于 5 秒之内返回 response。</p>
<p><img src="/images/pasted-188.png" alt="upload successful"></p>
<p>上图为 API 提供的图片可能内容的概率</p>
<p>此外，Lambda 的价格便宜的令人惊讶。以现在的情况，我可以每个月免费分析 60,952 张图片，之后的图片每张仅需 0.0001094 美元（这意味着接下来的 60,952 张图像约花费 6.67 美元）。</p>
<p>有关 API 的更多信息，请参考 repo：<a href="https://github.com/abhisuri97/auto-alt-text-lambda-api" target="_blank" rel="noopener">https://github.com/abhisuri97/auto-alt-text-lambda-api</a></p>
<p>剩下的工作就是将其打包为 Chrome 拓展插件，以方便用户使用。这个工作没啥挑战性（仅需要向我的 API 端点发起一个简单的 AJAX 请求即可）。</p>
<p><img src="/images/pasted-189.png" alt="upload successful"></p>
<p>上图为 Auto Alt Text Chrome 插件运行示例</p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>Im2txt 模型对于人物、风景以及其它存在于 COCO 数据集中的内容表现良好。</p>
<p><img src="/images/pasted-190.png" alt="upload successful"></p>
<p>上图为 COCO 数据集图片分类</p>
<p>这个模型能够标注的内容还是有所限制；不过，它能标注的内容已经涵盖了 Facebook、Reddit 等社交媒体上的大多数图片。</p>
<p>但是，对于 COCO 数据集中不存在的图片内容，这个模型并不能完成标注。我曾尝试着使用 Tesseract 来解决这个问题，但是它的结果并不是很准确，而且花费的时间也太长了（超过 10 秒）。现在我正在尝试使用 Tensorflow 实现 <a href="http://ai.stanford.edu/~ang/papers/ICPR12-TextRecognitionConvNeuralNets.pdf" target="_blank" rel="noopener">王韬等人的论文</a>，将其加入这个项目中。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>虽然现在几乎每周都会涌现一些关于 AI 的新事物，但最重要的是退回一步，看看这些工具能在研究环境之外发挥出怎样的作用，以及这些研究能怎样帮助世界各地的人们。总而言之，我希望我能深入研究 Tensorflow 和 in2txt 模型，并将我所学知识应用于现实世界。我希望这个工具能成为帮助视障人士”看“更好的互联网的第一步。</p>
<h4 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h4><ul>
<li>关注文章作者：我会在 <a href="https://medium.com/@abhisuri97" target="_blank" rel="noopener">Medium</a> 上首发我写的文章。如果你喜欢这篇文章，欢迎关注我:)。接下来一个月，我将会在下个月发布一系列“如何使用 AI/tensorflow 解决现实世界问题”的文章。最近我还会发一些 JS 方面的教程。</li>
<li>本文工具 Chrome 插件：<a href="http://abhinavsuri.com/aat" target="_blank" rel="noopener">下载地址</a></li>
<li>Auto Alt Text Lambda API：<a href="http://github.com/abhisuri97/auto-alt-text-lambda-api" target="_blank" rel="noopener">Github repository 地址</a></li>
</ul>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/59a51e91f265da2499603c8c" target="_blank" rel="noopener">https://juejin.im/post/59a51e91f265da2499603c8c</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/22/%E9%9A%8F%E6%9C%BA%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-An-Introduction-to-Random-Indexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/22/%E9%9A%8F%E6%9C%BA%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-An-Introduction-to-Random-Indexing/" class="post-title-link" itemprop="url">随机索引算法论文笔记 An Introduction to Random Indexing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-22 09:34:00" itemprop="dateCreated datePublished" datetime="2017-08-22T09:34:00+08:00">2017-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Paper/" itemprop="url" rel="index">
                    <span itemprop="name">Paper</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Sahlgren M. An Introduction to Random Indexing[C]// Methods &amp; Applications of Semantic Indexing Workshop at International Conference on Terminology &amp; Knowledge Engineering. 2005:194–201.</p>
</blockquote>
<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><p>文章作者为 Sahlgren M</p>
<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>本文主要内容分为了 4 段，分别为：</p>
<ul>
<li>The word space methodology</li>
<li>Problems and solutions</li>
<li>Random Indexing</li>
<li>Results</li>
</ul>
<p>文章从文本空间讲起，简述了使用向量表示词的作用。接着以 LSA 加上 SVD 降维为例，简单说明了传统词向量表示算法的一些局限性（向量维度依然过大，计算代价大等），引出了 Random Indexing 算法。</p>
<h2 id="Random-Indexing"><a href="#Random-Indexing" class="headerlink" title="Random Indexing"></a>Random Indexing</h2><p>文中描述：<br>• First, each context (e.g. each document or each word) in the data is assigned a unique and randomly generated representation called an index vector. These index vectors are sparse, high-dimensional, and ternary, which means that their dimensionality (d) is on the order of thousands, and that they consist of a small number of randomly distributed +1s and -1s, with the rest of the elements of the vectors set to 0.<br>• Then, context vectors are produced by scanning through the text, and each time a word occurs in a context (e.g. in a document, or within a sliding context window), that context’s d-dimensional index vector is added to the context vector for the word in question. Words are thus represented by d-dimensional context vectors that are effectively the sum of the words’ contexts.</p>
<p>结合下面的论文提到的解释理解 Random Indexing algorithm。</p>
<blockquote>
<p>论文 2 — 熊玮, 白越, 刘爱国,等. 基于改进RI方法的文本聚类[J]. 南昌大学学报(理科版), 2016, 40(5):426-430.</p>
</blockquote>
<h3 id="第一步：生成随机索引向量"><a href="#第一步：生成随机索引向量" class="headerlink" title="第一步：生成随机索引向量"></a>第一步：生成随机索引向量</h3><p>为正文、单词生成随机索引向量。这些随机索引向量是稀疏、高维的。随机索引向量的值可以为 (-1, +1, 0) 三种。大多数的向量值都为 0，只有少数向量值为 -1 和 +1。在论文 2 中提到随机索引向量可以使用二元组 $ (d,\epsilon) $表示。<br>其中，$d$ 为向量维度，$\epsilon$为不同索引向量元素数量参数。对于所有文本来说，它们向量空间中出现的 -1 与 +1 的数量是相同的，在 $d$ 确定后由 $\epsilon$ 决定它们出现的数量。<br>令文本集全集为 $W$，文本集的子集（单词）为$\omega _j \in W,j \in {1,2,3,…,n} $，此时生成的随机索引向量为 $ R_{\nu_j} = (r\nu_1^j,r\nu_2^j,r\nu_3^j,…,r\nu_d^j ) $，其中 $r\nu_{h^j} \in {+1,-1,0}, h \in {1,2,3,…,d}$。$\epsilon$的取值远小于$d$。总体来说，+1 与 -1 分别占随机索引向量总维度的概率为 $\frac{\epsilon /2}{d}$，显然有</p>
<script type="math/tex; mode=display">\frac{\epsilon /2}{d} + \frac{d - \epsilon}{d} + \frac{\epsilon /2}{d} = 1</script><h3 id="第二步：生成文本向量"><a href="#第二步：生成文本向量" class="headerlink" title="第二步：生成文本向量"></a>第二步：生成文本向量</h3><p>根据滑动窗口包含的上下文生成上下文向量，接着根据上下文向量计算文本向量。<br>在论文 2 中，这一步又分为了两步：</p>
<h4 id="生成特征词汇的上下文向量"><a href="#生成特征词汇的上下文向量" class="headerlink" title="生成特征词汇的上下文向量"></a>生成特征词汇的上下文向量</h4><p>设滑动窗口大小为 2L，则窗口范围为 [-L, L]。记特征词 $\omega_j$ 在文本 $d_i$ 中的上下文向量为 $c^i_j$，则其表达式为：</p>
<script type="math/tex; mode=display">c^i_j = \sum^{k = L}_{k = -L}Rv_{j+k} * \omega f(\omega_{j+k})</script><p>其中 $Rv_{j+k}$ 表示特征词 $\omega_j$ 在窗口范围内共现词 $\omega_{j+k}$ 对应的随机索引向量；<br>$\omega f(\omega_{j+k})$ 为特征词 $\omega_j$ 在窗口范围上下文中共现特征词 $\omega_{j+k}$ 在文本 $d_i$ 中的加权权重。论文 2 中采用了 tf-idf 加权计算算法。论文 2 此时引用了</p>
<blockquote>
<p>Gorman J, Curran J R. Random Indexing using Statistical Weight Functions[C]// EMNLP 2007, Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing, 22-23 July 2006, Sydney, Australia. DBLP, 2006:457-464.</p>
</blockquote>
<p>根据 tf-idf 加权算法，可以得到 $\omega f(\omega_{j+k})$ 的表达式：</p>
<script type="math/tex; mode=display">\omega f(\omega_{j+k}) = \frac{f(\omega,\omega')}{n(\omega')} = \frac{n(\omega,\omega')}{n(\omega) * n(\omega')}</script><p>其中 $n(\omega)$ 表示特征词汇 $\omega$ 在上下文中出现的数量，$n(\omega,\omega’)$ 表示上下文中 $\omega$ 与 $\omega’$ 共同出现的数量。</p>
<p>最终，某个特征词汇 $\omega_j$ 在滑动窗口上下文中的上下文向量表示为</p>
<script type="math/tex; mode=display">C_j = \sum^{n}_{i=1} c^i_j</script><h4 id="生成文本向量"><a href="#生成文本向量" class="headerlink" title="生成文本向量"></a>生成文本向量</h4><ul>
<li>计算文本集中所有特征词汇上下文向量的平均值</li>
</ul>
<script type="math/tex; mode=display">\tau = \frac{\sum^n_{i=1}\sum^{z_i}_{j=1}Cj}{m}</script><p>其中 $z_i$ 表示文档 $d_i$ 中特征词汇总数，m 表示文 本集中所有不同特征词汇的总数量，n 表示文本集的文本总数量。</p>
<ul>
<li>生成文档 $d_i$ 的文本向量</li>
</ul>
<script type="math/tex; mode=display">V_i =\frac{\sum^{z_i}_{j=1}C_j}{z_i} - \tau</script><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>文章最后总结了一些经典数据集与实验应用 RI 算法之后准确率大多有所上升。论文 2 中最终总结了 RI 算法的优缺点。</p>
<h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul>
<li>计算量小</li>
<li>容易实现</li>
<li>处理效率高</li>
<li>潜在语义表现好，利用了上下文信息表示特征词的词向量，容易解决同义词、近义词等问题</li>
<li>降维性能好</li>
</ul>
<h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ul>
<li>随机向量元素 (-1, +1, 0) 的随机性可能导致在计算特征词上下文向量时发生相加消减的情况，导致潜在语义信息丢失</li>
<li>论文 2 中选用的 tf-idf 计算出的加权值过小（此条仅对全文特征向量计算而言）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了 Random Indexing algorithm 的基本原理及应用。之后有精力希望能将 RI 算法的代码实现，并将其与其它词向量表示算法进行对比。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/18/%E5%9C%A8-Ulysses-%E4%B8%AD%E4%BD%BF%E7%94%A8-Latex-%E5%85%AC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/18/%E5%9C%A8-Ulysses-%E4%B8%AD%E4%BD%BF%E7%94%A8-Latex-%E5%85%AC%E5%BC%8F/" class="post-title-link" itemprop="url">在 Ulysses 中使用 Latex 公式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-18 17:27:58" itemprop="dateCreated datePublished" datetime="2017-08-18T17:27:58+08:00">2017-08-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tool/" itemprop="url" rel="index">
                    <span itemprop="name">Tool</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在文档的头部加上如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">~~ <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="undefined"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript">~~ MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath:[[<span class="string">'$latex'</span>,<span class="string">'$'</span>]]&#125;&#125;);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="undefined">~~ </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">~~ <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>
<p>即可在 Ulysses 中正常使用 Latex 公式啦。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">~~ $latex a &#x3D; frac&#123;1&#125;&#123;b&#125; $</span></pre></td></tr></table></figure>
<p>得到</p>
<p><img src="/images/pasted-182.png" alt="upload successful"></p>
<p>试试在 wp 里 latex 的显示：</p>
<p>~~ $latex a = frac{1}{b} $</p>
<p>除了多了两波浪号没别的问题，手动去掉吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/14/%E6%9C%BA%E5%99%A8%E4%B9%8B%E9%AD%82%EF%BC%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/14/%E6%9C%BA%E5%99%A8%E4%B9%8B%E9%AD%82%EF%BC%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/" class="post-title-link" itemprop="url">机器之魂：聊天机器人是怎么工作的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-14 15:52:47" itemprop="dateCreated datePublished" datetime="2017-08-14T15:52:47+08:00">2017-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>自早期的工业时代以来，人类就被能自主操作的设备迷住了。因为，它们代表了科技的“人化”。</p>
<p>而在今天，各种软件也在逐渐变得人性化。其中变化最明显的当属“聊天机器人”。</p>
<p>但是这些“机械”是如何运作的呢？首先，让我们回溯过去，探寻一种原始，但相似的技术。</p>
<h3 id="音乐盒是如何工作的"><a href="#音乐盒是如何工作的" class="headerlink" title="音乐盒是如何工作的"></a>音乐盒是如何工作的</h3><p><img src="/images/pasted-177.png" alt="upload successful"></p>
<p>早期自动化的样例 —— 机械音乐盒。<br>一组经过调音的金属齿排列成梳状结构，置于一个有针的圆柱边上。每根针都以一个特定的时间对应着一个音符。</p>
<p>当机械转动时，它便会在预定好的时间通过单个或者多个针的拨动来产生乐曲。如果要播放不同的歌，你得换不同的圆柱桶（假设不同的乐曲对应的特定音符是一样的）。</p>
<p>除了发出音符之外，圆筒的转动还可以附加一些其它的动作，例如移动小雕像等。不管怎样，这个音乐盒的基本机械结构是不会变的。</p>
<h3 id="聊天机器人是如何工作的"><a href="#聊天机器人是如何工作的" class="headerlink" title="聊天机器人是如何工作的"></a>聊天机器人是如何工作的</h3><p>输入的文本将经过一种名为“分类器”的函数处理，这种分类器会将一个输入的句子和一种“意图”（聊天的目的）联系起来，然后针对这种“意图”产生回应。</p>
<p><img src="/images/pasted-178.png" alt="upload successful"></p>
<p><a href="http://lauragelston.ghost.io/speakeasy/" target="_blank" rel="noopener">一个聊天机器人的例子</a></p>
<p>你可以将分类器看成是将一段数据（一句话）分入几个分类中的一种（即某种意图）的一种方式。输入一句话“how are you?”，将被分类成一种意图，然后将其与一种回应（例如“I’m good”或者更好的“I am well”）联系起来。</p>
<p>我们在基础科学中早学习了分类：黑猩猩属于“哺乳动物”类，蓝鸟属于“鸟”类，地球属于“行星”等等。</p>
<p>一般来说，文本分类有 3 种不同的方法。可以将它们看做是为了一些特定目的制造的软件机械，就如同音乐盒的圆筒一样。</p>
<h3 id="聊天机器人的文本分类方法"><a href="#聊天机器人的文本分类方法" class="headerlink" title="聊天机器人的文本分类方法"></a><strong>聊天机器人的文本分类方法</strong></h3><ul>
<li><strong>模式匹配</strong></li>
<li><strong>算法</strong></li>
<li><strong>神经网络</strong></li>
</ul>
<p>无论你使用哪种分类器，最终的结果一定是给出一个回应。音乐盒可以利用一些机械机构的联系来完成一些额外的“动作”，聊天机器人也如此。回应中可以使用一些额外的信息（例如天气、体育比赛比分、网络搜索等等），但是这些信息并不是聊天机器人的组成部分，它们仅仅是一些额外的代码。也可以根据句子中的某些特定“词性”来产生回应（例如某个专有名词）。此外，符合意图的回应也可以使用逻辑条件来判断对话的“状态”，以提供一些不同的回应，这也可以通过随机选择实现（好让对话更加“自然”）。</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>早期的聊天机器人通过模式匹配来进行文本分类以及产生回应。这种方法常常被称为“暴力法”，因为系统的作者需要为某个回应详细描述所有模式。</p>
<p>这些模式的标准结构是“AIML”（人工智能标记语言）。这个名词里用了“人工智能”作为修饰词，但是<a href="https://medium.com/@gk_/the-ai-label-is-bullshit-559b171867ff" target="_blank" rel="noopener">它们完全不是一码事</a>。</p>
<p>下面是一个简单的模式匹配定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aiml</span> <span class="attr">version</span> = <span class="string">"1.0.1"</span> <span class="attr">encoding</span> = <span class="string">"UTF-8"</span>?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span> WHO IS ALBERT EINSTEIN <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">template</span>&gt;</span>Albert Einstein was a German physicist.<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span> WHO IS Isaac NEWTON <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">template</span>&gt;</span>Isaac Newton was a English physicist and mathematician.<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>DO YOU KNOW WHO * IS<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">template</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">         <span class="tag">&lt;<span class="name">srai</span>&gt;</span>WHO IS <span class="tag">&lt;<span class="name">star</span>/&gt;</span><span class="tag">&lt;/<span class="name">srai</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;/<span class="name">category</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">aiml</span>&gt;</span></span></pre></td></tr></table></figure>
<p>然后机器经过处理会回答：</p>
<pre><code>Human: Do you know who Albert Einstein is
Robot: Albert Einstein was a German physicist.
</code></pre><p>它之所以知道别人问的是哪个物理学家，只是靠着与他或者她名字相关联的模式匹配。同样的，它靠着创作者预设的模式可以对任何意图进行回应。在给予它成千上万种模式之后，你终将能看到一个“类人”的聊天机器人出现。</p>
<p>2000 年的时候，John Denning 和他的同事就以这种方法做了个聊天机器人（<a href="http://mashable.com/2014/06/12/eugene-goostman-turing-test/" target="_blank" rel="noopener">相关新闻</a>），并通过了“图灵测试”。它设计的目标是模仿来自乌克兰的一个 13 岁的男孩，这孩子的英语水平很蹩脚。我在 2015 年的时候和 John 见过面，他没有矢口否认这个自动机的内部原理。因此，这个聊天机器人很可能就是用“暴力”的方法进行模式匹配。但它也证明了一点：在足够大的模式匹配定义的支持下，可以让大部分对话都贴近“自然”的程度。同时也符合了图灵（Alan Turing）的断言：制作用来糊弄人类的机器是“毫无意义”的。</p>
<p>使用这种方法做机器人的典型案例还有 <a href="http://www.pandorabots.com/" target="_blank" rel="noopener">PandoraBots</a>，他们宣称已经用他们的框架构建了超过 28.5 万个聊天机器人。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>暴力穷举法做自动机让人望而却步：对于每个输入都得有可用的模式来匹配其回应。人们由“老鼠洞”得到灵感，创建了模式的层级结构。</p>
<p>我们可以使用<strong>算法</strong>这种方法来减少分类器以便对机器进行管理，或者也可以说我们为它创建一个方程。这种方法是计算机科学家们称为“简化”的方法：问题需要<strong>缩减</strong>，那么解决问题的方法就是将其简化。</p>
<p>有一种叫做“朴素贝叶斯多项式模型”的经典文本分类算法，你可以在<a href="http://nlp.stanford.edu/IR-book/pdf/13bayes.pdf" target="_blank" rel="noopener">这儿</a>或者别的地方学习它。下面是它的公式：</p>
<p><img src="/images/pasted-179.png" alt="upload successful"></p>
<p>实际用起它来比看上去要简单的多。给定一组句子，每个句子对应一个分类；接着输入一个新的句子，我们可以通过计算这个句子的单词在各个分类中的词频，找出各个分类的共性，并给每个分类一个<strong>分值</strong>（找出共性这点是很重要的：例如匹配到单词“cheese”（奶酪）比匹配到单词“it”要有意义的多）。最后，得到最高分值的分类很可能就是输入句子的同类。当然以上的说法是经过简化的，例如你还得先找到每个单词的<a href="https://en.wikipedia.org/wiki/Stemming" target="_blank" rel="noopener">词干</a>才行。不过，现在你应该对这种算法已经有了基本的概念。</p>
<p>下面是一个简单的训练集：</p>
<pre><code>class: weather
    &quot;is it nice outside?&quot;
    &quot;how is it outside?&quot;
    &quot;is the weather nice?&quot;

class: greeting
    &quot;how are you?&quot;
    &quot;hello there&quot;
    &quot;how is it going?&quot;
</code></pre><p>让我们来对几个简单的输入句子进行分类：</p>
<pre><code>input: &quot;Hi there&quot;
 term: &quot;hi&quot; (**no matches)**
 term: &quot;there&quot; **(class: greeting)**
 classification: **greeting **(score=1)

input: &quot;What’s it like outside?&quot;
 term: &quot;it&quot; **(class: weather (2), greeting)**
 term: &quot;outside **(class: weather (2) )**
 classification: **weather **(score=4)
</code></pre><p>请注意，“What’s it like outside”在分类时找到了另一个分类的单词，但是正确的分类给了单词较高的分值。通过算法公式，我们可以为句子计算匹配每个分类对应的词频，因此不需要去标明所有的模式。</p>
<p>这种分类器通过标定分类分值（计算词频）的方法给出最匹配语句的分类，但是它仍然有局限性。分值与概率不同，它仅仅能告诉我们句子的意图最有可能是哪个分类，而不能告诉我们它的所有匹配分类的可能性。因此，很难去给出一个阈值来判定是接受这个得分结果还是不接受这个结果。这种类型的算法给出的最高分仅仅能作为判断相关性的基础，它本质上作为分类器的效果还是比较差的。此外，这个算法不能接受 *is not* 类型的句子，因为它仅仅计算了 *it* 可能是什么。也就是说这种方法不适合做为包含 *not* 的否定句的分类。</p>
<p>有许多的聊天机器人框架<a href="https://medium.com/@gk_/text-classification-using-algorithms-e4d50dcba45#.ewnhttxa4" target="_blank" rel="noopener">都是用这种方法来判断意图分类</a>。而且大多数都是针对训练集进行词频计算，这种“幼稚”的方法有时还意外的有效。</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>人工神经网络发明于 20 世纪 40 年代，它通过迭代计算训练数据得到连接的加权值（“突触”），然后用于对输入数据进行分类。通过一次次使用训练数据计算改变加权值以使得神经网络的输出得到更高的“准确率”（低错误率）。</p>
<p><img src="/images/pasted-180.png" alt="upload successful"></p>
<p>上图为一种神经网络结构，其中包括神经元（圆）和突触（线）</p>
<p>其实除了当今的软件可以用更快的处理器、更大的内存外，这些结构并没有出现什么新奇的东西。当做数十万次的矩阵乘法（神经网络中的基本数学运算）的时候，运行内存和计算速度成为了关键问题。</p>
<p>在前面的方法里，每个分类都会给定一些例句。接着，根据词干进行分句，将所有单词作为神经网络的输入。然后遍历数据，进行成千上万次迭代计算，每次迭代都通过改变突触权重来得到更高的准确率。接着反过来通过对训练集输出值和神经网络计算结果的对比，对各层重新进行计算权重（反向传播）。这个“权重”可以类比成神经突触想记住某个东西的“力度”，你能记住某个东西是因为你曾多次见过它，在每次见到它的时候这个“权重”都会轻微地上升。</p>
<p>有时，在权重调整到某个程度后反而会使得结果逐渐变差，这种情况称为“过拟合”，在出现过拟合的情况下继续进行训练，反而会适得其反。</p>
<p><img src="/images/pasted-181.png" alt="upload successful"></p>
<p>训练好的神经网络模型的代码量其实很小，不过它需要一个很大的潜在权重矩阵。举个相对较小的样例，它的训练句子包括了 150 个单词、30 种分类，这可能产生一个 150x30 大小的矩阵；你可以想象一下，为了降低错误率，这么大的一个矩阵需要反复的进行 10 万次矩阵乘法。这也是为什么说需要高性能处理器的原因。</p>
<p>神经网络之所以能够做到既复杂又稀疏，归结于<a href="https://www.khanacademy.org/math/precalculus/precalc-matrices/multiplying-matrices-by-matrices/v/matrix-multiplication-intro" target="_blank" rel="noopener">矩阵乘法</a>和一种<a href="https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank" rel="noopener">缩小值至 -1，1 区间的公式</a>（即激活函数，这里指的是 Sigmoid），一个中学生也能在几小时内学会它。其实真正困难的工作是清洗训练数据。</p>
<p>就像前面的模式匹配和算法匹配一样，神经网络也有各种各样的变体，有一些变体会十分复杂。不过它的基本原理是相同的，做的主要工作也都是进行分类。</p>
<p>机械音乐盒并不了解乐理，同样的，<strong>聊天机器人并不了解语言</strong>。</p>
<p>聊天机器人实质上就是寻找短语集合中的模式，每个短语还能再分割成单个单词。在聊天机器人内部，除了它们存在的模式以及训练数据之外的<strong>单词其实并没有意义</strong>。为这样的“机器人”贴上“人工智能”的标签其实<a href="https://medium.com/@gk_/the-ai-label-is-bullshit-559b171867ff#.3tlhftemt" target="_blank" rel="noopener">也很糟糕</a>。</p>
<p>总结：聊天机器人就像机械音乐盒一样：它就是<strong>一个根据模式来进行输出的机器</strong>，只不过它不用圆筒和针，而是使用软件代码和数学原理。</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/599155d86fb9a03c467c151d" target="_blank" rel="noopener">https://juejin.im/post/599155d86fb9a03c467c151d</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/12/%E8%A7%A3%E5%86%B3%E5%B0%86-ionic2-%E5%8D%87%E7%BA%A7%E8%87%B3-3-%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84-webpackJsonp-%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/12/%E8%A7%A3%E5%86%B3%E5%B0%86-ionic2-%E5%8D%87%E7%BA%A7%E8%87%B3-3-%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84-webpackJsonp-%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决将 ionic2 升级至 3 时出现的 webpackJsonp 问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-12 18:28:26" itemprop="dateCreated datePublished" datetime="2017-08-12T18:28:26+08:00">2017-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Front-End/" itemprop="url" rel="index">
                    <span itemprop="name">Front End</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ionic3 修复了2.x 存在的 ion-select 组件的 interface 等 bug，因此对其进行升级。修改 package.json，删除 node_module 目录，在 npm I 的时候依次按照提示在 package.json 中将不符合版本的库改为兼容版本。</p>
<p>升级完成之后 build 时提示 webpackjsonp is not defined，翻阅 README 的 Change log 发现新版 cli 脚手架写的 webpack 配置有所改变，将公用部分使用 CommonsChunkPlugin 额外打了一个包，此包命名为 vendor。在 app 入口文件中引用该公用包解决问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">卷积神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-09 16:25:34" itemprop="dateCreated datePublished" datetime="2017-08-09T16:25:34+08:00">2017-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CNN-是怎么学习的？学习了什么？"><a href="#CNN-是怎么学习的？学习了什么？" class="headerlink" title="CNN 是怎么学习的？学习了什么？"></a>CNN 是怎么学习的？学习了什么？</h2><p><strong>这篇文章是深度学习系列的一部分。你可以在</strong><a href="https://github.com/xitu/gold-miner/blob/master/TODO/deep-learning-1-setting-up-aws-image-recognition.md" target="_blank" rel="noopener"><strong>这里</strong></a><strong>查看第一部分，以及在</strong><a href="https://github.com/xitu/gold-miner/blob/master/TODO/deep-learning-3-more-on-cnns-handling-overfitting.md" target="_blank" rel="noopener"><strong>这里</strong></a><strong>查看第三部分。</strong></p>
<p><img src="/images/pasted-171.png" alt="upload successful"></p>
<p>这一周，我们将探索卷积神经网络（CNN）的内部工作原理。你可能会问：在网络内部究竟发生了什么？它们是怎样学习的？</p>
<p>这门课程遵循自上而下的学习方法与理念。因此一般来说，我们在开始学习的时候就能立即玩到所有的模型，然后我们会逐渐深入其内部的工作原理。因此，本系列也将会逐渐深入探索神经网络的内部工作原理。现在仅仅是第二周，让我们朝着最终的目标迈进吧！</p>
<p>在上周，我在猫狗图像集上训练了 Vgg 16 模型。我想先聊一下为什么说使用预先训练好的模型是一种很好的方法。为了使用这些模型，首先你得要弄清楚这些模型到底学习的是什么。从本质上说，CNN 学习的是过滤器，并将学习到的过滤器应用于图像。当然，这些“过滤器”和你在 Instagram 里用的滤镜（英文也为“filter”）并不是一种东西，但它们其实有一些相同之处。CNN 会使用一个小方块遍历整张图片，通常将这个小方块称为“窗口”。接下来，网络会在图片中查找与过滤器匹配的图片内容。在第一层，网络可能只学习到了一些简单的事物（例如对角线）。在之后的每一层中，网络都将结合前面找到的特征，持续学习更加复杂的概念。单单听这些概念可能会让人比较迷糊，让我们直接来看一些例子。<a href="https://arxiv.org/abs/1311.2901" target="_blank" rel="noopener">Zeiler and Fergus (2013)</a> 为可视化 CNN 学习过程做出了一项很棒的工作。下图是他们在论文中用的 CNN 模型，赢得 Imagenet 竞赛的 Vgg16 模型就是基于这个模型做出来的。</p>
<p><img src="/images/pasted-172.png" alt="upload successful"></p>
<p>CNN，作者：Zeiler &amp; Fergus (2013)</p>
<p>可能你现在会觉得这个图片很难懂，请不要慌！让我们先从我们可以在图中看到的东西说起吧。首先，输入图像是正方形，大小为 224x224 像素。我之前说的过滤器大小是 7x7 像素大小。该模型有一个输入层，7 个隐藏层以及一个输出层。输出层的“C”指的是模型的预测分类数量。现在让我们来了解 CNN 中最有趣的部分：这个神经网络在每一层中都学到了什么！</p>
<p><img src="/images/pasted-173.png" alt="upload successful"></p>
<p>上图为 CNN 的第二层。左边的图像代表了 CNN 的这层网络在右边的真实图片中学习到的内容。<br>在 CNN 的第二层中，你可以发现这个模型已经不仅仅是去提取对角线了，它找到了一些更有意思的形状特征。例如在第二排第二列的方块中，你可以看到模型正在提取圆形；还有，最后一个方块表明模型正在专注于识别图中的一个直角作为特征。</p>
<p><img src="/images/pasted-174.png" alt="upload successful"></p>
<p>上图为 CNN 的第三层。<br>在第三层中，我们可以看到模型已经开始学习一些更具体的东西。第一个方块中的图像表明模型已经能够识别出一些地理特征；第二排第二列的方块表明模型正在识别车轮；倒数第二个方块表明模型正在识别人类。</p>
<p><img src="/images/pasted-175.png" alt="upload successful"></p>
<p>CNN 的第四层与第五层</p>
<p>在最后，第四层与第五层保持前面模型越来越具体的趋势。第五层找到了对解决我们的猫狗问题非常有帮助的特征。与此同时，它还识别出了独轮车，以及鸟类、爬行动物的眼睛。请注意，这些图像仅仅展示了每一层学习到的东西的极小一部分。</p>
<p>希望上面的文字已经告诉了你为什么使用预先训练好的模型是很有用的。如果你想更多的了解这块领域的研究，你可以搜索“迁移学习”（transfer learning）的相关内容。虽然我们的猫狗问题训练集仅仅只有 25000 张图片，一个新的模型可能还无法从这些图片中学习到所有的特征，但我们的 Vgg16 模型已经相当“了解”怎么去识别猫和狗了。最后，通过“微调”（Finetuning） Vgg16 模型的最后一层，让其不再输出 1000 多种分类的概率，而是直接输出二分类 —— 猫和狗。</p>
<p>如果你对深度学习背后的数学知识感兴趣，<a href="http://cs231n.github.io/" target="_blank" rel="noopener">Stanford’s CNN pages</a> 是很好的参考材料。他们首次以“数学之美”解释了浅层神经网络。</p>
<hr>
<h4 id="微调及线性层（全连接层）"><a href="#微调及线性层（全连接层）" class="headerlink" title="微调及线性层（全连接层）"></a>微调及线性层（全连接层）</h4><p>上周，我用这个预先训练好的 Vgg16 模型不能很自然的区分猫和狗这两个分类下的图片，而是提出了 1000 余种分类。此外，这个模型并不会直接输出“猫”和“狗”的分类，而是输出猫和狗的一些特定品种。那我们如何修改这个模型，让它能够有效地对猫和狗进行分类呢？</p>
<p>有种可选方案：手动将这些品种分到猫和狗中去，然后计算其概率之和。但是，这种做法会丢弃一些关键信息。例如，如果图片中只有一根骨头，但它很可能是一张属于狗的照片。如果我们仅查看这些品种分为猫狗的概率，前面提到的这种信息很可能会丢失。因此在模型的最后，我们加入一个线性层（全连接层），它将仅输出两种分类。实际上，Vgg16 模型的最后有 3 层全连接层。我们可以微调这些层，通过反向传播来训练它们。反向传播算法常常被人看成是一种抽象的魔法，但其实它只是简单应用链式求导法则。你可以暂时忽略这些数学上的细节，TensorFlow、Theano 和其它深度学习库已经帮你做好了这些工作。</p>
<p>如果你正在运行 Fast AI 课程 lesson 2 的 notebook，我建议你最好先只使用 notebook 的样例图片。如果你运行 p2 的实例，可能会由于保存、加载 numpy 数组将内存耗尽。</p>
<hr>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>前面我们讨论了网络最后的线性层（全连接层）。然而，神经网络的所有层都不是线性的。在神经网络计算出每个神经元的参数之后，我们需要将它们的计算结果作为参数输入到激活函数中。人工神经网络基本上由矩阵乘法组成，如果我们只使用线性计算的话，我们只能将它们一个个叠加在一起，并不能做成一个很深的网络。因此，我们会经常在网络的各层使用非线性的激活函数。通过将重重线性与非线性函数叠加在一起，理论上我们可以对任何事物进行建模。下面是三种最受欢迎的非线性激活函数：</p>
<ul>
<li>Sigmoid <strong>（将值转换到 0，1 间）</strong></li>
<li>TanH <strong>（将值转换到 -1，1 间）</strong></li>
<li>ReLu <strong>（如果值为负则输出 0，否则输出原值）</strong></li>
</ul>
<p><img src="/images/pasted-176.png" alt="upload successful"></p>
<p>上图为最常用的激活函数：Sigmoid、Tanh 和 ReLu（又名修正线性单元）<br>目前，ReLu 是使用的最多的非线性激活函数，主要原因是它可以减少梯度消失的可能性，以及保持稀疏特征。稍后会讨论这方面的更多详情。因为我们希望模型最后能够输出确定的内容，因此模型的最后一层通常使用一种另外的激活函数 —— softmax。softmax 函数是一种非常受欢迎的分类器。</p>
<p>在微调完 Vgg16 模型的最后一层之后，它总共有 138357544 个参数。谢天谢地，我们不需要手动计算各种梯度 XD。下一周我们将更深入地了解 CNN 的工作原理，讨论主题为欠拟合和过拟合。</p>
<p>如果你喜欢这篇文章，请将它推荐给其他人吧！你也可以关注此系列文章，跟上 Fast AI 课程的进度。下篇文章再会！</p>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/598ac6a55188257dd366367f" target="_blank" rel="noopener">https://juejin.im/post/598ac6a55188257dd366367f</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/08/09/%E5%A6%82%E4%BD%95%E5%B0%86%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E7%94%A8-Python-%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/09/%E5%A6%82%E4%BD%95%E5%B0%86%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E7%94%A8-Python-%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">如何将时间序列问题用 Python 转换成为监督学习问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-09 16:23:01" itemprop="dateCreated datePublished" datetime="2017-08-09T16:23:01+08:00">2017-08-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一些机器学习方法（例如深度学习）可以用于进行时间序列预测。</p>
<p>在使用这些机器学习方法前，必须先将时间序列预测问题转化为监督学习问题。也就是说，需要将一个时间序列转换成一组包含成对输入输出的序列。</p>
<p>在这篇教程里，你将了解如何将单变量时间序列预测问题和多变量时间序列预测问题转换成监督学习问题，以使用机器学习算法。</p>
<p>读完这篇教程，你将会了解：</p>
<ul>
<li>如何编写一个将时间序列数据集转换为监督学习数据集的函数。</li>
<li>如何转换一元时间序列数据以使用机器学习。</li>
<li>如何转换多元时间序列数据以使用机器学习。</li>
</ul>
<p>让我们开始吧。</p>
<p><img src="/images/pasted-170.png" alt="upload successful"></p>
<p>题图：如何将时间序列问题用 Python 转换成为监督学习问题</p>
<p><a href="https://www.flickr.com/photos/quimgil/8490510169/" target="_blank" rel="noopener">Quim Gil</a> 拍摄，版权所有。</p>
<h2 id="时间序列-vs-监督学习"><a href="#时间序列-vs-监督学习" class="headerlink" title="时间序列 vs 监督学习"></a>时间序列 vs 监督学习</h2><p>在正式开始之前，让我们先花点时间更好地了解一下时间序列和监督学习的数据集结构。</p>
<p>单个时间序列由一系列按照时间排序的数字序列组成。可以将其理解为一列有序值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">9</span></pre></td></tr></table></figure>
<p>而一个监督学习问题是由一组输入（*X*）和一组输出（*y*）组成，算法可以学会如何通过输入值来预测输出值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">X,  y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2,  3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3,  4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4,  5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5,  6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6,  7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">7,  8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">8,  9</span></pre></td></tr></table></figure>
<p>可以参阅这篇文章，学习更多有关知识：</p>
<ul>
<li><a href="http://machinelearningmastery.com/time-series-forecasting-supervised-learning/" target="_blank" rel="noopener">Time Series Forecasting as Supervised Learning</a></li>
</ul>
<h2 id="Pandas-的-shift-函数"><a href="#Pandas-的-shift-函数" class="headerlink" title="Pandas 的 shift() 函数"></a>Pandas 的 shift() 函数</h2><p>我们将时间序列数据转化为监督学习问题的关键就是使用 Pandas 的 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.shift.html" target="_blank" rel="noopener">shift()</a> 函数。</p>
<p>给定一个 DataFrame，*shift()* 函数会将输入的列复制一份，然后将副本列整体往后移动（最前面的数据空位会用 NaN 填充）或者往前移动（最后面的数据空位会用 NaN 填充）。</p>
<p>这样可以创建一个滞后值列，加上观察列，就能将时间序列数据集变成监督学习数据集的格式。</p>
<p>让我们看看 shift 函数实际用起来效果如何。</p>
<p>我们可以通过下面的代码模拟一个长度为 10 的时间序列数据集，此时它在 DataFrame 中为单独的一列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">df = DataFrame()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">print(df)</span></pre></td></tr></table></figure>
<p>运行上面的样例，将时间序列数据输出，其每一行都为带有索引的观察组数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">0  0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">1  1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">2  2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">3  3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">4  4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">5  5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">6  6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">7  7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">8  8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">9  9</span></pre></td></tr></table></figure></p>
<p>我们可以在数据顶部插入一行，将观察组的数据整体下挪一位。由于最上面插入的新行没有数据，因此我们可以用 NaN 填充来表示这儿“没有数据”。</p>
<p>shift 函数可以完成这些操作。我们可以将 shift 函数“挪动”过的新列插入原始序列的旁边。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">df = DataFrame()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">df[<span class="string">'t-1'</span>] = df[<span class="string">'t'</span>].shift(<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">print(df)</span></pre></td></tr></table></figure>
<p>运行上面的样例，你将得到一个包含两列的数据集。第一列是原始的观察组，第二列是经由 shift 函数挪动生成的新列。</p>
<p>可以看到，经过将序列移动一次的操作之后，我们得到了一个原始的监督学习问题（虽然此时的 *X* 和 *y* 的排序明显是错的）。忽略最前面的表头，第一行存在 NaN 值，因此需要将其丢弃。在第二行，我们可以将第二列的 0.0 作为输入值（也就是 *X*），将第一列的 1 作为输出值（或 *y*）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   t  t-1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">0  0  NaN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">1  1  0.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">2  2  1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">3  3  2.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">4  4  3.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">5  5  4.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">6  6  5.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">7  7  6.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">8  8  7.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">9  9  8.0</span></pre></td></tr></table></figure>
<p>如果我们重复 shift 步骤，让原始列挪动 2 位、3 位或者更多位，我们就能得到一系列的输入数据（*X*），由这些输入值就能去预测输出值（*y*）了。</p>
<p>shift 操作能也能接受负整数作为参数。如果你这么做，它会在列底部插入新行，从而使得原列向上移动。下面是例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">df = DataFrame()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">df[<span class="string">'t'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">df[<span class="string">'t+1'</span>] = df[<span class="string">'t'</span>].shift(<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">print(df)</span></pre></td></tr></table></figure>
<p>运行上面的样例，可以看到新列中的最后一个值为 NaN。</p>
<p>此时可以将预测列作为输入值（*X*），将第二列作为输出值（*y*）。也就是给定输入值 0 可以用于预测输出值 1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   t  t+1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">0  0  1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">1  1  2.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">2  2  3.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">3  3  4.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">4  4  5.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">5  5  6.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">6  6  7.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">7  7  8.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">8  8  9.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">9  9  NaN</span></pre></td></tr></table></figure>
<p>从技术上说，在时间序列预测问题的术语中，当前时间（*t*）和未来时间（*t+1, t+n*）为待预测时间，过去时间（*t-1, t-n*）则用于预测。</p>
<p>从上面的例子中，我们可以学会如何使用通过 shift 函数正向或反向移动序列，生成新的 DataFrame，将时间序列问题转变成监督学习问题的输入-输出模式。</p>
<p>这不仅可以解决经典的 *X -> y* 类预测问题，也可以用于输入输出值都是序列的 *X -> Y* 类预测。</p>
<p>另外，shift 函数也能用于多元时间序列问题中。这类问题中包含多列观察组（例如温度、气压等）。时间序列中的所有变量都能用通过向前或向后挪动，生成多元输入值与输出值序列。稍后我们将探讨这类问题。</p>
<h2 id="series-to-supervised-函数"><a href="#series-to-supervised-函数" class="headerlink" title="series_to_supervised() 函数"></a>series_to_supervised() 函数</h2><p>我们可以使用 Pandas 的 *shift()* 函数，在给定希望得到的输入值、输出值序列长度后自动生成时间序列问题的新格式数据。</p>
<p>这是个很有用的工具。我们可以通过机器学习算法研究各种时间序列问题格式，探究哪种格式能够得到效果更佳的模型。</p>
<p>在本节中，我们将创建一个新的 Python 函数，名为 *series_to_supervised()*。它可以将多元时间序列问题与一元时间序列问题转换为监督学习数据集的格式。</p>
<p>这个函数接收以下 4 个参数：</p>
<ul>
<li><strong>data</strong>：必填，待转换的序列，数据类型为 list 或 2 维 NumPy array。</li>
<li><strong>n_in</strong>： 可选，滞后组（作为输入值 X）的数量。范围可以在 [1..len(data)] 之间，默认值为 1。</li>
<li><strong>n_out</strong>： 可选，观察组（作为输出值 y）的数量。范围可以在  [0..len(data)-1] 之间，默认值为 1。</li>
<li><strong>dropnan</strong>：选填，决定是否抛去包含 NaN 的行。类型为 Boolean，默认值为 True。</li>
</ul>
<p>函数将会返回一个值：</p>
<ul>
<li><strong>return</strong>：返回监督学习格式的数据集，数据类型为 Pandas DataFrame。</li>
</ul>
<p>新数据集 DataFrame 格式，每一列都由原变量名称和移动步数命名，让你可以根据给定的一元或多元时间序列问题设计出各种移动步数的序列。</p>
<p>在 DataFrame 返回时，你可以对其行进行分割，根据你的需要决定如何将返回的 DataFrame 分成 X 和 y 两部分。</p>
<p>这个函数的参数都设置了默认值，因此可以直接调用它处理你的数据，这种默认情况它将会返回一个 *t-1* 作为 X，*t* 作为 y 的 DataFrame。</p>
<p>这个函数已确定同时兼容 Python2 和 Python3。</p>
<p>下面为完整代码，并写好了注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr></table></figure>
<p>你觉得可以怎样提高这个函数的鲁棒性或者可读性吗？请留言在评论区。</p>
<p>至此我们已经得到了整个函数，接下来探索它的用法。</p>
<h2 id="单步或单变量预测"><a href="#单步或单变量预测" class="headerlink" title="单步或单变量预测"></a>单步或单变量预测</h2><p>在时间序列预测问题中通常使用滞后时间（例如 t-1）作为输入变量来预测当前时间（t）。</p>
<p>这种问题被称为单步预测。</p>
<p>下面展示了使用滞后一个时间步的时间（t-1）来预测当前时间（t）的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  data = series_to_supervised(values)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  print(data)</span></pre></td></tr></table></figure>
<p>运行样例，输出转换后的时间序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var1(t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1        0.0        1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2        1.0        2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3        2.0        3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4        3.0        4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5        4.0        5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6        5.0        6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">7        6.0        7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">8        7.0        8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">9        8.0        9</span></pre></td></tr></table></figure>
<p>可以看到，观察组被命名为“*var1*”，作为输入值的观察组被命名为（*t-1*），输出值组被命名为（*t*）。</p>
<p>此外，可以看到包含 NaN 的行已经被自动从 DataFrame 中移除。</p>
<p>我们可以任意给定输入序列数量的值来重复运行这个例子。例如输入 3，我们事先已经将输入序列的数量定义为了一个参数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values, <span class="number">3</span>)</span></pre></td></tr></table></figure>
<p>完整样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">print(data)</span></pre></td></tr></table></figure>
<p>再次运行样例，输出重新构造的序列，可以看到输入序列准确无误地从左至右裴烈，作为预测项的输入值在最右边。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   var1(t-3)  var1(t-2)  var1(t-1)  var1(t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">3        0.0        1.0        2.0        3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">4        1.0        2.0        3.0        4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">5        2.0        3.0        4.0        5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">6        3.0        4.0        5.0        6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">7        4.0        5.0        6.0        7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">8        5.0        6.0        7.0        8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">9        6.0        7.0        8.0        9</span></pre></td></tr></table></figure>
<h2 id="多步或序列预测"><a href="#多步或序列预测" class="headerlink" title="多步或序列预测"></a>多步或序列预测</h2><p>还有一类预测问题：使用过去的观察组来对未来的观察组序列做预测。</p>
<p>可以将这类问题成为序列预测问题或者多步预测问题。</p>
<p>我们可以通过规定另一个参数来将序列预测问题的时间序列重新构造。例如，我们可以把 2 个过去的观察组转变为 2 个未来的观察组，从而重新构造预测问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">data=series_to_supervised(values,<span class="number">2</span>,<span class="number">2</span>)</span></pre></td></tr></table></figure>
<p>完整样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">values = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values, <span class="number">2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">print(data)</span></pre></td></tr></table></figure>
<p>运行样例，可以看到将（*t-n*）作为输入变量、将（*t+n*）作为输出变量时，与将当前观察组（*t*）作为输出的不同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   var1(t-2)  var1(t-1)  var1(t)  var1(t+1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2        0.0        1.0        2        3.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3        1.0        2.0        3        4.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">4        2.0        3.0        4        5.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">5        3.0        4.0        5        6.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">6        4.0        5.0        6        7.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">7        5.0        6.0        7        8.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">8        6.0        7.0        8        9.0</span></pre></td></tr></table></figure>
<h2 id="多元预测"><a href="#多元预测" class="headerlink" title="多元预测"></a>多元预测</h2><p>还有一种重要的时间序列类型，叫做多元时间序列。</p>
<p>这种情况我们会将多个不同的指标作为观察组，并预测它们中的一个或多个的值。</p>
<p>例如，我们有两组时间序列观察组 obs1 和 obs2，希望预测它们或它们中的一者。</p>
<p>我们同样可以调用 *series_to_supervised()*。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">raw = DataFrame()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">raw[<span class="string">'ob1'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">raw[<span class="string">'ob2'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>, <span class="number">60</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">values = raw.values</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">print(data)</span></pre></td></tr></table></figure>
<p>运行样例，将会得到经过重新构造后的数据。数据显示了分别处于同一个时间的两组变量作为输入组以及输出组。</p>
<p>与之前一样，根据问题的需要，可以将列分入 *X* 和 *y* 两个子集中，需要注意的是如果放入了 *var1* 做为观察组，那就要放入 *var2* 作为待预测组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var2(t-1)  var1(t)  var2(t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1        0.0       50.0        1       51</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2        1.0       51.0        2       52</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3        2.0       52.0        3       53</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4        3.0       53.0        4       54</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5        4.0       54.0        5       55</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6        5.0       55.0        6       56</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">7        6.0       56.0        7       57</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">8        7.0       57.0        8       58</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">9        8.0       58.0        9       59</span></pre></td></tr></table></figure>
<p>可以看到，通过上面这样给定输入序列和输出序列的数量生成的新的序列，可以帮助你轻松地完成多元时间序列的预测。</p>
<p>例如，下面将把 1 作为输入列数量，将 2 作为输出列（预测列）数量，重新构造预测序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> concat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">series_to_supervised</span><span class="params">(data, n_in=<span class="number">1</span>, n_out=<span class="number">1</span>, dropnan=True)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  函数用途：将时间序列转化为监督学习数据集。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  参数说明：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">    data: 观察值序列，数据类型可以是 list 或者 NumPy array。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_in: 作为输入值(X)的滞后组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">    n_out: 作为输出值(y)的观察组的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">    dropnan: Boolean 值，确定是否将包含 NaN 的行移除。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  返回值:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">    经过转换的用于监督学习的 Pandas DataFrame 序列。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">  """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  n_vars = <span class="number">1</span> <span class="keyword">if</span> type(data) <span class="keyword">is</span> list <span class="keyword">else</span> data.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  df = DataFrame(data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  cols, names = list(), list()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 输入序列 (t-n, ... t-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n_in, <span class="number">0</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    names += [(<span class="string">'var%d(t-%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 预测序列 (t, t+1, ... t+n)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n_out):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cols.append(df.shift(-i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t)'</span> % (j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      names += [(<span class="string">'var%d(t+%d)'</span> % (j+<span class="number">1</span>, i)) <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vars)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 将所有列拼合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  agg = concat(cols, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  agg.columns = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment"># drop 掉包含 NaN 的行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> dropnan:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    agg.dropna(inplace=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> agg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">raw = DataFrame()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">raw[<span class="string">'ob1'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">raw[<span class="string">'ob2'</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>, <span class="number">60</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">values = raw.values</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">data = series_to_supervised(values, <span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">print(data)</span></pre></td></tr></table></figure>
<p>运行样例，将会展示重新构造的很大的 DataFrame。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   var1(t-1)  var2(t-1)  var1(t)  var2(t)  var1(t+1)  var2(t+1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1        0.0       50.0        1       51        2.0       52.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2        1.0       51.0        2       52        3.0       53.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3        2.0       52.0        3       53        4.0       54.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4        3.0       53.0        4       54        5.0       55.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">5        4.0       54.0        5       55        6.0       56.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">6        5.0       55.0        6       56        7.0       57.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">7        6.0       56.0        7       57        8.0       58.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">8        7.0       57.0        8       58        9.0       59.0</span></pre></td></tr></table></figure>
<p>你可以用你自己的数据集多做几次实验，来试试哪种重构的效果更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇教程中，你已经了解了如何使用 Python 将时间序列数据集转换为监督学习问题。</p>
<p>特别的，你了解了：</p>
<ul>
<li>有关 Pandas *shift()* 函数的知识，以及它如何自动将时间序列数据转化为监督学习数据集。</li>
<li>如何将一元时间序列重构成单步或多步监督学习问题。</li>
<li>如何将多元时间序列重构成单步或多步监督学习问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="default">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/21/%E4%BD%BF%E7%94%A8-Python-spaCy-%E8%BF%9B%E8%A1%8C%E7%AE%80%E6%98%93%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/21/%E4%BD%BF%E7%94%A8-Python-spaCy-%E8%BF%9B%E8%A1%8C%E7%AE%80%E6%98%93%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">使用 Python+spaCy 进行简易自然语言处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-21 22:35:00" itemprop="dateCreated datePublished" datetime="2017-07-21T22:35:00+08:00">2017-07-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translate/" itemprop="url" rel="index">
                    <span itemprop="name">Translate</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自然语言处理（NLP）是人工智能领域最重要的部分之一。它在许多智能应用中担任了关键的角色，例如聊天机器人、正文提取、多语翻译以及观点识别等应用。业界 NLP 相关的公司都意识到了，处理非结构文本数据时，不仅要看正确率，还需要注意是否能快速得到想要的结果。</p>
<p>NLP 是一个很宽泛的领域，它包括了文本分类、实体识别、机器翻译、问答系统、概念识别等子领域。在我最近的一篇<a href="https://www.analyticsvidhya.com/blog/2017/01/ultimate-guide-to-understand-implement-natural-language-processing-codes-in-python/" target="_blank" rel="noopener">文章</a>中，我探讨了许多用于实现 NLP 的工具与组件。在那篇文章中，我更多的是在描述<a href="http://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>（Natural Language Toolkit）这个伟大的库。</p>
<p>在这篇文章中，我会将 spaCy —— 这个现在最强大、最先进的 NLP python 库分享给你们。</p>
<hr>
<h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><ol>
<li>spaCy 简介及安装方法</li>
<li><p>spaCy 的管道与属性</p>
<ul>
<li>Tokenization</li>
<li>词性标注</li>
<li>实体识别</li>
<li>依存句法分析</li>
<li>名词短语</li>
</ul>
</li>
<li><p>集成词向量计算</p>
</li>
<li>使用 spaCy 进行机器学习</li>
<li>与 NLTK 和 CoreNLP 对比</li>
</ol>
<hr>
<h2 id="1-spaCy-简介及安装方法"><a href="#1-spaCy-简介及安装方法" class="headerlink" title="1. spaCy 简介及安装方法"></a>1. spaCy 简介及安装方法</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>spaCy 由 cython（Python 的 C 语言拓展，旨在让 python 程序达到如同 C 程序一样的性能）编写，因此它的运行效率非常高。spaCy 提供了一系列简洁的 API 方便用户使用，并基于已经训练好的机器学习与深度学习模型实现底层。</p>
<hr>
<h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>spaCy 及其数据和模型可以通过 pip 和安装工具轻松地完成安装。使用下面的命令在电脑中安装 spaCy：</p>
<pre><code>sudo pip install spacy
</code></pre><p>如果你使用的是 Python3，请用 “pip3” 代替 “pip”。</p>
<p>或者你也可以在 <a href="https://pypi.python.org/pypi/spacy" target="_blank" rel="noopener">这儿</a> 下载源码，解压后运行下面的命令安装：</p>
<pre><code>python setup.py install
</code></pre><p>在安装好 spacy 之后，请运行下面的命令以下载所有的数据集和模型：</p>
<pre><code>python -m spacy.en.download all
</code></pre><p>一切就绪，现在你可以自由探索、使用 spacy 了。</p>
<h2 id="2-spaCy-的管道（Pipeline）与属性（Properties）"><a href="#2-spaCy-的管道（Pipeline）与属性（Properties）" class="headerlink" title="2. spaCy 的管道（Pipeline）与属性（Properties）"></a>2. spaCy 的管道（Pipeline）与属性（Properties）</h2><p>spaCy 的使用，以及其各种属性，是通过创建管道实现的。在加载模型的时候，spaCy 会将管道创建好。在 spaCy 包中，提供了各种各样的<a href="https://github.com/explosion/spacy-models/" target="_blank" rel="noopener">模块</a>，这些模块中包含了各种关于词汇、训练向量、语法和实体等用于语言处理的信息。</p>
<p>下面，我们会加载默认的模块（english-core-web 模块）。</p>
<pre><code>import spacy
nlp = spacy.load(“en”)
</code></pre><p>“nlp” 对象用于创建 document、获得 linguistic annotation 及其它的 nlp 属性。首先我们要创建一个 document，将文本数据加载进管道中。我使用了来自猫途鹰网的旅店评论数据。这个数据文件可以在<a href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2017/04/04080929/Tripadvisor_hotelreviews_Shivambansal.txt" target="_blank" rel="noopener">这儿</a>下载。</p>
<pre><code>document = unicode(open(filename).read().decode(&#39;utf8&#39;))
document = nlp(document)
</code></pre><p>这个 document 现在是 spacy.english 模型的一个 class，并关联上了许多的属性。可以使用下面的命令列出所有 document（或 token）的属性：</p>
<pre><code>dir(document)
&gt;&gt; [ &#39;doc&#39;, &#39;ents&#39;, … &#39;mem&#39;]
</code></pre><p>它会输出 document 中各种各样的属性，例如：token、token 的 index、词性标注、实体、向量、情感、单词等。下面让我们会对其中的一些属性进行一番探究。</p>
<h3 id="2-1-Tokenization"><a href="#2-1-Tokenization" class="headerlink" title="2.1 Tokenization"></a>2.1 Tokenization</h3><p>spaCy 的 document 可以在 tokenized 过程中被分割成单句，这些单句还可以进一步分割成单词。你可以通过遍历文档来读取这些单词：</p>
<pre><code># document 的首个单词
document[0]
&gt;&gt; Nice

# document 的最后一个单词  
document[len(document)-5]
&gt;&gt; boston

# 列出 document 中的句子
list(document.sents)
&gt;&gt; [ Nice place Better than some reviews give it credit for.,
 Overall, the rooms were a bit small but nice.,
...
Everything was clean, the view was wonderful and it is very well located (the Prudential Center makes shopping and eating easy and the T is nearby for jaunts out and about the city).]
</code></pre><h3 id="2-2-词性标注-POS-Tag"><a href="#2-2-词性标注-POS-Tag" class="headerlink" title="2.2 词性标注(POS Tag)"></a>2.2 词性标注(POS Tag)</h3><p>词性标注即标注语法正确的句子中的词语的词性。这些标注可以用于信息过滤、统计模型，或者基于某些规则进行文本解析。</p>
<p>来看看我们的 document 中所有的词性标注：</p>
<pre><code># 获得所有标注
all_tags = {w.pos: w.pos_ for w in document}
&gt;&gt; {97:  u&#39;SYM&#39;, 98: u&#39;VERB&#39;, 99: u&#39;X&#39;, 101: u&#39;SPACE&#39;, 82: u&#39;ADJ&#39;, 83: u&#39;ADP&#39;, 84: u&#39;ADV&#39;, 87: u&#39;CCONJ&#39;, 88: u&#39;DET&#39;, 89: u&#39;INTJ&#39;, 90: u&#39;NOUN&#39;, 91: u&#39;NUM&#39;, 92: u&#39;PART&#39;, 93: u&#39;PRON&#39;, 94: u&#39;PROPN&#39;, 95: u&#39;PUNCT&#39;}

# document 中第一个句子的词性标注
for word in list(document.sents)[0]:  
    print word, word.tag_
&gt;&gt; ( Nice, u&#39;JJ&#39;) (place, u&#39;NN&#39;) (Better, u&#39;NNP&#39;) (than, u&#39;IN&#39;) (some, u&#39;DT&#39;) (reviews, u&#39;NNS&#39;) (give, u&#39;VBP&#39;) (it, u&#39;PRP&#39;) (creit, u&#39;NN&#39;) (for, u&#39;IN&#39;) (., u&#39;.&#39;)
</code></pre><p>来看一看 document 中的最常用词汇。我已经事先写好了预处理和文本数据清洗的函数。</p>
<pre><code>#一些参数定义
noisy_pos_tags = [“PROP”]
min_token_length = 2

#检查 token 是不是噪音的函数
def isNoise(token):     
    is_noise = False
    if token.pos_ in noisy_pos_tags:
        is_noise = True
    elif token.is_stop == True:
        is_noise = True
    elif len(token.string) &lt;= min_token_length:
        is_noise = True
    return is_noise
def cleanup(token, lower = True):
    if lower:
       token = token.lower()
    return token.strip()

# 评论中最常用的单词
from collections import Counter
cleaned_list = [cleanup(word.string) for word in document if not isNoise(word)]
Counter(cleaned_list) .most_common(5)
&gt;&gt; [( u&#39;hotel&#39;, 683), (u&#39;room&#39;, 652), (u&#39;great&#39;, 300),  (u&#39;sheraton&#39;, 285), (u&#39;location&#39;, 271)]
</code></pre><h3 id="2-3-实体识别"><a href="#2-3-实体识别" class="headerlink" title="2.3 实体识别"></a>2.3 实体识别</h3><p>spaCy 拥有一个快速实体识别模型，这个实体识别模型能够从 document 中找出实体短语。它能识别各种类型的实体，例如人名、位置、机构、日期、数字等。你可以通过“.ents”属性来读取这些实体。</p>
<p>下面让我们来获取我们 document 中所有类型的命名实体：</p>
<pre><code>labels = set([w.label_ for w in document.ents])
for label in labels:
    entities = [cleanup(e.string, lower=False) for e in document.ents if label==e.label_]
    entities = list(set(entities))
    print label,entities
</code></pre><h3 id="2-4-依存句法分析"><a href="#2-4-依存句法分析" class="headerlink" title="2.4 依存句法分析"></a>2.4 依存句法分析</h3><p>spaCy 最强大的功能之一就是它可以通过调用轻量级的 API 来实现又快又准确的依存分析。这个分析器也可以用于句子边界检测以及区分短语块。依存关系可以通过“.children”、“.root”、“.ancestor”等属性读取。</p>
<pre><code># 取出所有句中包含“hotel”单词的评论
hotel = [sent for sent in document.sents if &#39;hotel&#39; in sent.string.lower()]

# 创建依存树
sentence = hotel[2] for word in sentence:
print word, &#39;: &#39;, str(list(word.children))
&gt;&gt; A :  []  cab :  [A, from]
from :  [airport, to]
the :  []
airport :  [the]
to :  [hotel]
the :  [] hotel :  
[the] can :  []
be :  [cab, can, cheaper, .]
cheaper :  [than] than :  
[shuttles]
the :  []
shuttles :  [the, depending]
depending :  [time] what :  []
time :  [what, of] of :  [day]
the :  [] day :  
[the, go] you :  
[]
go :  [you]
. :  []
</code></pre><p>解析所有居中包含“hotel”单词的句子的依存关系，并检查对于 hotel 人们用了哪些形容词。我创建了一个自定义函数，用于分析依存关系并进行相关的词性标注。</p>
<pre><code># 检查修饰某个单词的所有形容词
def pos_words (sentence, token, ptag):
    sentences = [sent for sent in sentence.sents if token in sent.string]     
    pwrds = []
    for sent in sentences:
        for word in sent:
            if character in word.string:
                   pwrds.extend([child.string.strip() for child in word.children
                                                      if child.pos_ == ptag] )
    return Counter(pwrds).most_common(10)

pos_words(document, &#39;hotel&#39;, “ADJ”)
&gt;&gt; [(u&#39;other&#39;, 20), (u&#39;great&#39;, 10), (u&#39;good&#39;, 7), (u&#39;better&#39;, 6), (u&#39;nice&#39;, 6), (u&#39;different&#39;, 5), (u&#39;many&#39;, 5), (u&#39;best&#39;, 4), (u&#39;my&#39;, 4), (u&#39;wonderful&#39;, 3)]
</code></pre><h3 id="2-5-名词短语（NP）"><a href="#2-5-名词短语（NP）" class="headerlink" title="2.5 名词短语（NP）"></a>2.5 名词短语（NP）</h3><p>依存树也可以用来生成名词短语：</p>
<pre><code># 生成名词短语
doc = nlp(u&#39;I love data science on analytics vidhya&#39;)
for np in doc.noun_chunks:
    print np.text, np.root.dep_, np.root.head.text
&gt;&gt; I nsubj love
   data science dobj love
   analytics pobj on
</code></pre><h2 id="3-集成词向量"><a href="#3-集成词向量" class="headerlink" title="3. 集成词向量"></a>3. 集成词向量</h2><p>spaCy 提供了内置整合的向量值算法，这些向量值可以反映词中的真正表达信息。它使用 <a href="https://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">GloVe</a> 来生成向量。GloVe 是一种用于获取表示单词的向量的无监督学习算法。</p>
<p>让我们创建一些词向量，然后对其做一些有趣的操作吧：</p>
<pre><code>from numpy import dot
from numpy.linalg import norm
from spacy.en import English
parser = English()

# 生成“apple”的词向量 
apple = parser.vocab[u&#39;apple&#39;]

# 余弦相似性计算函数
cosine = lambda v1, v2: dot(v1, v2) / (norm(v1) * norm(v2))
others = list({w for w in parser.vocab if w.has_vector and w.orth_.islower() and w.lower_ != unicode(&quot;apple&quot;)})

# 根据相似性值进行排序
others.sort(key=lambda w: cosine(w.vector, apple.vector))
others.reverse()


print &quot;top most similar words to apple:&quot;
for word in others[:10]:
    print word.orth_
&gt;&gt; apples iphone f ruit juice cherry lemon banana pie mac orange
</code></pre><h2 id="4-使用-spaCy-对文本进行机器学习"><a href="#4-使用-spaCy-对文本进行机器学习" class="headerlink" title="4. 使用 spaCy 对文本进行机器学习"></a>4. 使用 spaCy 对文本进行机器学习</h2><p>将 spaCy 集成进机器学习模型是非常简单、直接的。让我们使用 sklearn 做一个自定义的文本分类器。我们将使用 cleaner、tokenizer、vectorizer、classifier 组件来创建一个 sklearn 管道。其中的 tokenizer 和 vectorizer 会使用我们用 spaCy 自定义的模块构建。</p>
<pre><code>from sklearn.feature_extraction.stop_words import ENGLISH_STOP_WORDS as stopwords
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics import accuracy_score
from sklearn.base import TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.svm import LinearSVC

import string
punctuations = string.punctuation

from spacy.en import English
parser = English()

# 使用 spaCy 自定义 transformer
class predictors(TransformerMixin):
    def transform(self, X, **transform_params):
        return [clean_text(text) for text in X]
    def fit(self, X, y=None, **fit_params):
        return self
    def get_params(self, deep=True):
        return {}

# 进行文本清洗的实用的基本函数
def clean_text(text):     
    return text.strip().lower()
</code></pre><p>现在让我们使用 spaCy 的解析器和一些基本的数据清洗函数来创建一个自定义的 tokenizer 函数。值得一提的是，你可以用词向量来代替文本特征（使用深度学习模型效果会有较大的提升）</p>
<pre><code>#创建 spaCy tokenizer，解析句子并生成 token
#也可以用词向量函数来代替它
def spacy_tokenizer(sentence):
    tokens = parser(sentence)
    tokens = [tok.lemma_.lower().strip() if tok.lemma_ != &quot;-PRON-&quot; else tok.lower_ for tok in tokens]
    tokens = [tok for tok in tokens if (tok not in stopwords and tok not in punctuations)]     return tokens

#创建 vectorizer 对象，生成特征向量，以此可以自定义 spaCy 的 tokenizer
vectorizer = CountVectorizer(tokenizer = spacy_tokenizer, ngram_range=(1,1)) classifier = LinearSVC()
</code></pre><p>现在可以创建管道，加载数据，然后运行分类模型了。</p>
<pre><code># 创建管道，进行文本清洗、tokenize、向量化、分类操作
pipe = Pipeline([(&quot;cleaner&quot;, predictors()),
                 (&#39;vectorizer&#39;, vectorizer),
                 (&#39;classifier&#39;, classifier)])

# Load sample data
train = [(&#39;I love this sandwich.&#39;, &#39;pos&#39;),          
         (&#39;this is an amazing place!&#39;, &#39;pos&#39;),
         (&#39;I feel very good about these beers.&#39;, &#39;pos&#39;),
         (&#39;this is my best work.&#39;, &#39;pos&#39;),
         (&quot;what an awesome view&quot;, &#39;pos&#39;),
         (&#39;I do not like this restaurant&#39;, &#39;neg&#39;),
         (&#39;I am tired of this stuff.&#39;, &#39;neg&#39;),
         (&quot;I can&#39;t deal with this&quot;, &#39;neg&#39;),
         (&#39;he is my sworn enemy!&#39;, &#39;neg&#39;),          
         (&#39;my boss is horrible.&#39;, &#39;neg&#39;)]
test =   [(&#39;the beer was good.&#39;, &#39;pos&#39;),     
         (&#39;I do not enjoy my job&#39;, &#39;neg&#39;),
         (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;),
         (&quot;I feel amazing!&quot;, &#39;pos&#39;),
         (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;),
         (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;)]

# 创建模型并计算准确率
pipe.fit([x[0] for x in train], [x[1] for x in train])
pred_data = pipe.predict([x[0] for x in test])
for (sample, pred) in zip(test, pred_data):
    print sample, pred
print &quot;Accuracy:&quot;, accuracy_score([x[1] for x in test], pred_data)

&gt;&gt;    (&#39;the beer was good.&#39;, &#39;pos&#39;) pos
      (&#39;I do not enjoy my job&#39;, &#39;neg&#39;) neg
      (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;) neg
      (&#39;I feel amazing!&#39;, &#39;pos&#39;) pos
      (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;) pos
      (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;) neg
      Accuracy: 1.0
</code></pre><h2 id="5-和其它库的对比"><a href="#5-和其它库的对比" class="headerlink" title="5. 和其它库的对比"></a>5. 和其它库的对比</h2><p>Spacy 是一个非常强大且具备工业级能力的 NLP 包，它能满足大多数 NLP 任务的需求。可能你会思考：为什么会这样呢？</p>
<p>让我们把 Spacy 和另外两个 python 中有名的实现 NLP 的工具 —— CoreNLP 和 NLTK 进行对比吧！</p>
<h3 id="支持功能表"><a href="#支持功能表" class="headerlink" title="支持功能表"></a>支持功能表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>Spacy</th>
<th>NLTK</th>
<th>Core NLP</th>
</tr>
</thead>
<tbody>
<tr>
<td>简易的安装方式</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Python API</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>多语种支持</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>分词</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>词性标注</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>分句</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>依存性分析</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>实体识别</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>词向量计算集成</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>情感分析</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>共指消解</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
</div>
<h3 id="速度：主要功能（Tokenizer、Tagging、Parsing）速度"><a href="#速度：主要功能（Tokenizer、Tagging、Parsing）速度" class="headerlink" title="速度：主要功能（Tokenizer、Tagging、Parsing）速度"></a>速度：主要功能（Tokenizer、Tagging、Parsing）速度</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>库</strong></th>
<th><strong>Tokenizer</strong></th>
<th><strong>Tagging</strong></th>
<th><strong>Parsing</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>spaCy</td>
<td>0.2ms</td>
<td>1ms</td>
<td>19ms</td>
</tr>
<tr>
<td>CoreNLP</td>
<td>2ms</td>
<td>10ms</td>
<td>49ms</td>
</tr>
<tr>
<td>NLTK</td>
<td>4ms</td>
<td>443ms</td>
<td>–</td>
</tr>
</tbody>
</table>
</div>
<h3 id="准确性：实体抽取结果"><a href="#准确性：实体抽取结果" class="headerlink" title="准确性：实体抽取结果"></a>准确性：实体抽取结果</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>库</strong></th>
<th><strong>准确率</strong></th>
<th><strong>Recall</strong></th>
<th><strong>F-Score</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>spaCy</td>
<td>0.72</td>
<td>0.65</td>
<td>0.69</td>
</tr>
<tr>
<td>CoreNLP</td>
<td>0.79</td>
<td>0.73</td>
<td>0.76</td>
</tr>
<tr>
<td>NLTK</td>
<td>0.51</td>
<td>0.65</td>
<td>0.58</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文讨论了 spaCy —— 这个基于 python，完全用于实现 NLP 的库。我们通过许多用例展示了 spaCy 的可用性、速度及准确性。最后我们还将其余其它几个著名的 NLP 库 —— CoreNLP 与 NLTK 进行了对比。</p>
<p>如果你能真正理解这篇文章要表达的内容，那你一定可以去实现各种有挑战的文本数据与 NLP 问题。</p>
<p>希望你能喜欢这篇文章，如果你有疑问、问题或者别的想法，请在评论中留言。</p>
<p>作者介绍：</p>
<p><a href="https://www.analyticsvidhya.com/blog/author/shivam5992/" target="_blank" rel="noopener">Shivam Bansal</a></p>
<p>Shivam Bansal 是一位数据科学家，在 NLP 与机器学习领域有着丰富的经验。他乐于学习，希望能解决一些富有挑战性的分析类问题。</p>
<ul>
<li><a href="https://twitter.com/shivamshaz" target="_blank" rel="noopener">https://twitter.com/shivamshaz</a></li>
<li><a href="https://www.linkedin.com/in/shivambansal1" target="_blank" rel="noopener">https://www.linkedin.com/in/shivambansal1</a></li>
<li><a href="https://github.com/shivam5992" target="_blank" rel="noopener">https://github.com/shivam5992</a></li>
</ul>
<blockquote>
<p>发布于掘金 <a href="https://juejin.im/post/5971a4b9f265da6c42353332" target="_blank" rel="noopener">https://juejin.im/post/5971a4b9f265da6c42353332</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lsvih</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">199</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lsvih" title="GitHub → https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lsvih@qq.com" title="E-Mail → mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备18029472号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsvih</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
