<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lsvih.com","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"algolia":{"appID":"6U6P1RGK4F","apiKey":"b14e73cdd627eabe947b5decbe14850f","indexName":"lsvih","hits":{"per_page":10}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="My note">
<meta property="og:url" content="https://lsvih.com/page/6/index.html">
<meta property="og:site_name" content="My note">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="lsvih">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lsvih.com/page/6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>My note - lsvih</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142893470-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-142893470-1');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">My note</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lsvih</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="https://cv.lsvih.com/" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lsvih</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">205</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lsvih" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lsvih" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lsvih@qq.com" title="E-Mail → mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/11/29/bash-%E6%89%B9%E9%87%8F%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/29/bash-%E6%89%B9%E9%87%8F%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">bash 批量查找替换文件内容</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-29 10:27:04" itemprop="dateCreated datePublished" datetime="2017-11-29T10:27:04+08:00">2017-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tool/" itemprop="url" rel="index"><span itemprop="name">Tool</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rl <span class="string">&quot;192.168.1.1&quot;</span> |xargs -i sed -i <span class="string">&#x27;s/192.168.1.1/192.168.1.2/g&#x27;</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>将目录下所有文件的192.168.1.1替换成192.168.1.2</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/11/12/%E5%89%8D%E7%AB%AF-Console-%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/12/%E5%89%8D%E7%AB%AF-Console-%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">前端 Console 调试小技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-12 16:41:00" itemprop="dateCreated datePublished" datetime="2017-11-12T16:41:00+08:00">2017-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/pasted-263.png" alt="upload successful"></p>
<p>开发者们在开发的过程中会无意地产生一些 bug。bug 越老，找到并修复它的难度就越高。在本系列的文章中，我将试着向你展示如何使用 Google Chrome 开发者工具、Chrome 插件以及 WebStorm 进行调试。</p>
<p>这篇文章将介绍最常用的调试工具 —— Chrome Console。请享用！</p>
<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>打开 Chrome 开发者工具的方法：</p>
<ul>
<li>在主菜单中选择“更多工具”菜单 &gt; 点击开发者工具。</li>
<li>在页面任何元素上右键，选择“检查”。</li>
<li>在 Mac 中，按下 Command+Option+I；在 Windows 与 Linux 中，按下 Ctrl+Shift+I。</li>
</ul>
<p>请观察 Console 选项卡中的内容。</p>
<p><img src="/images/pasted-264.png" alt="upload successful"></p>
<p>第一行：</p>
<p><img src="/images/pasted-265.png" alt="upload successful"></p>
<ul>
<li>清空 console 控制台</li>
</ul>
<p><code>top</code> — 在默认状态下，Console 的上下文（context）为 top（顶级）。不过当你检查元素或使用 Chrome 插件上下文时，它会发生变化。<br>你可以在此更改 console 执行的上下文（页面的顶级 frame）。</p>
<p><strong>过滤：</strong><br>对控制台的输出进行过滤。你可以根据输出严重级别、正则表达式对其进行过滤，也可以在此隐藏网络连接产生的消息。</p>
<p><strong>设置：</strong><br><code>Hide network</code> — 隐藏诸如 404 之类的网络错误。<br><code>Preserve log</code> — 控制台将会在页面刷新或者跳转时不清空记录。<br><code>Selected context only</code> — 勾上后可以根据前面 top 选择的上下文来指定控制台的日志记录范围。<br><code>User messages only</code> — 隐藏浏览器产生的访问异常之类的警告。<br><code>Log XMLHttpRequests</code> — 顾名思义，记录 XMLHttpRequest 产生的信息。<br><code>Show timestamps</code> — 在控制台中显示时间戳信息。<br><code>Autocomplete from history</code> — Chrome 会记录你曾经输入过的命令，进行自动补全。</p>
<h3 id="选择合适的-Console-API"><a href="#选择合适的-Console-API" class="headerlink" title="选择合适的 Console API"></a>选择合适的 Console API</h3><p>控制台会在你应用的上下文中运行你输入的 JS 代码。你可以轻松地通过控制台查看全局作用域中存储的东西，也可以直接输入并查看表达式的结果。例如：“null === 0”。</p>
<h4 id="console-log-—-对象引用"><a href="#console-log-—-对象引用" class="headerlink" title="console.log — 对象引用"></a>console.log — 对象引用</h4><p>根据定义，console.log 将会在控制台中打印输出内容。除此之外，你还得知道，console.log 会对你展示的对象保持引用关系。请看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [&#123;<span class="attr">one</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">two</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">three</span>: <span class="number">3</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits before modification: &#x27;</span>, fruits);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits before modification - stringed: &#x27;</span>, <span class="built_in">JSON</span>.stringify(fruits));</span><br><span class="line">fruits.splice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits after modification: &#x27;</span>, fruits);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits after modification - stringed : &#x27;</span>, <span class="built_in">JSON</span>.stringify(fruits))</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-266.png" alt="upload successful"></p>
<p>当调试对象或数组时，你需要注意这点。我们可以看到 <code>fruits</code> 数组再被修改前包含 3 个对象，但之后发生了变化。如需要在特定时刻查看结果，可以使用 <code>JSON.stringify</code> 来展示信息。不过这种方法对于展示大对象来说并不方便。之后我们会介绍更好的解决方案。</p>
<h4 id="console-log-—-对对象属性进行排序"><a href="#console-log-—-对对象属性进行排序" class="headerlink" title="console.log — 对对象属性进行排序"></a>console.log — 对对象属性进行排序</h4><p>JavaScript 是否能保证对象属性的顺序呢？</p>
<blockquote>
<p>4.3.3 Object — ECMAScript 第三版 (1999)</p>
<p>对象是 Object 的成员，它是一组无序属性的集合，每个属性都包含一个原始值、对象或函数。称存储在对象属性中的函数为方法。</p>
</blockquote>
<p>但是…… 在 ES5 中它的定义发生了改变，属性可以有序 —— 但你还是不能确定你的对象属性是否能按顺序排列。浏览器通过各种方法实现了有序属性。在 Chrome 中运行下面的代码，可以看到令人困惑的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = &#123;</span><br><span class="line">  z: <span class="number">1</span>,</span><br><span class="line">  t: <span class="number">2</span>,</span><br><span class="line">  k: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits&#x27;</span>, letters);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;fruits - stringify&#x27;</span>, <span class="built_in">JSON</span>.stringify(letters));</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-267.png" alt="upload successful"></p>
<p>Chrome 按照字母表的顺序对属性进行了排序。没法说我们是否应该喜欢这种排序方式，但了解这儿发生了什么总没坏处。</p>
<h4 id="console-assert-expression-message"><a href="#console-assert-expression-message" class="headerlink" title="console.assert(expression, message)"></a>console.assert(expression, message)</h4><p>如果 expression 表达式的结果为 <code>false</code>，<code>Console.assert</code> 将会抛出错误。关键的是，assert 函数不会由于报错而停止评估之后的代码。它可以帮助你调试冗长棘手的代码，或者找到多次迭代后函数自身产生的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAssert</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.assert(a === b, <span class="string">&#x27;message: a !== b ***** a: &#x27;</span> + a +<span class="string">&#x27; b:&#x27;</span> +b);</span><br><span class="line">&#125;</span><br><span class="line">callAssert(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">callAssert(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-268.png" alt="upload successful"></p>
<h4 id="console-count-label"><a href="#console-count-label" class="headerlink" title="console.count(label)"></a>console.count(label)</h4><p>简而言之，它就是一个会计算相同表达式执行过多少次的 <code>console.log</code>。其它的都一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.count(i + <span class="string">&#x27; Can I go with you?&#x27;</span>);</span><br><span class="line">	<span class="built_in">console</span>.count(<span class="string">&#x27;No, no this time&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-269.png" alt="upload successful"></p>
<p>如上面的例子所述，只有完全相同的表达式才会增加统计数字。</p>
<h4 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h4><p>很好用的调试函数，但即使它会提高工作效率，我也一般懒得用它…… 别像我这样，咱要保持高效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="attr">like</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;pear&#x27;</span>, <span class="attr">like</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;plum&#x27;</span>, <span class="attr">like</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.table(fruits);</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-270.png" alt="upload successful"></p>
<p>它非常棒。第一，你可以将所有东西都整齐地放在表格中；第二，你也会得到 <code>console.log</code> 的结果。它在 Chrome 中可以正常工作，但是不保证兼容所有浏览器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="attr">like</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;pear&#x27;</span>, <span class="attr">like</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;plum&#x27;</span>, <span class="attr">like</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.table(fruits, [<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-271.png" alt="upload successful"></p>
<p>我们可以决定是完全展示数据内容还是只展示整个对象的某几列。这个表格是可排序的 —— 点击需要排序的列的表头，即可按此列对表格进行排序。</p>
<h4 id="console-group-console-groupEnd"><a href="#console-group-console-groupEnd" class="headerlink" title="console.group() / console.groupEnd();"></a>console.group() / console.groupEnd();</h4><p>这次让我们直接从代码开始介绍。运行下面的代码看看控制台是如何进行分组的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;iteration&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> firstLevel = <span class="number">0</span>; firstLevel&lt;<span class="number">2</span>; firstLevel++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.group(<span class="string">&#x27;First level: &#x27;</span>, firstLevel);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> secondLevel = <span class="number">0</span>; secondLevel&lt;<span class="number">2</span>; secondLevel++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.group(<span class="string">&#x27;Second level: &#x27;</span>, secondLevel);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> thirdLevel = <span class="number">0</span>; thirdLevel&lt;<span class="number">2</span>; thirdLevel++)&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">&#x27;This is third level number: &#x27;</span>, thirdLevel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.groupEnd();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.groupEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-272.png" alt="upload successful"></p>
<p>它可以帮助你更好的处理数据。</p>
<h4 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace();"></a>console.trace();</h4><p>console.trace 会将调用栈打印在控制台中。如果你正在构建库或框架时，它给出的信息将十分有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line">func1();</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-274.png" alt="upload successful"></p>
<h4 id="对比-console-log-与-console-dir"><a href="#对比-console-log-与-console-dir" class="headerlink" title="对比 console.log 与 console.dir"></a>对比 console.log 与 console.dir</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.dir([<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-275.png" alt="upload successful"></p>
<p>它们的实现方式取决于浏览器。在最开始的时候，规范中建议 dir 要保持对对象的引用，而 log 不需要引用。（Log 会显示一个对象的副本）。但现在，如上图所示，log 也保持了对于对象的引用。它们展示对象的方式有所不同，但我们不再加以深究。不过 dir 在调试 HTML 对象的时候会非常有用。</p>
<blockquote>
<p>译注：console.dir 会详细打印一个对象的所有属性与方法。</p>
</blockquote>
<h4 id="0-—-4"><a href="#0-—-4" class="headerlink" title="$_, $0 — $4"></a>$_, $0 — $4</h4><p><code>$_</code> 会返回最近执行表达式的值。<br><code>$0 — $4</code> — 分别作为近 5 此检查元素时对 HTML 元素的引用。</p>
<p><img src="/images/pasted-276.png" alt="upload successful"></p>
<h4 id="getEventListeners-object"><a href="#getEventListeners-object" class="headerlink" title="getEventListeners(object)"></a>getEventListeners(object)</h4><p>返回指定 DOM 元素上注册的事件监听器。这儿还有一种更便捷的方法来设置事件监听，下次教程会介绍它。</p>
<p><img src="/images/pasted-277.png" alt="upload successful"></p>
<h3 id="monitorEvents-DOMElement-events-unmonitorEvents-DOMElement"><a href="#monitorEvents-DOMElement-events-unmonitorEvents-DOMElement" class="headerlink" title="monitorEvents(DOMElement, [events]) / unmonitorEvents(DOMElement)"></a>monitorEvents(DOMElement, [events]) / unmonitorEvents(DOMElement)</h3><p>在指定 DOM 元素上触发任何事件时，都可以在控制台中看到相关信息。直到取消对相应元素的监视。</p>
<p><img src="/images/pasted-278.png" alt="upload successful"></p>
<h3 id="在控制台中选择元素"><a href="#在控制台中选择元素" class="headerlink" title="在控制台中选择元素"></a>在控制台中选择元素</h3><p><img src="/images/pasted-279.png" alt="upload successful"></p>
<p>在 Element 标签中按 ESC 键展开这个界面。</p>
<p>在 <code>$</code> 没有另做它用的情况下：</p>
<p><code>$()</code> — 相当于 <code>**document.querySelector()**</code>。它会返回匹配 CSS 选择器的第一个元素（例如 <code>$(&#39;span&#39;)</code> 会返回第一个 span）<br><code>$$()</code> — 相当于 <code>**document.querySelectorAll()**</code>。它会以数组的形式返回所有匹配 CSS 选择器的元素。</p>
<h4 id="复制打印的数据"><a href="#复制打印的数据" class="headerlink" title="复制打印的数据"></a>复制打印的数据</h4><p>有时，当你处理数据时可能会想打个草稿，或者简单地看看两个对象是否有区别。全选之后再复制可能会很麻烦，在此介绍一种很方便的方法。</p>
<p>在打印出的对象上点击右键，选择 copy（复制），或选择 Store as global element（将指定元素的引用存储在全局作用域中），然后你就可以在控制台中操作刚才存储的元素啦。</p>
<p>控制台中的任何内容都可以通过使用 <code>copy(&#39;object-name&#39;)</code> 进行复制。</p>
<h4 id="自定义控制台输出样式"><a href="#自定义控制台输出样式" class="headerlink" title="自定义控制台输出样式"></a>自定义控制台输出样式</h4><p>假设你正在开发一个库，或者在为公司、团队开发一个大模块。此时在开发模式下对一些日志进行高亮处理会很舒爽。你可以试试下面的代码：</p>
<p><code>console.log(&#39;%c Truly hackers code! &#39;, &#39;background: #222; color: #bada55&#39;);</code></p>
<p><img src="/images/pasted-280.png" alt="upload successful"></p>
<p><code>%d</code> 或 <code>%i</code> — 整型值<br><code>%f</code> — 浮点值<br><code>%o</code> — 可展开的 DOM 元素<br><code>%O</code> — 可展开的 JS 对象<br><code>%c</code> — 使用 CSS 格式化输出</p>
<p>以上就是本文的全部内容，但并不是 Console 这个话题的全部内容。你可以点击以下链接了解更多有关知识：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference">Command Line API Reference</a> by Google</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Console">Console API</a> by MDN</li>
<li><a target="_blank" rel="noopener" href="http://2ality.com/2013/10/console-api.html">Console API</a> by 2ality</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/pl/docs/Web/CSS/CSS_Selectors">CSS Selectors</a></li>
</ul>
<blockquote>
<p>本文发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/5a08087f6fb9a04529363d71">https://juejin.im/post/5a08087f6fb9a04529363d71</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/11/03/RNN-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/03/RNN-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%85%83/" class="post-title-link" itemprop="url">RNN 循环神经网络系列 5: 自定义单元</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-03 10:23:00" itemprop="dateCreated datePublished" datetime="2017-11-03T10:23:00+08:00">2017-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>本系列文章汇总</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner/blob/master/TODO/recurrent-neural-networks-rnn-part-1-basic-rnn-char-rnn.md">RNN 循环神经网络系列 1：基本 RNN 与 CHAR-RNN</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner/blob/master/TODO/recurrent-neural-networks-rnn-part-2-text-classification.md">RNN 循环神经网络系列 2：文本分类</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner/blob/master/TODO/recurrent-neural-networks-rnn-part-3-encoder-decoder.md">RNN 循环神经网络系列 3：编码、解码器</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner/blob/master/TODO/recurrent-neural-network-rnn-part-4-attentional-interfaces.md">RNN 循环神经网络系列 4：注意力机制</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xitu/gold-miner/blob/master/TODO/recurrent-neural-network-rnn-part-5-custom-cells.md">RNN 循环神经网络系列 5：自定义单元</a></li>
</ol>
<p>在本文中，我们将探索并尝试创建我们自己定义的 RNN 单元。不过在此之前，我们需要先仔细研究简单的 RNN，再逐步深入较为复杂的单元（如 LSTM 与 GRU）。我们会分析这些单元在 tensorflow 中的实现代码，最终参照这些代码来创建我们的自定义单元。本文将援引由 Chris Olah 所著，在 RNN、LSTM 方面非常棒的一篇文章中的图片。在此我强烈推荐你阅读<strong><a target="_blank" rel="noopener" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">这篇文章</a></strong>，本文中会重申其中许多相关内容，不过由于我们主要还是关注 tf 代码，所以这些内容将会较快地略过。将来当我要对 RNN 结构进行层规范化时，我还会引用本文中的代码。之后的文章可以在<strong><a target="_blank" rel="noopener" href="https://theneuralperspective.com/2016/10/27/gradient-topics/">这儿</a></strong>查看。</p>
<h2 id="基本-RNN："><a href="#基本-RNN：" class="headerlink" title="基本 RNN："></a>基本 RNN：</h2><p>对于传统的 RNN 来说，最大的问题就在于每个单元的重复输入都是静态的，因此我们无法充分学习到长期的依赖情况。你回想一下基本 RNN 单元，就会发现所有操作都是单一的 tanh 运算。</p>
<p><img src="/images/pasted-255.png" alt="upload successful"></p>
<p>对于解决短期依赖情况的问题来说，这种结构已经够用了；但如果我们希望通过有效的长期记忆来预测目标，则需要使用更稳定强大的 RNN 单元 —— LSTM。</p>
<h2 id="长短期记忆网络（LSTM）："><a href="#长短期记忆网络（LSTM）：" class="headerlink" title="长短期记忆网络（LSTM）："></a>长短期记忆网络（LSTM）：</h2><p>LSTM 的结构可以让我们在更多的操作中进行长期的信息控制。传统的 RNN 仅有一个输出，其既作为隐藏状态表示也作为此单元的输出端。</p>
<p><img src="/images/pasted-256.png" alt="upload successful"></p>
<p>这种结构缺乏对信息的控制，无法存住对许多步之后有用的信息。而 LSTM 有两种不同的输出。其中一种仍与前面的传统结构一样，既作为隐藏状态表示也作为单元输出；但 LSTM 单元还有另一种输出 - 单元状态 C。这也是 LSTM 精髓所在，让我们仔细研究它。</p>
<p><img src="/images/pasted-257.png" alt="upload successful"></p>
<h3 id="遗忘门："><a href="#遗忘门：" class="headerlink" title="遗忘门："></a>遗忘门：</h3><p>第一个要介绍的门就是遗忘门。这个门可以让我们选择性地传递信息以决定单元的状态。我将公式罗列在下，后面介绍其它的门时也会如此。</p>
<p><img src="/images/pasted-258.png" alt="upload successful"></p>
<p><img src="/images/pasted-259.png" alt="upload successful"></p>
<p>你可以参考类似 tf 的 <a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py#867">_linear</a> 函数来实现它。不过遗忘门的主要要点是对输入与隐藏状态前应用了 sigmoid。那么这个 sigmoid 的作用是什么？请回想一下，sigmoid 会输出在 [0, 1] 范围的值，在此我们将其应用于 [N X H] 的矩阵，因此会得到 NXH 个 sigmoid 算出的值。如果 sigmoid 得到 0 值，那么其对应的隐藏值就会失效；如果 sigmoid 得到 1 值，那么此隐藏值将会被应用在计算中。而处于 0 和 1 之间的值将会允许一部分的信息继续传递。这样就能很好地通过阻塞与选择性地传递输入单元的数据，以达到控制信息的目的。</p>
<p>这就是遗忘门。它是我们的单元得到最终结果前的第一个步骤。下面介绍另一个操作：输入门。</p>
<h3 id="输入门："><a href="#输入门：" class="headerlink" title="输入门："></a>输入门：</h3><p>输入门将获取我们的输入值 X 以及在前面的隐藏状态，并对它们进行两次运算。首先会通过 sigmoid 门来选择性地允许部分数据输入，接着将其与输入值的 tanh 值相乘。</p>
<p><img src="/images/pasted-260.png" alt="upload successful"></p>
<p>这儿的 tanh 与前面的 sigmoid 操作不同。请回忆一下，tanh 会将输入值改变为 [-1, 1] 范围内的值。它本质上通过非线性的方式改变了输入的表示。这一步与我们在基本 RNN 单元中进行的操作一致，不过在此我们将两值的乘积加上遗忘门得到的值得到本单元的状态值。</p>
<p>遗忘门与输入门的操作可以看做同时保存了旧状态（C_{t-1}）的一部分与新变换（tanh）单元状态（C~_t）的一部分。这些权重将会通过我们数据的训练学到需要保存多少数据以及如何进行正确的变换。</p>
<h3 id="输出门："><a href="#输出门：" class="headerlink" title="输出门："></a>输出门：</h3><p>最后一个门是输出门，它利用输入值、前面的隐藏状态值以及新单元状态值来共同决定新隐藏状态的表示。</p>
<p><img src="/images/pasted-261.png" alt="upload successful"></p>
<p>该步骤依旧涉及到了 sigmoid，将它的值与单元状态的 tanh 值相乘以决定信息的去留。需要注意这一步的 tanh 计算与输入门的 tanh 计算不同，此步不再是神经网络的计算，而仅仅是单纯、不带任何权重地计算单元状态值的 tanh 值。这样我们就能强制单元状态矩阵 [NXH] 的值处于 [-1, 1] 的范围内。</p>
<h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h3><p>RNN 单元有许多种变体，在此再次建议去阅读 Chris Olah 的<strong><a target="_blank" rel="noopener" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">这篇博文</a></strong>学习更多相关知识。不过他在文中讨论的是 peehole 模型（在计算 C_{t-1} 或 C_t 时允许所有门都能观察到单元状态值）以及单元状态的 couple（更新与遗忘同时进行）。不过目前 LSTM 的竞争对手是正在被广泛使用的 GRU（Gated Recurrent Unit）。</p>
<h2 id="GRU（Gated-Recurrent-Unit）："><a href="#GRU（Gated-Recurrent-Unit）：" class="headerlink" title="GRU（Gated Recurrent Unit）："></a>GRU（Gated Recurrent Unit）：</h2><p>GRU 的主要原理是将遗忘门与输入门结合成一个更新门。</p>
<p><img src="/images/pasted-262.png" alt="upload successful"></p>
<p>在实际使用中，GRU 的性能与 LSTM 相当，但其计算量更小，因此它现在日益流行。</p>
<h2 id="原生-Tensorflow-实现："><a href="#原生-Tensorflow-实现：" class="headerlink" title="原生 Tensorflow 实现："></a>原生 Tensorflow 实现：</h2><p>我们先观察一下 Tensorflow 官方对于 GRU 单元的实现代码，主要关注其函数调用方式、输入以及输出。然后我们会复制它的结构用于创建我们自己的单元。如果你对其它的单元有兴趣，可以在<strong><a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell.py">这儿</a></strong>找到它们的实现。本文将主要关注 GRU，因为它在大多数情况下性能与 LSTM 相当且复杂度更低。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GRUCell</span>(<span class="params">RNNCell</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;Gated Recurrent Unit cell (cf. http://arxiv.org/abs/1406.1078).&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_units, input_size=None, activation=tanh</span>):</span></span><br><span class="line">    <span class="keyword">if</span> input_size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      logging.warn(<span class="string">&quot;%s: The input_size parameter is deprecated.&quot;</span>, self)</span><br><span class="line">    self._num_units = num_units</span><br><span class="line">    self._activation = activation</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">state_size</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self._num_units</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output_size</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self._num_units</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, inputs, state, scope=None</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Gated recurrent unit (GRU) with nunits cells.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> vs.variable_scope(scope <span class="keyword">or</span> type(self).__name__):  <span class="comment"># &quot;GRUCell&quot;</span></span><br><span class="line">      <span class="keyword">with</span> vs.variable_scope(<span class="string">&quot;Gates&quot;</span>):  <span class="comment"># Reset gate and update gate.</span></span><br><span class="line">        <span class="comment"># We start with bias of 1.0 to not reset and not update.</span></span><br><span class="line">        r, u = array_ops.split(<span class="number">1</span>, <span class="number">2</span>, _linear([inputs, state],</span><br><span class="line">                                             <span class="number">2</span> * self._num_units, <span class="literal">True</span>, <span class="number">1.0</span>))</span><br><span class="line">        r, u = sigmoid(r), sigmoid(u)</span><br><span class="line">      <span class="keyword">with</span> vs.variable_scope(<span class="string">&quot;Candidate&quot;</span>):</span><br><span class="line">        c = self._activation(_linear([inputs, r * state],</span><br><span class="line">                                     self._num_units, <span class="literal">True</span>))</span><br><span class="line">      new_h = u * state + (<span class="number">1</span> - u) * c</span><br><span class="line">    <span class="keyword">return</span> new_h, new_h</span><br></pre></td></tr></table></figure>
<p>GRUCell 类由 <strong>init</strong> 函数开始执行。在 <strong>init</strong> 函数中定义了单元的数量与其使用的激活函数。其激活函数一般是 tanh，不过也可以使用 sigmoid 来使得值固定在 [0, 1] 范围内方便我们控制信息流。另外，它还有两个在调用时会返回 self._num_units 的属性。最后定义了 <strong>call</strong> 函数，它将处理输入值并得出新的隐藏值。回忆一下，GRU 没有类似 LSTM 的单元状态值。</p>
<p>在 <strong>call</strong> 中，我们首先计算 r 和 u（u 是前面图中的 z）。在这步中，我们没有单独去计算它们，而是以乘以 2 倍 num_units 的形式合并了权重，再将结果分割成两份得到它们（split(dim, num_splits, value)）。然后对得到的值应用 sigmoid 激活函数，以选择性地控制信息流。接着计算 c 的值，用它计算新隐藏状态表示值。你可能发现它计算 new_h 的顺序和之前颠倒了，不过由于权重会同时进行训练，因此代码仍能正常运行。</p>
<p>其它的单元代码都与此代码类似，你弄明白了上面的代码就能轻松解释其它单元的代码。</p>
<blockquote>
<p>本文发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/59fbd28b6fb9a045204b91f2">https://juejin.im/post/59fbd28b6fb9a045204b91f2</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/11/03/Spotify-%E6%AF%8F%E5%91%A8%E6%8E%A8%E8%8D%90%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/03/Spotify-%E6%AF%8F%E5%91%A8%E6%8E%A8%E8%8D%90%E5%8A%9F%E8%83%BD%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90/" class="post-title-link" itemprop="url">Spotify 每周推荐功能：基于机器学习的音乐推荐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-11-03 10:16:14" itemprop="dateCreated datePublished" datetime="2017-11-03T10:16:14+08:00">2017-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在每周周一，超过 1 亿位 Spotify 用户会收到一份新鲜的歌曲播放列表。这个自定义列表中包含了 30 首用户从来没听过，但可能会喜欢上的歌曲。这个神奇的功能被称为“每周推荐（Discover Weekly）”。</p>
<p>我是 Spotify 的忠实粉丝，尤其喜欢它的每周推荐功能。因为，它让我感觉到我被<strong>重视</strong>着。它比谁都了解我的音乐品味，而且每周的推荐都<strong>刚好</strong>令我满足。如果没有它，我可能一辈子都找不到一些我非常喜欢的歌曲。</p>
<p>如果你苦于找不到想听的音乐，请让我隆重介绍我最好的虚拟伙伴：</p>
<p><img src="/images/pasted-241.png" alt="upload successful"></p>
<p>事实证明，痴迷于每周推荐的用户不仅只有我一个 —— 许多用户都为它痴狂，这足以让 Spotify 重新思考其发展重点，将更多的资源投入播放列表推荐算法中。</p>
<p>每周推荐功能于 2015 亮相，从那时开始，我就非常渴望了解它是如何运作的（我是他们公司的粉丝，所以常常假设自己在 Spotify 工作并研究他们的产品）。在经过三个星期的疯狂搜索之后，我得以瞟到了其帷幕后的一丝真容。</p>
<p>那么 Spotify 是如何做出每周为每个用户选出 30 首歌这个惊人的工作的呢？让我们先看一看其它一些音乐服务商是如何进行音乐推荐的，然后分析为什么 Spotify 做的更好。</p>
<hr>
<p><img src="/images/pasted-242.png" alt="upload successful"></p>
<p>早在 2000 年，Songza 就开始使用<strong>人工编辑</strong>来进行在线音乐策展（curation，策划并展示）。“人工编辑”意味着需要一些”音乐专家“团队或者其它管理员手动将他们认为很好听的歌放到歌单中去。（后来 Beats Music 也实行了同样的策略）。虽然人工编辑运作的很好，但是它需要手动操作并且过于简单，<strong>无法考虑到每个听众个人音乐品味的差别</strong>。</p>
<p>如 Songza 一样，Pandora 也是音乐策展的元老之一。它采用的方法较为先进，使用<strong>人工标注歌曲属性</strong>的方法。也就是说，有一组人在听歌之后，为每首歌选择一些描述性的词，对各个曲目进行了标注。然后，Pandora 就能利用代码简单地对标注进行筛选，得到比较类似的歌单。</p>
<p>与此同时，麻省理工学院媒体实验室开发出了名为”The Echo Nest“的智能音乐助手，开创了一种更加先进的个性化音乐推荐方式。The Echo Nest 使用<strong>算法分析各个音乐音频与文本的内容</strong>，使其能进行音乐识别、个性化推荐、创建歌单以及进行分析。</p>
<p>此外，至今依然存在的 Last.fm 采用了一种名为<strong>协同过滤</strong>的不同的方法。它可以识别用户可能喜欢的音乐。稍后会详细提到它。</p>
<hr>
<p>以上就是<strong>其它</strong>音乐策展服务进行推荐的方法。那么 Spotify 是如何造出它们神奇的引擎，如何做出更加符合用户口味的推荐的呢？</p>
<h2 id="Spotify-的-3-种推荐模型"><a href="#Spotify-的-3-种推荐模型" class="headerlink" title="Spotify 的 3 种推荐模型"></a>Spotify 的 3 种推荐模型</h2><p>实际上 Spotify 并没有使用某个革命性的推荐模型 —— 与此相反，<strong>他们是将一些其它服务中单一使用的最佳策略混合起来，创建了自己独特、强大的发现引擎。</strong></p>
<p>Spotify 每周推荐的开发者主要采用了如下三种类型的推荐：</p>
<ol>
<li><strong>协同过滤</strong>模型（就是 Last.fm 最开始使用的模型），通过分析<strong>你的</strong>行为与<strong>他人</strong>的行为进行运作。</li>
<li><strong>自然语言处理（NLP）</strong>模型，用于分析<strong>文本</strong>。 </li>
<li><strong>音频</strong> 模型，用于分析<strong>原始音轨</strong>。</li>
</ol>
<p><img src="/images/pasted-243.png" alt="upload successful"></p>
<p>下面让我们深入了解上述各个推荐模型吧！</p>
<hr>
<h2 id="推荐模型-1：协同过滤"><a href="#推荐模型-1：协同过滤" class="headerlink" title="推荐模型 #1：协同过滤"></a>推荐模型 #1：协同过滤</h2><p><img src="/images/pasted-244.png" alt="upload successful"></p>
<p>首先简述一些背景：当人们听见”协同推荐“这个词的时候，大多会想起 <strong>Netflix</strong> 这个首批采用协同过滤推荐模型的公司。他们使用用户对影片的评星来确定将什么影片推荐给<strong>其它</strong>喜好相似的用户。</p>
<p>当 Netflix 成功使用这种推荐方法之后，开始迅速发展。现在通常被认为是尝试使用推荐模型的鼻祖。</p>
<p>与 Netflix 不同，Spotify 没有让用户对音乐进行评星。他们采用的数据是<strong>隐式反馈</strong> —— 具体来说，包括对用户听歌的<strong>流数据进行统计</strong>，以及收集一些其它的流数据，包括用户是否将歌曲保存到他们自己的歌单、在听完歌之后是否访问了歌手的主页等等。</p>
<p>那么什么是协同过滤，它又是如何运作的呢？这儿用下面这个简短的对话来做个简述：</p>
<p><img src="/images/pasted-245.png" alt="upload successful"></p>
<p>图中发生了什么？图中的两个人都有一些喜欢的歌曲 - 左边的人喜欢歌曲 P、Q、R 及 S；右边的人喜欢歌曲 Q、R、S 及 T。</p>
<p>协同过滤就像用这些数据说：</p>
<p><strong>”Emmmmm，你们都喜欢 Q、R、S 三首歌，所以你们可能是类似的用户。所以，你应该会喜欢对方爱听而你还没听过的歌。“</strong></p>
<p>也就是说，会建议右边的人去听歌曲 P 试试，建议左边的人去听听歌曲 T。这很简单吧！</p>
<p>但 Spotify 是如何将这种方法落到实处，用于由<strong>百万级别用户</strong>的喜好歌曲来计算<strong>百万级别用户</strong>的推荐的呢？</p>
<p><strong>……应用数学矩阵，然后使用 Python 库来实现。</strong></p>
<p><img src="/images/pasted-246.png" alt="upload successful"></p>
<p>在实际情况中，你在看到的这个矩阵是<strong>巨大无比</strong>的，<strong>矩阵中的每一行都代表了 Spotify 的 1.4 亿用户</strong>（如果你也用 Spotify，那你也会是这个矩阵的一行），<strong>每列代表了 Spotify 数据库中的 3000 万首歌</strong>。</p>
<p>接着，Python 库会长时间、缓慢地对矩阵按照以下分离公式进行计算：</p>
<p><img src="/images/pasted-247.png" alt="upload successful"></p>
<p>在它完成计算之后，我们会得到两种向量，在这里用 X 与 Y 表示。<strong>X 是用户向量</strong>，代表了单个用户的口味；<strong>Y 是歌曲向量</strong>，代表了一首歌的属性。</p>
<p><img src="/images/pasted-248.png" alt="upload successful"></p>
<p>现在，我们有了 1.4 亿条用户向量以及 3000 万条歌曲向量。这些向量的内容实质上就是一堆数字，本身没有任何意义。但是对它们进行对比就能起到巨大的作用。</p>
<p>为了找到哪些用户和我有着最相似的口味，协同过滤会将我的向量和其它每个用户的向量进行对比，最终找到与我最相近的用户。同样的，对 Y 向量进行比较，可以找到与你正在听的歌最相近的歌。</p>
<p>协同过滤的效果相当不错，但 Spotify 没有满足于此，他们知道通过增加一些其它的引擎可以使得效果更好。下面让我们看看 NLP。</p>
<hr>
<h2 id="推荐模型-2：自然语言处理（NLP）"><a href="#推荐模型-2：自然语言处理（NLP）" class="headerlink" title="推荐模型 #2：自然语言处理（NLP）"></a>推荐模型 #2：自然语言处理（NLP）</h2><p>Spotify 采用的第二种推荐模型是<strong>自然语言处理（NLP）模型</strong>。顾名思义，这种模型的数据来源就是传统意义上的<strong>文字</strong> —— 这些文字来源于歌曲的元数据、新闻文章、博客，以及互联网中的其它文本。</p>
<p><img src="/images/pasted-249.png" alt="upload successful"></p>
<p>NLP 是一种让计算机理解人类语言的能力，是一个庞大的领域。在这儿可以采用一些情感分析 API 来实现。</p>
<p>NLP 背后的机制已经超出了本文的讨论范围。不过我们可以这么来大致概括：Spotify 爬虫不断地查找与音乐有关的博客以及各种文本，并了解人们对特定艺术家及歌曲的看法 —— 谈到这些歌曲人们通常会用什么形容词和语言，以及会同时提到哪些<strong>其他</strong>的艺术家及歌曲。</p>
<p>虽然我不知道 Spotify 处理数据的细节，但我知道 the Echo Nest 是如何与他们进行协同工作的。他们会将语言处理封装为“文化向量”或者“高频短语”。每个艺术家及歌曲都有着数以千计的高频短语，且每天都在变化。每个短语都有一个权重，用于表示这个短语的重要性（大致来说，就是某人描述这个音乐时会用这个短语的概率）。</p>
<p><img src="/images/pasted-250.png" alt="upload successful"></p>
<p>the Echo Nest 使用的“文化向量”与“高频短语”，Brian Whitman 提供表格</p>
<p>接下来与协同过滤一样，NLP 模型会使用这些短语和权重为每首歌构建一个表示向量，这样就能判断两首歌是否相似了。酷不酷炫？</p>
<hr>
<h2 id="推荐模型-3：原始音频模型"><a href="#推荐模型-3：原始音频模型" class="headerlink" title="推荐模型 #3：原始音频模型"></a>推荐模型 #3：原始音频模型</h2><p><img src="/images/pasted-251.png" alt="upload successful"></p>
<p>在开始本章之前，你可能会问：</p>
<blockquote>
<p>我们已经在前两个模型中应用了足够多的数据，为什么还需要分析音频本身呢？</p>
</blockquote>
<p>首先，引入这第三个模型能使这个惊人的推荐服务的准确率得到进一步的提升。但实际上，使用这个模型还有第二种目的：与前两个模型不同，<strong>原始音频模型可以用于处理<em>新</em>歌</strong>。</p>
<p>举个例子，你的歌手朋友将他的新歌传上了 Spotify，然而他仅有 50 名听众，如果要使用协同过滤显然人数太少了。并且他还没有火起来，在互联网上任何角落都没有被提到过，因此 NLP 模型也没法为他发挥作用。不过幸运的是原始音频模型不会在乎这是新歌还是老歌，有了它的帮助，你朋友的歌就有可能和那些流行的歌一起被加入每周推荐歌单了！</p>
<p>接下来解释“如何”对如此抽象的<strong>原始音频</strong>进行分析。</p>
<p>…使用 <strong>卷积神经网络（CNN）</strong>!</p>
<p>卷积神经网络正是人脸识别背后使用的技术。在 Spotify 这个场景中，工程师们使用音频数据来代替像素。下面是神经网络一中结构的实例：</p>
<p><img src="/images/pasted-252.png" alt="upload successful"></p>
<p>这个特制的神经网络有 4 层<strong>卷积层</strong>，它们在图的左边，看起来像很厚的木板；它还有 3 层<strong>全连接层</strong>，它们在图的右边，看起来像很窄的木板。输入值是音频帧的频率的表示，在图中以光谱图的形式表示。</p>
<p>音频帧通过这些卷积层后，在最后一个卷积层边你可以看到一个“全局时间池化”层。这个池化层沿整个时间轴进行池化，高效地根据统计学找出在歌曲的时间序列中找到的特征。</p>
<p>在此之后，神经网络会输出它对一首歌的理解，其中包括各种类似<strong>时间戳、调性、风格、节奏、音量</strong>等典型特征。下图为 Daft Punk 的 “Around the World” 一曲中截取 30 秒片段的数据。</p>
<p><img src="/images/pasted-253.png" alt="upload successful"></p>
<p>图片版权：<a target="_blank" rel="noopener" href="http://docs.echonest.com.s3-website-us-east-1.amazonaws.com/_static/AnalyzeDocumentation.pdf">Tristan Jehan &amp; David DesRoches (The Echo Nest)</a></p>
<p>最终，这些由一首歌理解到的各种关键的信息可以让 Spotify 理解不同的歌中的一些本质的相似之处，由此基于用户的听歌历史推断出此用户可能会喜欢这首新歌。</p>
<hr>
<p>以上概况了推荐模型中的三个基本组成部分。正是由这些推荐模型组成的推荐 pipeline，最终构成了强大的每周推荐歌单功能！</p>
<p><img src="/images/pasted-254.png" alt="upload successful"></p>
<p>当然，这些推荐模型还与 Spotify 更大的生态系统息息相关，这个生态系统中包含了<strong>海量</strong>的数据，使用大量的 Hadoop 集群对推荐系统践行规模化运作，使得这些引擎能够在大尺度、无穷尽的互联网中顺利地分析音乐相关文章以及无比庞大的音频文件。</p>
<p>我希望本文的信息能满足你的好奇心（就像我的好奇心被满足了一样）。现在我正在通过我个性化的每周推荐找到我喜欢的音乐，了解以及欣赏它背后的各种机器学习知识。🎶</p>
<hr>
<p>**资源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/MrChrisJohnson/from-idea-to-execution-spotifys-discover-weekly/31-1_0_0_0_1">From Idea to Execution: Spotify’s Discover Weekly</a> (Chris Johnson, ex-Spotify)</li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/erikbern/collaborative-filtering-at-spotify-16182818/10-Supervised_collaborative_filtering_is_pretty">Collaborative Filtering at Spotify</a> (Erik Bernhardsson, ex-Spotify)</li>
<li><a target="_blank" rel="noopener" href="http://benanne.github.io/2014/08/05/spotify-cnns.html">Recommending music on Spotify with deep learning</a> (Sander Dieleman)</li>
<li><a target="_blank" rel="noopener" href="https://notes.variogr.am/2012/12/11/how-music-recommendation-works-and-doesnt-work/"> How music recommendation works — and doesn’t work</a> (Brian Whitman, co-founder of The Echo Nest)</li>
<li><a target="_blank" rel="noopener" href="http://blog.galvanize.com/spotify-discover-weekly-data-science/">Ever Wonder How Spotify Discover Weekly Works? Data Science</a> (Galvanize)</li>
<li><a target="_blank" rel="noopener" href="https://qz.com/571007/the-magic-that-makes-spotifys-discover-weekly-playlists-so-damn-good/">The magic that makes Spotify’s Discover Weekly playlists so damn good</a> (Quartz)</li>
<li><a target="_blank" rel="noopener" href="http://docs.echonest.com.s3-website-us-east-1.amazonaws.com/_static/AnalyzeDocumentation.pdf">The Echo Nest’s Analyzer Documentation</a></li>
</ul>
<blockquote>
<p>本文发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/59fbd0d9518825299a468a8b">https://juejin.im/post/59fbd0d9518825299a468a8b</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/16/Keras-%E4%B8%AD%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84-5-%E4%B8%AA%E6%AD%A5%E9%AA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/16/Keras-%E4%B8%AD%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84-5-%E4%B8%AA%E6%AD%A5%E9%AA%A4/" class="post-title-link" itemprop="url">Keras 中构建神经网络的 5 个步骤</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-16 12:57:27" itemprop="dateCreated datePublished" datetime="2017-10-16T12:57:27+08:00">2017-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 Keras 创建、评价深度神经网络非常的便捷，不过你需要严格地遵循几个步骤来构建模型。</p>
<p>在本文中我们将一步步地探索在 Keras 中创建、训练、评价深度神经网络，并了解如何使用训练好的模型进行预测。</p>
<p>在阅读完本文后你将了解：</p>
<ul>
<li>如何在 Keras 中定义、编译、训练以及评价一个深度神经网络。</li>
<li>如何选择、使用默认的模型解决回归、分类预测问题。</li>
<li><p>如何使用 Keras 开发并运行你的第一个多层感知机网络。</p>
</li>
<li><p><strong>2017 年 3 月更新</strong>：将示例更新至 Keras 2.0.2 / TensorFlow 1.0.1 / Theano 0.9.0。</p>
</li>
</ul>
<p><img src="/images/pasted-240.png" alt="upload successful"></p>
<p>题图版权由 <a target="_blank" rel="noopener" href="https://www.flickr.com/photos/dxhawk/6842278135/">Martin Stitchener</a> 所有。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>下面概括一下我们将要介绍的在 Keras 中构建神经网络模型的 5 个步骤。</p>
<ol>
<li>定义网络。</li>
<li>编译网络。</li>
<li>训练网络。</li>
<li>评价网络。</li>
<li>进行预测。</li>
</ol>
<p><img src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2016/07/5-Step-Life-Cycle-for-Neural-Network-Models-in-Keras.png" alt="Keras 中构建神经网络的 5 个步骤"></p>
<p>Keras 中构建神经网络的 5 个步骤</p>
<h2 id="想要了解更多使用-Python-进行深度学习的知识？"><a href="#想要了解更多使用-Python-进行深度学习的知识？" class="headerlink" title="想要了解更多使用 Python 进行深度学习的知识？"></a>想要了解更多使用 Python 进行深度学习的知识？</h2><p>免费订阅 2 周，收取我的邮件，探索 MLP、CNN 以及 LSTM 吧！（附带样例代码）</p>
<p>现在点击注册还能得到免费的 PDF 版教程。</p>
<p><a target="_blank" rel="noopener" href="https://machinelearningmastery.leadpages.co/leadbox/142d6e873f72a2%3A164f8be4f346dc/5657382461898752/">点击这里开始你的小课程吧！</a></p>
<h2 id="第一步：定义网络"><a href="#第一步：定义网络" class="headerlink" title="第一步：定义网络"></a>第一步：定义网络</h2><p>首先要做的就是定义你的神经网络。</p>
<p>在 Keras 中，可以通过一系列的层来定义神经网络。这些层的容器就是 Sequential 类。（译注：序贯模型）</p>
<p>第一步要做的就是创建 Sequential 类的实例。然后你就可以按照层的连接顺序创建你所需要的网络层了。</p>
<p>例如，我们可以做如下两步：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">model</span> = <span class="function"><span class="title">Sequential</span>()</span></span><br><span class="line"><span class="variable">model.add</span>(<span class="function"><span class="title">Dense</span>(<span class="number">2</span>))</span></span><br></pre></td></tr></table></figure>
<p>此外，我们也可以通过创建一个层的数组，并将其传给 Sequential 构造器来定义模型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layers</span> = [Dense(<span class="number">2</span>)]</span><br><span class="line"><span class="attr">model</span> = Sequential(layers)</span><br></pre></td></tr></table></figure>
<p>网络的第一层必须要定义预期输入维数。指定这个参数的方式有许多种，取决于要建造的模型种类，不过在本文的多层感知机模型中我们将通过 <code>input_dim</code> 属性来指定它。</p>
<p>例如，我们要定义一个小型的多层感知机模型，这个模型在可见层中具有 2 个输入，在隐藏层中有 5 个神经元，在输出层中有 1 个神经元。这个模型可以定义如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(5, <span class="attribute">input_dim</span>=2))</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(1))</span><br></pre></td></tr></table></figure>
<p>你可以将这个序贯模型看成一个管道，从一头喂入数据，从另一头得到预测。</p>
<p>这种将通常互相连接的层分开，并作为单独的层加入模型是 Keras 中一个非常有用的概念，这样可以清晰地表明各层在数据从输入到输出的转换过程中起到的职责。例如，可以将用于将各个神经元中信号求和、转换的激活函数单独提取出来，并将这个 Activation 对象同层一样加入 Sequential 模型中。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(5, <span class="attribute">input_dim</span>=2))</span><br><span class="line">model.<span class="builtin-name">add</span>(Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(1))</span><br><span class="line">model.<span class="builtin-name">add</span>(Activation(<span class="string">&#x27;sigmoid&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>输出层激活函数的选择尤为重要，它决定了预测值的格式。</p>
<p>例如，以下是一些常用的预测建模问题类型，以及它们可以在输出层使用的结构和标准的激活函数：</p>
<ul>
<li><strong>回归问题</strong>：使用线性的激活函数 “linear”，并使用与与输出数量相匹配的神经元数量。</li>
<li><strong>二分类问题</strong>：使用逻辑激活函数 “sigmoid”，在输出层仅设一个神经元。</li>
<li><strong>多分类问题</strong>：使用 Softmax 激活函数 “softmax”；假如你使用的是 one-hot 编码的输出格式的话，那么每个输出对应一个神经元。</li>
</ul>
<h2 id="第二步：编译网络"><a href="#第二步：编译网络" class="headerlink" title="第二步：编译网络"></a>第二步：编译网络</h2><p>当我们定义好网络之后，必须要对它进行编译。</p>
<p>编译是一个高效的步骤。它会将我们定义的层序列通过一系列高效的矩阵转换，根据 Keras 的配置转换成能在 GPU 或 CPU 上执行的格式。</p>
<p>你可以将编译过程看成是对你网络的预计算。</p>
<p>无论是要使用优化器方案进行训练，还是从保存的文件中加载一组预训练权重，只要是在定义模型之后都需要编译，因为编译步骤会将你的网络转换为适用于你的硬件的高效结构。此外，进行预测也是如此。</p>
<p>编译步骤需要专门针对你的网络的训练设定一些参数，设定训练网络使用的优化算法 以及用于评价网络通过优化算法最小化结果的损失函数尤为重要。</p>
<p>下面的例子对定义好的用于回归问题的模型进行编译时，指定了随机梯度下降（sgd）优化算法，以及均方差（mse）算是函数。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(<span class="attribute">optimizer</span>=<span class="string">&#x27;sgd&#x27;</span>, <span class="attribute">loss</span>=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>预测建模问题的种类也会限制可以使用的损失函数类型。</p>
<p>例如，下面是几种不同的预测建模类型对应的标准损失函数：</p>
<ul>
<li><strong>回归问题</strong>：均方差误差 “_mse_”。</li>
<li><strong>二分类问题</strong>：对数损失（也称为交叉熵）“_binary_crossentropy_”。</li>
<li><strong>多分类问题</strong>：多类对数损失 “_categorical_crossentropy_”。</li>
</ul>
<p>你可以查阅 <a target="_blank" rel="noopener" href="http://keras.io/objectives/">Keras 支持的损失函数</a>。</p>
<p>最常用的优化算法是随机梯度下降，不过 Keras 也支持<a target="_blank" rel="noopener" href="http://keras.io/optimizers/">其它的一些优化算法</a>。</p>
<p>以下几种优化算法可能是最常用的优化算法，因为它们的性能一般都很好：</p>
<ul>
<li><strong>随机梯度下降</strong> “_sgd_” 需要对学习率以及动量参数进行调参。</li>
<li><strong>ADAM</strong> “_adam_” 需要对学习率进行调参。</li>
<li><strong>RMSprop</strong> “_rmsprop_” 需要对学习率进行调参。</li>
</ul>
<p>最后，你还可以指定在训练模型过程中除了损失函数值之外的特定指标。一般对于分类问题来说，最常收集的指标就是准确率。需要收集的指标由设定数组中的名称决定。</p>
<p>例如：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(<span class="attribute">optimizer</span>=<span class="string">&#x27;sgd&#x27;</span>, <span class="attribute">loss</span>=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="第三步：训练网络"><a href="#第三步：训练网络" class="headerlink" title="第三步：训练网络"></a>第三步：训练网络</h2><p>在网络编译完成后，就能对它进行训练了。这个过程也可以看成是调整权重以拟合训练数据集。</p>
<p>训练网络需要制定训练数据，包括输入矩阵 X 以及相对应的输出 y。</p>
<p>在此步骤，将使用反向传播算法对网络进行训练，并使用在编译时制定的优化算法以及损失函数来进行优化。</p>
<p>反向传播算法需要指定训练的 Epoch（回合数、历元数）、对数据集的 exposure 数。</p>
<p>每个 epoch 都可以被划分成多组数据输入输出对，它们也称为 batch（批次大小）。batch 设定的数字将会定义在每个 epoch 中更新权重之前输入输出对的数量。这种做法也是一种优化效率的方式，可以确保不会同时加载过多的输入输出对到内存（显存）中。</p>
<p>以下是一个最简单的训练网络的例子：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(<span class="attribute">optimizer</span>=<span class="string">&#x27;sgd&#x27;</span>, <span class="attribute">loss</span>=<span class="string">&#x27;mse&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>在训练网络之后，会返回一个历史对象（History oject），其中包括了模型在训练中各项性能的摘要（包括每轮的损失函数值及在编译时制定收集的指标）。</p>
<h2 id="第四步：评价网络"><a href="#第四步：评价网络" class="headerlink" title="第四步：评价网络"></a>第四步：评价网络</h2><p>在网络训练完毕之后，就可以对其进行评价。</p>
<p>可以使用训练集的数据对网络进行评价，但这种做法得到的指标对于将网络进行预测并没有什么用。因为在训练时网络已经“看”到了这些数据。</p>
<p>因此我们可以使用之前没有“看”到的额外数据集来评估网络性能。这将提供网络在未来对没有见过的数据进行预测的性能时的估测。</p>
<p>评价模型将会评价所有测试集中的输入输出对的损失值，以及在模型编译时指定的其它指标（例如分类准确率）。本步骤将返回一组评价指标结果。</p>
<p>例如，一个在编译时使用准确率作为指标的模型可以在新数据集上进行评价，如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">loss,</span> accuracy = model.evaluate(X, y)</span><br></pre></td></tr></table></figure>
<h2 id="第五步：进行预测"><a href="#第五步：进行预测" class="headerlink" title="第五步：进行预测"></a>第五步：进行预测</h2><p>最后，如果我们对训练后的模型的性能满意的话，就能用它来对新的数据做预测了。</p>
<p>这一步非常简单，直接在模型上调用 predict() 函数，传入一组新的输入即可。</p>
<p>例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predictions</span> = model.predict(x)</span><br></pre></td></tr></table></figure>
<p>预测值将以网络输出层定义的格式返回。</p>
<p>在回归问题中，这些由线性激活函数得到的预测值可能直接就符合问题需要的格式。</p>
<p>对于二分类问题，预测值可能是一组概率值，这些概率说明了数据分到第一类的可能性。可以通过四舍五入（K.round）将这些概率值转换成 0 与 1。</p>
<p>而对于多分类问题，得到的结果可能也是一组概率值（假设输出变量用的是 one-hot 编码方式），因此它还需要用 <a target="_blank" rel="noopener" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html">argmax 函数</a>将这些概率数组转换为所需要的单一类输出。</p>
<h2 id="End-to-End-Worked-Example"><a href="#End-to-End-Worked-Example" class="headerlink" title="End-to-End Worked Example"></a>End-to-End Worked Example</h2><p>让我们用一个小例子将以上的所有内容结合起来。</p>
<p>我们将以 Pima Indians 糖尿病发病二分类问题为例。你可以在 <a target="_blank" rel="noopener" href="https://archive.ics.uci.edu/ml/datasets/Pima+Indians+Diabetes">UCI 机器学习仓库</a>中下载此数据集。</p>
<p>该问题有 8 个输入变量，需要输出 0 或 1 的分类值。</p>
<p>我们将构建一个包含 8 个输入的可见层、12 个神经元的隐藏层、rectifier 激活函数、1 个神经元的输出层、sigmoid 激活函数的多层感知机神经网络。</p>
<p>我们将对网络进行 100 epoch 次训练，batch 大小设为 10，使用 ADAM 优化算法以及对数损失函数。</p>
<p>在训练之后，我们使用训练数据对模型进行评价，然后使用训练数据对模型进行单独的预测。这么做是为了方便起见，一般来说我们都会使用额外的测试数据集进行评价，用新的数据进行预测。</p>
<p>完整代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Keras 多层感知机神经网络样例</span></span><br><span class="line"><span class="keyword">from</span> keras.models import Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers import Dense</span><br><span class="line">import numpy</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataset = numpy.loadtxt(<span class="string">&quot;pima-indians-diabetes.csv&quot;</span>, <span class="attribute">delimiter</span>=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">X = dataset[:,0:8]</span><br><span class="line">Y = dataset[:,8]</span><br><span class="line"><span class="comment"># 1. 定义网络</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(12, <span class="attribute">input_dim</span>=8, <span class="attribute">activation</span>=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.<span class="builtin-name">add</span>(Dense(1, <span class="attribute">activation</span>=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"><span class="comment"># 2. 编译网络</span></span><br><span class="line">model.compile(<span class="attribute">loss</span>=<span class="string">&#x27;binary_crossentropy&#x27;</span>, <span class="attribute">optimizer</span>=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 3. 训练网络</span></span><br><span class="line">history = model.fit(X, Y, <span class="attribute">epochs</span>=100, <span class="attribute">batch_size</span>=10)</span><br><span class="line"><span class="comment"># 4. 评价网络</span></span><br><span class="line">loss, accuracy = model.evaluate(X, Y)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">&quot;\nLoss: %.2f, Accuracy: %.2f%%&quot;</span> % (loss, accuracy<span class="number">*100</span>))</span><br><span class="line"><span class="comment"># 5. 进行预测</span></span><br><span class="line">probabilities = model.predict(X)</span><br><span class="line">predictions = [float(round(x)) <span class="keyword">for</span> x <span class="keyword">in</span> probabilities]</span><br><span class="line">accuracy = numpy.mean(predictions == Y)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">&quot;Prediction Accuracy: %.2f%%&quot;</span> % (accuracy<span class="number">*100</span>))</span><br></pre></td></tr></table></figure>
<p>运行样例，会得到以下输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">768</span>/<span class="number">768</span> [==============================] - <span class="number">0</span>s - loss: <span class="number">0.5219</span> - acc: <span class="number">0.7591</span></span><br><span class="line">Epoch <span class="number">99</span>/<span class="number">100</span></span><br><span class="line"><span class="number">768</span>/<span class="number">768</span> [==============================] - <span class="number">0</span>s - loss: <span class="number">0.5250</span> - acc: <span class="number">0.7474</span></span><br><span class="line">Epoch <span class="number">100</span>/<span class="number">100</span></span><br><span class="line"><span class="number">768</span>/<span class="number">768</span> [==============================] - <span class="number">0</span>s - loss: <span class="number">0.5416</span> - acc: <span class="number">0.7331</span></span><br><span class="line"><span class="number">32</span>/<span class="number">768</span> [&gt;.............................] - ETA: <span class="number">0</span>s</span><br><span class="line">Loss: <span class="number">0.51</span>, Accuracy: <span class="number">74.87</span>%</span><br><span class="line">Prediction Accuracy: <span class="number">74.87</span>%</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们探索了使用 Keras 库进行深度学习时构建神经网络的 5 个步骤。</p>
<p>此外，你还学到了：</p>
<ul>
<li>如何在 Keras 中定义、编译、训练以及评价一个深度神经网络。</li>
<li>如何选择、使用默认的模型解决回归、分类预测问题。</li>
<li>如何使用 Keras 开发并运行你的第一个多层感知机网络。</li>
</ul>
<p>你对 Keras 的神经网络模型还有别的问题吗？或者你对本文还有什么建议吗？请在评论中留言，我会尽力回答。</p>
<blockquote>
<p>本文发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/59e43b5b6fb9a0452a3b5f4f">https://juejin.im/post/59e43b5b6fb9a0452a3b5f4f</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/13/Javascript-%E4%B8%AD%E5%A4%9A%E6%A0%B7%E7%9A%84-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/13/Javascript-%E4%B8%AD%E5%A4%9A%E6%A0%B7%E7%9A%84-this/" class="post-title-link" itemprop="url">Javascript 中多样的 this</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-13 15:14:22" itemprop="dateCreated datePublished" datetime="2017-10-13T15:14:22+08:00">2017-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/pasted-239.png" alt="upload successful"></p>
<p>本文将尽量解释清楚 JavaScript 中最基础的部分之一：执行上下文（execution context）。如果你经常使用 JS 框架，那理解 <code>this</code> 更是锦上添花。但如果你想更加认真地对待编程的话，理解上下文无疑是非常重要的。</p>
<p>我们可以像平常说话一样来使用 <code>this</code>。例如：我会说“我妈很不爽，这（this）太糟糕了”，而不会说“我妈很不爽，我妈很不爽这件事太糟糕了”。理解了 <code>this</code> 的上下文，才会理解我们为什么觉得很糟糕。</p>
<p>现在试着把这个例子与编程语言联系起来。在 Javascript 中，我们将 <code>this</code> 作为一个快捷方式，一个引用。它指向其所在上下文的某个对象或变量。</p>
<p>现在这么说可能会让人不解，不过很快你就能理解它们了。</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a><strong>全局上下文</strong></h2><p>如果你和某人聊天，在刚开始对话、没有做介绍、没有任何上下文时，他对你说：“这（this）太糟糕了”，你会怎么想？大多数情况人们会试图将“这（this）”与周围的事物、最近发生的事情联系起来。</p>
<p>对于浏览器来说也是如此。成千上万的开发者在没有上下文的情况下使用了 <code>this</code>。我们可怜的浏览器只能将 <code>this</code> 指向一个全局对象（大多数情况下是 window）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line"><span class="comment">// =&gt; 15</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"><span class="comment">// =&gt; 15</span></span><br></pre></td></tr></table></figure>
<p>[以上代码需在浏览器中执行]</p>
<p>函数外部的任何地方都为全局上下文，<code>this</code> 始终指向全局上下文（window 对象）。</p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>以真实世界来类比，函数上下文可以看成句子的上下文。“我妈很不爽，这（this）很不妙。”我们都知道这句话中的 <code>this</code> 是什么意思。其它句子中同样可以使用 <code>this</code>，但是由于其处于所处上下文不同因而意思全然不同。例如，“风暴来袭，这（this）太糟糕了。”</p>
<p>JavaScript 的上下文与对象有关，它取决于函数被执行时所在的对象。因此 <code>this</code> 会指向被执行函数所在的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gx</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fx</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fy</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gx() === <span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br><span class="line"><span class="built_in">console</span>.log(fx());</span><br><span class="line"><span class="comment">// =&gt; 20</span></span><br><span class="line"><span class="built_in">console</span>.log(fy());</span><br><span class="line"><span class="comment">// =&gt; 20</span></span><br></pre></td></tr></table></figure>
<p><code>this</code> 由函数被调用的方式决定。如你所见，上面的所有函数都是在全局上下文中被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  prop: <span class="number">37</span>,</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.f());</span><br><span class="line"><span class="comment">// =&gt; 37</span></span><br></pre></td></tr></table></figure>
<p>当一个函数是作为某个对象的方法被调用时，它的 <code>this</code> 指向的就是这个方法所在的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fx</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x_obj = &#123;</span><br><span class="line">    y_obj: &#123;</span><br><span class="line">        method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fx() === <span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// =&gt; True — 我们仍处于全局上下文中。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === <span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// =&gt; False — 函数作为一个对象的方法被调用。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === obj);</span><br><span class="line"><span class="comment">// =&gt; True — 函数作为一个对象的方法被调用。</span></span><br><span class="line"><span class="built_in">console</span>.log(x_obj.y_obj.method() === x_obj)</span><br><span class="line"><span class="comment">// =&gt; False — 函数作为 y_obj 对象的方法被调用，因此 `this` 指向的是 y_obj 的上下文。</span></span><br></pre></td></tr></table></figure>
<p><strong>例 4</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br></pre></td></tr></table></figure>
<p>在严格模式下，全局作用域的函数在全局作用域被调用时，<code>this</code> 为 <code>undefined</code>。</p>
<p><strong>例 5</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fx</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    method: fx</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === <span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// =&gt; False</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === obj);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br></pre></td></tr></table></figure>
<p>与前面的例子一样，无论函数是如何被定义的，在这儿它都是作为一个对象方法被调用。</p>
<p><strong>例 6</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sec_obj = &#123;</span><br><span class="line">    method: obj.method</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sec_obj.method() === obj);</span><br><span class="line"><span class="comment">// =&gt; False</span></span><br><span class="line"><span class="built_in">console</span>.log(sec_obj.method() === sec_obj);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br></pre></td></tr></table></figure>
<p><code>this</code> 是动态的，它可以由一个对象指向另一个对象。</p>
<p><strong>例 7</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shop = &#123;</span><br><span class="line">  fruit: <span class="string">&quot;Apple&quot;</span>,</span><br><span class="line">  sellMe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this &quot;</span>, <span class="built_in">this</span>.fruit);</span><br><span class="line"><span class="comment">// =&gt; this Apple</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;shop &quot;</span>, shop.fruit);</span><br><span class="line"><span class="comment">// =&gt; shop Apple</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shop.sellMe()</span><br></pre></td></tr></table></figure>
<p>我们既能通过 <code>shop</code> 对象也能通过 <code>this</code> 来访问 <code>fruit</code> 属性。</p>
<p><strong>例 8</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.bar = <span class="string">&quot;baz&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar); </span><br><span class="line"><span class="comment">// =&gt; baz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bar);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>现在情况不同了。<code>new</code> 操作符创建了一个对象的实例。因此函数的上下文设置为这个被创建的对象实例。</p>
<h2 id="Call、apply、bind"><a href="#Call、apply、bind" class="headerlink" title="Call、apply、bind"></a>Call、apply、bind</h2><p>依旧以真实世界举例：“这（this）太糟糕了，因为我妈开始不爽了。”</p>
<p>这三个方法可以让我们在任何期许的上下文中执行函数。让我们举几个例子看看它们的用法：</p>
<p><strong>例 1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="string">&quot;xo xo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="string">&quot;lorem ipsum&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br><span class="line"><span class="comment">// =&gt; xo xo — 我们在全局上下文中调用了 test 函数。</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(foo)); </span><br><span class="line"><span class="comment">// =&gt; lorem ipsum — 通过使用 `call`，我们在 foo 对象的上下文中调用了 test 函数。</span></span><br><span class="line"><span class="built_in">console</span>.log(test.apply(foo));</span><br><span class="line"><span class="comment">// =&gt; lorem ipsum — 通过使用 `apply`，我们在 foo 对象的上下文中调用了 test 函数。</span></span><br></pre></td></tr></table></figure>
<p>这两种方法都能让你在任何需要的上下文中执行函数。</p>
<p><code>apply</code> 可以让你在调用函数时将参数以不定长数组的形式传入，而 <code>call</code> 则需要你明确参数。</p>
<p><strong>例 2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bound = test.bind(<span class="built_in">document</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bound()); </span><br><span class="line"><span class="comment">// =&gt; undefined — 在 document 对象中没有 a 这个变量。</span></span><br><span class="line"><span class="built_in">console</span>.log(bound.call(<span class="built_in">window</span>)); </span><br><span class="line"><span class="comment">// =&gt; undefined — 在 document 对象中没有 a 这个变量。在这个情况中，call 不能改变上下文。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sec_bound = test.bind(&#123;<span class="attr">a</span>: <span class="number">15</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sec_bound())</span><br><span class="line"><span class="comment">// =&gt; 15 — 我们创建了一个新对象 &#123;a:15&#125;，并在此上下文中调用了 test 函数。</span></span><br></pre></td></tr></table></figure>
<p><code>bind</code> 方法返回的函数的下上文会被永久改变。<br>在使用 bind 之后，其上下文就固定了，无论你再使用 call、apply 或者 bind 都无法再改变其上下文。</p>
<h2 id="箭头函数（ES6）"><a href="#箭头函数（ES6）" class="headerlink" title="箭头函数（ES6）"></a><strong>箭头函数（ES6）</strong></h2><p>箭头函数是 ES6 中的一个新语法。它是一个非常方便的工具，不过你需要知道，在箭头函数中的上下文与普通函数中的上下文的定义是不同的。让我们举例看看。</p>
<p><strong>例 1</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = <span class="function">(<span class="params">()</span> =&gt;</span> <span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); </span><br><span class="line"><span class="regexp">//</span> =&gt; True</span><br></pre></td></tr></table></figure>
<p>当我们使用箭头函数时，<code>this</code> 会保留其封闭范围的上下文。</p>
<p><strong>例 2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">method</span>: <span class="function">() =&gt;</span> <span class="built_in">this</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sec_obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === obj);</span><br><span class="line"><span class="comment">// =&gt; False</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.method() === <span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br><span class="line"><span class="built_in">console</span>.log(sec_obj.method() === sec_obj);</span><br><span class="line"><span class="comment">// =&gt; True</span></span><br></pre></td></tr></table></figure>
<p>请注意箭头函数与普通函数的不同点。在这个例子中使用箭头函数时，我们仍然处于 window 上下文中。<br>我们可以这么看：</p>
<blockquote>
<p><em>x =&gt; this.y equals function (x) { return this.y }.bind(this)</em></p>
</blockquote>
<p>可以将箭头函数看做其始终 <code>bind</code> 了函数外层上下文的 <code>this</code>，因此不能将它作为构造函数使用。下面的例子也说明了其不同之处。</p>
<p><strong>例 3</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     a: <span class="string">&quot;inside method&quot;</span>,</span><br><span class="line">     normal: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">     &#125;,</span><br><span class="line">     arrowFunction: <span class="function">() =&gt;</span> <span class="built_in">this</span>.a</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;,</span><br><span class="line"> a: <span class="string">&quot;inside obj&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.method().normal());</span><br><span class="line"><span class="comment">// =&gt; inside method</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.method().arrowFunction());</span><br><span class="line"><span class="comment">// =&gt; inside obj</span></span><br></pre></td></tr></table></figure>
<p>当你了解了函数中动态（dynamic） <code>this</code> 与词法（lexical）<code>this</code> ，在定义新函数的时候请三思。如果函数将作为一个方法被调用，那么使用动态 <code>this</code>；如果它作为一个子程序（subroutine）被调用，则使用词法 <code>this</code>。</p>
<blockquote>
<p>译注：了解动态作用域与词法作用域可<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/5700095.html">阅读此文章</a></p>
</blockquote>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a><strong>相关阅读</strong></h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.joshuakehn.com/2011/10/20/Understanding-JavaScript-Context.html">http://www.joshuakehn.com/2011/10/20/Understanding-JavaScript-Context.html</a></li>
<li><a target="_blank" rel="noopener" href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/">http://ryanmorr.com/understanding-scope-and-context-in-javascript/</a></li>
<li><a target="_blank" rel="noopener" href="https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c">https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c</a></li>
<li><a target="_blank" rel="noopener" href="http://2ality.com/2012/04/arrow-functions.html">http://2ality.com/2012/04/arrow-functions.html</a></li>
</ul>
<blockquote>
<p>本文发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/59e066d551882578c3411908">https://juejin.im/post/59e066d551882578c3411908</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/12/Slide-of-Information-Extraction-In-Illicit-Web-Domains-used-in-workshop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/12/Slide-of-Information-Extraction-In-Illicit-Web-Domains-used-in-workshop/" class="post-title-link" itemprop="url">Slide of 'Information Extraction In Illicit Web Domains' used in workshop.</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-12 22:06:00" itemprop="dateCreated datePublished" datetime="2017-10-12T22:06:00+08:00">2017-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><iframe src="https://lsvih.github.io/workshop/17-10-11/Information%20Extraction%20in%20Illicit%20Web%20Domains.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/11/Information-Extraction-in-Illicit-Web-Domains-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/11/Information-Extraction-in-Illicit-Web-Domains-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Information Extraction in Illicit Web Domains 论文笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-10-11 00:27:00" itemprop="dateCreated datePublished" datetime="2017-10-11T00:27:00+08:00">2017-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Kejriwal M, Szekely P. Information Extraction in Illicit Web Domains[J]. 2017.</p>
</blockquote>
<h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><p>论文作者为南加大维特比学院的 Mayank Kejriwal 和 Pedro Szekely，发表于 WWW 2017。</p>
<h3 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h3><p>建立了稳定可靠的信息提取系统（Information Extraction System），用以从非法领域的网页中抽取有用的实体信息。将建立的模型应用于真实数据集得到的结果比 baseline（设定为 CRF）的 F-Score 高了 18%。</p>
<h3 id="论文提纲"><a href="#论文提纲" class="headerlink" title="论文提纲"></a>论文提纲</h3><ol>
<li>论文简介</li>
<li>描述了一些 IE system 的相关工作</li>
<li>详细描述了此文章所使用的模型</li>
<li>实验评估</li>
<li>总结工作</li>
</ol>
<h4 id="一、论文简介"><a href="#一、论文简介" class="headerlink" title="一、论文简介"></a>一、论文简介</h4><p>作者首先简介了构建领域知识图谱（knowledge graph）所需要做的工作：</p>
<ol>
<li><p>领域发现。来源可以为爬虫或领域本体库。</p>
<blockquote>
<p>爬虫部分引用了 S. Chakrabarti. Mining the Web: Discovering knowledge from hypertext data. Elsevier, 2002.<br>领域本体库部分引用了 A. Zouaq and R. Nkambou. A survey of domain ontology engineering: methods and tools. In Advances in intelligent tutoring systems, pages 103–119. Springer, 2010.   </p>
</blockquote>
</li>
<li><p>有了数据源后，使用 IE system 抽取相关结构化数据。作者简述了基于统计学习的信息抽取方法：使用 CRF 序列标注、以及在数据量大的情况下使用深层神经网络,目的为抽取命名实体与关系（extraction of name entities and relationships）。</p>
<blockquote>
<p>神经网络部分引用 R. Collobert and J. Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In Proceedings of the 25th international conference on Machine learning, pages 160–167. ACM, 2008.   </p>
</blockquote>
<p> 当 IE system 在跨领域 Web 数据源（cross-domain Web source，以维基百科为例）和传统领域（以生物学为例）表现优秀时，在一些“动态领域”（dynamic domain）中表现一般。这些领域包括：news feed、自媒体、广告、在线市场以及一些非法领域（如人口贩卖 human trafficking）等。</p>
</li>
<li>非法领域的信息抽取之所以难做是因为在非法网站中常常会对信息进行混淆、非随机地对一些常用词进行错误拼写、OOV（out of vocabulary，非登录词）及生僻词高频出现、有时候还非随机使用Unicode 字符，且相关网页中正文分布稀疏、网页结构各异。与传统领域中（如聊天记录、Twitter 等）规律的信息不同，这些信息正文在非法网站中基本上是独一无二的。此论文仅讨论人口贩卖领域，不过在另一些在暗网中存在 Web 服务的非法领域（如武器贩卖、恐怖袭击、假货等）也可以适用。</li>
<li><p>接着举了两个典型例子说明上面的情况：<br> eg1. Hey gentleman im neWYOrk and i’m looking for generous…<br> eg2. AVAILABLE NOW! ?? - (4 two 4) six 5 two - 0 9 three 1 - 21 </p>
</li>
<li><p>因此传统领域 IE system 的包装归纳学习系统（wrapper induction systems）不能在这些领域中正常工作，只能将数据给调查员和领域专家进行分析。<br> 作者归纳：此论文分析了传统的 IE system 在动态的、非法的领域中的不适用性，因此提出了一种不依赖于传统信息提取系统、可在小样本 Web 数据集上正常运行的方法。</p>
</li>
<li>简介这种方法。此方法包含了两个步骤：<br>1) 第一步，使用召回率很高的识别器（用于识别地址、年龄等）为所有页面做候选标注（candidate annotations）。如下图所示</li>
</ol>
<p><img src="/images/pasted-224.png" alt="upload successful"></p>
<p>2) 第二步，使用一种无特征的监督学习算法，基于随机映射学习单词表示的意思。用此算法对上面的候选标注进行二分类，分为正确与不正确。</p>
<ol>
<li>简述贡献：创建了一种轻量级的、无特征的信息提取系统，可以适用于各种各样的非法领域。且这种方法很容易实现，无需大范围地调参，效果随数据集增大而增强，适用部署于流数据。且此方法在刚开始做领域发现的小数据集上也表现良好，在遇到超大 web 数据集时依然稳定。</li>
<li>简述 baseline，基于 CRF 的最新的 Stanford Named Entity Resolution system，包含关于人口贩卖的预训练数据。</li>
</ol>
<h4 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h4><p>Open IE</p>
<blockquote>
<p>N. Kushmerick. Wrapper induction for information extraction. PhD thesis, University of Washington, 1997.<br>M. Banko, M. J. Cafarella, S. Soderland,M. Broadhead, and O. Etzioni. Open information extraction from the web. In IJCAI, volume 7, pages 2670–2676, 2007.<br>ADRMine<br>B. Han, P. Cook, and T. Baldwin. Text-based twitter user geolocation prediction. Journal of Artificial Intelligence Research, 49:451–500, 2014.<br>A. Nikfarjam, A. Sarker, K. OaˆA ̆Z ́Connor, R. Ginn, and G. Gonzalez. Pharmacovigilance from social media: mining adverse drug reaction mentions using sequence labeling with word embedding cluster features. Journal of the American Medical Informatics Association, page ocu041, 2015.   </p>
</blockquote>
<p>在此之前还没有工作对无特征、低监督的 web 非法领域信息提取进行研究。</p>
<h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>总体的架构如上图 Figure 1 所示。模型有两个输入端，一个是包含有关兴趣领域的 Web 页面集，一个是有着高召回率的识别器。在此论文中假定模型初始化时的数据集很小，接着会有很多的数据不断地加入到数据集中（即模仿流数据条件）。首先将给定一个初始的数据集，其中已经人工标注好了 10-100 条数据的属性（假定为城市、姓名、年龄），模型将根据此数据集在没有做特征工程的情况下学习出一个信息提取系统。</p>
<blockquote>
<p>此处数据条数有疑问</p>
</blockquote>
<p>需要注意的是需要分析的 Web 页面大多是多领域结合，因此在处理页面时不仅需要不断将新的页面加入数据集中，还要由初始数据集进行概念漂移（concept drift）以适应各种新的情况。</p>
<h5 id="1-预处理过程"><a href="#1-预处理过程" class="headerlink" title="1 预处理过程"></a>1 预处理过程</h5><p>爬取相关网页，使用 RTE（Readability Text Extractor）对 HTML 文本进行正文提取。对 RTE 进行调参，将其调至高召回率。由于 Web 网页的结构多样，因此正文中可能会存在许多无关内容（包括一些无用的数字及 Unicode 字符等等）。RTE 最终会返回一组字符串集，字符串集中包含以句子为单位的内容。</p>
<blockquote>
<p>RTE 给了网址：<a target="_blank" rel="noopener" href="https://www.readability.com/developers/api">https://www.readability.com/developers/api</a></p>
</blockquote>
<p>接下来使用 NLTK 对 RTE 返回内容的每个句子分别进行分词。</p>
<h5 id="2-词向量表示"><a href="#2-词向量表示" class="headerlink" title="2 词向量表示"></a>2 词向量表示</h5><p>接下来作者使用 CRF 序列标注模型对已标注数据进行学习（详细内容在后面）。但是由于数据集实在太少，CRF 的效果并不好。<br>为了避免 CRF 出现的状态，又为了避免工作量极大的页面标注，作者使用了非监督算法，以低维空间来表示页面中所有词的全集。在此使用了嵌入算法（embedding algorithms），作者在此提及了 Word2Vec 和 Bollegala 的算法和一种更简单的算法（random indexing）。</p>
<blockquote>
<p>Word2Vec 引用了 T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations of words and phrases and their compositionality. In Advances in neural information processing systems, pages 3111–3119, 2013.<br>Bollegala 算法引用了 D. Bollegala, T. Maehara, and K.-i. Kawarabayashi. Embedding semantic relations into word representations. arXiv preprint arXiv:1505.00161, 2015.<br>random indexing 引用了 M. Sahlgren. An introduction to random indexing. In  Methods and applications of semantic indexing workshop at the 7th international conference on terminology and knowledge engineering, TKE, volume 5, 2005.<br>最终作者选用了“最简单”的 RI（random indexing）算法。此算法可以保证向量在表示时，即使是在低维空间中点与点间依然能够保持足够的距离。RI 算法最开始本来是为了增量降维（incremental dimensionality reduction）设计的。RI 算法定义如下：</p>
</blockquote>
<p>$d \in \mathbb{Z}^+$ -&gt; 向量维数<br>$r \in [0,1]$ -&gt; 定义为 +1 或 -1 的概率</p>
<p>对于一个词向量（这里应该叫做 token 向量，因为在这个情景中 nltk 并不能很好地进行正确分词）来说，随机选择 $[d <em> r]$ 个维度设定为 +1，随机选择 $[d </em> r]$ 个维度设定为 -1，其余 $d - 2 [d * r]$ 个维度设定为 0。</p>
<p>由于在此场景下数据均为噪音很多的流数据，因此只考虑较短的上下文范围。由此确定 RI 算法的滑动窗口大小。滑动窗口定义如下：</p>
<p>给定一组数量为 $|t|$ 的单位元素 $t$，以及一个窗口基准位置 $0 &lt; i &lt; |t|$，则可以定义一个滑动窗口 $(u, v)$。滑动窗口内的所有元素记为 $S$，将基准位置的特征词挖去：$S - t[i]$，得到滑动窗口全集。滑动窗口的位置坐标为 $[max(i-u,1),min(i+v,|t|)]$。</p>
<p><img src="/images/pasted-226.png" alt="upload successful"></p>
<p>上图为使用 RI 算法，设定滑动窗口大小设定为 (2,2) 时产生的 Token 向量。</p>
<p>作者对于原始的 RI 算法进行了一些改进，改动内容如下：</p>
<p>原始 RI 算法在求某特征词上下文向量时没有进行任何权重计算，直接对上下文非特征词的词向量进行了求和。也就是说，对于单词 w 来说，其表示向量进行了 $\vec{w}_{i+1} = \vec{w}_i + \vec{a}$ 计算。但是对于非法领域来说，在此情景中会出现大量独特的 token ，包括且不仅限于罕见单词、Unicode 符号、HTML tag、数字序列（如电话号码）等。这些 token 可能在文本全集中仅仅会出现一次或少数几次，因此它们产生的表示向量也会很少出现。作者为了避免这种情况的出现，预先定义了一些“高权重单位”（compound unit）</p>
<p>为了定义这种高权重单位的值，作者对于上下文中 token 可能出现的一些“罕见”情况进行了定义，定义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>High-idf-units</td>
<td>低词频单元</td>
<td>单元内的单词词频低于设定值$\theta$（默认为 1%）</td>
</tr>
<tr>
<td>Pure-num-units</td>
<td>纯数字单元</td>
<td>只包含数字的单元</td>
</tr>
<tr>
<td>Alpha-num-units</td>
<td>字母-数字混合单元</td>
<td>至少包含 1 个数字与 1 个字母的单元</td>
</tr>
<tr>
<td>Pure-punct-units</td>
<td>纯符号单元</td>
<td>只包含标点符号的单元</td>
</tr>
<tr>
<td>Alpha-punct-units</td>
<td>字母-符号混合单元</td>
<td>至少包含 1 个字母与 1 个符号的单元</td>
</tr>
<tr>
<td>Nonascii-unicode-units</td>
<td>非 ASCII 字符单元</td>
<td>只包含非 ASCII 字符的单元</td>
</tr>
</tbody>
</table>
</div>
<p>以上 6 种“罕见”的单元就是“高权重单位”。</p>
<p>作者在这儿举了个例子：有个单词为“rare”它在文中出现的词频低于某个设定值（如 1%），它根据上表可以定义为 High-idf-units。</p>
<p>作者对 RI 算法根据上面的定义进行了一定修改：RI 算法在计算上下文向量时，仅使用上面 6 中高权重单元的表示向量进行计算。也就是说，每个 token 最终都可以根据上面 6 中高权重单元的向量的线性计算得到自己的独特向量 $\vec{w}_C$。</p>
<p>个人认为作者这样做丢失了很多可能会有用的信息，但是这样可以在本来整体信息就不多的非法领域网页 Web 正文中最大可能地提取高敏感信息。如果之后对这种方法进行改进的话，可以在这块找出更多高敏感信息的模式特征，或者使用改造过的 word2vec 等其它算法进行尝试。</p>
<h5 id="3-应用高召回率识别器"><a href="#3-应用高召回率识别器" class="headerlink" title="3 应用高召回率识别器"></a>3 应用高召回率识别器</h5><p>此处的“识别器”指的是对单一属性进行识别的函数。作者在此给出了相关定义：</p>
<p>对于某个属性 A，它的识别器 $R_A$ 为一个函数，该函数接受一组 token，该组数据记为 t。给定两个输入值 i 与 j（$j \geq i$），分别代表 t 中的两个位置。如果 t 的 t[i]:t[j] 子集为 A 属性的 instance 则返回 True，否则返回 False。</p>
<p>值得注意的是在上面的定义中，识别器并不能识别出 token 中所隐藏的 instance。在平常的 IE system 中所使用的识别器一般都是 recall 和 precision 都相对较高的。在现在这个情境中，识别器不再追求纯粹的准确率（评判标准为 recall 与 precision），而是尽量少丢失一些信息。因此作者选用了有着高 recall 的识别器对文本进行识别标注，在后面一步再去使用监督学习分类来改进这一步产生的候选标注的 precision。</p>
<p><img src="/images/pasted-227.png" alt="upload successful"></p>
<h5 id="4-使用监督学习根据上下文进行分类"><a href="#4-使用监督学习根据上下文进行分类" class="headerlink" title="4 使用监督学习根据上下文进行分类"></a>4 使用监督学习根据上下文进行分类</h5><p>在此之前，已经通过高 recall 的识别器将大多数有可能正确的有意义实体给识别出来，因此需要应用分类器对前一步骤得到的各个实体进行分类以提高最终结果精确度。</p>
<p>由识别器得到一系列的标注（标注可以为单独的 token，也可以是一组连续的 token），将各个标注所在的滑动窗口 (u,v)-context 取出其上下文，求其向量表示，上下文向量的无权重和（unweighted sum）来表示这些标注的上下文向量。</p>
<p>接着，对这些向量应用 l2 正则，使用监督学习分类器（如随机森林）对其进行分类。</p>
<h4 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h4><h5 id="1-数据集与评价标准"><a href="#1-数据集与评价标准" class="headerlink" title="1 数据集与评价标准"></a>1 数据集与评价标准</h5><p><img src="/images/pasted-228.png" alt="upload successful"></p>
<p>表 2：数据集用量</p>
<p>作者描述，数据集来自于 DARPA MEMEX 项目。（网址：<a target="_blank" rel="noopener" href="http://www.darpa.mil/program/memex）">http://www.darpa.mil/program/memex）</a></p>
<p><img src="/images/pasted-229.png" alt="upload successful"></p>
<p>表 3：5 种类别的标准数据集</p>
<p>baseline 与本文的分类器都将对上表包含的 5 种类型的数据进行分类标注。</p>
<p>本文的标准数据集来自于数据集。对数据集应用高 recall 识别器，再对识别器得到的结果进行人工标注。</p>
<h5 id="2-系统描述"><a href="#2-系统描述" class="headerlink" title="2 系统描述"></a>2 系统描述</h5><p>根据上文所述，本文构建的 Information Extraction System 对于每种属性都由两个部分组成：高 recall 识别器与用于裁剪标记的分类器。作者实验室为此构建了 4 中高 recall 的识别器，分别为:</p>
<p>GeoNames-Cities<br>GeoNames-States<br>RegEx-Ages<br>Dictionary-Names</p>
<p>其中前两种识别器的数据集来自于<a target="_blank" rel="noopener" href="http://www.geonames.org/，在此处引用了">http://www.geonames.org/，在此处引用了</a> M. Wick and C. Boutreux. Geonames. GeoNames Geographical Database, 2011。</p>
<p>对于年龄识别，开发了 <a target="_blank" rel="noopener" href="https://github.com/usc-isi-i2/dig-age-extractor">https://github.com/usc-isi-i2/dig-age-extractor</a> </p>
<blockquote>
<p>阅读代码发现原理特别简单，单纯的匹配数字</p>
</blockquote>
<p>对于姓名属性，作者收集了各种语言的姓名于数据集中，数据集地址：<br><a target="_blank" rel="noopener" href="https://github.com/usc-isi-i2/dig-dictionaries/tree/master/person-names">https://github.com/usc-isi-i2/dig-dictionaries/tree/master/person-names</a></p>
<h5 id="3-baseline"><a href="#3-baseline" class="headerlink" title="3 baseline"></a>3 baseline</h5><p>作者使用 Stanford Named Entity Recognition system(NER) 作为其 baseline。</p>
<blockquote>
<p>此处引用 J. R. Finkel, T. Grenager, and C. Manning. Incorporating non-local information into information extraction systems by gibbs sampling. In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 363–370. Association for Computational Linguistics, 2005.</p>
</blockquote>
<p>并使用为其使用了一个预训练数据集（脚标 12）。对于新数据集使用 baseline 模型进行重训练，随机采样 30% 与 70% 数据集作为训练集，其余数据作为测试集。baseline 的设置如下表所示：</p>
<p><img src="/images/pasted-230.png" alt="upload successful"><br>表 4：斯坦福 NER 在模型重训练时的参数设置</p>
<h5 id="4-相关参数"><a href="#4-相关参数" class="headerlink" title="4 相关参数"></a>4 相关参数</h5><p>词向量表示中，使用 100 维，低词频词的词频比例阈值设为 0.01。（这些参数作者说是根据之前的相关论文设定的，但是在这儿没有引用具体论文）。滑动窗口大小设置为 (2,2)，作者在此描述尝试使用了更大的滑动窗口但是没有很好的效果。</p>
<p>分类器采用随机森林分类，树数量为 10，变量重要性度量方式为 Gini 指数法，找出最佳的 20 个特征进行分类，使用 ANOVA（方差分析）作为评估函数。</p>
<p><strong>评估指标</strong>：准确率、回归率与 F1 指标</p>
<p><strong>实验环境</strong>：iMac，4GHz Intel core i7，32 GB RAM，Scikit-learn v0.18</p>
<h5 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5 实验结果"></a>5 实验结果</h5><p>直接贴论文中实验结果的指标表格：</p>
<p><img src="/images/pasted-231.png" alt="upload successful"></p>
<p>表 5：baseline 与此系统在训练 30% 数据时的 PRF 指标</p>
<p><img src="/images/pasted-232.png" alt="upload successful"></p>
<p>表 6：baseline 与此系统在训练 70% 数据时的 PRF 指标</p>
<p><img src="/images/pasted-233.png" alt="upload successful"></p>
<p>表 7：训练 30% 数据时，此系统在不同全集中的 F1 指标</p>
<p><img src="/images/pasted-234.png" alt="upload successful"></p>
<p>表 8：训练 70% 数据时，此系统在不同全集中的 F1 指标</p>
<p><img src="/images/pasted-235.png" alt="upload successful"></p>
<p>图 5：训练 30% 数据时，在姓名属性识别中，使用不同特征数量得到的 PRF 指标变化折线图</p>
<p><img src="/images/pasted-236.png" alt="upload successful"></p>
<p>表 9：系统识别城市名称的一些样例</p>
<h5 id="6-讨论"><a href="#6-讨论" class="headerlink" title="6 讨论"></a>6 讨论</h5><p>（作者”解释“了前面我关于为什么不使用 word2vec 的疑惑）作者表示，他也不清楚为啥不能使用 word2vec 之类更具适应性的算法来代替 Random Indexing 算法。不过表 7 与表 8 可以看到 Random Indexing 算法在不断加入更多网站的情况下表现仍然稳定。</p>
<p><img src="/images/pasted-237.png" alt="upload successful"></p>
<p>表 10：在一万数据集与全集中 Random Indexing 算法找到的相似语义样例</p>
<p>由表 10 可以看到 Random Indexing 算法在不同数据集大小下表现的鲁棒性，给出的相似语义词依然较为准确。</p>
<p><img src="/images/pasted-238.png" alt="upload successful"></p>
<p>图 6：城市名称上下文分类时的可视化图（不同的颜色表示在标准数据集中的标签）</p>
<p>使用 t-SNE 工具对数据进行可视化，得到上图。</p>
<blockquote>
<p>t-SNE 工具引用了 L. v. d. Maaten and G. Hinton. Visualizing data using t-sne. Journal of Machine Learning Research, 9(Nov):2579–2605, 2008.</p>
</blockquote>
<p>由图可见，分类器对城市名称正负例分类效果良好。另外可以观察到图中有许多点各自又组成了一些”子聚类“（sub-cluster），这些点来自于上下文比较相似的数据。</p>
<p>最后，作者表示他们在后来的工作中对一些不常见的属性（例如一些领域特定属性）进行了测试，仍然得到了相似的性能。因此这种方法在各种情况都适用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作者提出了一种轻量、特征不可知的信息提取方式，适用于非法 Web 领域。这种方法基于初始本体集中构建的向量表示，与使用高 recall 的分类器结合，得到了良好的结果。实验结果表明这种方法相对于其 baseline（CRF）有明显的提升。论文中的各种代码都在 github 上进行了公开。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/27/Uber-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0-%E2%80%94-%E7%B1%B3%E5%BC%80%E6%9C%97%E5%9F%BA%E7%BD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/27/Uber-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B9%B3%E5%8F%B0-%E2%80%94-%E7%B1%B3%E5%BC%80%E6%9C%97%E5%9F%BA%E7%BD%97/" class="post-title-link" itemprop="url">Uber 机器学习平台 — 米开朗基罗</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-27 20:04:46" itemprop="dateCreated datePublished" datetime="2017-09-27T20:04:46+08:00">2017-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Uber 工程师们一直致力于开发各种新技术，以让客户得到有效、无缝的用户体验。现在，他们正在加大对人工智能、机器学习领域的投入来实现这个愿景。在 Uber，工程师们开发出了一个名为“米开朗基罗”（Michelangelo）的机器学习平台，它是一个内部的“MLaaS”（机器学习即服务）平台，用以降低机器学习开发的门槛，并能根据不同的商业需求对 AI 进行拓展与缩放，就有如客户使用 Uber 打车一样方便。</p>
<p>米开朗基罗平台可以让公司内部团队无缝构建、部署与运行 Uber 规模的机器学习解决方案。它旨在覆盖全部的端到端机器学习工作流，包括：数据管理、训练模型、评估模型、部署模型、进行预测、预测监控。此系统不仅支持传统的机器学习模型，还支持时间序列预测以及深度学习。</p>
<p>米开朗基罗在 Uber 投产约一年时间，已经成为了 Uber 工程师、数据科学家真正意义上的“平台”，现在有数十个团队在此平台上构建、部署模型。实际上，米开朗基罗平台现在部署于多个 Uber 数据中心并使用专用硬件，用于为公司内最高负载的在线服务提供预测功能。</p>
<p>本文将介绍米开朗基罗以及其产品用例，并简单通过这个强大的 MLaaS 系统介绍整个机器学习工作流。</p>
<h2 id="米开朗基罗背后的动机"><a href="#米开朗基罗背后的动机" class="headerlink" title="米开朗基罗背后的动机"></a>米开朗基罗背后的动机</h2><p>在米开朗基罗平台出现前，Uber 的工程师和数据科学家们在构建、部署一些公司需要，并且能根据实际操作进行规模拓展的机器学习模型时，遇到了很多挑战。那时他们试图使用各种各样的工具来创建预测模型（如 R 语言、<a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/">scikit-learn</a>、自定义算法等），此时工程团队会构建一些一次性的系统以使用这些模型进行预测。因此，在 Uber 内能够在短时间内使用各种开源工具构建出框架的数据科学家与工程师少之又少，限制了机器学习在公司内的应用。</p>
<p>具体来说，那时没有建立一个可靠、统一、pipeline 可复用的系统用于创建、管理、训练、预测规模化数据。因此在那时，不会有人做出数据科学家的台式机跑不了的模型，也没有一个规范的结果存储方式，要将几个实验结果进行对比也是相当困难的事情。更重要的是，那时没有一种将模型部署到生产环境的确定方法。因此，大多数情况下都是相关的工程团队不得不为手中的项目开发定制的服务容器。这时，他们注意到了这些迹象符合由 Scully 等人记录的<a target="_blank" rel="noopener" href="https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf">机器学习的反模式</a>一文的描述。</p>
<p>米开朗基罗旨在将整个团队的工作流程和工具标准化，通过端对端系统让整个公司的用户都能轻松构建、运行大型机器学习系统。但是工程师们的目标不仅限于解决这些直观的问题，更是要创立一个能与业务共同发展的体系。</p>
<p>当工程师们于 2015 年年中开始构建米开朗基罗系统时，他们也开始解决一些规模化模型训练以及一些将模型部署于生产环境容器的问题。接着，他们专注于构建能够更好进行管理、共享特征 pipeline 的系统。而最近，他们的重心转移到了开发者生产效率 — 如何加速从想法到产品模型的实现以及接下来的快速迭代。</p>
<p>下一节将通过一个样例来介绍如何使用米开朗基罗构建、部署一个模型，用于解决 Uber 的某种特定问题。虽然下面重点讲的是 <a target="_blank" rel="noopener" href="https://www.ubereats.com/">UberEATS</a> 中的具体用例，但是这个平台也管理着公司里其他针对多种预测用例的类似模型。</p>
<h2 id="用例：UberEATS-送餐到家时间预估模型"><a href="#用例：UberEATS-送餐到家时间预估模型" class="headerlink" title="用例：UberEATS 送餐到家时间预估模型"></a>用例：UberEATS 送餐到家时间预估模型</h2><p>UberEATS 在米开朗基罗中有数个模型在运行，包括送餐到达时间预测、搜索排行、搜索自动完成、餐厅排行等。送餐到达时间预测模型能够预测准备膳食、送餐以及送餐过程中的各个阶段所需的时间。</p>
<p><img src="/images/pasted-214.png" alt="upload successful"></p>
<p>图 1：UberEATS app 提供了估测外卖送达时间的功能，此功能由基于米开朗基罗构建的机器学习模型驱动。</p>
<p>预测外卖的送达时间（ETD）并不是一件简单的事情。当 UberEATS 用户下单时，订单将被送到餐厅进行处理。餐厅需要确认订单，根据订单的复杂度以及餐厅的繁忙程度准备餐品，这一步自然要花费一些时间。在餐品快要准备完毕的时候，Uber 外卖员出发去取餐。接着，外卖员需要开车到达餐厅、找到停车场、进餐厅取餐、回到车里、开车前往客户家（这个步骤耗时取决于路线、交通等因素）、找到车位、走到客户家门口，最终完成交货。UberEATS 的目标就是预测这个复杂的多阶段过程的总时间，并在各个步骤重新计算 ETD。</p>
<p>在米开朗基罗平台上，UberEATS 数据科学家们使用了 GBDT（梯度提升决策树）回归模型来预测这种端到端的送达时间。此模型使用的特征包括请求信息（例如时间、送餐地点）、历史特征（例如餐厅在过去 7 天中的平均餐食准备时间）、以及近似实时特征（例如最近一小时的平均餐食准备时间）。此模型部署于 Uber 数据中心的米开朗基罗平台提供的容器中，通过 UberEATS 微服务提供网络调用。预测结果将在餐食准备及送达前展示给客户。</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>米开朗基罗系统由一些开源系统和内置组件组成。主要使用的开源组件有 <a target="_blank" rel="noopener" href="http://hadoop.apache.org/">HDFS</a>、<a target="_blank" rel="noopener" href="https://spark.apache.org/">Spark</a>、<a target="_blank" rel="noopener" href="http://samza.apache.org/">Samza</a>、<a target="_blank" rel="noopener" href="http://cassandra.apache.org/">Cassandra</a>、<a target="_blank" rel="noopener" href="https://spark.apache.org/mllib/">MLLib</a>、<a target="_blank" rel="noopener" href="https://github.com/dmlc/xgboost">XGBoost</a>、<a target="_blank" rel="noopener" href="https://www.tensorflow.org/">TensorFlow</a>。在条件允许的前提下，开发团队更倾向于使用一些成熟的开源系统，并会进行 fork、定制化，如果有需求的话也会对其进行贡献。如果找不到合适的开源解决方案，他们也会自己构建一些系统。</p>
<p>米开朗基罗系统建立与 Uber 的数据及计算基础设施之上，它们提供了一个“数据湖”，其中包含了 Uber 所有的事务和日志数据。由 Kafka 对 Uber 的所有服务日志进行采集汇总，使用 Cassandra 集群管理的 Samza 流计算引擎以及 Uber 内部服务进行计算与部署。</p>
<p>在下一节中将以 UberEATS 的 ETD 模型为例，简单介绍系统的各个层次，说明米开朗基罗的技术细节。</p>
<h2 id="机器学习工作流"><a href="#机器学习工作流" class="headerlink" title="机器学习工作流"></a>机器学习工作流</h2><p>在 Uber，大多数的机器学习用例（包括一些正在做的工作，例如分类、回归以及时间序列预测等）都有着一套同样的工作流程。这种工作流程可以与具体实现分离，因此很容易进行拓展以支持新的算法和框架（例如最新的深度学习框架）。它还适用于各种不同预测用例的部署模式（如在线部署与离线部署，在车辆中使用与在手机中使用）。</p>
<p>米开朗基罗专门设计提供可拓展、可靠、可重用、易用的自动化工具，用于解决下面 6 步工作流：</p>
<ol>
<li>管理数据</li>
<li>训练模型</li>
<li>评估模型</li>
<li>部署模型</li>
<li>预测结果</li>
<li>预测监控</li>
</ol>
<p>下面将详细介绍米开朗基罗的架构是如何促进工作流中的各个步骤的。</p>
<h2 id="管理数据"><a href="#管理数据" class="headerlink" title="管理数据"></a>管理数据</h2><p>找出良好的特征经常是是机器学习最难的部分，工程师们也发现整个机器学习解决方案中最费时费力的部分就是构建及管理数据管道。</p>
<p>因此，平台应提供一套标准工具以构建数据管道，生成特征，对数据集进行标记（用于训练及再训练），以及提供无标记特征数据用以预测，这些工具需要与公司的数据湖、数据中心以及公司的在线数据服务系统进行深度的整合。构建出来的数据管道必须具有可缩放性以及足够的性能，能够监控数据流以及数据质量，为各种在线/离线训练与预测都提供全面的支持。这些工具还应该能通过团队共享的方式生成特征，以减少重复工作并提高数据质量。此外，这些工具应当提供强有力的保护措施，鼓励用户去采用最好的方式使用工具（例如，保证在训练时和预测时都采用同一批次生成的数据）。</p>
<p>米开朗基罗的数据管理组件分为在线管道和离线管道。目前，离线管道主要用于为批量模型训练以及批量预测作业提供数据；在线管道主要为在线、低时延预测作业提供数据（以及之后会为在线学习系统提供支持）。</p>
<p>此外，工程师们还为数据管理层新加了一个特征存储系统，可以让各个团队共享、发现高质量的数据特征以解决他们的机器学习问题。工程师们发现，Uber 的许多模型都是用了类似或相同的特征，而在不同组织的团队以及团队里的不同项目中共享特征是一件很有价值的事情。</p>
<p><img src="/images/pasted-215.png" alt="upload successful"></p>
<p>图 2：数据预处理管道将数据存入特征库以及训练数据仓库中。</p>
<h3 id="离线部署"><a href="#离线部署" class="headerlink" title="离线部署"></a>离线部署</h3><p>Uber 的事务与日志数据会“流入”一个 HDFS 数据湖中，可以使用 Spark 和 Hive SQL 的计算作业轻松调用这些数据。平台提供了容器与计划任务两种方式运行常规作业，用于计算项目内部的私有特征或将其发布至特征存储库（见后文）与其他团队共享。当计划任务运行批量作业或通过别的方式触发批量作业时，作业将被整合传入数据质量监控工具，此工具能够快速回溯找出问题出在 pipeine 中的位置，判明是本地代码的问题还是上游代码的问题导致的数据错误。</p>
<h3 id="在线部署"><a href="#在线部署" class="headerlink" title="在线部署"></a>在线部署</h3><p>在线部署的模型将无法访问 HDFS 存储的数据，因此，一些需要在 Uber 生产服务的支撑数据库中读取的特征很难直接用于这种在线模型（例如，无法直接查询 UberEATS 的订单服务去计算某餐厅某特定时间段平均膳食准备时间）。因此，工程师们将在线模型需要的特征预计算并存储在 Cassandra 中，线上模型可以低延迟读取这些数据。</p>
<p>在线部署支持两种计算系统：批量预计算与近实时计算，详情如下：</p>
<ul>
<li><strong>批量预计算</strong>。这个系统会定期进行大批量计算，并将 HDFS 中的特征历史记录加载进 Cassandra 数据库中。这样做虽然很简单粗暴，但是如果需要的特征对实时性要求不高（比如允许隔几小时更新一次），那么效果还是很好的。这个系统还能保证在批处理管道中用于训练和服务的数据是同批次的。UberEATS 就采用了这个系统处理一部分特征，如“餐厅过去七天的膳食平均准备时间”。</li>
<li><strong>近实时计算</strong>。这个系统会将相关指标发布至 Kafka 系统，接着运行 Samza 流计算作业以低时延生成所有特征。接着这些特征将直接存入 Cassandra 数据库用于提供服务，并同时备份至 HDFS 用于之后的训练作业。和批量预计算系统一样，这样做同样能保证提供服务和进行训练的数据为同一批次。为了避免这个系统的冷启动，工程师们还专门为这个系统制作了一个工具，用于“回填”数据与基于历史记录运行批处理生成训练数据。UberEATS 就使用了这种近实时计算 pipeline 来得到如“餐厅过去一小时的膳食平均准备时间”之类的特征。</li>
</ul>
<h3 id="共享特征库"><a href="#共享特征库" class="headerlink" title="共享特征库"></a>共享特征库</h3><p>工程师们发现建立一个集中的特征库是很有用的，这样 Uber 的各个团队可以使用其他团队创建和管理的可靠的特征，且特征可以被分享。从大方向上看，它做到了以下两件事情：</p>
<ol>
<li>它可以让用户轻松地将自己构建的特征存入共享特征库中（只需要增加少许元数据，如添加者、描述、SLA 等），另外它也能让一些特定项目使用的特征以私有形式存储。</li>
<li>只要特征存入了特征库，那之后再用它就十分简单了。无论是在线模型还是离线模型，都只要简单地在模型配置中写上特征的名称就行了。系统将会从 HDFS 取出正确的数据，进行处理后返回相应的特征集既可以用于模型训练，也可以用于批量预测或者从 Cassandra 取值做在线预测。</li>
</ol>
<p>目前，Uber 的特征库中有大约 10000 个特征用于加速机器学习工程的构建，公司的各个团队还在不断向其中增加新的特征。特征库中的特征每天都会进行自动计算与更新。</p>
<p>未来，工程师们打算构建自动化系统，以进行特征库搜索并找出解决给定预测问题的最有用的特征。</p>
<p><strong>用于特征选择及转换的领域特定语言（DSL）。</strong></p>
<p>由数据 pipeline 生成的特征与客户端服务传来的特征经常不符合模型需要的数据格式，而且这些数据时常会缺失一些值，需要对其进行填充；有时候，模型可能只需要传入的特征的一个子集；还有的时候，将传入的时间戳转换为 小时/天 或者 天/周 会在模型中起到更好的效果；另外，还可能需要对特征值进行归一化（例如减去平均值再除以标准差）。</p>
<p>为了解决这些问题，工程师们为建模人员创造了一种 DSL（领域特定语言），用于选择、转换、组合那些用于训练或用于预测的特征。这种 DSL 为 Scala 的子集，是一种纯函数式语言，包含了一套常用的函数集，工程师们还为这种 DSL 增加了自定义函数的功能。这些函数能够从正确的地方取出特征（离线模型从数据 pipeline 取特征值，在线模型从客户请求取特征值，或是直接从特征库中取出特征）。</p>
<p>此外，DSL 表达式是模型配置的一部分，在训练时取特征的 DSL 与在与测试时用的 DSL 需要保持一致，以确保任何时候传入模型的特征集的一致性。</p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>目前平台支持离线、大规模分布式训练，包括决策树、线性模型、逻辑模型、无监督模型（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/K-means_clustering">k-means</a>）、时间序列模型以及深度神经网络。工程师们将定期根据用户的需求增加一些由 Uber <a target="_blank" rel="noopener" href="https://www.uber.com/info/ailabs/">AI 实验室</a>新开发的模型。此外，用户也可以自己提供模型类型，包括自定义训练、评价以及提供服务的代码。分布式模型训练系统可以规模化处理数十亿的样本数据，也可以处理一些小数据集进行快速迭代。</p>
<p>一个模型的配置包括模型类型、超参、数据源、特征 DSL，以及计算资源需求（需要的机器数量、内存用量、是否使用 GPU 等）。这些信息将用于配置运行在 <a target="_blank" rel="noopener" href="https://yarnpkg.com/">YARN</a> 或 <a target="_blank" rel="noopener" href="https://yarnpkg.com/">Mesos</a> 集群上的训练作业。</p>
<p>在模型训练完毕之后，系统会将其计算得到的性能指标（例如 ROC 曲线和 PR 曲线）进行组合，得到一个模型评价报告。在训练结束时，系统会将原始配置、学习到的参数以及评价包括存回模型库，用于分析与部署。</p>
<p>除了训练单个模型之外，米开朗基罗系统还支持对分块模型等各种模型进行超参搜索。以分块模型为例，以分块模型为例，系统会根据用户配置自动对训练数据进行分块，对每个分块训练一个模型；在有需要的时候再将各个分块模型合并到父模型中（例如，先对每个城市数据进行训练，如果无法得到准确的市级模型时再将其合并为国家级模型）。</p>
<p>训练作业可以通过 Web UI 或者 API 进行配置与管理（通常使用 <a target="_blank" rel="noopener" href="http://jupyter.org/">Jupyter notebook</a>）。大多数团队都使用 API 以及流程管理工具来对他们的模型进行定期重训练。</p>
<p><img src="/images/pasted-216.png" alt="upload successful"></p>
<p>图 3：模型训练作业使用特征库与数据训练仓库中的数据集来训练模型，接着将模型存入模型库中。</p>
<h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><p>训练模型可以看成是一种寻找最佳特征、算法、超参以针对问题建立最佳模型的探索过程。在得到用例的理想模型前，训练数百种模型而一无所获也是常有的事。虽然这些失败的模型最终不能用于生产，但它们可以指导工程师们更好地进行模型配置，从而获得更好的性能。追踪这些训练过的模型（例如谁、何时训练了它们，用了什么数据集、什么超参等），对它们的性能进行评估、互相对比，可以为平台带来更多的价值与机会。不过要处理如此之多的模型，也是一个极大的挑战。</p>
<p>米开朗基罗平台中训练的每个模型都需要将以下信息作为版本对象存储在 Cassandra 的模型库中：</p>
<ul>
<li>谁训练的模型。</li>
<li>训练模型的开始时间与结束时间。</li>
<li>模型的全部配置（包括用了什么特征、超参的设置等）。</li>
<li>引用训练集和测试集。</li>
<li>描述每个特征的重要性。</li>
<li>模型准确性评价方法。</li>
<li>模型每个类型的标准评价表或图（例如 ROC 曲线图、PR 曲线图，以及二分类的混淆矩阵等）。</li>
<li>模型所有学习到的参数。</li>
<li>模型可视化摘要统计。</li>
</ul>
<p>用户可以通过 Web UI 或者使用 API 轻松获取这些数据，用以检查单个模型的详细情况或者对多个模型进行比较。</p>
<h3 id="模型准确率报告"><a href="#模型准确率报告" class="headerlink" title="模型准确率报告"></a>模型准确率报告</h3><p>回归模型的准确率报告会展示标准的准确率指标与图表；分类模型的准确率报告则会展示不同的分类集合，如图 4 图 5 所示：</p>
<p><img src="/images/pasted-217.png" alt="upload successful"></p>
<p>图 4：回归模型的报告展示了与回归相关的性能指标。</p>
<p><img src="/images/pasted-218.png" alt="upload successful"></p>
<p>图 5：二分类模型报告展示了分类相关的性能指标。</p>
<h3 id="可视化决策树"><a href="#可视化决策树" class="headerlink" title="可视化决策树"></a>可视化决策树</h3><p>决策树作为一种重要的模型类型，工程师们为其提供了可视化工具，以帮助建模者更好地理解模型的行为原理，并在建模者需要时帮助其进行调试。例如在一个决策树模型中，用户可以浏览每个树分支，看到其对于整体模型的重要程度、决策分割点、每个特征对于某个特定分支的权重，以及每个分支上的数据分布等变量。用户可以输入一个特征值，可视化组件将会遍历整个决策树的触发路径、每个树的预测、整个模型的预测，将数据展示成类似下图的样子：</p>
<p><img src="/images/pasted-219.png" alt="upload successful"></p>
<p>图 6：使用强大的树可视化组件查看树模型。</p>
<h3 id="特征报告"><a href="#特征报告" class="headerlink" title="特征报告"></a>特征报告</h3><p>米开朗基罗提供了特征报告，在报告中使用局部依赖图以及混合直方图展示了各个特征对于模型的重要性。选中两个特征可以让用户看到它们之间相互的局部依赖图表，如下所示：</p>
<p><img src="/images/pasted-220.png" alt="upload successful"></p>
<p>图 7：在特征报告中可以看到的特征、对模型的重要性以及不同特征间的相关性。</p>
<h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p>米开朗基罗支持使用 UI 或 API 端对端管理模型的部署。一个模型可以有下面三种部署方式：</p>
<ol>
<li><strong>离线部署</strong>。模型将部署于离线容器中，使用 Spark 作业，根据需求或计划任务进行批量预测。</li>
<li><strong>在线部署</strong>。模型将部署于在线预测服务集群（集群通常为使用负载均衡部署的数百台机器），客户端可以通过网络 RPC 调用发起单个或批量的预测请求。</li>
<li><strong>部署为库</strong>。工程师们希望能在服务容器中运行模型。可以将其整合为一个库，也可以通过 Java API 进行调用（在下图中没有展示此类型，不过这种方式与在线部署比较类似）。</li>
</ol>
<p><img src="/images/pasted-221.png" alt="upload successful"></p>
<p>图 8：模型库中的模型部署于在线及离线容器中用于提供服务。</p>
<p>上面所有情况中，所需要的模型组件（包括元数据文件、模型参数文件以及编译好的 DSL）都将被打包为 ZIP 文件，使用 Uber 的标准代码部署架构将其复制到 Uber 数据中心的相关数据上。预测服务容器将会从磁盘自动加载新模型，并自动开始处理预测请求。</p>
<p>许多团队都自己写了自动化脚本，使用米开朗基罗 API 进行一般模型的定期再训练及部署。例如 UberEATS 的送餐时间预测模型就由数据科学家和工程师通过 Web UI 控制进行训练与部署。</p>
<h3 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h3><p>一旦模型部署于服务容器并加载成功，它就可以开始用于对数据管道传来的特征数据或用户端发来的数据进行预测。原始特征将通过编译好的 DSL 传递，如有需要也可以对 DSL 进行修改以改进原始特征，或者从特征存储库中拉取一些额外的特征。最终构造出的特征向量会传递给模型进行评分。如果模型为在线模型，预测结果将通过网络传回给客户端。如果模型为离线模型，预测结果将被写回 Hive，之后可以通过下游的批处理作业或者直接使用 SQL 查询传递给用户，如下所示：</p>
<p><img src="/images/pasted-222.png" alt="upload successful"></p>
<p>图 9：在线预测服务及离线预测服务使用一组特征向量生成预测结果。</p>
<h3 id="引用模型"><a href="#引用模型" class="headerlink" title="引用模型"></a>引用模型</h3><p>在米开朗基罗平台中可以同时向服务容器部署多个模型。这也使得从旧模型向新模型进行无痛迁移以及对模型进行 A/B 测试成为可能。在服务中，可以由模型的 UUID 以及一个在部署时可指定的 tag（或者别名）识别不同的模型。以一个在线模型为例，客户端服务会将特征向量与需要使用的模型 UUID 或者 tag 同时发送给服务容器；如果使用的是 tag，服务容器会使用此 tag 对应的最新部署的模型进行预测。如果使用的是多个模型，所有对应的模型都将对各批次的数据进行预测，并将 UUID 和 tag 与预测结果一同传回，方便客户端进行筛选过滤。</p>
<p>如果在部署一个新模型替换旧模型时用了相同的事物（例如用了一些同样的特征），用户可以为新模型设置和旧模型一样的 tag，这样容器就会立即开始使用新模型。这可以让用户只需要更新模型，而不用去修改他们的客户端代码。用户也可以通过设置 UUID 来部署新模型，再将客户端或中间件配置中旧模型的 UUID 换成新的，逐步将流量切换到新模型去。</p>
<p>如果需要对模型进行 A/B 测试，用户可以通过 UUID 或者 tag 轻松地部署竞争模型，再使用客户端服务中的 Uber 实验框架将部分流量导至各个模型，再对性能指标进行评估。</p>
<h3 id="规模缩放与时延"><a href="#规模缩放与时延" class="headerlink" title="规模缩放与时延"></a>规模缩放与时延</h3><p>由于机器学习模型是无状态的，且不需要共享任何东西，因此，无论是在线模式还是离线模式下对它们进行规模缩放都是一件轻而易举的事情。如果是在线模型，工程师可以简单地给预测服务集群增加机器，使用负载均衡器分摊负载。如果是离线预测，工程师可以给 Spark 设置更多的 executor，让 Spark 进行并行管理。</p>
<p>在线服务的延迟取决于模型的类型与复杂度以及是否使用从 Cassandra 特征库中取出的特征。在模型不需要从 Cassandra 取特征的情况下，P95 测试延迟小于 5 毫秒。在需要从 Cassandra 取特征时，P95 测试延迟仍小于 10 毫秒。目前用量最大的模型每秒能提供超过 250000 次预测。</p>
<h3 id="预测监控"><a href="#预测监控" class="headerlink" title="预测监控"></a>预测监控</h3><p>当模型训练完成并完成评价之后，使用的数据都将是历史数据。监控模型的预测情况，是确保其在未来正常工作的重要保障。工程师需要确保数据管道传入的是正确的数据，并且生产环境没有发生变化，这样模型才能够进行准确的预测。</p>
<p>为了解决这个问题，米开朗基罗系统会自动记录并将部分预测结果加入到数据 pipeline 的标签中去，有了这些信息，就能得到持续的、实时的模型精确度指标。在回归模型中，会将 R^2/<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">决定系数</a>、<a target="_blank" rel="noopener" href="https://www.kaggle.com/wiki/RootMeanSquaredLogarithmicError">均方根对数误差</a>（RMSLE）、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">均方根误差</a>（RMSE）以及<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mean_absolute_error">平均绝对值误差</a>发布至 Uber 的实时监控系统中，用户可以分析指标与时间关系的图标，并设置阈值告警：</p>
<p><img src="/images/pasted-223.png" alt="upload successful"></p>
<p>图 10：对预测结果进行采样，与观测结果进行比较得到模型准确指标。</p>
<h3 id="管理层、API、Web-UI"><a href="#管理层、API、Web-UI" class="headerlink" title="管理层、API、Web UI"></a>管理层、API、Web UI</h3><p>米开朗基罗系统的最后一个重要部分就是 API 层了，它也是整个系统的大脑。API 层包含一个管理应用，提供了 Web UI 以及网络 API 两种访问方式，并与 Uber 的监控、报警系统相结合。同时该层还包含了用于管理批量数据管道、训练作业、批量预测作业、模型批量部署以及在线容器的工作流系统。</p>
<p>米开朗基罗的用户可以通过 Web UI、REST API 以及监控、管理工具直接与这些组件进行交互。</p>
<h2 id="米开朗基罗平台之后的构建工作"><a href="#米开朗基罗平台之后的构建工作" class="headerlink" title="米开朗基罗平台之后的构建工作"></a>米开朗基罗平台之后的构建工作</h2><p>工程师们打算在接下来几个月继续扩展与加强现有的系统，以支持不断增长的用户和 Uber 的业务。随着米开朗基罗平台各个层次的不断成熟，他们计划开发更高层的工具与服务，以推动机器学习在公司内部的发展，更好地支持商业业务：</p>
<ul>
<li><strong>AutoML</strong>。这是将会成为一个自动搜寻与发现模型配置的系统（包括算法、特征集、超参值等），可以为给定问题找到表现最佳的模型。该系统还会自动构建数据管道，根据模型的需要生成特征与标签。目前工程师团队已经通过特征库、统一的离线在线数据管道、超参搜索特征解决了此系统的一大部分问题。AutoML 系统可以加快数据科学的早期工作，数据科学家们只需要指定一组标签和一个目标函数，接着就能高枕无忧地使用 Uber 的数据找到解决问题的最佳模型了。这个系统的最终目标就是构建更智能的工具，简化数据科学家们的工作，从而提高生产力。</li>
<li><strong>模型可视化</strong>。对于机器学习，尤其是深度学习，理解与调试模型现在变得越来越重要。虽然工程师们已经首先为树状模型提供了可视化工具，但是还需要做更多的工作，帮助数据科学家理解、debug、调整他们的模型，得到真正令人信服的结果。</li>
<li><strong>在线学习</strong>。Uber 的机器学习模型大多数直接受到 Uber 产品的实时影响。这也意味着这些模型需要能够在复杂、不断变化的真实世界中运行。为了保证模型在变化环境中的准确性，这些模型需要随着环境一同进化；现在，各个团队会在米开朗基罗平台上定期对模型进行重训练。一个完整的平台式解决方案应该让用户能够轻松地对模型进行升级、快速训练及评价，有着更精细的监控及报警系统。虽然这将是一个很大的工程，但是早前的研究结果表明，构建完成在线学习系统可能会带来巨大的收益。</li>
<li><strong>分布式深度学习</strong>。越来越多的 Uber 机器学习系统开始使用深度学习实现。定义与迭代深度学习模型的工作流与标准的工作流有着很大的区别，因此需要平台对其进行额外的支持。深度学习需要处理更大的数据集，需要不同的硬件支持（例如 GPU），因此它更需要分布式学习的支持，以及与更具弹性的资源管理堆栈进行紧密结合。</li>
</ul>
<p>如果你对挑战规模化机器学习有兴趣，欢迎申请<a target="_blank" rel="noopener" href="https://www.uber.com/careers/list/?city=all&amp;country=all&amp;keywords=machine+learning+platform+team&amp;subteam=all&amp;team=all">Uber 机器学习平台团队</a> ！</p>
<p>作者简介：Jeremy Hermann 是 Uber 机器学习平台团队的工程经理，Mike Del Balso 是 Uber 机器学习平台团队的产品经理。</p>
<blockquote>
<p>发布于掘金 <a target="_blank" rel="noopener" href="https://juejin.im/post/59c8b4d56fb9a00a4843b2a6">https://juejin.im/post/59c8b4d56fb9a00a4843b2a6</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/10/%E5%A4%84%E7%90%86unbalanced-parenthesis%E6%83%85%E5%BD%A2%EF%BC%8C%E5%AF%B9%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/10/%E5%A4%84%E7%90%86unbalanced-parenthesis%E6%83%85%E5%BD%A2%EF%BC%8C%E5%AF%B9%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89/" class="post-title-link" itemprop="url">处理unbalanced parenthesis情形，对正则字符串进行转义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-09-10 02:00:14" itemprop="dateCreated datePublished" datetime="2017-09-10T02:00:14+08:00">2017-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Back-End/" itemprop="url" rel="index"><span itemprop="name">Back End</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 python re 处理数据时，程序提示“unbalanced parenthesis”，中文意思即为“不平衡的括号”。查看代码发现，在定义正则时使用了这样的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(<span class="string">r&quot;123&quot;</span> + str + <span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后排查发现数据中有几个例外的 str 含有括号，这些括号没有经过处理就直接传入了正则表达式中，变成了类似</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r&quot;123this is str)123&quot;</span></span><br></pre></td></tr></table></figure>
<p>的数据，造成错误。</p>
<p>翻阅 python re 文档发现，可以使用 re.escape 对字符串进行正则转义。如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> str)</span><br></pre></td></tr></table></figure>
<p>可以转成</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span><span class="string">\</span> <span class="keyword">is</span><span class="string">\</span> str<span class="string">\)</span></span><br></pre></td></tr></table></figure>
<p>这样传入正则就不会出现问题了。</p>
<blockquote>
<p>以后写正则如果还要传字符串进去一定要细心这类问题</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18029472号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsvih</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["$", "$"],["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="//cdn.jsdelivr.net/npm/algoliasearch@4.4.0/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.7.1/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













  








  

  

  

</body>
</html>
