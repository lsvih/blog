<!DOCTYPE html><html class="theme-next pisces"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0"><link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.5.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"6U6P1RGK4F",apiKey:"b14e73cdd627eabe947b5decbe14850f",indexName:"lsvih",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="My note"><meta property="og:url" content="https://lsvih.com/page/6/index.html"><meta property="og:site_name" content="My note"><meta property="og:locale" content="default"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="My note"><link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml"><link rel="canonical" href="https://lsvih.com/page/6/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>My note – lsvih</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My note</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">lsvih</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/21/使用-Python-spaCy-进行简易自然语言处理/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/07/21/使用-Python-spaCy-进行简易自然语言处理/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">使用 Python+spaCy 进行简易自然语言处理</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-07-21 22:35:00" itemprop="dateCreated datePublished" datetime="2017-07-21T22:35:00+08:00">2017-07-21</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自然语言处理（NLP）是人工智能领域最重要的部分之一。它在许多智能应用中担任了关键的角色，例如聊天机器人、正文提取、多语翻译以及观点识别等应用。业界 NLP 相关的公司都意识到了，处理非结构文本数据时，不仅要看正确率，还需要注意是否能快速得到想要的结果。</p><p>NLP 是一个很宽泛的领域，它包括了文本分类、实体识别、机器翻译、问答系统、概念识别等子领域。在我最近的一篇<a href="https://www.analyticsvidhya.com/blog/2017/01/ultimate-guide-to-understand-implement-natural-language-processing-codes-in-python/" target="_blank" rel="noopener">文章</a>中，我探讨了许多用于实现 NLP 的工具与组件。在那篇文章中，我更多的是在描述<a href="http://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>（Natural Language Toolkit）这个伟大的库。</p><p>在这篇文章中，我会将 spaCy —— 这个现在最强大、最先进的 NLP python 库分享给你们。</p><hr><h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><ol><li>spaCy 简介及安装方法</li><li><p>spaCy 的管道与属性</p><ul><li>Tokenization</li><li>词性标注</li><li>实体识别</li><li>依存句法分析</li><li>名词短语</li></ul></li><li><p>集成词向量计算</p></li><li>使用 spaCy 进行机器学习</li><li>与 NLTK 和 CoreNLP 对比</li></ol><hr><h2 id="1-spaCy-简介及安装方法"><a href="#1-spaCy-简介及安装方法" class="headerlink" title="1. spaCy 简介及安装方法"></a>1. spaCy 简介及安装方法</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>spaCy 由 cython（Python 的 C 语言拓展，旨在让 python 程序达到如同 C 程序一样的性能）编写，因此它的运行效率非常高。spaCy 提供了一系列简洁的 API 方便用户使用，并基于已经训练好的机器学习与深度学习模型实现底层。</p><hr><h3 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h3><p>spaCy 及其数据和模型可以通过 pip 和安装工具轻松地完成安装。使用下面的命令在电脑中安装 spaCy：</p><pre><code>sudo pip install spacy
</code></pre><p>如果你使用的是 Python3，请用 “pip3” 代替 “pip”。</p><p>或者你也可以在 <a href="https://pypi.python.org/pypi/spacy" target="_blank" rel="noopener">这儿</a> 下载源码，解压后运行下面的命令安装：</p><pre><code>python setup.py install
</code></pre><p>在安装好 spacy 之后，请运行下面的命令以下载所有的数据集和模型：</p><pre><code>python -m spacy.en.download all
</code></pre><p>一切就绪，现在你可以自由探索、使用 spacy 了。</p><h2 id="2-spaCy-的管道（Pipeline）与属性（Properties）"><a href="#2-spaCy-的管道（Pipeline）与属性（Properties）" class="headerlink" title="2. spaCy 的管道（Pipeline）与属性（Properties）"></a>2. spaCy 的管道（Pipeline）与属性（Properties）</h2><p>spaCy 的使用，以及其各种属性，是通过创建管道实现的。在加载模型的时候，spaCy 会将管道创建好。在 spaCy 包中，提供了各种各样的<a href="https://github.com/explosion/spacy-models/" target="_blank" rel="noopener">模块</a>，这些模块中包含了各种关于词汇、训练向量、语法和实体等用于语言处理的信息。</p><p>下面，我们会加载默认的模块（english-core-web 模块）。</p><pre><code>import spacy
nlp = spacy.load(“en”)
</code></pre><p>“nlp” 对象用于创建 document、获得 linguistic annotation 及其它的 nlp 属性。首先我们要创建一个 document，将文本数据加载进管道中。我使用了来自猫途鹰网的旅店评论数据。这个数据文件可以在<a href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2017/04/04080929/Tripadvisor_hotelreviews_Shivambansal.txt" target="_blank" rel="noopener">这儿</a>下载。</p><pre><code>document = unicode(open(filename).read().decode(&#39;utf8&#39;))
document = nlp(document)
</code></pre><p>这个 document 现在是 spacy.english 模型的一个 class，并关联上了许多的属性。可以使用下面的命令列出所有 document（或 token）的属性：</p><pre><code>dir(document)
&gt;&gt; [ &#39;doc&#39;, &#39;ents&#39;, … &#39;mem&#39;]
</code></pre><p>它会输出 document 中各种各样的属性，例如：token、token 的 index、词性标注、实体、向量、情感、单词等。下面让我们会对其中的一些属性进行一番探究。</p><h3 id="2-1-Tokenization"><a href="#2-1-Tokenization" class="headerlink" title="2.1 Tokenization"></a>2.1 Tokenization</h3><p>spaCy 的 document 可以在 tokenized 过程中被分割成单句，这些单句还可以进一步分割成单词。你可以通过遍历文档来读取这些单词：</p><pre><code># document 的首个单词
document[0]
&gt;&gt; Nice

# document 的最后一个单词  
document[len(document)-5]
&gt;&gt; boston

# 列出 document 中的句子
list(document.sents)
&gt;&gt; [ Nice place Better than some reviews give it credit for.,
 Overall, the rooms were a bit small but nice.,
...
Everything was clean, the view was wonderful and it is very well located (the Prudential Center makes shopping and eating easy and the T is nearby for jaunts out and about the city).]
</code></pre><h3 id="2-2-词性标注-POS-Tag"><a href="#2-2-词性标注-POS-Tag" class="headerlink" title="2.2 词性标注(POS Tag)"></a>2.2 词性标注(POS Tag)</h3><p>词性标注即标注语法正确的句子中的词语的词性。这些标注可以用于信息过滤、统计模型，或者基于某些规则进行文本解析。</p><p>来看看我们的 document 中所有的词性标注：</p><pre><code># 获得所有标注
all_tags = {w.pos: w.pos_ for w in document}
&gt;&gt; {97:  u&#39;SYM&#39;, 98: u&#39;VERB&#39;, 99: u&#39;X&#39;, 101: u&#39;SPACE&#39;, 82: u&#39;ADJ&#39;, 83: u&#39;ADP&#39;, 84: u&#39;ADV&#39;, 87: u&#39;CCONJ&#39;, 88: u&#39;DET&#39;, 89: u&#39;INTJ&#39;, 90: u&#39;NOUN&#39;, 91: u&#39;NUM&#39;, 92: u&#39;PART&#39;, 93: u&#39;PRON&#39;, 94: u&#39;PROPN&#39;, 95: u&#39;PUNCT&#39;}

# document 中第一个句子的词性标注
for word in list(document.sents)[0]:  
    print word, word.tag_
&gt;&gt; ( Nice, u&#39;JJ&#39;) (place, u&#39;NN&#39;) (Better, u&#39;NNP&#39;) (than, u&#39;IN&#39;) (some, u&#39;DT&#39;) (reviews, u&#39;NNS&#39;) (give, u&#39;VBP&#39;) (it, u&#39;PRP&#39;) (creit, u&#39;NN&#39;) (for, u&#39;IN&#39;) (., u&#39;.&#39;)
</code></pre><p>来看一看 document 中的最常用词汇。我已经事先写好了预处理和文本数据清洗的函数。</p><pre><code>#一些参数定义
noisy_pos_tags = [“PROP”]
min_token_length = 2

#检查 token 是不是噪音的函数
def isNoise(token):     
    is_noise = False
    if token.pos_ in noisy_pos_tags:
        is_noise = True
    elif token.is_stop == True:
        is_noise = True
    elif len(token.string) &lt;= min_token_length:
        is_noise = True
    return is_noise
def cleanup(token, lower = True):
    if lower:
       token = token.lower()
    return token.strip()

# 评论中最常用的单词
from collections import Counter
cleaned_list = [cleanup(word.string) for word in document if not isNoise(word)]
Counter(cleaned_list) .most_common(5)
&gt;&gt; [( u&#39;hotel&#39;, 683), (u&#39;room&#39;, 652), (u&#39;great&#39;, 300),  (u&#39;sheraton&#39;, 285), (u&#39;location&#39;, 271)]
</code></pre><h3 id="2-3-实体识别"><a href="#2-3-实体识别" class="headerlink" title="2.3 实体识别"></a>2.3 实体识别</h3><p>spaCy 拥有一个快速实体识别模型，这个实体识别模型能够从 document 中找出实体短语。它能识别各种类型的实体，例如人名、位置、机构、日期、数字等。你可以通过“.ents”属性来读取这些实体。</p><p>下面让我们来获取我们 document 中所有类型的命名实体：</p><pre><code>labels = set([w.label_ for w in document.ents])
for label in labels:
    entities = [cleanup(e.string, lower=False) for e in document.ents if label==e.label_]
    entities = list(set(entities))
    print label,entities
</code></pre><h3 id="2-4-依存句法分析"><a href="#2-4-依存句法分析" class="headerlink" title="2.4 依存句法分析"></a>2.4 依存句法分析</h3><p>spaCy 最强大的功能之一就是它可以通过调用轻量级的 API 来实现又快又准确的依存分析。这个分析器也可以用于句子边界检测以及区分短语块。依存关系可以通过“.children”、“.root”、“.ancestor”等属性读取。</p><pre><code># 取出所有句中包含“hotel”单词的评论
hotel = [sent for sent in document.sents if &#39;hotel&#39; in sent.string.lower()]

# 创建依存树
sentence = hotel[2] for word in sentence:
print word, &#39;: &#39;, str(list(word.children))
&gt;&gt; A :  []  cab :  [A, from]
from :  [airport, to]
the :  []
airport :  [the]
to :  [hotel]
the :  [] hotel :  
[the] can :  []
be :  [cab, can, cheaper, .]
cheaper :  [than] than :  
[shuttles]
the :  []
shuttles :  [the, depending]
depending :  [time] what :  []
time :  [what, of] of :  [day]
the :  [] day :  
[the, go] you :  
[]
go :  [you]
. :  []
</code></pre><p>解析所有居中包含“hotel”单词的句子的依存关系，并检查对于 hotel 人们用了哪些形容词。我创建了一个自定义函数，用于分析依存关系并进行相关的词性标注。</p><pre><code># 检查修饰某个单词的所有形容词
def pos_words (sentence, token, ptag):
    sentences = [sent for sent in sentence.sents if token in sent.string]     
    pwrds = []
    for sent in sentences:
        for word in sent:
            if character in word.string:
                   pwrds.extend([child.string.strip() for child in word.children
                                                      if child.pos_ == ptag] )
    return Counter(pwrds).most_common(10)

pos_words(document, &#39;hotel&#39;, “ADJ”)
&gt;&gt; [(u&#39;other&#39;, 20), (u&#39;great&#39;, 10), (u&#39;good&#39;, 7), (u&#39;better&#39;, 6), (u&#39;nice&#39;, 6), (u&#39;different&#39;, 5), (u&#39;many&#39;, 5), (u&#39;best&#39;, 4), (u&#39;my&#39;, 4), (u&#39;wonderful&#39;, 3)]
</code></pre><h3 id="2-5-名词短语（NP）"><a href="#2-5-名词短语（NP）" class="headerlink" title="2.5 名词短语（NP）"></a>2.5 名词短语（NP）</h3><p>依存树也可以用来生成名词短语：</p><pre><code># 生成名词短语
doc = nlp(u&#39;I love data science on analytics vidhya&#39;)
for np in doc.noun_chunks:
    print np.text, np.root.dep_, np.root.head.text
&gt;&gt; I nsubj love
   data science dobj love
   analytics pobj on
</code></pre><h2 id="3-集成词向量"><a href="#3-集成词向量" class="headerlink" title="3. 集成词向量"></a>3. 集成词向量</h2><p>spaCy 提供了内置整合的向量值算法，这些向量值可以反映词中的真正表达信息。它使用 <a href="https://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">GloVe</a> 来生成向量。GloVe 是一种用于获取表示单词的向量的无监督学习算法。</p><p>让我们创建一些词向量，然后对其做一些有趣的操作吧：</p><pre><code>from numpy import dot
from numpy.linalg import norm
from spacy.en import English
parser = English()

# 生成“apple”的词向量 
apple = parser.vocab[u&#39;apple&#39;]

# 余弦相似性计算函数
cosine = lambda v1, v2: dot(v1, v2) / (norm(v1) * norm(v2))
others = list({w for w in parser.vocab if w.has_vector and w.orth_.islower() and w.lower_ != unicode(&quot;apple&quot;)})

# 根据相似性值进行排序
others.sort(key=lambda w: cosine(w.vector, apple.vector))
others.reverse()


print &quot;top most similar words to apple:&quot;
for word in others[:10]:
    print word.orth_
&gt;&gt; apples iphone f ruit juice cherry lemon banana pie mac orange
</code></pre><h2 id="4-使用-spaCy-对文本进行机器学习"><a href="#4-使用-spaCy-对文本进行机器学习" class="headerlink" title="4. 使用 spaCy 对文本进行机器学习"></a>4. 使用 spaCy 对文本进行机器学习</h2><p>将 spaCy 集成进机器学习模型是非常简单、直接的。让我们使用 sklearn 做一个自定义的文本分类器。我们将使用 cleaner、tokenizer、vectorizer、classifier 组件来创建一个 sklearn 管道。其中的 tokenizer 和 vectorizer 会使用我们用 spaCy 自定义的模块构建。</p><pre><code>from sklearn.feature_extraction.stop_words import ENGLISH_STOP_WORDS as stopwords
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics import accuracy_score
from sklearn.base import TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.svm import LinearSVC

import string
punctuations = string.punctuation

from spacy.en import English
parser = English()

# 使用 spaCy 自定义 transformer
class predictors(TransformerMixin):
    def transform(self, X, **transform_params):
        return [clean_text(text) for text in X]
    def fit(self, X, y=None, **fit_params):
        return self
    def get_params(self, deep=True):
        return {}

# 进行文本清洗的实用的基本函数
def clean_text(text):     
    return text.strip().lower()
</code></pre><p>现在让我们使用 spaCy 的解析器和一些基本的数据清洗函数来创建一个自定义的 tokenizer 函数。值得一提的是，你可以用词向量来代替文本特征（使用深度学习模型效果会有较大的提升）</p><pre><code>#创建 spaCy tokenizer，解析句子并生成 token
#也可以用词向量函数来代替它
def spacy_tokenizer(sentence):
    tokens = parser(sentence)
    tokens = [tok.lemma_.lower().strip() if tok.lemma_ != &quot;-PRON-&quot; else tok.lower_ for tok in tokens]
    tokens = [tok for tok in tokens if (tok not in stopwords and tok not in punctuations)]     return tokens

#创建 vectorizer 对象，生成特征向量，以此可以自定义 spaCy 的 tokenizer
vectorizer = CountVectorizer(tokenizer = spacy_tokenizer, ngram_range=(1,1)) classifier = LinearSVC()
</code></pre><p>现在可以创建管道，加载数据，然后运行分类模型了。</p><pre><code># 创建管道，进行文本清洗、tokenize、向量化、分类操作
pipe = Pipeline([(&quot;cleaner&quot;, predictors()),
                 (&#39;vectorizer&#39;, vectorizer),
                 (&#39;classifier&#39;, classifier)])

# Load sample data
train = [(&#39;I love this sandwich.&#39;, &#39;pos&#39;),          
         (&#39;this is an amazing place!&#39;, &#39;pos&#39;),
         (&#39;I feel very good about these beers.&#39;, &#39;pos&#39;),
         (&#39;this is my best work.&#39;, &#39;pos&#39;),
         (&quot;what an awesome view&quot;, &#39;pos&#39;),
         (&#39;I do not like this restaurant&#39;, &#39;neg&#39;),
         (&#39;I am tired of this stuff.&#39;, &#39;neg&#39;),
         (&quot;I can&#39;t deal with this&quot;, &#39;neg&#39;),
         (&#39;he is my sworn enemy!&#39;, &#39;neg&#39;),          
         (&#39;my boss is horrible.&#39;, &#39;neg&#39;)]
test =   [(&#39;the beer was good.&#39;, &#39;pos&#39;),     
         (&#39;I do not enjoy my job&#39;, &#39;neg&#39;),
         (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;),
         (&quot;I feel amazing!&quot;, &#39;pos&#39;),
         (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;),
         (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;)]

# 创建模型并计算准确率
pipe.fit([x[0] for x in train], [x[1] for x in train])
pred_data = pipe.predict([x[0] for x in test])
for (sample, pred) in zip(test, pred_data):
    print sample, pred
print &quot;Accuracy:&quot;, accuracy_score([x[1] for x in test], pred_data)

&gt;&gt;    (&#39;the beer was good.&#39;, &#39;pos&#39;) pos
      (&#39;I do not enjoy my job&#39;, &#39;neg&#39;) neg
      (&quot;I ain&#39;t feelin dandy today.&quot;, &#39;neg&#39;) neg
      (&#39;I feel amazing!&#39;, &#39;pos&#39;) pos
      (&#39;Gary is a good friend of mine.&#39;, &#39;pos&#39;) pos
      (&quot;I can&#39;t believe I&#39;m doing this.&quot;, &#39;neg&#39;) neg
      Accuracy: 1.0
</code></pre><h2 id="5-和其它库的对比"><a href="#5-和其它库的对比" class="headerlink" title="5. 和其它库的对比"></a>5. 和其它库的对比</h2><p>Spacy 是一个非常强大且具备工业级能力的 NLP 包，它能满足大多数 NLP 任务的需求。可能你会思考：为什么会这样呢？</p><p>让我们把 Spacy 和另外两个 python 中有名的实现 NLP 的工具 —— CoreNLP 和 NLTK 进行对比吧！</p><h3 id="支持功能表"><a href="#支持功能表" class="headerlink" title="支持功能表"></a>支持功能表</h3><div class="table-container"><table><thead><tr><th>功能</th><th>Spacy</th><th>NLTK</th><th>Core NLP</th></tr></thead><tbody><tr><td>简易的安装方式</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Python API</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>多语种支持</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>分词</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>词性标注</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>分句</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>依存性分析</td><td>Y</td><td>N</td><td>Y</td></tr><tr><td>实体识别</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>词向量计算集成</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>情感分析</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>共指消解</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table></div><h3 id="速度：主要功能（Tokenizer、Tagging、Parsing）速度"><a href="#速度：主要功能（Tokenizer、Tagging、Parsing）速度" class="headerlink" title="速度：主要功能（Tokenizer、Tagging、Parsing）速度"></a>速度：主要功能（Tokenizer、Tagging、Parsing）速度</h3><div class="table-container"><table><thead><tr><th><strong>库</strong></th><th><strong>Tokenizer</strong></th><th><strong>Tagging</strong></th><th><strong>Parsing</strong></th></tr></thead><tbody><tr><td>spaCy</td><td>0.2ms</td><td>1ms</td><td>19ms</td></tr><tr><td>CoreNLP</td><td>2ms</td><td>10ms</td><td>49ms</td></tr><tr><td>NLTK</td><td>4ms</td><td>443ms</td><td>–</td></tr></tbody></table></div><h3 id="准确性：实体抽取结果"><a href="#准确性：实体抽取结果" class="headerlink" title="准确性：实体抽取结果"></a>准确性：实体抽取结果</h3><div class="table-container"><table><thead><tr><th><strong>库</strong></th><th><strong>准确率</strong></th><th><strong>Recall</strong></th><th><strong>F-Score</strong></th></tr></thead><tbody><tr><td>spaCy</td><td>0.72</td><td>0.65</td><td>0.69</td></tr><tr><td>CoreNLP</td><td>0.79</td><td>0.73</td><td>0.76</td></tr><tr><td>NLTK</td><td>0.51</td><td>0.65</td><td>0.58</td></tr></tbody></table></div><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文讨论了 spaCy —— 这个基于 python，完全用于实现 NLP 的库。我们通过许多用例展示了 spaCy 的可用性、速度及准确性。最后我们还将其余其它几个著名的 NLP 库 —— CoreNLP 与 NLTK 进行了对比。</p><p>如果你能真正理解这篇文章要表达的内容，那你一定可以去实现各种有挑战的文本数据与 NLP 问题。</p><p>希望你能喜欢这篇文章，如果你有疑问、问题或者别的想法，请在评论中留言。</p><p>作者介绍：</p><p><a href="https://www.analyticsvidhya.com/blog/author/shivam5992/" target="_blank" rel="noopener">Shivam Bansal</a></p><p>Shivam Bansal 是一位数据科学家，在 NLP 与机器学习领域有着丰富的经验。他乐于学习，希望能解决一些富有挑战性的分析类问题。</p><ul><li><a href="https://twitter.com/shivamshaz" target="_blank" rel="noopener">https://twitter.com/shivamshaz</a></li><li><a href="https://www.linkedin.com/in/shivambansal1" target="_blank" rel="noopener">https://www.linkedin.com/in/shivambansal1</a></li><li><a href="https://github.com/shivam5992" target="_blank" rel="noopener">https://github.com/shivam5992</a></li></ul><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5971a4b9f265da6c42353332" target="_blank" rel="noopener">https://juejin.im/post/5971a4b9f265da6c42353332</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/10/你会给想学习机器学习的软件工程师提出什么建议？/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/07/10/你会给想学习机器学习的软件工程师提出什么建议？/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">你会给想学习机器学习的软件工程师提出什么建议？</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-07-10 14:51:00" itemprop="dateCreated datePublished" datetime="2017-07-10T14:51:00+08:00">2017-07-10</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>这很大一部分都取决于这名软件工程师的背景，以及他希望掌握机器学习的哪一部分。为了具体讨论，现在假设这是一名初级工程师，他读了 4 年本科，从业 2 年，现在想从事计算广告学（CA）、自然语言处理（NLP）、图像分析、社交网络分析、搜索、推荐排名相关领域。现在，让我们从机器学习的必要课程开始讨论（声明：下面的清单很不完整，如果您的论文没有被包括在内，提前向您抱歉）。</p><ul><li><p>线性代数<br>很多的机器学习算法、统计学原理、模型优化都依赖线性代数。这也解释了为何在深度学习领域 GPU 要优于 CPU。在线性代数方面，你至少得熟练掌握以下内容：</p><ul><li>标量、向量、矩阵、张量。你可以将它们看成零维、一维、二维、三维与更高维的对象，可以对它们进行各种组合、变换，就像乐高玩具一样。它们为数据变换提供了最基础的处理方法。</li><li>特征向量、标准化、矩阵近似、分解。实质上这些方法都是为了方便线性代数的运算。如果你想分析一个矩阵是如何运算的（例如检查神经网络中梯度消失问题，或者检查强化学习算法发散的问题），你得了解矩阵与向量应用了多少种缩放方法。而低阶矩阵近似与 Cholesky 分解可以帮你写出性能更好、稳定性更强的代码。</li><li>数值线性代数<br>如果你想进一步优化算法的话，这是必修课。它对于理解核方法与深度学习很有帮助，不过对于图模型及采样来说它并不重要。</li><li>推荐书籍<br><a href="http://www.amazon.com/Linear-Algebra-Undergraduate-Texts-Mathematics/dp/0387964126" target="_blank" rel="noopener">《Serge Lang, Linear Algebra》</a><br>很基础的线代书籍，很适合在校学生。<br><a href="http://www.amazon.com/Linear-Analysis-Introductory-Cambridge-Mathematical/dp/0521655773" target="_blank" rel="noopener">《Bela Bolobas, Linear Analysis》</a><br>这本书目标人群是那些想做数学分析、泛函分析的人。当然它的内容更加晦涩难懂，但更有意义。如果你攻读 PhD，值得一读。<br><a href="http://www.amazon.com/Numerical-Linear-Algebra-Lloyd-Trefethen/dp/0898713617" target="_blank" rel="noopener">《Lloyd Trefethen and David Bau, Numerical Linear Algebra》</a><br>这本书是同类书籍中较为推荐的一本。<a href="http://www.amazon.com/Numerical-Recipes-Scientific-Computing-Second/dp/0521431085/" target="_blank" rel="noopener">《Numerical Recipes》</a>也是一本不错的书，但是里面的算法略为过时了。另外，推荐 Golub 和 van Loan 合著的书<a href="http://www.amazon.com/Computations-Hopkins-Studies-Mathematical-Sciences/dp/1421407949/" target="_blank" rel="noopener">《Matrix Computations》</a>。</li></ul></li><li><p>优化与基础运算</p><p>大多数时候提出问题是很简单的，而解答问题则是很困难的。例如，你想对一组数据使用线性回归（即线性拟合），那么你应该希望数据点与拟合线的距离平方和最小；又或者，你想做一个良好的点击预测模型，那么你应该希望最大程度地提高用户点击广告概率估计的准确性。也就是说，在一般情况下，我们会得到一个客观问题、一些参数、一堆数据，我们要做的就是找到通过它们解决问题的方法。找到这种方法是很重要的，因为我们一般得不到闭式解。</p><ul><li><p>凸优化</p><p>在大多情况下，优化问题不会存在太多的局部最优解，因此这类问题会比较好解决。这种“局部最优即全局最优”的问题就是凸优化问题。</p><p>（如果你在集合的任意两点间画一条直线，整条线始终在集合范围内，则这个集合是一个凸集合；如果你在一条函数曲线的任意两点间画一条直线，这两点间的函数曲线始终在这条直线之下，则这个函数是一个凸函数）</p><p>Steven Boyd 与 Lieven Vandenberghe <a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">合著的书</a>可以说是这个领域的规范书籍了，这本书非常棒，而且是免费的，值得一读；此外，你可以在 <a href="http://web.stanford.edu/~boyd/" target="_blank" rel="noopener">Boyd 的课程</a>中找到很多很棒的幻灯片；<a href="http://www.mit.edu/~dimitrib/home.html" target="_blank" rel="noopener">Dimitri Bertsekas</a> 写了一系列关于优化、控制方面的书籍。读通这些书足以让任何一个人在这个领域立足。</p></li><li><p>随机梯度下降（SGD）</p><p>大多数问题其实最开始都是凸优化问题的特殊情况（至少早期定理如此），但是随着数据的增加，凸优化问题的占比会逐渐减少。因此，假设你现在得到了一些数据，你的算法将会需要在每一个更新步骤前将所有的数据都检查一遍。</p><p>现在，我不怀好意地给了你 10 份相同的数据，你将不得不重复 10 次没有任何帮助的工作。不过在现实中并不会这么糟糕，你可以设置很小的更新迭代步长，每次更新前都将所有的数据检查一遍，这种方法将会帮你解决这类问题。小步长计算在机器学习中已经有了很大的转型，配合上一些相关的算法会使得解决问题更加地简单。</p><p>不过，这样的做法对并行化计算提出了挑战。我们于 2009 年发表的<a href="http://arxiv.org/abs/0911.0491" target="_blank" rel="noopener">《Slow Learners are Fast》</a>论文可能就是这个方向的先导者之一。2013 年牛峰等人发表的<a href="https://www.eecs.berkeley.edu/~brecht/papers/hogwildTR.pdf" target="_blank" rel="noopener">《Hogwild》</a>论文给出了一种相当优雅的无锁版本变体。简而言之，这类各种各样的算法都是通过在单机计算局部梯度，并异步更新共有的参数集实现并行快速迭代运算。</p><p>随机梯度下降的另一个难题就是如何控制过拟合（例如可以通过正则化加以控制）。另外还有一种解决凸优化的惩罚方式叫近端梯度算法（PGD）。最流行的当属 Amir Beck 和 Marc Teboulle 提出的 <a href="http://people.rennes.inria.fr/Cedric.Herzet/Cedric.Herzet/Sparse_Seminar/Entrees/2012/11/12_A_Fast_Iterative_Shrinkage-Thresholding_Algorithmfor_Linear_Inverse_Problems_(A._Beck,_M._Teboulle" target="_blank" rel="noopener">FISTA 算法</a>_files/Breck_2009.pdf)了。相关代码可以参考 Francis Bach 的 <a href="http://spams-devel.gforge.inria.fr/" target="_blank" rel="noopener">SPAM toolbox</a>。</p></li><li><p>非凸优化方法</p><p>许多的机器学习问题是非凸的。尤其是与深度学习相关的问题几乎都是非凸的，聚类、主题模型（topic model）、潜变量方法（latent variable method）等各种有趣的机器学习方法也是如此。一些最新的加速技术将对此有所帮助。例如我的学生 <a href="http://www.cs.cmu.edu/~sjakkamr/" target="_blank" rel="noopener">Sashank Reddy</a> 最近展示了如何在这种情况下得到良好的<a href="http://arxiv.org/abs/1603.06160" target="_blank" rel="noopener">收敛</a><a href="http://arxiv.org/abs/1603.06159" target="_blank" rel="noopener">速率</a>。</p><p>也可以用一种叫做谱学习算法（Spectral Method）的技术。<a href="http://newport.eecs.uci.edu/anandkumar/" target="_blank" rel="noopener">Anima Anandkumar</a> 在最近的 <a href="/profile/Anima-Anandkumar-1">Quora session</a> 中详细地描述了这项技术的细节。请仔细阅读她的文章，因为里面干货满满。简而言之，凸优化问题并不是唯一能够可靠解决的问题。在某些情况中你可以试着找出其问题的数学等价形式，通过这样找到能够真正反映数据中聚类、主题、相关维度、神经元等一切信息的参数。如果你愿意且能够将一切托付给数学解决，那是一件无比伟大的事。</p><p>最近，在深度神经网络训练方面涌现出了各种各样的新技巧。我将会在下面介绍它们，但是在一些情况中，我们的目标不仅仅是优化模型，而是找到一种特定的解决方案（就好像旅途的重点其实是过程一样）。</p></li></ul></li><li><p>（分布式）系统</p><p>机器学习之所以现在成为了人类、测量学、传感器及数据相关领域几乎是最常用的工具，和过去 10 年规模化算法的发展密不可分。<a href="http://research.google.com/pubs/jeff.html" target="_blank" rel="noopener">Jeff Dean</a> 过去的一年发了 6 篇机器学习教程并不是巧合。在此简单介绍一下他：<a href="http://www.informatika.bg/jeffdean" target="_blank" rel="noopener">点击查看</a>，他是 MapReduce、GFS 及 BigTable 等技术背后的创造者，正是这些技术让 Google 成为了伟大的公司。</p><p>言归正传，（分布式）系统研究为我们提供了分布式、异步、容错、规模化、简单（Simplicity）的宝贵工具。最后一条“简单”是机器学习研究者们常常忽视的一件事。简单（Simplicity）不是 bug，而是一种特征。下面这些技术会让你受益良多：</p><ul><li><p>分布式哈希表</p><p>它是 <a href="https://memcached.org/" target="_blank" rel="noopener">memcached</a>、<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">dynamo</a>、<a href="http://research.microsoft.com/en-us/um/people/antr/PAST/pastry.pdf" target="_blank" rel="noopener">pastry</a> 以及 <a href="http://docs.ceph.com/docs/hammer/rados/" target="_blank" rel="noopener">ceph</a> 等的技术基础。它们所解决的都是同一件事情 —— 如何将对象分发到多台机器上，从而避免向中央存储区提出请求。为了达到这个目的，你必须将数据位置进行随机但确定的编码（即哈希）。另外，你需要考虑到当有机器出现故障时的处理方式。</p><p>我们自己的参数服务器就是使用这种<a href="https://www.cs.cmu.edu/~dga/papers/osdi14-paper-li_mu.pdf" target="_blank" rel="noopener">数据布局</a>。这个项目的幕后大脑是我的学生 <a href="http://www.cs.cmu.edu/~muli/" target="_blank" rel="noopener">Mu Li</a> 。请参阅 <a href="http://dmlc.ml/" target="_blank" rel="noopener">DMLC</a> 查看相关的工具集。</p></li><li><p>一致性与通信</p><p>这一切的基础都是 Leslie Lamport 的 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">PAXOS</a> 协议。它解决了不同机器（甚至部分机器不可用）的一致性问题。如果你曾经使用过版本控制工具，你应该可以直观地明白它是如何运行的——比如你有很多机器（或者很多开发者）都在进行数据更新（或更新代码），在它们（他们）不随时进行交流的情况下，你会如何将它们（他们）结合起来（不靠反复地求 diff）?</p><p>在（分布式）系统中，解决方案是一个叫做向量时钟的东西（请参考 Google 的 <a href="http://blogoscoped.com/archive/2008-07-24-n69.html" target="_blank" rel="noopener">Chubby</a>）。我们也在参数服务器上使用了这种向量时钟的变体，这个变体与本体的区别就是我们仅使用向量时钟来限制参数的范围（Mu Li 做的），这样可以确保内存不会被无限增长的向量时钟时间戳给撑爆，正如文件系统不需要给每个字节都打上时间戳。</p></li><li><p>容错机制、规模化与云</p><p>学习这些内容最简单的方法就是在云服务器上运行各种算法，至于云服务可以找 <a href="http://aws.amazon.com" target="_blank" rel="noopener">Amazon AWS</a>、<a href="http://console.google.com" target="_blank" rel="noopener">Google GWC</a>、<a href="http://azure.microsoft.com" target="_blank" rel="noopener">Microsoft Azure</a> 或者 <a href="http://serverbear.com/" target="_blank" rel="noopener">其它各种各样的服务商</a>。一次性启动 1,000 台服务器，意识到自己坐拥如此之大的合法“僵尸网络”是多么的让人兴奋！之前我在 Google 工作，曾在欧洲某处接手 5,000 余台高端主机作为主题模型计算终端，它们是我们通过能源法案获益的核电厂相当可观的一部分资源。我的经理把我带到一旁，偷偷告诉我这个实验是多么的昂贵……</p><p>可能入门这块最简单的方法就是去了解 <a href="http://www.docker.com" target="_blank" rel="noopener">docker</a> 了吧。现在 docker 团队已经开发了大量的规模化工具。特别是他们最近加上的 <a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">Docker Machine</a> 和 <a href="https://docs.docker.com/cloud/" target="_blank" rel="noopener">Docker Cloud</a>，可以让你就像使用打印机驱动一样连接云服务。</p></li><li><p>硬件</p><p>说道硬件可能会让人迷惑，但是如果你了解你的算法会在什么硬件上运行，对优化算法是很有帮助的。这可以让你知道你的算法是否能在任何条件下保持巅峰性能。我认为每个入门者都应该看看 Jeff Dean 的 <a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener">《每个工程师都需要记住的数值》</a>。我在面试时最喜欢的问题（至少现在最喜欢）就是“请问你的笔记本电脑有多快”。了解是什么限制了算法的性能是很有用的：是缓存？是内存带宽？延迟？还是磁盘？或者别的什么？<a href="http://www.anandtech.com" target="_blank" rel="noopener">Anandtech</a> 在微处理器架构与相关方面写了很多很好的文章与评论，在 Intel、ARM、AMD 发布新硬件的时候不妨去看一看他的评论。</p></li></ul></li><li><p>统计学</p><p>我故意把这块内容放在文章的末尾，因为几乎所有人都认为它是（它的确是）机器学习的关键因而忽视了其它内容。统计学可以帮你问出好的问题，也能帮你理解你的建模与实际数据有多接近。</p><p>大多数图模型、核方法、深度学习等都能从“问一个好的问题”得到改进，或者说能够定义一个合理的可优化的目标函数。</p><ul><li><p>统计学相关资料<br><a href="http://www.stat.cmu.edu/~larry/" target="_blank" rel="noopener">Larry Wasserman</a> 的书<a href="http://www.stat.cmu.edu/~larry/all-of-statistics/" target="_blank" rel="noopener">《All of Statistics》</a>很好地介绍了统计学。或者你也可以看看 David McKay 的 <a href="http://www.inference.phy.cam.ac.uk/itprnn/book.pdf" target="_blank" rel="noopener">《Machine Learning》</a>一书，它是免费的，内容丰富而全面。此外还有很多好书值得一看，例如 <a href="https://mitpress.mit.edu/books/machine-learning-0" target="_blank" rel="noopener">Kevin Murphy</a> 的、<a href="http://research.microsoft.com/en-us/um/people/cmbishop/prml/" target="_blank" rel="noopener">Chris Bishop</a> 的、以及 <a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/" target="_blank" rel="noopener">Trevor Hastie、Rob Tibshirani 与 Jerome Friedman</a> 合著的书。还有，Bernhard Scholkopf 和我也<a href="https://mitpress.mit.edu/books/learning-kernels" target="_blank" rel="noopener">写了一本</a>。</p></li><li><p>随机算法与概率计算</p><p>统计学算法本质上也是个计算机科学方面的问题。但是统计学的算法与计算机科学的最大区别在于，统计学是将计算机作为一个工具来设计算法，而不是作为一个黑箱进行调参。我很喜欢<a href="http://www.amazon.com/Probability-Computing-Randomized-Algorithms-Probabilistic/dp/0521835402" target="_blank" rel="noopener">这本 Michael Mitzenmacher 与 Eli Upfal 合著的书</a>，它涵盖了很多方面的问题，并且很容易读懂。另外如果你想更深入地了解这个“工具”，请阅读<a href="http://www.amazon.com/Randomized-Algorithms-Rajeev-Motwani/dp/0521474655" target="_blank" rel="noopener">这本 Rajeev Motwani 和 Prabhakar Raghavan 合著的书籍</a>。这本书写的很棒，但是没有统计学背景很难理解它。</p></li></ul></li></ul><p>这篇文章已经写的够久了，不知道有没有人能读到这里，我要去休息啦。现在网上有很多很棒的视频内容可以帮助你学习，许多教师现在都开通了他们的 Youtube 频道，上传他们的上课内容。这些课程有时可以帮你解决一些复杂的问题。这儿是<a href="https://www.youtube.com/user/smolix/playlists" target="_blank" rel="noopener">我的 Youtube 频道</a>欢迎订阅。顺便推荐 <a href="https://www.youtube.com/user/ProfNandoDF" target="_blank" rel="noopener">Nando de Freitas 的 Youtube 频道</a>，他比我讲得好多了。</p><p>最后推荐一个非常好用的工具：<a href="http://www.dmlc.ml" target="_blank" rel="noopener">DMLC</a>。它很适合入门，包含了大量的分布式、规模化的机器学习算法，还包括了通过 MXNET 实现的神经网络。</p><p>虽然本文还有很多方面没有提到（例如编程语言、数据来源等），但是这篇文章已经太长了，这些内容请参考其他文章吧~</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/596323416fb9a06bae1dff63" target="_blank" rel="noopener">https://juejin.im/post/596323416fb9a06bae1dff63</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/04/V8-性能优化杀手/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/07/04/V8-性能优化杀手/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">V8 性能优化杀手</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-07-04 12:58:00" itemprop="dateCreated datePublished" datetime="2017-07-04T12:58:00+08:00">2017-07-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章将会给你一些建议，让你避免写出性能远低于期望值的代码。在此特别指出有一些代码会导致 V8 引擎（涉及到 Node.JS、Opera、Chromium 等）无法对相关函数进行优化。</p><p>vhf 正在做一个类似的项目，试图将 V8 引擎的性能杀手全部列出来：<a href="https://github.com/vhf/v8-bailout-reasons" target="_blank" rel="noopener">V8 Bailout Reasons</a>。</p><h3 id="V8-引擎背景知识"><a href="#V8-引擎背景知识" class="headerlink" title="V8 引擎背景知识"></a>V8 引擎背景知识</h3><p>V8 引擎中没有解释器，但有 2 种不同的编译器：普通编译器与优化编译器。编译器会将你的 JavaScript 代码编译成汇编语言后直接运行。但这并不意味着运行速度会很快。被编译成汇编语言后的代码并不能显著地提高其性能，它只能省去解释器的性能开销，如果你的代码没有被优化的话速度依然会很慢。</p><p>例如，在普通编译器中 <code>a + b</code> 将会被编译成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">call RuntimeAdd</span><br></pre></td></tr></table></figure><p>换句话说，其实它仅仅调用了 runtime 函数。但如果 <code>a</code> 和 <code>b</code> 能确定都是整型变量，那么编译结果会是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">add eax, ebx</span><br></pre></td></tr></table></figure><p>它的执行速度会比前面那种去在 runtime 中调用复杂的 JavaScript 加法算法快得多。</p><p>通常来说，使用普通编译器将会得到前面那种代码，使用优化编译器将会得到后面那种代码。走优化编译器的代码可以说比走普通编译器的代码性能好上 100 倍。但是请注意，并不是任何类型的 JavaScript 代码都能被优化。在 JS 中，有很多种情况（甚至包括一些我们常用的语法）是不能被优化编译器优化的（这种情况被称为“bailout”，从优化编译器降级到普通编译器）。</p><p>记住一些会导致整个函数无法被优化的情况是很重要的。JS 代码被优化时，将会逐个优化函数，在优化各个函数的时候不会关心其它的代码做了什么（除非那些代码被内联在即将优化的函数中。）。</p><p>这篇文章涵盖了大多数会导致函数坠入“无法被优化的深渊”的情况。不过在未来，优化编译器进行更新后能够识别越来越多的情况时，下面给出的建议与各种变通方法可能也会变的不再必要或者需要修改。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ol><li><a href="#1-工具">工具</a></li><li><a href="#2-不支持的语法">不支持的语法</a></li><li><a href="#3-使用-arguments">使用 <code>arguments</code></a></li><li><a href="#4-switch-case">Switch-case</a></li><li><a href="#5-for-in">For-in</a></li><li><a href="#6-退出条件藏的很深-或者没有定义明确出口的无限循环">退出条件藏的很深，或者没有定义明确出口的无限循环</a></li></ol><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><p>你可以在 node.js 中使用一些 V8 自带的标记来验证不同的代码用法对优化的影响。通常来说你可以创建一个包括特定模式的函数，然后使用所有允许的参数类型去调用它，再使用 V8 的内部去优化与检查它：</p><p>test.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建包含需要检查的情况的函数（检查使用 `eval` 语句是否能被优化）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStatus</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(%GetOptimizationStatus(fn)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(<span class="string">"Function is not optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(<span class="string">"Function is always optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(<span class="string">"Function is never optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(<span class="string">"Function is maybe deoptimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized by TurboFan"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">"Unknown optimization status"</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别类型信息</span></span><br><span class="line">exampleFunction();</span><br><span class="line"><span class="comment">//这里调用 2 次是为了让这个函数状态从 uninitialized -&gt; pre-monomorphic -&gt; monomorphic</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line">%OptimizeFunctionOnNextCall(exampleFunction);</span><br><span class="line"><span class="comment">//再次调用</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查</span></span><br><span class="line">printStatus(exampleFunction);</span><br></pre></td></tr></table></figure><p>运行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">(v0.12.7) Function is not optimized</span><br><span class="line">(v4.0.0) Function is optimized by TurboFan</span><br></pre></td></tr></table></figure><p><a href="https://codereview.chromium.org/1962103003" target="_blank" rel="noopener">https://codereview.chromium.org/1962103003</a></p><p>为了检验我们做的这个工具是否真的有用，注释掉 <code>eval</code> 语句然后再运行一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">[optimizing 000003FFCBF74231 &lt;JS Function exampleFunction (SharedFunctionInfo 00000000FE1389E1)&gt; - took 0.345, 0.042, 0.010 ms]</span><br><span class="line">Function is optimized</span><br></pre></td></tr></table></figure><p>事实证明，使用这个工具来验证处理方法是可行且必要的。</p><h2 id="2-不支持的语法"><a href="#2-不支持的语法" class="headerlink" title="2. 不支持的语法"></a>2. 不支持的语法</h2><p>有一些语法结构是不支持被编译器优化的，用这类语法将会导致包含在其中的函数不能被优化。</p><p><strong>请注意</strong>，即使这些语句不会被访问到或者不会被执行，它仍然会导致整个函数不能被优化。</p><p>例如下面这样做是没用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEVELOPMENT) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使 debugger 语句根本不会被执行到，上面的代码将会导致包含它的整个函数都不能被优化。</p><p>目前不可被优化的语法有：</p><ul><li><del>Generator 函数</del> （<a href="https://v8project.blogspot.de/2017/02/v8-release-57.html" target="_blank" rel="noopener">V8 5.7</a> 对其做了优化）</li><li><del>包含 for of 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/11e1e20" target="_blank" rel="noopener">11e1e20</a> 对其做了优化）</li><li><del>包含 try catch 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li><li><del>包含 try finally 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li><li><del>包含<a href="http://stackoverflow.com/q/34595356/504611" target="_blank" rel="noopener"><code>let</code> 复合赋值</a>的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li><li><del>包含 <code>const</code> 复合赋值的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li><li>包含 <code>__proto__</code> 对象字面量、<code>get</code> 声明、<code>set</code> 声明的函数</li></ul><p>看起来永远不会被优化的语法有：</p><ul><li>包含 <code>debugger</code> 语句的函数</li><li>包含字面调用 <code>eval()</code> 的函数</li><li>包含 <code>with</code> 语句的函数</li></ul><p>最后明确一下：如果你用了下面任何一种情况，整个函数将不能被优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithProto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__proto__</span>: <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get prop() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithSetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        set prop(val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在此要特别提一下 <code>eval</code> 和 <code>with</code>，它们会导致它们的调用栈链变成动态作用域，可能会导致其它的函数也受到影响，因为这种情况无法从字面上判断各个变量的有效范围。</p><p><strong>变通办法</strong></p><p>前面提到的不能被优化的语句用在生产环境代码中是无法避免的，例如 <code>try-finally</code> 和 <code>try-catch</code>。为了让使用这些语句的影响尽量减小，它们需要被隔离在一个最小化的函数中，这样主要的函数就不会被影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorObject = &#123;<span class="attr">value</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">fn, ctx, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        errorObject.value = e;</span><br><span class="line">        <span class="keyword">return</span> errorObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = tryCatch(mightThrow, <span class="keyword">void</span> <span class="number">0</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//明确地报出 try-catch 会抛出什么</span></span><br><span class="line"><span class="keyword">if</span>(result === errorObject) &#123;</span><br><span class="line">    <span class="keyword">var</span> error = errorObject.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//result 是返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用-arguments"><a href="#3-使用-arguments" class="headerlink" title="3. 使用 arguments"></a>3. 使用 <code>arguments</code></h2><p>有许多种使用 <code>arguments</code> 的方式会导致函数不能被优化。因此当使用 <code>arguments</code> 的时候需要格外小心。</p><h4 id="3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例："><a href="#3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例：" class="headerlink" title="3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 arguments 引用的参数重新赋值。典型案例："></a>3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 <code>arguments</code> 引用的参数重新赋值。典型案例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultArgsReassign</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变通方法</strong> 是将参数值保存在一个新的变量中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = b_;</span><br><span class="line">    <span class="comment">//与 b_ 不同，可以安全地对 b 进行重新赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅仅是像上面这样用 <code>arguments</code>（上面代码作用为检测第二个参数是否存在，如果不存在则赋值为 5），也可以用 <code>undefined</code> 检测来代替这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="keyword">void</span> <span class="number">0</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是之后如果需要用到 <code>arguments</code>，很容易忘记需要在这儿加上重新赋值的语句。</p><p><strong>变通方法 2</strong>：为整个文件或者整个函数开启严格模式 （<code>&#39;use strict&#39;</code>）。</p><h4 id="3-2-arguments-泄露："><a href="#3-2-arguments-泄露：" class="headerlink" title="3.2. arguments 泄露："></a>3.2. arguments 泄露：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arguments</code> 对象在任何地方都不允许被传递或者被泄露。</p><p><strong>变通方法</strong> 可以通过创建一个数组来代理 <code>arguments</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//.length 仅仅是一个整数，不存在泄露</span></span><br><span class="line">                    <span class="comment">//arguments 对象本身的问题</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">                <span class="comment">//i 是 arguments 对象的合法索引值</span></span><br><span class="line">        args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherNotLeakingExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">while</span> (i--) args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样要写很多让人烦的代码，因此得判断是否真的值得这么做。后面一次又一次的优化会代理更多的代码，越来越多的代码意味着代码本身的意义会被逐渐淹没。</p><p>不过，如果你有 build 这个过程，可以将上面这一系列过程由一个不需要 source map 的宏来实现，保证代码为合法的 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    INLINE_SLICE(args, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bluebird 就使用了这个技术，上面的代码经过 build 之后会被拓展成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $_len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>($_len); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> $_i = <span class="number">0</span>; $_i &lt; $_len; ++$_i) &#123;</span><br><span class="line">        args[$_i] = <span class="built_in">arguments</span>[$_i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-对-arguments-进行赋值："><a href="#3-3-对-arguments-进行赋值：" class="headerlink" title="3.3. 对 arguments 进行赋值："></a>3.3. 对 arguments 进行赋值：</h4><p>在非严格模式下可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignToArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变通方法</strong>：犯不着写这么蠢的代码。另外，在严格模式下它会报错。</p><h4 id="那么如何安全地使用-arguments-呢？"><a href="#那么如何安全地使用-arguments-呢？" class="headerlink" title="那么如何安全地使用 arguments 呢？"></a>那么如何安全地使用 <code>arguments</code> 呢？</h4><p>只使用：</p><ul><li><code>arguments.length</code></li><li><code>arguments[i]</code> <strong><code>i</code> 需要始终为 arguments 的合法整型索引，且不允许越界</strong></li><li>除了 <code>.length</code> 和 <code>[i]</code>，不要直接使用 <code>arguments</code></li><li>严格来说用 <code>fn.apply(y, arguments)</code> 是没问题的，但除此之外都不行（例如 <code>.slice</code>）。 <code>Function#apply</code> 是特别的存在。</li><li>请注意，给函数添加属性值（例如 <code>fn.$inject = ...</code>）和绑定函数（即 <code>Function#bind</code> 的结果）会生成隐藏类，因此此时使用 <code>#apply</code> 不安全。</li></ul><p>如果你按照上面的安全方式做，毋需担心使用 <code>arguments</code> 导致不确定 arguments 对象的分配。</p><h2 id="4-Switch-case"><a href="#4-Switch-case" class="headerlink" title="4. Switch-case"></a>4. Switch-case</h2><p>在以前，一个 switch-case 语句最多只能包含 128 个 case 代码块，超过这个限制的 switch-case 语句以及包含这种语句的函数将不能被优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">over128Cases</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="number">128</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">129</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要让 case 代码块的数量保持在 128 个之内，否则应使用函数数组或者 if-else。</p><p>这个限制现在已经被解除了，请参阅此 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=2275#c9" target="_blank" rel="noopener">comment</a>。</p><h2 id="5-For-in"><a href="#5-For-in" class="headerlink" title="5. For-in"></a>5. For-in</h2><p>For-in 语句在某些情况下会导致整个函数无法被优化。</p><p>这也解释了”For-in 速度不快“之类的说法。</p><h4 id="5-1-键不是局部变量："><a href="#5-1-键不是局部变量：" class="headerlink" title="5.1. 键不是局部变量："></a>5.1. 键不是局部变量：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种用法db都将会导致函数不能被优化的问题。因此键不能在上级作用域定义，也不能在下级作用域被引用。它必须是一个局部变量。</p><h4 id="5-2-被遍历的对象不是一个”简单可枚举对象“"><a href="#5-2-被遍历的对象不是一个”简单可枚举对象“" class="headerlink" title="5.2. 被遍历的对象不是一个”简单可枚举对象“"></a>5.2. 被遍历的对象不是一个”简单可枚举对象“</h4><h5 id="5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"><a href="#5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。" class="headerlink" title="5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"></a>5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashTableIteration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashTable = &#123;<span class="string">"-"</span>: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> hashTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你给一个对象动态增加了很多的属性（在构造函数外）、<code>delete</code> 属性或者使用不合法的标识符作为属性，这个对象将会变成哈希表模式。换句话说，当你把一个对象当做哈希表来用，它就真的会变成哈希表。请不要对这种对象使用 <code>for-in</code>。你可以用过开启 Node.JS 的 <code>--allow-natives-syntax</code>，调用 <code>console.log(%HasFastProperties(obj))</code> 来判断一个对象是否为哈希表模式。</p><hr><h5 id="5-2-2-对象的原型链中存在可枚举属性"><a href="#5-2-2-对象的原型链中存在可枚举属性" class="headerlink" title="5.2.2. 对象的原型链中存在可枚举属性"></a>5.2.2. 对象的原型链中存在可枚举属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面这么做会给所有对象（除了用 <code>Object.create(null)</code> 创建的对象）的原型链中添加一个可枚举属性。此时任何包含了 <code>for-in</code> 语法的函数都不会被优化（除非仅遍历 <code>Object.create(null)</code> 创建的对象）。</p><p>你可以使用 <code>Object.defineProperty</code> 创建不可枚举属性（不推荐在 runtime 中调用，但是在定义一些例如原型属性之类的静态数据的时候它很高效）。</p><hr><h5 id="5-2-3-对象中包含可枚举数组索引"><a href="#5-2-3-对象中包含可枚举数组索引" class="headerlink" title="5.2.3. 对象中包含可枚举数组索引"></a>5.2.3. 对象中包含可枚举数组索引</h5><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4" target="_blank" rel="noopener">ECMAScript 262 规范</a> 定义了一个属性是否有数组索引：</p><blockquote><p>数组对象会给予一些种类的属性名特殊待遇。对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 2<sup>32</sup>−1 时，它是个 数组索引 。一个属性名是数组索引的属性也叫做元素 。</p></blockquote><p>一般只有数组有数组索引，但是有时候一般的对象也可能拥有数组索引： <code>normalObj[0] = value;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratesOverArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此使用 <code>for-in</code> 进行数组遍历不仅会比 for 循环要慢，还会导致整个包含 <code>for-in</code> 语句的函数不能被优化。</p><hr><p>如果你试图使用 <code>for-in</code> 遍历一个非简单可枚举对象，它会导致包含它的整个函数不能被优化。</p><p><strong>变通方法</strong>：只对 <code>Object.keys</code> 使用 <code>for-in</code>，如果要遍历数组需使用 for 循环。如果非要遍历整个原型链上的属性，需要将 <code>for-in</code> 隔离在一个辅助函数中以降低影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        ret.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-退出条件藏的很深，或者没有定义明确出口的无限循环"><a href="#6-退出条件藏的很深，或者没有定义明确出口的无限循环" class="headerlink" title="6. 退出条件藏的很深，或者没有定义明确出口的无限循环"></a>6. 退出条件藏的很深，或者没有定义明确出口的无限循环</h2><p>有时候在你写代码的时候，你需要用到循环，但是不确定循环体内的代码之后会是什么样子。所以这时候你用了一个 <code>while (true) {</code> 或者 <code>for (;;) {</code>，在之后将终止条件放在循环体中，打断循环进行后面的代码。然而你写完这些之后就忘了这回事。在重构时，你发现这个函数很慢，出现了反优化情况 - 上面的循环很可能就是罪魁祸首。</p><p>重构时将循环内的退出条件放到循环的条件部分并不是那么简单。</p><ol><li>如果代码中的退出条件是循环最后的 if 语句的一部分，且代码至少要运行一轮，那么你可以将这个循环重构为 <code>do{} while ();</code>。</li><li>如果退出条件在循环的开头，请将它放在循环的条件部分中去。</li><li>如果退出条件在循环体中部，你可以尝试”滚动“代码：试着依次将一部分退出条件前的代码移到后面去，然后在之前的位置留下它的引用。当退出条件可以放在循环条件部分，或者至少变成一个浅显的逻辑判断时，这个循环就不再会出现反优化的情况了。</li></ol><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5959edfc5188250d83241399" target="_blank" rel="noopener">https://juejin.im/post/5959edfc5188250d83241399</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/30/在html中使用背景透明的video视频/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/30/在html中使用背景透明的video视频/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">在html中使用背景透明的video视频</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-30 16:53:24" itemprop="dateCreated datePublished" datetime="2017-06-30T16:53:24+08:00">2017-06-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>由于对效果的要求，需要加入透明背景的video。经过了解，现代浏览器（新版 Chrome、Firefox、Safari 等）已经全面支持 webM 格式的视频了，因此可以使用带 alpha 通道的 webM 格式视频满足要求。</p><p>要得到透明 webM 格式视频，则需要来源视频已经带有透明通道。</p><p>目前有几种方法：</p><p>1、使用 blander 进行绿幕抠图，将 green screen 扣去，生成背景透明的 png 帧序列，然后使用 ffmpeg 之类的工具将其生成 webM 文件。</p><p>2、使用 Adobe After Effect 之类的软件，在渲染时直接输出 Alpha + RGB 通道文件，然后使用 ffmpeg 之类的工具将其转换为 webM 文件。</p><blockquote><p>ffmpeg 软件下载：<a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener">https://ffmpeg.org/download.html</a></p></blockquote><p>由于视频是自己用 AE 做的，因此直接选用第二种方法很方便。</p><p>首先，将视频背景颜色改成透明的：</p><p><img src="/images/pasted-166.png" alt="upload successful"></p><p>模式选择 Alpha 添加。在工作区下方将网络切换为透明网络</p><p><img src="/images/pasted-167.png" alt="upload successful"></p><p>如果改成功了，此时应该看到工作区的背景是灰白两色栅格。</p><p>将合成添加到渲染队列，进行设置：</p><p><img src="/images/pasted-168.png" alt="upload successful"></p><p>将输出模块改为“使用 Alpha 无损耗”，此时详情应该可以看到格式为 QuickTime，通道是 RGB + Alpha</p><p><img src="/images/pasted-169.png" alt="upload successful"></p><p>渲染输出，得到 .mov 文件，使用 ffmpeg 对其进行压缩编码。</p><p>执行命令：</p><pre><code>ffmpeg -i in.mov -c:a libvorbis -ac 1 -b:a 96k -ar 48000 -b:v 1100k -maxrate 1100k -bufsize 1835k out.webm
</code></pre><p>得到 out.webm，它就是所需要的透明背景的 webM 文件了，可以在网页中使用 <code>&lt;video&gt;</code> tag 引用。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/15/用-Go-语言理解-Tensorflow/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">用 Go 语言理解 Tensorflow</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-15 15:41:00" itemprop="dateCreated datePublished" datetime="2017-06-15T15:41:00+08:00">2017-06-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>根据官方说明，Tensorflow 开发者发布了以下内容：</p><ul><li><p>C++ 源码：底层和高层的具体功能由 C ++ 源码实现，它是真正 Tensorflow 的核心。</p></li><li><p>Python 封装与Python 库：由 C++ 实现自动生成的封装版本，通过这种方式我们可以直接用 Python 来调用 C++ 函数：这也是 numpy 的核心实现方式。</p><p>Python 库通过将 Python 封装版的各种调用结合起来，组成了各种广为人知的高层 API。</p></li><li><p>Java 封装</p></li><li><p>Go 封装</p></li></ul><p>作为一名 Gopher 而非一名 java 爱好者，我对 Go 封装给予了极大的关注，希望了解其适用于何种任务。</p><blockquote><p>译注，这里说的”封装“也有说法叫做”语言界面“</p></blockquote><h2 id="Go-封装"><a href="#Go-封装" class="headerlink" title="Go 封装"></a>Go 封装</h2><p><img src="/images/pasted-165.png" alt="upload successful"></p><p>图为 Gopher（由 Takuya Ueda <a href="https://twitter.com/tenntenn" target="_blank" rel="noopener">@tenntenn</a> 创建，遵循 CC 3.0 协议）与 Tensorflow 的 Logo 结合在一起。</p><hr><p>首先要注意的是，代码维护者自己也承认了，Go API 缺少 <code>Variable</code> 支持，因此这个 API 仅用于<strong>使用</strong>训练好的模型，而<strong>不能用于</strong>进行模型训练。</p><p>在文档 <a href="https://www.tensorflow.org/versions/master/install/install_go" target="_blank" rel="noopener">Installing Tensorflow for Go</a> 中已经明确提到：</p><blockquote><p>TensorFlow 为 Go 编程提供了一些 API。这些 API 特别适合加载在 Python 中创建的模型，让其在 Go 应用 中运行。</p></blockquote><p>如果我们对训练机器学习模型没兴趣，那这个限制是 OK 的。</p><p>但是，如果你打算自己训练模型，请看下面给的建议：</p><blockquote><p>作为一名 Gopher，请让 Go 保持简洁！使用 Python 去定义、训练模型，在这之后你随时都可以用 Go 来加载训练好的模型！（意思就是他们懒得开发呗）</p></blockquote><p>简而言之，golang 版 tensorflow 可以<strong>导入与定义</strong>常数图（constant graph）。这个常数图指的是在图中没有训练过程，也没有需要训练的变量。</p><p>让我们用 Golang 深入研究 Tensorflow 吧！首先创建我们的第一个应用。</p><p>我建议读者在阅读下面的内容前，先准备好 Go 环境，以及编译、安装好 Tensorflow Go 版（编译、安装过程参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/go/README.md" target="_blank" rel="noopener">README</a>）。</p><h2 id="理解-Tensorflow-的结构"><a href="#理解-Tensorflow-的结构" class="headerlink" title="理解 Tensorflow 的结构"></a>理解 Tensorflow 的结构</h2><p>先复习一下什么是 Tensorflow 吧！（这是我个人的理解，和<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">官网</a>的有所不同）</p><blockquote><p>TensorFlow™ 是一个采用数据流图(data flow graphs),用于数值计算的开源软件库。节点（Nodes）在图中<strong>表示</strong>数学操作，图中的线（edges）则<strong>表示</strong>在节点间相互联系的多维数据数组，即张量（tensor）。</p></blockquote><p>我们可以把 Tensorflow 看做一种类似于 SQL 的描述性语言，首先你得确定你需要什么数据，它会通过底层引擎（数据库）分析你的查询语句，检查你的句法错误和语法错误，将查询语句转换为私有语言表达式，进行优化之后运算得出计算结果。这样，它能保证将正确的结果传达给你。</p><p>因此，我们无论使用什么 API 实质上都是在描述一个图。我们将它放在 <code>Session</code> 中作为求值的起点，这样做确定了这个图将会在这个 Session 中运行。</p><p>了解这一点，我们可以试着定义一个计算操作的图，并将其放在一个 <code>Session</code> 中进行求值。</p><p><a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go" target="_blank" rel="noopener">API 文档</a>中明确告知了 <code>tensorflow</code>（简称 <code>tf</code>）包与 <code>op</code> 包中的可用方法列表。</p><p>在这个列表中我们可以看到，这两个包中包含了一切我们需要用来定义与评价图的方法。</p><p><code>tf</code> 包中包含了各种构建基础结构的函数，例如 <code>Graph</code>（图）。<code>op</code> 包是最重要的包，它包含了由 C++ 实现自动生成的绑定等功能。</p><p>现在，假设我们要计算 AAA 与 xxx 的矩阵乘法：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fg9itnbsc7j31au06274m.jpg" alt=""></p><p>我假定你们都熟悉 tensorflow 图的定义，都了解 placeholder 并知道它们的工作原理。</p><p>下面的代码是一位 Tensorflow Python 用户第一次尝试时会写的代码。让我们给这个文件取名为 <code>attempt1.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span></span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">	x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line"></span><br><span class="line">	graph, err := root.Finalize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session</span><br><span class="line">	sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量</span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]</span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]</span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor</span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;</span><br><span class="line">		A: matrix,</span><br><span class="line">		x: column,</span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int64</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码写好了注释，我建议读者阅读上面的每一条注释。</p><p>现在，这位 Tensorflow Python 用户自我感觉良好，认为他的代码能够成功编译与运行。让我们试一试吧：</p><p><code>go run attempt1.go</code></p><p>然后他会看到：</p><p><code>panic: failed to add operation &quot;Placeholder&quot;: Duplicate node name in graph: &#39;Placeholder&#39;</code></p><p>等等，为什么会这样呢？</p><p>问题很明显。上面代码里出现了 2 个重名的“Placeholder”操作。</p><h2 id="第-1-课：node-IDs"><a href="#第-1-课：node-IDs" class="headerlink" title="第 1 课：node IDs"></a>第 1 课：node IDs</h2><p><strong>每次在我们调用方法定义一个操作的时候，不管他是否在之前被调用过，Python API 都会生成不同的节点</strong>。</p><p>所以，下面的代码没有任何问题，会返回 3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.placeholder(tf.int32, shape=())</span><br><span class="line">b = tf.placeholder(tf.int32, shape=())</span><br><span class="line">add = tf.add(a,b)</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(sess.run(add, feed_dict=&#123;a: <span class="number">1</span>,b: <span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>我们可以验证一下这个问题，看看程序是否创建了两个不同的 placeholder 节点： <code>print(a.name, b.name)</code></p><p>它打印出 <code>Placeholder:0 Placeholder_1:0</code>。</p><p>这样就清楚了，<code>a</code> placeholder 是 <code>Placeholder:0</code> 而 <code>b</code> placeholder 是 <code>Placeholder_1:0</code>。</p><p>但是在 Go 中，上面的程序会报错，因为 <code>A</code> 与 <code>x</code> 都叫做 <code>Placeholder</code>。我们可以由此得出结论：</p><p><strong>每次我们调用定义操作的函数时，Go API 并不会自动生成新的名称</strong>。因此，它的操作名是固定的，我们没法修改。</p><h4 id="提问时间："><a href="#提问时间：" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>图中的每个节点都必须有唯一的名称。所有节点都是通过名称进行辨认。</strong></p></li><li><p>节点名称与定义操作符的名称是否相同？</p><p><strong>是的，也可说节点名称是操作符名称的最后一段。</strong></p></li></ul><p>接下来让我们修复节点名称重复的问题，来弄明白上面的第二个提问。</p><h2 id="第-2-课：作用域"><a href="#第-2-课：作用域" class="headerlink" title="第 2 课：作用域"></a>第 2 课：作用域</h2><p>正如我们所见，Python API 在定义操作时会自动创建新的名称。如果研究底层会发现，Python API 调用了 C++ <code>Scope</code> 类中的 <code>WithOpName</code> 方法。</p><p>下面是该方法的文档及特性，参考 <a href="https://github.com/tensorflow/tensorflow/blob/a5b1fb8e56ceda0ee2794ee05f5a7642157875c5/tensorflow/cc/framework/scope.h" target="_blank" rel="noopener">scope.h</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回新的作用域。所有在返回的作用域中的 op 都会被命名为</span></span><br><span class="line"><span class="comment">/// &lt;name&gt;/&lt;op_name&gt;[_&lt;suffix].</span></span><br><span class="line">Scope WithOpName(<span class="keyword">const</span> <span class="keyword">string</span>&amp; op_name) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>注意这个方法，返回一个作用域 <code>Scope</code> 来对节点进行命名，因此节点名称事实上就是作用域 <code>Scope</code>。</p><p><code>Scope</code> 就是从根 <code>/</code>（空图）追溯至 <code>op_name</code> 的<strong>完整路径</strong>。</p><p><code>WithOpName</code> 方法在我们尝试添加一个有着相同的 <code>/</code> 到 <code>op_name</code> 路径的节点时，为了避免在相同作用域下有重复的节点，会为其加上一个后缀 <code>_&lt;suffix&gt;</code>（<code>&lt;suffix&gt;</code> 是一个计数器）。</p><p>了解了以上内容，我们可以通过在 <code>type Scope</code> 中寻找 <code>WithOpName</code> 来解决重复节点名称的问题。然而，Go tf API 中没有这个方法。</p><p>如果查阅 <a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope" target="_blank" rel="noopener">type Scope 的文档</a>，我们可以看到唯一能返回新 <code>Scope</code> 的方法只有 <code>SubScope(namespace string)</code>。</p><p>下面引用文档中的内容：</p><blockquote><p>SubScope 将会返回一个新的 Scope，这个 Scope 能确保所有的被加入图中的操作都被放置在 ‘namespace’ 的命名空间下。如果这个命名空间和作用域中已经存在的命名空间冲突，将会给它加上后缀。</p></blockquote><p>这种加后缀的冲突处理和 C++ 中的 <code>WithOpName</code> 方法<strong>不同</strong>，<code>WithOpName</code> 是在<strong>操作名后面</strong>加<code>suffix</code>，它们都在同样的作用域内（例如 <code>Placeholder</code> 变成 <code>Placeholder_1</code>），而 Go 的 <code>SubScope</code> 是在<strong>作用域名称后面</strong>加 <code>suffix</code>。</p><p>这将导致这两种方法会生成完全不同的图（节点在不同的作用域中了），但是它们的计算结果却是一样的。</p><p>让我们试着改一改 placeholder 定义，让它们定义两个不同的节点，然后打印 <code>Scope</code> 名称。</p><p>让我们创建 <code>attempt2.go</code> ，将下面几行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line"><span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">fmt.Println(A.Op.Name(), x.Op.Name())</span><br></pre></td></tr></table></figure><p>编译、运行： <code>go run attempt2.go</code>，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br></pre></td></tr></table></figure><h4 id="提问时间：-1"><a href="#提问时间：-1" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>节点完全由其定义所在的作用域标识。这个”作用域“是我们从图的根节点追溯到指定节点的一条路径。有两种方法来定义执行同一种操作的节点：1、将其定义放在不同的作用域中（Go 风格）2、改变操作名称（我们在 C++ 中可以这么做，Python 版会自动这么做）</strong></p></li></ul><p>现在，我们已经解决了节点命名重复的问题，但是现在我们的控制台中出现了另一个问题：</p><pre><code>panic: failed to add operation &quot;MatMul&quot;: Value for attr &#39;T&#39; of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128
</code></pre><p>为什么 <code>MatMul</code> 节点的定义出错了？我们要做的仅仅是计算两个 <code>tf.int64</code> 矩阵的乘积而已！似乎 <code>MatMul</code> 偏偏不能接受 <code>int64</code> 的类型。</p><blockquote><p>Value for attr ‘T’ of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128</p></blockquote><p>上面这个列表是什么？为什么我们能计算 2 个 <code>int32</code> 矩阵的乘积却不能计算 <code>int64</code> 的乘积？</p><p>下面我们将解决这个问题。</p><h2 id="第-3-课：Tensorflow-类型系统"><a href="#第-3-课：Tensorflow-类型系统" class="headerlink" title="第 3 课：Tensorflow 类型系统"></a>第 3 课：Tensorflow 类型系统</h2><p>让我们深入研究 <a href="https://github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/core/ops/math_ops.cc#L1048" target="_blank" rel="noopener">源代码</a> 来看 C++ 是如何定义 <code>MatMul</code> 操作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_OP(<span class="string">"MatMul"</span>)</span><br><span class="line">    .Input(<span class="string">"a: T"</span>)</span><br><span class="line">    .Input(<span class="string">"b: T"</span>)</span><br><span class="line">    .Output(<span class="string">"product: T"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_a: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_b: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"T: &#123;half, float, double, int32, complex64, complex128&#125;"</span>)</span><br><span class="line">    .SetShapeFn(shape_inference::MatMulShape)</span><br><span class="line">    .Doc(R<span class="string">"doc(</span></span><br><span class="line"><span class="string">Multiply the matrix "</span>a<span class="string">" by the matrix "</span>b<span class="string">".</span></span><br><span class="line"><span class="string">The inputs must be two-dimensional matrices and the inner dimension of</span></span><br><span class="line"><span class="string">"</span>a<span class="string">" (after being transposed if transpose_a is true) must match the</span></span><br><span class="line"><span class="string">outer dimension of "</span>b<span class="string">" (after being transposed if transposed_b is</span></span><br><span class="line"><span class="string">true).</span></span><br><span class="line"><span class="string">*Note*: The default kernel implementation for MatMul on GPUs uses</span></span><br><span class="line"><span class="string">cublas.</span></span><br><span class="line"><span class="string">transpose_a: If true, "</span>a<span class="string">" is transposed before multiplication.</span></span><br><span class="line"><span class="string">transpose_b: If true, "</span>b<span class="string">" is transposed before multiplication.</span></span><br></pre></td></tr></table></figure><p>这几行代码为 <code>MatMul</code> 操作定义了一个接口，由 <code>REGISTER_OP</code> 宏对此操作做出了如下描述：</p><ul><li>名称: <code>MatMul</code></li><li>参数: <code>a</code>, <code>b</code></li><li>属性（可选参数）: <code>transpose_a</code>, <code>transpose_b</code></li><li>模版 <code>T</code> 支持的类型: <code>half, float, double, int32, complex64, complex128</code></li><li>输出类型: 自动识别</li><li>文档</li></ul><p>这个宏没有包含任何 C++ 代码，但是它告诉了我们<strong>当在定义一个操作的时候，即使它使用模版定义，我们也需要指定特定类型 <code>T</code> 支持的类型（或属性）列表。</strong></p><p>实际上，属性 <code>.Attr(&quot;T: {half, float, double, int32, complex64, complex128}&quot;)</code> 将 <code>T</code> 的类型限制在了这个类型列表中。<br><a href="https://www.tensorflow.org/extend/adding_an_op" target="_blank" rel="noopener">tensorflow 教程</a>中提到，当时模版 <code>T</code> 时，我们需要对所有支持的重载运算在内核进行注册。这个内核会使用 CUDA 方式引用 C/C++ 函数，进行并发执行。</p><p><code>MatMul</code> 的作者可能是出于以下 2 个原因仅支持上述类型而将 <code>int64</code> 排除在外的：</p><ol><li>疏忽：这个是有可能的，毕竟 Tensorflow 的作者也是人类呀！</li><li>为了支持不能使用 <code>int64</code> 的设备，可能这个特性的内核实现不能在各种支持的硬件上运行。</li></ol><p>回到我们的问题中，已经很清楚如何解决问题了。我们需要将 <code>MatMul</code> 支持类型的参数传给它。</p><p>让我们创建 <code>attempt3.go</code> ，将所有 <code>int64</code> 的地方都改成 <code>int32</code>。</p><p>有一点需要注意：<strong>Go 封装版 tf 有自己的一套类型，基本与 Go 本身的类型 1:1 相映射。当我们要将值传入图中时，我们必须遵循这种映射关系（例如定义 <code>tf.Int32</code> 类型的 placeholder 时要传入 <code>int32</code>）。从图中取值同理。</strong></p><p><code>*tf.Tensor</code> 类型将会返回一个张量 evaluation，它包含一个 <code>Value()</code> 方法，此方法将返回一个必须转换为正确类型的 <code>interface{}</code>（这是从图的结构了解到的）。</p><p>运行 <code>go run attempt3.go</code>，得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br><span class="line">[[210] [-210]]</span><br></pre></td></tr></table></figure><p>成功了！</p><p>下面是 <code>attempt3</code> 的完整代码，你可以编译并运行它。（这是一个 Gist，如果你发现有啥可以改进的话欢迎来<a href="https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）" target="_blank" rel="noopener">https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                        </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (                                            </span><br><span class="line">	<span class="string">"fmt"</span>                                       </span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span>                                              </span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span>                                              </span><br><span class="line">)                                                   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                       </span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()                       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	<span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line">	<span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">	A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))   </span><br><span class="line">	x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))   </span><br><span class="line">	fmt.Println(A.Op.Name(), x.Op.Name())       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)            </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line">	graph, err := root.Finalize()               </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session                        </span><br><span class="line">        sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)                                           </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量             </span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor               </span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]                 </span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                       </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]                      </span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                            </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor                    </span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;                                             </span><br><span class="line">		A: matrix,                          </span><br><span class="line">		x: column,                          </span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;            </span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int32</span>))                                            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问时间：-2"><a href="#提问时间：-2" class="headerlink" title="提问时间："></a>提问时间：</h4><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>每个操作都有自己的一组关联内核。Tensorflow 是一种强类型的描述性语言，它不仅遵循 C++ 类型规则，同时要求在 op 注册时需定义好类型才能实现其功能。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Go 来定义与处理一个图让我们能够更好地理解 Tensorflow 的底层结构。通过不断地试错，我们最终解决了这个简单的问题，一步一步地掌握了图、节点以及类型系统的知识。</p><p>如果你觉得这篇文章有用，请点个赞或者分享给别人吧~</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59420951128fe1006a1960f8" target="_blank" rel="noopener">https://juejin.im/post/59420951128fe1006a1960f8</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/11/Reinforcement-Learning-notes-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/11/Reinforcement-Learning-notes-1/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">Reinforcement Learning notes(1)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-11 14:33:00" itemprop="dateCreated datePublished" datetime="2017-06-11T14:33:00+08:00">2017-06-11</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Stanford CS229 notes 12: <a href="http://cs229.stanford.edu/notes/cs229-notes12.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes12.pdf</a></p><p><a href="//lsivh.com/img/1496555948888450.pdf">cs229-notes12.pdf</a></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>在CS229 notes 中提到了强化学习的意义：</p><p>In the reinforcement learning framework, we will instead provide our algorithms only a reward function, which indicates to the learning agent when it is doing well, and when it is doing poorly.</p><p>个人的理解就是强化学习就是让 agent 根据环境包含的信息与强化信号量判断策略的选择，同时策略的不同造成的结果会以反馈的形式产生强化信号量给 agent，最终 agent 以“得到最大化的正强化信号量”为标准，做出最佳的策略选择。</p><p>换句话说，强化学习不会给模型提供任何“正确的决策”规则，只会给 agent 从环境状态得来的强化信号量，通过这种方式，agent 在行动=&gt;评价=&gt;学习的过程中学习到了知识，学到了如何做出让评价最好的决策方式。</p><h3 id="Markov-decision-processes-MDP"><a href="#Markov-decision-processes-MDP" class="headerlink" title="Markov decision processes (MDP)"></a>Markov decision processes (MDP)</h3><p>马尔科夫决策过程为一个包含5个元素的元组</p><script type="math/tex;mode=display">MDP = (S,A,{P_{sa}},\gamma,R)</script><p>其中：</p><p>S 为 states，状态集，包含所有 agent 可能处于的状态。</p><p>A 为 actions，行动集，包含了所有 agent 在各种状态下可以采取的行动。</p><p>$P_{sa}$ 为概率，代表了 agent 在 s 状态下做出 a 行动的概率</p><p>$\gamma$ 的值 $\gamma in [0,1)$，称为“discount factor”，可以理解为“折算率”</p><p>R 为奖励函数（reward function），其值由$S\times A \mapsto R$或$S \mapsto R$决定。</p><p>马尔科夫决策过程即为 agent 从初状态$s_0$开始行动，在马尔科夫决策的 A（行动集）中选择一种行动方式 $a_0 \in A$，到达第二个状态$s_1$，接着选择$a_1$……</p><script type="math/tex;mode=display">s_0 \overset{a_0}{\rightarrow} s_1\overset{a_1}{\rightarrow} s_2\overset{a_2}{\rightarrow} s_3\overset{a_3}{\rightarrow} ...</script><p>这个过程的价值（payoff）记作</p><script type="math/tex;mode=display">R(s_0,a_0) + \gamma R(s_1,a_1)+\gamma^2 R(s_2,a_2) + ...</script><p>简写为</p><script type="math/tex;mode=display">r_0 + \gamma r_1 + \gamma^2 r_2 + ...</script><p>$\gamma^i$会越来越小，因此越后面的 R 权值越小。</p><p>当 MDP 确定后，每次决策时的状态、行为都是确定的，为了让 agent 在任意状态做出最佳的行为让状态尽量达到最好的情况（即获得最大的奖励值），需要确定一组策略，让整个过程的价值尽量最大化。</p><p>整个过程的期望记为：</p><script type="math/tex;mode=display">E[r_0 + \gamma r_1+\gamma^2 r_2 + ...]</script><p>将策略记为$\pi$，规定了任意情况下的$s \rightarrow a$，因此可以记为：</p><script type="math/tex;mode=display">a = \pi (s)</script><p>这个策略的价值函数（value function）记为</p><script type="math/tex;mode=display">V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2 + ...| r_0=R(s),\pi]</script><p>上式表示的是在起点为$s$、使用策略[latex]pi[/latex]的情况下的价值函数值。</p><h4 id="状态值函数"><a href="#状态值函数" class="headerlink" title="状态值函数"></a>状态值函数</h4><h5 id="策略评价"><a href="#策略评价" class="headerlink" title="策略评价"></a>策略评价</h5><p>对上式变换：</p><script type="math/tex;mode=display">V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2+ ...| r_0=R(s),\pi]</script><script type="math/tex;mode=display">V^pi(s_t)=E_\pi[r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + ...]</script><script type="math/tex;mode=display">V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]</script><p>上式的$s_{t+1}$指的是$s_t$状态经过策略$\pi$之后到达的下一个状态。根据$P_{s\pi(s)}$对上式期望值进行展开，同时考虑在状态$s_t$下的所有策略动作情况：</p><script type="math/tex;mode=display">V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]</script><script type="math/tex;mode=display">=\sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^\pi(s_{t+1})]</script><p>上式中的$P(s_{t+1}|s_t,\pi(s))$指的是在$s_t$状态下进行策略$\pi(s)$到达状态 $s_{t+1}$的概率，$R(s_t,\pi(s),s_{t+1})$为从状态 $s_t$ 转移到状态 $s_{t+1}$ 的期望回报值（其实就是之前的$s_t$）。</p><p>根据贝尔曼最优化方程，有</p><script type="math/tex;mode=display">V^*(s_t) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^*(s_{t+1})]</script><p>因此，对于任意一种策略$\pi$，我们都能通过这种方法对各个动作得到的价值函数值进行最大化迭代，逐渐逼近最大价值函数值。</p><script type="math/tex;mode=display">\text{input pi} \\
\text{While }\Delta < \theta \{\\
\text{tmp} = V(s)\\
V(s) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s))[R(s_t,\pi(s),s_{t+1}) +\gamma V^*(s_{t+1})\\
\Delta = \max(\Delta,|V(s) - \text{tmp}|)\\
\} \\
\text{output } V(s) \approx V^\pi(s)</script><h5 id="策略改进"><a href="#策略改进" class="headerlink" title="策略改进"></a>策略改进</h5><p>假设有$\pi$与$\pi_1$两种策略，如果$Q^\pi(s,\pi_1(s)) \geq V^\pi(s)$（也就是$V^\pi_1(s) \geq V^\pi$），那么说明$\pi_1$的效果一定比$\pi$要好。</p><p>以此为依据，可以在每个状态 s 下对决策允许集进行遍历，计算所有决策会产生的价值函数值，根据贪心策略找到产生做大价值函数值的策略$\pi^*$，它即为效果最好的策略。</p><script type="math/tex;mode=display">\pi_1 = \arg \max_a Q^\pi(s,a)</script><script type="math/tex;mode=display">=\arg \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,a) [R(s_t,a,s_{t+1}) + \gamma V^*(s_{t+1})]</script><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><p>由上面的策略评价进行计算，能够得到当前策略下最大的价值函数值，接着使用策略改进，得到更好的策略$\pi_1$，再接着对这个$\pi_1$再次使用策略评估……这样一遍又一遍地迭代计算，最终能得到趋近最佳值的策略价值函数值与对应的策略。</p><p><img src="/images/pasted-163.png" alt="upload successful"></p><h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p><img src="/images/pasted-164.png" alt="upload successful"></p><h3 id="值迭代与策略迭代的区别"><a href="#值迭代与策略迭代的区别" class="headerlink" title="值迭代与策略迭代的区别"></a>值迭代与策略迭代的区别</h3><p><a href="https://www.zhihu.com/question/41477987" target="_blank" rel="noopener">https://www.zhihu.com/question/41477987</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">解决flask慢的问题,以及开启多线程之后jpype的错误</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-09 15:54:00" itemprop="dateCreated datePublished" datetime="2017-06-09T15:54:00+08:00">2017-06-09</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Back-End/" itemprop="url" rel="index"><span itemprop="name">Back End</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>用 flask 做 API 时，发现在 client 的请求需要很长的时间才能得到响应（差不多要 20 多秒）。Google 之后得到解决方案，使用配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(threaded=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>开启多线程模式。</p><p>然而这个服务是使用 java 做的底层，用 jpype 让 python 能调用 java 的方法。flask 开启多线程之后服务报错。经过研究发现是 JVM 并没有能为新开启的线程提供服务。查阅 jpype 的文档，找到 python 线程相关部分：<a href="http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads" target="_blank" rel="noopener">http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads</a></p><p>因此可在调用 java class 前加上一个判断语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> jpype.isThreadAttachedToJVM():</span><br><span class="line">    jpype.attachThreadToJVM()</span><br></pre></td></tr></table></figure><p>使用 isTreadAttachedToJVM 先做出判断，然后使用 attachThreadToJVM 让 JVM 能为新线程提供服务。</p><p>完成上述步骤之后，发现已经没有报错了，但是相应速度依然很慢。从服务端控制台看，早已返回了 200，但是在浏览器中迟迟收不到数据，一直是 Pending 状态。查阅资料发现 flask 默认开启 Debug 模式，会对 response 做大量分析记录，使用配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(debug=False)</span><br></pre></td></tr></table></figure><p>关闭 Debug 模式，再连接发现响应时间大大减小了，从 20 多秒减到了几百毫秒。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">RxJS 简介：可观察对象、观察者与操作符</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-05 11:41:47" itemprop="dateCreated datePublished" datetime="2017-06-05T11:41:47+08:00">2017-06-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>对于响应式编程来说，RxJS 是一个不可思议的工具。今天我们将深入探讨什么是 Observable（可观察对象）和 observer（观察者），然后了解如何创建自己的 operator（操作符）。</p><p>如果你之前用过 RxJS，想了解它的内部工作原理，以及 Observable、operator 是如何运作的，这篇文章将很适合你阅读。</p><h3 id="什么是-Observable（可观察对象）？"><a href="#什么是-Observable（可观察对象）？" class="headerlink" title="什么是 Observable（可观察对象）？"></a>什么是 Observable（可观察对象）？</h3><p>可观察对象其实就是一个比较特别的函数，它接受一个“观察者”（observer）对象作为参数（在这个观察者对象中有 “next”、“error”、“complete”等方法），以及它会返回一种解除与观察者关系的逻辑。例如我们自己实现的时候会使用一个简单的 “unsubscribe” 函数来实现退订功能（即解除与观察者绑定关系的逻辑）。而在 RxJS 中， 它是一个包含 <code>unsubsribe</code> 方法的订阅对象（Subscription）。</p><p>可观察对象会创建观察者对象（稍后我们将详细介绍它），并将它和我们希望获取数据值的“东西”连接起来。这个“东西”就是生产者（producer），它可能来自于 <code>click</code> 或者 <code>input</code> 之类的 DOM 事件，是数据值的来源。当然，它也可以是一些更复杂的情况，比如通过 HTTP 与服务器交流的事件。</p><p>我们稍后将要自己写一个可观察对象，以便更好地理解它！在此之前，让我们先看看一个订阅对象的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input[type=text]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`你刚刚输入了 <span class="subst">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class="line">  error: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Oops... <span class="subst">$&#123;err&#125;</span>`</span>),</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`完成!`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子使用了一个 <code>&lt;input type=&quot;text&quot;&gt;</code> 节点，并将其传入 <code>Rx.Observable.fromEvent()</code> 中。当我们触发指定的事件名时，它将会返回一个输入的 <code>Event</code> 的可观察对象。（因此我们在 console.log 中用 <code>${event.target.value}</code> 可以获取输入值）</p><p>当输入事件被触发的时候，可观察对象会将它的值传给观察者。</p><h3 id="什么是-Observer（观察者）？"><a href="#什么是-Observer（观察者）？" class="headerlink" title="什么是 Observer（观察者）？"></a>什么是 Observer（观察者）？</h3><p>观察者相当容易理解。在前面的例子中，我们传入 <code>.subscribe()</code> 中的对象字面量就是观察者（订阅对象将会调用我们的可观察对象）。</p><blockquote><p><code>.subscribe(next, error, complete)</code> 也是一种合法的语法，但是我们现在研究的是对象字面量的情况。</p></blockquote><p>当一个可观察对象产生数据值的时候，它会通知观察者，当新的值被成功捕获的时候调用 <code>.next()</code>，发生错误的时候调用 <code>.error()</code>。</p><p>当我们订阅一个可观察对象的时候，它会持续不断地将值传递给观察者，直到发生以下两件事：一种是生产者告知没有更多的值需要传递了，这种情况它会调用观察者的 <code>.complete()</code> ；一种是我们（“消费者”）对之后的值不再感兴趣，决定取消订阅（unsubsribe）。</p><p>如果我们想要对可观察对象传来的值进行组成构建（compose），那么在值传达最终的 <code>.subscribe()</code> 代码块之前，需要经过一连串的可观察对象（也就是操作符）处理。这个一连串的“链”也就是我们所说的可观察对象序列。链中的每个操作符都会返回一个新的可观察对象，让我们的序列能够持续进行下去——这也就是我们所熟知的“流”。</p><h3 id="什么是-Operator（操作符）？"><a href="#什么是-Operator（操作符）？" class="headerlink" title="什么是 Operator（操作符）？"></a>什么是 Operator（操作符）？</h3><p>我们前面提到，可观察对象能够进行链式调用，也就是说我们可以像这样写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">  .filter(<span class="function"><span class="params">value</span> =&gt;</span> value.length &gt;= <span class="number">2</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use the `value`</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这段代码做了下面一系列事情：</p><ul><li>我们先假定用户输入了一个“a”</li><li>可观察对象将会对这个输入事件作出反应，将值传给下一个观察者</li><li>“a”被传给了订阅了我们<strong>初始</strong>可观察对象的 <code>.map()</code></li><li><code>.map()</code> 会返回一个 <code>event.target.value</code> 的新可观察对象，然后调用它观察者对象中的 <code>.next()</code></li><li><code>.next()</code> 将会调用订阅了 <code>.map()</code> 的 <code>.filter()</code>，并将 <code>.map()</code> 处理后的值传递给它</li><li><code>.filter()</code> 将会返回另一个可观察对象，<code>.filter()</code> 过滤后留下 <code>.length</code> 大于等于 2 的值，并将其传给 <code>.next()</code></li><li>我们通过 <code>.subscribe()</code> 获得了最终的数据值</li></ul><p>这短短的几行代码做了这么多的事！如果你还觉得弄不清，只需要记住：</p><p>每当返回一个新的可观察对象，都会有一个新的<strong>观察者</strong>挂载到前一个<strong>可观察对象</strong>上，这样就能通过观察者的“流”进行传值，对观察者生产的值进行处理，然后调用 <code>.next()</code> 方法将处理后的值传递给下一个观察者。</p><p>简单来说，操作符将会不断地依次返回新的可观察对象，让我们的流能够持续进行。作为用户而言，我们不需要关心什么时候、什么情况下需要创建与使用可观察对象与观察者，我们只需要用我们的订阅对象进行链式调用就行了。</p><h3 id="创建我们自己的-Observable（可观察对象）"><a href="#创建我们自己的-Observable（可观察对象）" class="headerlink" title="创建我们自己的 Observable（可观察对象）"></a>创建我们自己的 Observable（可观察对象）</h3><p>现在，让我们开始写自己的可观察对象的实现吧。尽管它不会像 Rx 的实现那么高级，但我们还是对完善它充满信心。</p><h4 id="Observable-构造器"><a href="#Observable-构造器" class="headerlink" title="Observable 构造器"></a>Observable 构造器</h4><p>首先，我们需要创建一个 Observable 构造函数，此构造函数接受且仅接受 <code>subscribe</code> 函数作为其唯一的参数。每个 Observable 实例都存储 subscribe 属性，稍后可以由观察者对象调用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observable</span>(<span class="params">subscribe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subscribe = subscribe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个分配给 <code>this.subscribe</code> 的 <code>subscribe</code> 回调都将会被我们或者其它的可观察对象调用。这样我们下面做的事情就有意义了。</p><h4 id="Observer-示例"><a href="#Observer-示例" class="headerlink" title="Observer 示例"></a>Observer 示例</h4><p>在深入探讨实际情况之前，我们先看一看基础的例子。</p><p>现在我们已经配好了可观察对象函数，可以调用我们的观察者，将 <code>1</code> 这个值传给它并订阅它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one$ = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">one$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们订阅了 Observable 实例，将我们的 observer（对象字面量）传入构造器中（之后它会被分配给 <code>this.subscribe</code>）。</p><h4 id="Observable-fromEvent"><a href="#Observable-fromEvent" class="headerlink" title="Observable.fromEvent"></a>Observable.fromEvent</h4><p>现在我们已经完成了创建自己的 Observable 的基础步骤。下一步是为 Observable 添加 <code>static</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将像使用 RxJS 一样使用我们的 Observable：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>);</span><br></pre></td></tr></table></figure><p>这意味着我们需要返回一个新的 Observable，然后将函数作为参数传递给它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码将我们的函数传入了构造器中的 <code>this.subscribe</code>。接下来，我们需要将事件监听设置好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个 <code>observer</code> 参数是什么呢？它又是从哪里来的呢？</p><p>这个 <code>observer</code> 其实就是携带 <code>next</code>、<code>error</code>、<code>complete</code> 的对象字面量。</p><blockquote><p>这块其实很有意思。<code>observer</code> 在 <code>.subscribe()</code> 被调用之前都不会被传递，因此 <code>addEventListener</code> 在 Observable 被“订阅”之前都不会被执行。</p></blockquote><p>一旦调用 subscribe，也就会调用 Observable 构造器内的 <code>this.subscribe</code> 。它将会调用我们传入 <code>new Observable(callback)</code> 的 callback，同时也会依次将值传给我们的观察者。这样，当 Observable 做完一件事的时候，它就会用更新过的值调用我们观察者中的 <code>.next()</code> 方法。</p><p>那么之后呢？我们已经得到了初始化好的事件监听器，但是还没有调用 <code>.next()</code>。下面完成它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;</span><br><span class="line">      observer.next(event);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们都知道，可观察对象在被销毁前需要一个“处理后事”的函数，在我们这个例子中，我们需要移除事件监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="function">(<span class="params">event</span>) =&gt;</span> observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> element.removeEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为这个 Observable 还在处理 DOM API 和事件，因此我们还不会去调用 <code>.complete()</code>。这样在技术上就有无限的可用性。</p><p>试一试吧！下面是我们已经写好的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const node = document.querySelector(&apos;input&apos;);</span><br><span class="line">const p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">function Observable(subscribe) &#123;</span><br><span class="line">  this.subscribe = subscribe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.fromEvent = (element, name) =&gt; &#123;</span><br><span class="line">  return new Observable((observer) =&gt; &#123;</span><br><span class="line">    const callback = (event) =&gt; observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, false);</span><br><span class="line">    return () =&gt; element.removeEventListener(name, callback, false);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;);</span><br><span class="line"></span><br><span class="line">const unsubscribe = input$.subscribe(&#123;</span><br><span class="line">  next: (event) =&gt; &#123;</span><br><span class="line">    p.innerHTML = event.target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 5 秒之后自动取消订阅</span><br><span class="line">setTimeout(unsubscribe, 5000);</span><br></pre></td></tr></table></figure><p>在线示例：</p><iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/3zgv7q2g/embedded/js,html,result/" allowfullscreen frameborder="0"></iframe><h3 id="创造我们自己的-Operator（操作符）"><a href="#创造我们自己的-Operator（操作符）" class="headerlink" title="创造我们自己的 Operator（操作符）"></a>创造我们自己的 Operator（操作符）</h3><p>在我们理解了可观察对象与观察者对象的概念之后，我们可以更轻松地去创造我们自己的操作符了。我们在 <code>Observable</code> 对象原型中加上一个新的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map=function(mapFn)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法将会像 JavaScript 中的 <code>Array.prototype.map</code> 一样使用，不过它可以对任何值用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;)</span><br><span class="line">	.map(event =&gt; event.target.value);</span><br></pre></td></tr></table></figure><p>所以我们要取得回调函数，并调用它，返回我们期望得到的数据。在这之前，我们需要拿到流中最新的数据值。</p><p>下面该做什么就比较明了了，我们要得到调用了这个 <code>.map()</code> 操作符的 Observable 实例的引用入口。我们是在原型链上编程，因此可以直接这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = function (mapFn) &#123;</span><br><span class="line">  const input = this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找找乐子吧！现在我们可以在返回的 Obeservable 中调用 subscribe：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> input.subscribe();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我们要返回 <code>input.subscribe()</code> ，因为在我们退订的时候，非订阅对象将会顺着链一直转下去，解除每个 Observable 的订阅。</p></blockquote><p>这个订阅对象将允许我们把之前 <code>Observable.fromEvent</code> 传来的值传递下去，因为它返回了构造器中含有 <code>subscribe</code> 原型的新的 Observable 对象。我们可以轻松地订阅它对数据值做出的任何更新！最后，完成通过 map 调用我们的 <code>mapFn()</code> 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input.subscribe(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">value</span>) =&gt;</span> observer.next(mapFn(value)),</span><br><span class="line">      error: <span class="function">(<span class="params">err</span>) =&gt;</span> observer.error(err),</span><br><span class="line">      complete: <span class="function"><span class="params">()</span> =&gt;</span> observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们可以进行链式调用了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    p.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意到最后一个 <code>.subscribe()</code> 不再和之前一样传入 <code>Event</code> 对象，而是传入了一个 <code>value</code> 了吗？这说明你成功地创建了一个可观察对象流。</p><p>再试试：</p><iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/0rpkchm8/embedded/js,html,result/" allowfullscreen frameborder="0"></iframe><p>希望这篇文章对你来说还算有趣~:)</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5934d2532f301e00585ea5f3" target="_blank" rel="noopener">https://juejin.im/post/5934d2532f301e00585ea5f3</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/04/动态规划/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/04/动态规划/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">动态规划</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-04 16:36:00" itemprop="dateCreated datePublished" datetime="2017-06-04T16:36:00+08:00">2017-06-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>拿着以前的笔记复习一下~</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>决策可以分为静态决策与动态决策。</p><p>其中静态决策又被称为“一次性决策”，即根据输入进行决策判断，得到相应的输出结果。如图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         u决策</span><br><span class="line">           +</span><br><span class="line">           |</span><br><span class="line">        +--v--+</span><br><span class="line">x1输入+--&gt;     +--&gt;x2输出</span><br><span class="line">        +--+--+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">        z决策效应</span><br></pre></td></tr></table></figure><p>动态决策也叫“多阶段决策”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       u1         u2                 uk                     un</span><br><span class="line">       |          |                  |                      |</span><br><span class="line">    +--v--+    +--v--+            +--v--+                +--v--+</span><br><span class="line">x1--&gt;  T1 +-x2-&gt; T2  +-x3-&gt;...xk--&gt;  Tk +-x(k+1)-&gt;...xn--&gt;  Tn  +--&gt;x(n+1)</span><br><span class="line">    +--+--+    +--v--+            +--v--+                +--v--+</span><br><span class="line">       |          |                  |                      |</span><br><span class="line">       v          v                  v                      v</span><br><span class="line">       r1         r2                 rk                     rn</span><br></pre></td></tr></table></figure><p>也可以记为$X_{k+1} = T_k(x_k,u_k)$，若系统在 k 阶段之后的决策只与$x_k$有关，而与之前做过的决策无关，则这样的决策过程称为具有<strong>无后效性的多段决策过程。</strong></p><p>多段决策过程从第 k 步到最后一步的过程称为 k-后部子过程，简称 k-子过程</p><h3 id="动态规划模型"><a href="#动态规划模型" class="headerlink" title="动态规划模型"></a>动态规划模型</h3><script type="math/tex;mode=display">\text{opt}_{u_1 \cdots u_n} R = \bigoplus_{k=1}^n r_k (x_k,u_k)</script><script type="math/tex;mode=display">\left\{
\begin{aligned}
   &x_{k+1} = T_k(x_k,u_k) \\
   &x_k \in X_k \\
   &u_k \in U_k \\
   &k = 1 \sim n
   \end{aligned}
   \right.</script><p>opt 表示求优过程</p><p>Xk 为一个集合，表示在 k 阶段时状态所有可能取值的范围，因此称为<strong>状态可能集合</strong></p><p>Uk 为一个集合，表示在 k 阶段时决策所有可能取值的范围，称为<strong>决策允许集合</strong></p><p>一般对于不同的状态，可以选择的决策范围也不同，因此决策允许集合也记为$U_k(x_k)$</p><p>解决动态规划问题需要确定以下几个步骤：</p><p>1、确定阶段与阶段变量</p><p>2、明确状态变量与状态可能集合</p><p>3、确定决策变量与决策允许集合</p><p>4、确定状态转移方程</p><p>5、明确阶段效应和目标</p><p>其中重要的是确定状态转移方程与明确阶段相应和目标。</p><p>状态转移方程即在状态$x_k$时做出了决策$u_k(x_k)$之后系统状态的变化，这个变化会影响之后的决策过程。因此必须明确状态的转移过程，即根据问题的内在关系，明确$x_{k+1}=T_k(x_k,u_k)$中的函数Tk()。</p><p>阶段效应$r_k(x_k,u_k)$是在阶段k以$x_k$为起点发出决策$u_k$所产生的后果。明确$r_k,x_k,u_k$才能构成目标函数，目标函数由具体问题决定，例如根据具体问题确定求最大还是最小。</p><h3 id="多段决策的特点"><a href="#多段决策的特点" class="headerlink" title="多段决策的特点"></a>多段决策的特点</h3><p>1、每个阶段都要进行决策</p><p>2、相继进行的阶段决策构成决策序列</p><p>3、前一阶段的终止状态是后一阶段的起始状态</p><p>阶段 k 的最优决策不应该只是当前阶段的最优决策，而应该是 k-后部子过程的最优决策。</p><h3 id="最优性原理"><a href="#最优性原理" class="headerlink" title="最优性原理"></a>最优性原理</h3><p>无论初始状态和初始决策如何，对于之前所有决策造成的某一状态而言，剩余的决策序列必须构成最优策略。</p><p><strong>最优性原理的含义：</strong></p><p>1、最优策略的任何一部分子策略，也是相应最初状态的最优策略。</p><p>2、每个最优策略只能由最优子策略构成。</p><p>因此对于无后效多段决策过程而言，按照 k-后部子过程最优的原则来求各阶段的最优决策，这样构成的决策序列一定具有最优性原理的性质。</p><h3 id="贝尔曼函数"><a href="#贝尔曼函数" class="headerlink" title="贝尔曼函数"></a>贝尔曼函数</h3><p>阶段 k，从状态$x_k$出发，执行最优决策序列，最终到达终点时，整个 k-后部子过程中的目标函数取值被称为条件最优目标函数，即贝尔曼函数。</p><script type="math/tex;mode=display">f_k(k_k)=opt_{u_k~u_n} \sum^{n}_{i=n} r_i(x_i,u_i) | k\in {1,2,3,...,n}</script><h3 id="动态规划基本方程、贝尔曼方程"><a href="#动态规划基本方程、贝尔曼方程" class="headerlink" title="动态规划基本方程、贝尔曼方程"></a>动态规划基本方程、贝尔曼方程</h3><p>在阶段 k时，执行任意决策$u_k$后的状态是$x_{k+1} = T_k(x_k,u_k)$。这时 k-后部子过程就缩小为了 k+1 后部子过程。根据最优性原理，k+1 后部子过程应该采取最优策略，由于无后效性，k-后部子过程的目标函数值为 $r_k(x_k,u_k)+f_{k+1}(T_k(x_k,u_k))$。根据条件最优目标函数的定义，有：</p><script type="math/tex;mode=display">f_k(x_k) = opt_{u_k}{ r_k(x_k,u_k) + f_{k+1}(T_k(x_k,u_k)) }</script><p>此方程即为动态规划基本方程。</p><h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>1、逆序求出条件最优目标函数值集合与条件最优决策集合</p><p>2、顺序求最优目标值、最优策略和最佳路线</p><p>逆序求集合：</p><script type="math/tex;mode=display">\begin{aligned}
 k=n, &f_n(x_n) = \text{opt}_{u_n}\{r_n(x_n,u_n) + f_{n+1}(x_{n+1})\} \\
 & \because f_{n+1}(x_{n+1}) = 0 \\
 & \therefore 原式 = \text{opt}_{u_n}\{r_n(x_n,u_n)\} \\
 & \Rightarrow f_n(x_n) = r_n(x_n,u_n^\prime(x_n)) \\\\
 k=n-1, &f_{n-1}(x_{n-1}) = \text{opt}_{u_{n-1}}\{r_{n-1}(x_{n-1},u_{n-1}) + f_{n}(x_{n})\} \\
 & \because f_n(x_n) 已求出，因此根据 x_n = T_{n-1}(x_{n-1},u_{n-1})\\
 & 可得 n-1 时的 x_{n-1} \in X_{n-1} 对应的条件最有目标函数值\\
 & f_{n-1}(x_{n-1}) \\
 & \Rightarrow \{f_{n-1}(x_{n-1}),u_{n-1}^\prime(x_{n-1})|x_{n-1} \in X_{n-1}\} \\\\
  k=1, &f_1(x_1) = \text{opt}_{u_1}\{r_1(x_1,u_1) + f_2(x_2)\} \\
 &  \{f_1(x_1),u_1^\prime(x_1)|x_1 \in X_1\} \\
\end{aligned}</script><p>顺序求目标值：</p><script type="math/tex;mode=display">\begin{aligned}
x_1 确定, &R^* = f_1(x_1) \qquad u^*_1(x_1) = u_1^\prime(x_1) \\
x_1 不确定, &R^* = \text{opt}_{x_1 \in X_1}\{f_1(x_1)\} = f_1(x_1^*) \\
& 得 x_1^*,带入求 x_2^,以此类推得 x_n^*,x_{n+1}^*
\end{aligned}</script></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/05/12/别让你的偏爱拖了后腿：快拥抱箭头函数吧！/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/12/别让你的偏爱拖了后腿：快拥抱箭头函数吧！/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">别让你的偏爱拖了后腿：快拥抱箭头函数吧！</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-05-12 19:12:00" itemprop="dateCreated datePublished" datetime="2017-05-12T19:12:00+08:00">2017-05-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/pasted-153.png" alt="upload successful"></p><p>我以教 JavaScript 为生。最近我给学生上了柯里化箭头函数这个课程——这还是最开始的几节课。我认为它是一个很好用的技能，因此将这个内容提到了课程的前面。而学生们没有让我失望，比我想象中地<strong>更快地</strong>掌握了使用箭头函数进行柯里化。</p><p>如果学生们能够理解它，并且能尽快由它获益，为什么不早点将箭头函数教给他们呢？</p><blockquote><p>Note：我的课程并不适合那些从来没有接触过代码的人。大多数学生在加入我们的课程之前至少有几个月的编程经历——无论他们是自学，还是通过培训班学习，或者本身就是专业的。然而，我发现许多只有一点经验或者没有经验的年轻开发者们能够很快地接受这些主题。</p></blockquote><p>我看到很多的学生在上了 1 小时的课之后就能很熟练地使用箭头函数工作了。（如果你是<a href="https://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“和 Eric Elliott 一起学习 JavaScript”</a>培训班的同学，你可以看这个约 55 分钟的视频——<a href="https://ericelliottjs.com/premium-content/es6-curry-composition/" target="_blank" rel="noopener">ES6 的柯里化与组合</a>）。</p><p>看到学生们如此之快地掌握与应用他们新发现的柯里化方法，我想起了我在推特上发了柯里化箭头函数的帖子，然后被一群人喷“可读性差”的事。我很惊讶为什么他们会坚持这个观点。</p><p>首先，我们先来看看这个例子。我在推特发了这个函数，然后我发现有人强烈反对这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const secret = msg =&gt; () =&gt; msg;</span><br></pre></td></tr></table></figure><p>我对有人在推特上指责我在误导别人感到不可思议。我写这个函数是为了示范在 ES6 中写柯里化函数是多么的<strong>简单</strong>。它是我能想到的在 JavaScript 中<strong>最简单</strong>的实际运用与闭包表达式了。（相关阅读：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">什么是闭包</a>）</p><p>它和下面的函数表达式等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const secret = function (msg) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>secret()</code> 是一个函数，它需要传入 <code>msg</code> 这个参数，然后会返回一个新的函数，这个函数将会返回 <code>msg</code> 的值。无论你向 <code>secret()</code> 中传入什么值，它都会利用闭包固定 <code>msg</code> 的值。</p><p>你可以这么用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mySecret = secret(&apos;hi&apos;);</span><br><span class="line">mySecret(); // &apos;hi&apos;</span><br></pre></td></tr></table></figure><p>事实证明，双箭头并没有让人感到困惑。我坚信：</p><blockquote><p>对于熟悉的人来说，单行的箭头函数是 JavaScript 表达柯里化函数<strong>最具有可读性</strong>的方法了。</p></blockquote><p>有许多人指责我，告诉我将代码写的长一些比简短的代码更容易阅读。他们有时也许是对的，但是大多数情况都错了。更长、更详细的代码不一定更容易阅读——至少，对熟悉箭头函数的人来说就是如此。</p><p>我在推特上看到的持反对意见的人，并没有像我的学生一样享受平滑的学习箭头函数的过程。在我的经验里，学生学习柯里化箭头函数就像鱼在水里生活一样。仅仅学了几天，他们就开始使用箭头了。它帮助学生们轻松地跨过了各种编程问题的鸿沟。</p><p>我没有看到学习、阅读、理解箭头函数对那些学生造成了任何的“困难”——一旦他们决定学习，只要上个大概一小时的课就能基本掌握。</p><p>他们能够很轻松地读懂柯里化箭头函数，尽管他们从来没有见过这类的东西，他们还是能够告诉我这些函数做了什么事。当我给他们布置任务后他们也能够很自如地自己完成任务。</p><p>从另一方面说，他们能够很快<strong>熟悉</strong>柯里化箭头函数，并且没有为此产生任何<strong>问题</strong>。他们阅读这些函数就像你读一句话一样，他们对其的理解让他们写出了更简单、更少 bug 的代码。</p><h3 id="为什么一些人认为传统的函数表达式看起来“更具有可读性”？"><a href="#为什么一些人认为传统的函数表达式看起来“更具有可读性”？" class="headerlink" title="为什么一些人认为传统的函数表达式看起来“更具有可读性”？"></a>为什么一些人认为传统的函数表达式看起来“更具有可读性”？</h3><p><strong>偏爱</strong>是一种显著的<a href="https://www.psychologytoday.com/blog/mind-my-money/200807/familiarity-bias-part-i-what-is-it" target="_blank" rel="noopener">人类认知偏差</a>，它会让我们在有更好的选择的情况下做出自暴自弃的选择。我们会因此无视更舒服更好的方法，习惯性地选用以前使用过的老方法。</p><p>你可以从这本书中更详细地了解“偏爱”这种心理：<a href="https://www.amazon.com/Undoing-Project-Friendship-Changed-Minds-ebook/dp/B01GI6S7EK/ref=as_li_ss_tl?ie=UTF8&amp;qid=1492606452&amp;sr=8-1&amp;keywords=the+undoing+project&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=4ebd1476f97023e8acb4bba37ea18b90" target="_blank" rel="noopener">《The Undoing Project: A Friendship that Changed Our Minds》</a>（很多情况都是我们自欺欺人）。每个软件工程师都应该读一读这本书，因为它会鼓励你辩证地去看待问题，以及鼓励你多对假设进行实验，以免掉入各种认知陷阱中。书中那些发现认知陷阱的故事也很有趣。</p><h3 id="传统的函数表达式可能会在你的代码中导致-Bug-的出现"><a href="#传统的函数表达式可能会在你的代码中导致-Bug-的出现" class="headerlink" title="传统的函数表达式可能会在你的代码中导致 Bug 的出现"></a>传统的函数表达式可能会在你的代码中导致 Bug 的出现</h3><p>今天我用 ES5 的语法重写了一个 ES6 写的柯里化箭头函数，以便发布开源模块让人们无需编译就能在老浏览器中用。然而 ES5 版本让我震惊。</p><p>ES6 版本的代码非常简短、简介、优雅——仅仅只需要 4 行。</p><p>我觉得，这件事可以发个推特，告诉大家箭头函数是一种更加优越的实现，是时候如同放弃自己的坏习惯一样，放弃传统函数表达式的写法了。</p><p>所以我发了一条推特：</p><p><img src="/images/pasted-154.png" alt="upload successful"></p><p>为了防止你看不清图片，下面贴上这个函数的文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用箭头函数柯里化</span><br><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br><span class="line">// 对比一下 ES5 风格的代码：</span><br><span class="line">var composeMixins = function () &#123;</span><br><span class="line">  var mixins = [].slice.call(arguments);</span><br><span class="line">  return function (instance, mix) &#123;</span><br><span class="line">    if (!instance) instance = &#123;&#125;;</span><br><span class="line">    if (!mix) &#123;</span><br><span class="line">      mix = function () &#123;</span><br><span class="line">        var fns = [].slice.call(arguments);</span><br><span class="line">        return function (x) &#123;</span><br><span class="line">          return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">            return fn(acc);</span><br><span class="line">          &#125;, x);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return mix.apply(null, mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的函数封装了一个 <code>pipe()</code>，它是标准的函数式编程的工具函数，通常<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">用于组合函数</a>。这个 <code>pipe()</code> 函数在 lodash 中是 <code>lodash/flow</code>，在 Ramda 中是 <code>R.pipe()</code>，在一些函数式编程语言中它甚至本身就是一个运算符号。</p><p>每个<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">熟悉函数式编程</a>的人都应该很熟悉它。它的实现主要依赖于<a href="https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d" target="_blank" rel="noopener">Reduce</a>。</p><p>在这个例子中，它用来组合混合函数，不过这点无关紧要（有专门写这方面的博客文章）。我们需要注意是以下几个重要的细节：</p><p>这个函数可以将任何数量的函数混合，最终返回一个函数，这个函数在管道中应用了其它的函数——就像流水线一样。每个混合函数都将实例（<code>instance</code>）作为输入，然后在将自己传递给管道中下一个函数之前，将一些变量传入。</p><p>如果你没有传入 <code>instance</code>，它将会为你创建一个新的对象。</p><p>有时你可能会想用别的混合方式。例如，使用 <code>compose()</code> 代替 <code>pipe()</code> 来传递函数，让组合顺序反过来。</p><p>如果你不需要自定义函数混合时的行为，你可以简单地使用默认设定，使用 <code>pipe()</code> 来完成过程。</p><h3 id="事实"><a href="#事实" class="headerlink" title="事实"></a>事实</h3><p>除了可读性的区别之外，以下列举了一些与这个例子有关的<strong>客观事实</strong>：</p><ul><li>我有多年的 ES5 与 ES6 编程经验，无论是箭头函数表达式还是别的函数表达式我都很熟悉。因此“偏爱”对我来说<strong>不是</strong>一个变化无常的因素。</li><li>我没几秒就写好了 ES6 版本的代码，它没有任何 bug（它通过了所有的单元测试，因此我敢肯定这点）。</li><li>写 ES5 版本的代码花了我好几分钟。一个是几秒，一个是几分钟，差距还是挺大的。写 ES5 代码时，我有 2 次弄错了函数的作用范围；写出了 3 个 bug，然后要花时间去分别调试与修复；还有 2 次我不得不使用 <code>console.log()</code> 来弄清函数执行的情况。</li><li>ES6 版本代码仅仅只有 4 行。</li><li>ES5 版本代码有 21 行（其中真正有代码的有 17 行）。</li><li>尽管 ES5 版本的代码更加冗长，但是它比起 ES6 版本的代码来说仍然缺少了一些信息。它虽然长，但是<strong>表达的东西更少</strong>。这个问题在后面会提到。</li><li>ES6 版本代码在代码中有 2 个 speard 运算符。而 ES5 版本代码中没有这个运算符，而是使用了<strong>意义晦涩</strong>的 <code>arguments</code> 对象，它将严重影响函数内容的可读性。（不推荐原因之一）</li><li>ES6 版本代码在函数片段中定义了 <code>mix</code> 的默认值，由此你可以很清楚地看到它是参数的值。而 ES5 版本代码却混淆了这个细节问题，将它隐藏在函数体中。（不推荐原因之二）</li><li>ES6 版本代码仅有 2 层代码块，这将会帮助读者理解代码结构，以及知道如何去阅读这个代码。而 ES5 代码有 6 层代码块，复杂的层级结构会让函数结构的可读性变得很差。（不推荐原因之三）</li></ul><p>在 ES5 版本代码中，<code>pipe()</code> 占据了函数体的大部分内容——要把它们放到同一行中去简直是个荒唐的想法。非常<strong>有必要</strong>将 <code>pipe()</code> 这个函数单独抽离出来，让我们的 ES5 版本代码更具有可读性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var pipe = function () &#123;</span><br><span class="line">  var fns = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">      return fn(acc);</span><br><span class="line">    &#125;, x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var composeMixins = function () &#123;</span><br><span class="line">  var mixins = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">  return function (instance, mix) &#123;</span><br><span class="line">    if (!instance) instance = &#123;&#125;;</span><br><span class="line">    if (!mix) mix = pipe;</span><br><span class="line"></span><br><span class="line">    return mix.apply(null, mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我觉得它更具可读性，并且更容易理解它的意思了。</p><p>让我们看看如果我们对 ES6 版本代码做一些可读性“优化”会怎么样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span><br><span class="line"></span><br><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = pipe</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>就像 ES5 版本代码的优化一样，这个“优化”后的代码更加冗长（它加入了之前没有的新变量）。与 ES5 版本代码不同，这个版本在将管道的概念抽象出来后<strong>并没有明显的提高代码可读性</strong>。不过毕竟函数里已经清楚的写明了 <code>mix</code> 这个变量，它还是更容易让人理解一些。</p><p><code>mix</code> 的定义本身在它的那一行就已经存在了，它不太可能会让阅读代码的人找不到何时结束 <code>mix</code>、剩下的代码何时执行。</p><p>而现在我们用了 2 个变量来表示同一个东西。我们因此而获益了吗？完全没有。</p><p>那么为什么 ES5 函数在对函数进行抽象之后会变得<strong>更具可读性</strong>呢？</p><p>因为之前 ES5 版本的代码<strong>明显更复杂</strong>。这种复杂度的来源是我们讨论的问题重点。我可以断言，它的复杂度的来源归根结底就是<strong>语法干扰</strong>，这种语法干扰只会让<strong>函数的本身含义变得费解</strong>，并没有别的用处。</p><p>让我们换种方法，把一些多余的变量去掉，在例子中都使用 ES6 代码，只比较<strong>箭头函数</strong>与<strong>传统函数表达式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var composeMixins = function (...mixins) &#123;</span><br><span class="line">  return function (</span><br><span class="line">    instance = &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    mix = function (...fns) &#123;</span><br><span class="line">      return function (x) &#123;</span><br><span class="line">        return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">          return fn(acc);</span><br><span class="line">        &#125;, x);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    return mix(...mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，至少我觉得它的可读性显著的提升了。我们利用 <strong>rest</strong> 语法以及<strong>默认参数</strong>语法对它进行了修改。当然，你得对 rest 语法和默认参数语法很熟悉才会觉得这个版本的代码更可读。不过即使你不了解这些，我觉得这个版本也会看起来更加<strong>有条理</strong>。</p><p>现在已经改进了许多了，但是我觉得这个版本还是比较简洁。将 <code>pipe()</code> 抽象出来，写到它自己的函数里可能会<strong>有所帮助</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const pipe = function (...fns) &#123;</span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">      return fn(acc);</span><br><span class="line">    &#125;, x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 传统函数表达式</span><br><span class="line">const composeMixins = function (...mixins) &#123;</span><br><span class="line">  return function (</span><br><span class="line">    instance = &#123;&#125;,</span><br><span class="line">    mix = pipe</span><br><span class="line">  ) &#123;</span><br><span class="line">    return mix(...mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样是不是更好了？现在 <code>mix</code> 只占了单独的一样，函数结构也更加的清晰——但是这样做不符合我的胃口，它的语法干扰实在是太多了。在现在的 <code>composeMixins()</code> 中，我觉得描述一个函数在哪结束、另一个函数从哪开始还不够清楚。</p><p>除了调用函数体之外，<code>funcion</code> 这个关键字似乎和其它的代码<strong>混淆</strong>在一起了。我的函数的真正的功能被<strong>隐藏</strong>了起来！参数的调用和函数体的起始到底在哪里？如果我仔细看也能够分析出来，但是它对我来说实在是不容易阅读。</p><p>那么如果我们去掉 <code>function</code> 这个关键字，然后通过一个<strong>大箭头</strong> <code>=&gt;</code> 指向返回值来代替 <code>return</code> 关键字，避免它们和其它关键部分混在一起，现在会怎么样呢？</p><p>我们当然可以这么做，代码会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = pipe</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>现在应该可以很清楚这段代码做了什么事了。<code>composeMixins()</code> 是一个函数，它传入了任意数量的 <code>mixins</code>，最终会返回一个得到两个额外参数（<code>instance</code> 与 <code>mix</code>）的函数。它返回了通过 <code>mixins</code> 管道组合的 <code>instance</code> 的结果。</p><p>还有一件事……如果我们对 <code>pipe()</code> 进行同样的优化，可以神奇地将它写到一行中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span><br></pre></td></tr></table></figure><p>当它在一行内被定义的时候，将它抽象成一个函数这件事反而变得不那么明了了。</p><p>另外请记住，这个函数在 Lodash、Ramda 以及其它库中都有用到，但是仅仅为了用这个函数就去 import 这些库并不是一件划得来的事。</p><p>那么我们自己写一行这个函数有必要吗？应该有的。它实际上是两个不同的函数，把它们分开会让代码更加清晰。</p><p>另一方面，如果将其写在一行中，当你看参数命名的时候，你就已经明了了其类型以及用例。我们将它写在一行，就如下面代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>现在让我们回头看看最初的函数。无论我们后面做了什么调整，<strong>我们都没有丢弃任何本来就有的信息</strong>。并且，通过在行内声明变量和默认值，我们还给这个函数<strong>增加了信息量</strong>，描述了这个函数是怎么使用的以及参数值是什么样子的。</p><p>ES5 版本中增加的额外的代码其实都是语法干扰。这些代码对于<strong>熟悉</strong>柯里化箭头函数的人来说<strong>没有任何有用之处</strong>。</p><p>只要你熟悉柯里化箭头函数，你就会觉得最开头的代码更加清晰并具有<strong>可读性</strong>，因为它没有多余的语法糊弄人。</p><p>柯里化箭头函数还能<strong>减少错误的藏身之处</strong>，因为它能让 bug 隐藏的部分更少。我猜想，在传统函数表达式中一定隐藏了许多的 bug，一旦你升级使用箭头函数就能找到并排除这些 bug。</p><p>我希望你的团队也能支持、学习与应用 ES6 的更加简洁的代码风格，提高工作效率。</p><p>有时，在代码中详细地进行描述是正确的行为，但通常来说，代码越少越好。如果更少的代码能够实现同样的东西，能够传达更多的信息，不用丢弃任何信息量，那么它<strong>明显</strong>更加优越。认知这些不同点的关键就是看它们表达的信息。如果加上的代码没有更多的意义，那么这种代码就不应该存在。这个道理很简单，就和自然语言的风格规范一样（不说废话）。将这种表达风格规范应用到代码中。拥抱它，你将能写出更好的代码。</p><p>一天过去，天色已黑，仍然有其它推特的回复在说 ES6 版本的代码更加缺乏可读性：</p><p><img src="/images/pasted-155.png" alt="upload successful"></p><p>我只想说：是时候熟练去掌握 ES6、柯里化与组合函数了。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p><a href="https://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“与 Eric Elliott 一起学习 JavaScript”</a>会员现在可以看这个大约 55 分钟的视频课程——<a href="https://ericelliottjs.com/premium-content/es6-curry-composition/" target="_blank" rel="noopener">ES6 柯里化与组合</a>。</p><p>如果你还不是我们的会员，你可会遗憾地错过这个机会哦！</p><p><img src="/images/pasted-156.png" alt="upload successful"></p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p><strong>*Eric Elliott*</strong> 是 O’Reilly 出版的<a href="http://pjabook.com" target="_blank" rel="noopener">*《Programming JavaScript Applications》*</a>书籍、<a href="http://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“与 Eric Elliott 学习 JavaScript”</a>课程作者。他曾经帮助 Adobe、莱美、华尔街日报、ESPN、BBC 进行软件开发，以及帮助 Usher、Frank Ocean、Metallica 等著名音乐家做网站。</p><p>最后<del>喂狗粮</del>：</p><p><strong>他与世界上最美丽的女人在旧金山湾区共度一生。</strong></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59158c92a0bb9f005fd58fd7" target="_blank" rel="noopener">https://juejin.im/post/59158c92a0bb9f005fd58fd7</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">lsvih</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">140</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">167</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">lsvih</span></div><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.5.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>