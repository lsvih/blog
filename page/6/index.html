<!DOCTYPE html><html class="theme-next pisces"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0"><link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.5.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"6U6P1RGK4F",apiKey:"b14e73cdd627eabe947b5decbe14850f",indexName:"lsvih",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="My note"><meta property="og:url" content="https://lsvih.com/page/6/index.html"><meta property="og:site_name" content="My note"><meta property="og:locale" content="default"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="My note"><link rel="canonical" href="https://lsvih.com/page/6/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>My note – lsvih</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My note</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">lsvih</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/07/04/V8-性能优化杀手/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/07/04/V8-性能优化杀手/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">V8 性能优化杀手</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-07-04 12:58:00" itemprop="dateCreated datePublished" datetime="2017-07-04T12:58:00+08:00">2017-07-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章将会给你一些建议，让你避免写出性能远低于期望值的代码。在此特别指出有一些代码会导致 V8 引擎（涉及到 Node.JS、Opera、Chromium 等）无法对相关函数进行优化。</p><p>vhf 正在做一个类似的项目，试图将 V8 引擎的性能杀手全部列出来：<a href="https://github.com/vhf/v8-bailout-reasons" target="_blank" rel="noopener">V8 Bailout Reasons</a>。</p><h3 id="V8-引擎背景知识"><a href="#V8-引擎背景知识" class="headerlink" title="V8 引擎背景知识"></a>V8 引擎背景知识</h3><p>V8 引擎中没有解释器，但有 2 种不同的编译器：普通编译器与优化编译器。编译器会将你的 JavaScript 代码编译成汇编语言后直接运行。但这并不意味着运行速度会很快。被编译成汇编语言后的代码并不能显著地提高其性能，它只能省去解释器的性能开销，如果你的代码没有被优化的话速度依然会很慢。</p><p>例如，在普通编译器中 <code>a + b</code> 将会被编译成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">call RuntimeAdd</span><br></pre></td></tr></table></figure><p>换句话说，其实它仅仅调用了 runtime 函数。但如果 <code>a</code> 和 <code>b</code> 能确定都是整型变量，那么编译结果会是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">add eax, ebx</span><br></pre></td></tr></table></figure><p>它的执行速度会比前面那种去在 runtime 中调用复杂的 JavaScript 加法算法快得多。</p><p>通常来说，使用普通编译器将会得到前面那种代码，使用优化编译器将会得到后面那种代码。走优化编译器的代码可以说比走普通编译器的代码性能好上 100 倍。但是请注意，并不是任何类型的 JavaScript 代码都能被优化。在 JS 中，有很多种情况（甚至包括一些我们常用的语法）是不能被优化编译器优化的（这种情况被称为“bailout”，从优化编译器降级到普通编译器）。</p><p>记住一些会导致整个函数无法被优化的情况是很重要的。JS 代码被优化时，将会逐个优化函数，在优化各个函数的时候不会关心其它的代码做了什么（除非那些代码被内联在即将优化的函数中。）。</p><p>这篇文章涵盖了大多数会导致函数坠入“无法被优化的深渊”的情况。不过在未来，优化编译器进行更新后能够识别越来越多的情况时，下面给出的建议与各种变通方法可能也会变的不再必要或者需要修改。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ol><li><a href="#1-工具">工具</a></li><li><a href="#2-不支持的语法">不支持的语法</a></li><li><a href="#3-使用-arguments">使用 <code>arguments</code></a></li><li><a href="#4-switch-case">Switch-case</a></li><li><a href="#5-for-in">For-in</a></li><li><a href="#6-退出条件藏的很深-或者没有定义明确出口的无限循环">退出条件藏的很深，或者没有定义明确出口的无限循环</a></li></ol><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><p>你可以在 node.js 中使用一些 V8 自带的标记来验证不同的代码用法对优化的影响。通常来说你可以创建一个包括特定模式的函数，然后使用所有允许的参数类型去调用它，再使用 V8 的内部去优化与检查它：</p><p>test.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建包含需要检查的情况的函数（检查使用 `eval` 语句是否能被优化）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStatus</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(%GetOptimizationStatus(fn)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(<span class="string">"Function is not optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(<span class="string">"Function is always optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(<span class="string">"Function is never optimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(<span class="string">"Function is maybe deoptimized"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">console</span>.log(<span class="string">"Function is optimized by TurboFan"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">"Unknown optimization status"</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别类型信息</span></span><br><span class="line">exampleFunction();</span><br><span class="line"><span class="comment">//这里调用 2 次是为了让这个函数状态从 uninitialized -&gt; pre-monomorphic -&gt; monomorphic</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line">%OptimizeFunctionOnNextCall(exampleFunction);</span><br><span class="line"><span class="comment">//再次调用</span></span><br><span class="line">exampleFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查</span></span><br><span class="line">printStatus(exampleFunction);</span><br></pre></td></tr></table></figure><p>运行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">(v0.12.7) Function is not optimized</span><br><span class="line">(v4.0.0) Function is optimized by TurboFan</span><br></pre></td></tr></table></figure><p><a href="https://codereview.chromium.org/1962103003" target="_blank" rel="noopener">https://codereview.chromium.org/1962103003</a></p><p>为了检验我们做的这个工具是否真的有用，注释掉 <code>eval</code> 语句然后再运行一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js</span><br><span class="line">[optimizing 000003FFCBF74231 &lt;JS Function exampleFunction (SharedFunctionInfo 00000000FE1389E1)&gt; - took 0.345, 0.042, 0.010 ms]</span><br><span class="line">Function is optimized</span><br></pre></td></tr></table></figure><p>事实证明，使用这个工具来验证处理方法是可行且必要的。</p><h2 id="2-不支持的语法"><a href="#2-不支持的语法" class="headerlink" title="2. 不支持的语法"></a>2. 不支持的语法</h2><p>有一些语法结构是不支持被编译器优化的，用这类语法将会导致包含在其中的函数不能被优化。</p><p><strong>请注意</strong>，即使这些语句不会被访问到或者不会被执行，它仍然会导致整个函数不能被优化。</p><p>例如下面这样做是没用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEVELOPMENT) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使 debugger 语句根本不会被执行到，上面的代码将会导致包含它的整个函数都不能被优化。</p><p>目前不可被优化的语法有：</p><ul><li><del>Generator 函数</del> （<a href="https://v8project.blogspot.de/2017/02/v8-release-57.html" target="_blank" rel="noopener">V8 5.7</a> 对其做了优化）</li><li><del>包含 for of 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/11e1e20" target="_blank" rel="noopener">11e1e20</a> 对其做了优化）</li><li><del>包含 try catch 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li><li><del>包含 try finally 语句的函数</del> （V8 commit <a href="https://github.com/v8/v8/commit/9aac80f" target="_blank" rel="noopener">9aac80f</a> / V8 5.3 / node 7.x 对其做了优化）</li><li><del>包含<a href="http://stackoverflow.com/q/34595356/504611" target="_blank" rel="noopener"><code>let</code> 复合赋值</a>的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li><li><del>包含 <code>const</code> 复合赋值的函数</del> （Chrome 56 / V8 5.6! 对其做了优化）</li><li>包含 <code>__proto__</code> 对象字面量、<code>get</code> 声明、<code>set</code> 声明的函数</li></ul><p>看起来永远不会被优化的语法有：</p><ul><li>包含 <code>debugger</code> 语句的函数</li><li>包含字面调用 <code>eval()</code> 的函数</li><li>包含 <code>with</code> 语句的函数</li></ul><p>最后明确一下：如果你用了下面任何一种情况，整个函数将不能被优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithProto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__proto__</span>: <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        get prop() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsObjectLiteralWithSetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        set prop(val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在此要特别提一下 <code>eval</code> 和 <code>with</code>，它们会导致它们的调用栈链变成动态作用域，可能会导致其它的函数也受到影响，因为这种情况无法从字面上判断各个变量的有效范围。</p><p><strong>变通办法</strong></p><p>前面提到的不能被优化的语句用在生产环境代码中是无法避免的，例如 <code>try-finally</code> 和 <code>try-catch</code>。为了让使用这些语句的影响尽量减小，它们需要被隔离在一个最小化的函数中，这样主要的函数就不会被影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorObject = &#123;<span class="attr">value</span>: <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">fn, ctx, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        errorObject.value = e;</span><br><span class="line">        <span class="keyword">return</span> errorObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = tryCatch(mightThrow, <span class="keyword">void</span> <span class="number">0</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//明确地报出 try-catch 会抛出什么</span></span><br><span class="line"><span class="keyword">if</span>(result === errorObject) &#123;</span><br><span class="line">    <span class="keyword">var</span> error = errorObject.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//result 是返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用-arguments"><a href="#3-使用-arguments" class="headerlink" title="3. 使用 arguments"></a>3. 使用 <code>arguments</code></h2><p>有许多种使用 <code>arguments</code> 的方式会导致函数不能被优化。因此当使用 <code>arguments</code> 的时候需要格外小心。</p><h4 id="3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例："><a href="#3-1-在非严格模式中，对一个已经被定义，同时在函数体中被-arguments-引用的参数重新赋值。典型案例：" class="headerlink" title="3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 arguments 引用的参数重新赋值。典型案例："></a>3.1. 在非严格模式中，对一个已经被定义，同时在函数体中被 <code>arguments</code> 引用的参数重新赋值。典型案例：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultArgsReassign</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变通方法</strong> 是将参数值保存在一个新的变量中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b_</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = b_;</span><br><span class="line">    <span class="comment">//与 b_ 不同，可以安全地对 b 进行重新赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅仅是像上面这样用 <code>arguments</code>（上面代码作用为检测第二个参数是否存在，如果不存在则赋值为 5），也可以用 <code>undefined</code> 检测来代替这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reAssignParam</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="keyword">void</span> <span class="number">0</span>) b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是之后如果需要用到 <code>arguments</code>，很容易忘记需要在这儿加上重新赋值的语句。</p><p><strong>变通方法 2</strong>：为整个文件或者整个函数开启严格模式 （<code>&#39;use strict&#39;</code>）。</p><h4 id="3-2-arguments-泄露："><a href="#3-2-arguments-泄露：" class="headerlink" title="3.2. arguments 泄露："></a>3.2. arguments 泄露：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leaksArguments3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arguments</code> 对象在任何地方都不允许被传递或者被泄露。</p><p><strong>变通方法</strong> 可以通过创建一个数组来代理 <code>arguments</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//.length 仅仅是一个整数，不存在泄露</span></span><br><span class="line">                    <span class="comment">//arguments 对象本身的问题</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">                <span class="comment">//i 是 arguments 对象的合法索引值</span></span><br><span class="line">        args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherNotLeakingExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">while</span> (i--) args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样要写很多让人烦的代码，因此得判断是否真的值得这么做。后面一次又一次的优化会代理更多的代码，越来越多的代码意味着代码本身的意义会被逐渐淹没。</p><p>不过，如果你有 build 这个过程，可以将上面这一系列过程由一个不需要 source map 的宏来实现，保证代码为合法的 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    INLINE_SLICE(args, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bluebird 就使用了这个技术，上面的代码经过 build 之后会被拓展成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesntLeakArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $_len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>($_len); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> $_i = <span class="number">0</span>; $_i &lt; $_len; ++$_i) &#123;</span><br><span class="line">        args[$_i] = <span class="built_in">arguments</span>[$_i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-对-arguments-进行赋值："><a href="#3-3-对-arguments-进行赋值：" class="headerlink" title="3.3. 对 arguments 进行赋值："></a>3.3. 对 arguments 进行赋值：</h4><p>在非严格模式下可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignToArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变通方法</strong>：犯不着写这么蠢的代码。另外，在严格模式下它会报错。</p><h4 id="那么如何安全地使用-arguments-呢？"><a href="#那么如何安全地使用-arguments-呢？" class="headerlink" title="那么如何安全地使用 arguments 呢？"></a>那么如何安全地使用 <code>arguments</code> 呢？</h4><p>只使用：</p><ul><li><code>arguments.length</code></li><li><code>arguments[i]</code> <strong><code>i</code> 需要始终为 arguments 的合法整型索引，且不允许越界</strong></li><li>除了 <code>.length</code> 和 <code>[i]</code>，不要直接使用 <code>arguments</code></li><li>严格来说用 <code>fn.apply(y, arguments)</code> 是没问题的，但除此之外都不行（例如 <code>.slice</code>）。 <code>Function#apply</code> 是特别的存在。</li><li>请注意，给函数添加属性值（例如 <code>fn.$inject = ...</code>）和绑定函数（即 <code>Function#bind</code> 的结果）会生成隐藏类，因此此时使用 <code>#apply</code> 不安全。</li></ul><p>如果你按照上面的安全方式做，毋需担心使用 <code>arguments</code> 导致不确定 arguments 对象的分配。</p><h2 id="4-Switch-case"><a href="#4-Switch-case" class="headerlink" title="4. Switch-case"></a>4. Switch-case</h2><p>在以前，一个 switch-case 语句最多只能包含 128 个 case 代码块，超过这个限制的 switch-case 语句以及包含这种语句的函数将不能被优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">over128Cases</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="number">128</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">129</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要让 case 代码块的数量保持在 128 个之内，否则应使用函数数组或者 if-else。</p><p>这个限制现在已经被解除了，请参阅此 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=2275#c9" target="_blank" rel="noopener">comment</a>。</p><h2 id="5-For-in"><a href="#5-For-in" class="headerlink" title="5. For-in"></a>5. For-in</h2><p>For-in 语句在某些情况下会导致整个函数无法被优化。</p><p>这也解释了”For-in 速度不快“之类的说法。</p><h4 id="5-1-键不是局部变量："><a href="#5-1-键不是局部变量：" class="headerlink" title="5.1. 键不是局部变量："></a>5.1. 键不是局部变量：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonLocalKey2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种用法db都将会导致函数不能被优化的问题。因此键不能在上级作用域定义，也不能在下级作用域被引用。它必须是一个局部变量。</p><h4 id="5-2-被遍历的对象不是一个”简单可枚举对象“"><a href="#5-2-被遍历的对象不是一个”简单可枚举对象“" class="headerlink" title="5.2. 被遍历的对象不是一个”简单可枚举对象“"></a>5.2. 被遍历的对象不是一个”简单可枚举对象“</h4><h5 id="5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"><a href="#5-2-1-处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“-这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。" class="headerlink" title="5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。"></a>5.2.1. 处于”哈希表模式“（又被称为”归一化对象“或”字典模式对象“ - 这种对象将哈希表作为其数据结构）的对象不是简单可枚举对象。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashTableIteration</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hashTable = &#123;<span class="string">"-"</span>: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> hashTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你给一个对象动态增加了很多的属性（在构造函数外）、<code>delete</code> 属性或者使用不合法的标识符作为属性，这个对象将会变成哈希表模式。换句话说，当你把一个对象当做哈希表来用，它就真的会变成哈希表。请不要对这种对象使用 <code>for-in</code>。你可以用过开启 Node.JS 的 <code>--allow-natives-syntax</code>，调用 <code>console.log(%HasFastProperties(obj))</code> 来判断一个对象是否为哈希表模式。</p><hr><h5 id="5-2-2-对象的原型链中存在可枚举属性"><a href="#5-2-2-对象的原型链中存在可枚举属性" class="headerlink" title="5.2.2. 对象的原型链中存在可枚举属性"></a>5.2.2. 对象的原型链中存在可枚举属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面这么做会给所有对象（除了用 <code>Object.create(null)</code> 创建的对象）的原型链中添加一个可枚举属性。此时任何包含了 <code>for-in</code> 语法的函数都不会被优化（除非仅遍历 <code>Object.create(null)</code> 创建的对象）。</p><p>你可以使用 <code>Object.defineProperty</code> 创建不可枚举属性（不推荐在 runtime 中调用，但是在定义一些例如原型属性之类的静态数据的时候它很高效）。</p><hr><h5 id="5-2-3-对象中包含可枚举数组索引"><a href="#5-2-3-对象中包含可枚举数组索引" class="headerlink" title="5.2.3. 对象中包含可枚举数组索引"></a>5.2.3. 对象中包含可枚举数组索引</h5><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4" target="_blank" rel="noopener">ECMAScript 262 规范</a> 定义了一个属性是否有数组索引：</p><blockquote><p>数组对象会给予一些种类的属性名特殊待遇。对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 2<sup>32</sup>−1 时，它是个 数组索引 。一个属性名是数组索引的属性也叫做元素 。</p></blockquote><p>一般只有数组有数组索引，但是有时候一般的对象也可能拥有数组索引： <code>normalObj[0] = value;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratesOverArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此使用 <code>for-in</code> 进行数组遍历不仅会比 for 循环要慢，还会导致整个包含 <code>for-in</code> 语句的函数不能被优化。</p><hr><p>如果你试图使用 <code>for-in</code> 遍历一个非简单可枚举对象，它会导致包含它的整个函数不能被优化。</p><p><strong>变通方法</strong>：只对 <code>Object.keys</code> 使用 <code>for-in</code>，如果要遍历数组需使用 for 循环。如果非要遍历整个原型链上的属性，需要将 <code>for-in</code> 隔离在一个辅助函数中以降低影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedKeys</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        ret.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-退出条件藏的很深，或者没有定义明确出口的无限循环"><a href="#6-退出条件藏的很深，或者没有定义明确出口的无限循环" class="headerlink" title="6. 退出条件藏的很深，或者没有定义明确出口的无限循环"></a>6. 退出条件藏的很深，或者没有定义明确出口的无限循环</h2><p>有时候在你写代码的时候，你需要用到循环，但是不确定循环体内的代码之后会是什么样子。所以这时候你用了一个 <code>while (true) {</code> 或者 <code>for (;;) {</code>，在之后将终止条件放在循环体中，打断循环进行后面的代码。然而你写完这些之后就忘了这回事。在重构时，你发现这个函数很慢，出现了反优化情况 - 上面的循环很可能就是罪魁祸首。</p><p>重构时将循环内的退出条件放到循环的条件部分并不是那么简单。</p><ol><li>如果代码中的退出条件是循环最后的 if 语句的一部分，且代码至少要运行一轮，那么你可以将这个循环重构为 <code>do{} while ();</code>。</li><li>如果退出条件在循环的开头，请将它放在循环的条件部分中去。</li><li>如果退出条件在循环体中部，你可以尝试”滚动“代码：试着依次将一部分退出条件前的代码移到后面去，然后在之前的位置留下它的引用。当退出条件可以放在循环条件部分，或者至少变成一个浅显的逻辑判断时，这个循环就不再会出现反优化的情况了。</li></ol><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5959edfc5188250d83241399" target="_blank" rel="noopener">https://juejin.im/post/5959edfc5188250d83241399</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/30/在html中使用背景透明的video视频/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/30/在html中使用背景透明的video视频/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">在html中使用背景透明的video视频</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-30 16:53:24" itemprop="dateCreated datePublished" datetime="2017-06-30T16:53:24+08:00">2017-06-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>由于对效果的要求，需要加入透明背景的video。经过了解，现代浏览器（新版 Chrome、Firefox、Safari 等）已经全面支持 webM 格式的视频了，因此可以使用带 alpha 通道的 webM 格式视频满足要求。</p><p>要得到透明 webM 格式视频，则需要来源视频已经带有透明通道。</p><p>目前有几种方法：</p><p>1、使用 blander 进行绿幕抠图，将 green screen 扣去，生成背景透明的 png 帧序列，然后使用 ffmpeg 之类的工具将其生成 webM 文件。</p><p>2、使用 Adobe After Effect 之类的软件，在渲染时直接输出 Alpha + RGB 通道文件，然后使用 ffmpeg 之类的工具将其转换为 webM 文件。</p><blockquote><p>ffmpeg 软件下载：<a href="https://ffmpeg.org/download.html" target="_blank" rel="noopener">https://ffmpeg.org/download.html</a></p></blockquote><p>由于视频是自己用 AE 做的，因此直接选用第二种方法很方便。</p><p>首先，将视频背景颜色改成透明的：</p><p><img src="/images/pasted-166.png" alt="upload successful"></p><p>模式选择 Alpha 添加。在工作区下方将网络切换为透明网络</p><p><img src="/images/pasted-167.png" alt="upload successful"></p><p>如果改成功了，此时应该看到工作区的背景是灰白两色栅格。</p><p>将合成添加到渲染队列，进行设置：</p><p><img src="/images/pasted-168.png" alt="upload successful"></p><p>将输出模块改为“使用 Alpha 无损耗”，此时详情应该可以看到格式为 QuickTime，通道是 RGB + Alpha</p><p><img src="/images/pasted-169.png" alt="upload successful"></p><p>渲染输出，得到 .mov 文件，使用 ffmpeg 对其进行压缩编码。</p><p>执行命令：</p><pre><code>ffmpeg -i in.mov -c:a libvorbis -ac 1 -b:a 96k -ar 48000 -b:v 1100k -maxrate 1100k -bufsize 1835k out.webm
</code></pre><p>得到 out.webm，它就是所需要的透明背景的 webM 文件了，可以在网页中使用 <code>&lt;video&gt;</code> tag 引用。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/15/用-Go-语言理解-Tensorflow/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">用 Go 语言理解 Tensorflow</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-15 15:41:00" itemprop="dateCreated datePublished" datetime="2017-06-15T15:41:00+08:00">2017-06-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>根据官方说明，Tensorflow 开发者发布了以下内容：</p><ul><li><p>C++ 源码：底层和高层的具体功能由 C ++ 源码实现，它是真正 Tensorflow 的核心。</p></li><li><p>Python 封装与Python 库：由 C++ 实现自动生成的封装版本，通过这种方式我们可以直接用 Python 来调用 C++ 函数：这也是 numpy 的核心实现方式。</p><p>Python 库通过将 Python 封装版的各种调用结合起来，组成了各种广为人知的高层 API。</p></li><li><p>Java 封装</p></li><li><p>Go 封装</p></li></ul><p>作为一名 Gopher 而非一名 java 爱好者，我对 Go 封装给予了极大的关注，希望了解其适用于何种任务。</p><blockquote><p>译注，这里说的”封装“也有说法叫做”语言界面“</p></blockquote><h2 id="Go-封装"><a href="#Go-封装" class="headerlink" title="Go 封装"></a>Go 封装</h2><p><img src="/images/pasted-165.png" alt="upload successful"></p><p>图为 Gopher（由 Takuya Ueda <a href="https://twitter.com/tenntenn" target="_blank" rel="noopener">@tenntenn</a> 创建，遵循 CC 3.0 协议）与 Tensorflow 的 Logo 结合在一起。</p><hr><p>首先要注意的是，代码维护者自己也承认了，Go API 缺少 <code>Variable</code> 支持，因此这个 API 仅用于<strong>使用</strong>训练好的模型，而<strong>不能用于</strong>进行模型训练。</p><p>在文档 <a href="https://www.tensorflow.org/versions/master/install/install_go" target="_blank" rel="noopener">Installing Tensorflow for Go</a> 中已经明确提到：</p><blockquote><p>TensorFlow 为 Go 编程提供了一些 API。这些 API 特别适合加载在 Python 中创建的模型，让其在 Go 应用 中运行。</p></blockquote><p>如果我们对训练机器学习模型没兴趣，那这个限制是 OK 的。</p><p>但是，如果你打算自己训练模型，请看下面给的建议：</p><blockquote><p>作为一名 Gopher，请让 Go 保持简洁！使用 Python 去定义、训练模型，在这之后你随时都可以用 Go 来加载训练好的模型！（意思就是他们懒得开发呗）</p></blockquote><p>简而言之，golang 版 tensorflow 可以<strong>导入与定义</strong>常数图（constant graph）。这个常数图指的是在图中没有训练过程，也没有需要训练的变量。</p><p>让我们用 Golang 深入研究 Tensorflow 吧！首先创建我们的第一个应用。</p><p>我建议读者在阅读下面的内容前，先准备好 Go 环境，以及编译、安装好 Tensorflow Go 版（编译、安装过程参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/go/README.md" target="_blank" rel="noopener">README</a>）。</p><h2 id="理解-Tensorflow-的结构"><a href="#理解-Tensorflow-的结构" class="headerlink" title="理解 Tensorflow 的结构"></a>理解 Tensorflow 的结构</h2><p>先复习一下什么是 Tensorflow 吧！（这是我个人的理解，和<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">官网</a>的有所不同）</p><blockquote><p>TensorFlow™ 是一个采用数据流图(data flow graphs),用于数值计算的开源软件库。节点（Nodes）在图中<strong>表示</strong>数学操作，图中的线（edges）则<strong>表示</strong>在节点间相互联系的多维数据数组，即张量（tensor）。</p></blockquote><p>我们可以把 Tensorflow 看做一种类似于 SQL 的描述性语言，首先你得确定你需要什么数据，它会通过底层引擎（数据库）分析你的查询语句，检查你的句法错误和语法错误，将查询语句转换为私有语言表达式，进行优化之后运算得出计算结果。这样，它能保证将正确的结果传达给你。</p><p>因此，我们无论使用什么 API 实质上都是在描述一个图。我们将它放在 <code>Session</code> 中作为求值的起点，这样做确定了这个图将会在这个 Session 中运行。</p><p>了解这一点，我们可以试着定义一个计算操作的图，并将其放在一个 <code>Session</code> 中进行求值。</p><p><a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go" target="_blank" rel="noopener">API 文档</a>中明确告知了 <code>tensorflow</code>（简称 <code>tf</code>）包与 <code>op</code> 包中的可用方法列表。</p><p>在这个列表中我们可以看到，这两个包中包含了一切我们需要用来定义与评价图的方法。</p><p><code>tf</code> 包中包含了各种构建基础结构的函数，例如 <code>Graph</code>（图）。<code>op</code> 包是最重要的包，它包含了由 C++ 实现自动生成的绑定等功能。</p><p>现在，假设我们要计算 AAA 与 xxx 的矩阵乘法：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fg9itnbsc7j31au06274m.jpg" alt=""></p><p>我假定你们都熟悉 tensorflow 图的定义，都了解 placeholder 并知道它们的工作原理。</p><p>下面的代码是一位 Tensorflow Python 用户第一次尝试时会写的代码。让我们给这个文件取名为 <code>attempt1.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span></span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">	x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line"></span><br><span class="line">	graph, err := root.Finalize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session</span><br><span class="line">	sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量</span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]</span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]</span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor</span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;</span><br><span class="line">		A: matrix,</span><br><span class="line">		x: column,</span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int64</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码写好了注释，我建议读者阅读上面的每一条注释。</p><p>现在，这位 Tensorflow Python 用户自我感觉良好，认为他的代码能够成功编译与运行。让我们试一试吧：</p><p><code>go run attempt1.go</code></p><p>然后他会看到：</p><p><code>panic: failed to add operation &quot;Placeholder&quot;: Duplicate node name in graph: &#39;Placeholder&#39;</code></p><p>等等，为什么会这样呢？</p><p>问题很明显。上面代码里出现了 2 个重名的“Placeholder”操作。</p><h2 id="第-1-课：node-IDs"><a href="#第-1-课：node-IDs" class="headerlink" title="第 1 课：node IDs"></a>第 1 课：node IDs</h2><p><strong>每次在我们调用方法定义一个操作的时候，不管他是否在之前被调用过，Python API 都会生成不同的节点</strong>。</p><p>所以，下面的代码没有任何问题，会返回 3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.placeholder(tf.int32, shape=())</span><br><span class="line">b = tf.placeholder(tf.int32, shape=())</span><br><span class="line">add = tf.add(a,b)</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(sess.run(add, feed_dict=&#123;a: <span class="number">1</span>,b: <span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>我们可以验证一下这个问题，看看程序是否创建了两个不同的 placeholder 节点： <code>print(a.name, b.name)</code></p><p>它打印出 <code>Placeholder:0 Placeholder_1:0</code>。</p><p>这样就清楚了，<code>a</code> placeholder 是 <code>Placeholder:0</code> 而 <code>b</code> placeholder 是 <code>Placeholder_1:0</code>。</p><p>但是在 Go 中，上面的程序会报错，因为 <code>A</code> 与 <code>x</code> 都叫做 <code>Placeholder</code>。我们可以由此得出结论：</p><p><strong>每次我们调用定义操作的函数时，Go API 并不会自动生成新的名称</strong>。因此，它的操作名是固定的，我们没法修改。</p><h4 id="提问时间："><a href="#提问时间：" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>图中的每个节点都必须有唯一的名称。所有节点都是通过名称进行辨认。</strong></p></li><li><p>节点名称与定义操作符的名称是否相同？</p><p><strong>是的，也可说节点名称是操作符名称的最后一段。</strong></p></li></ul><p>接下来让我们修复节点名称重复的问题，来弄明白上面的第二个提问。</p><h2 id="第-2-课：作用域"><a href="#第-2-课：作用域" class="headerlink" title="第 2 课：作用域"></a>第 2 课：作用域</h2><p>正如我们所见，Python API 在定义操作时会自动创建新的名称。如果研究底层会发现，Python API 调用了 C++ <code>Scope</code> 类中的 <code>WithOpName</code> 方法。</p><p>下面是该方法的文档及特性，参考 <a href="https://github.com/tensorflow/tensorflow/blob/a5b1fb8e56ceda0ee2794ee05f5a7642157875c5/tensorflow/cc/framework/scope.h" target="_blank" rel="noopener">scope.h</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回新的作用域。所有在返回的作用域中的 op 都会被命名为</span></span><br><span class="line"><span class="comment">/// &lt;name&gt;/&lt;op_name&gt;[_&lt;suffix].</span></span><br><span class="line">Scope WithOpName(<span class="keyword">const</span> <span class="keyword">string</span>&amp; op_name) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>注意这个方法，返回一个作用域 <code>Scope</code> 来对节点进行命名，因此节点名称事实上就是作用域 <code>Scope</code>。</p><p><code>Scope</code> 就是从根 <code>/</code>（空图）追溯至 <code>op_name</code> 的<strong>完整路径</strong>。</p><p><code>WithOpName</code> 方法在我们尝试添加一个有着相同的 <code>/</code> 到 <code>op_name</code> 路径的节点时，为了避免在相同作用域下有重复的节点，会为其加上一个后缀 <code>_&lt;suffix&gt;</code>（<code>&lt;suffix&gt;</code> 是一个计数器）。</p><p>了解了以上内容，我们可以通过在 <code>type Scope</code> 中寻找 <code>WithOpName</code> 来解决重复节点名称的问题。然而，Go tf API 中没有这个方法。</p><p>如果查阅 <a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope" target="_blank" rel="noopener">type Scope 的文档</a>，我们可以看到唯一能返回新 <code>Scope</code> 的方法只有 <code>SubScope(namespace string)</code>。</p><p>下面引用文档中的内容：</p><blockquote><p>SubScope 将会返回一个新的 Scope，这个 Scope 能确保所有的被加入图中的操作都被放置在 ‘namespace’ 的命名空间下。如果这个命名空间和作用域中已经存在的命名空间冲突，将会给它加上后缀。</p></blockquote><p>这种加后缀的冲突处理和 C++ 中的 <code>WithOpName</code> 方法<strong>不同</strong>，<code>WithOpName</code> 是在<strong>操作名后面</strong>加<code>suffix</code>，它们都在同样的作用域内（例如 <code>Placeholder</code> 变成 <code>Placeholder_1</code>），而 Go 的 <code>SubScope</code> 是在<strong>作用域名称后面</strong>加 <code>suffix</code>。</p><p>这将导致这两种方法会生成完全不同的图（节点在不同的作用域中了），但是它们的计算结果却是一样的。</p><p>让我们试着改一改 placeholder 定义，让它们定义两个不同的节点，然后打印 <code>Scope</code> 名称。</p><p>让我们创建 <code>attempt2.go</code> ，将下面几行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line"><span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">fmt.Println(A.Op.Name(), x.Op.Name())</span><br></pre></td></tr></table></figure><p>编译、运行： <code>go run attempt2.go</code>，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br></pre></td></tr></table></figure><h4 id="提问时间：-1"><a href="#提问时间：-1" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>节点完全由其定义所在的作用域标识。这个”作用域“是我们从图的根节点追溯到指定节点的一条路径。有两种方法来定义执行同一种操作的节点：1、将其定义放在不同的作用域中（Go 风格）2、改变操作名称（我们在 C++ 中可以这么做，Python 版会自动这么做）</strong></p></li></ul><p>现在，我们已经解决了节点命名重复的问题，但是现在我们的控制台中出现了另一个问题：</p><pre><code>panic: failed to add operation &quot;MatMul&quot;: Value for attr &apos;T&apos; of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128
</code></pre><p>为什么 <code>MatMul</code> 节点的定义出错了？我们要做的仅仅是计算两个 <code>tf.int64</code> 矩阵的乘积而已！似乎 <code>MatMul</code> 偏偏不能接受 <code>int64</code> 的类型。</p><blockquote><p>Value for attr ‘T’ of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128</p></blockquote><p>上面这个列表是什么？为什么我们能计算 2 个 <code>int32</code> 矩阵的乘积却不能计算 <code>int64</code> 的乘积？</p><p>下面我们将解决这个问题。</p><h2 id="第-3-课：Tensorflow-类型系统"><a href="#第-3-课：Tensorflow-类型系统" class="headerlink" title="第 3 课：Tensorflow 类型系统"></a>第 3 课：Tensorflow 类型系统</h2><p>让我们深入研究 <a href="https://github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/core/ops/math_ops.cc#L1048" target="_blank" rel="noopener">源代码</a> 来看 C++ 是如何定义 <code>MatMul</code> 操作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_OP(<span class="string">"MatMul"</span>)</span><br><span class="line">    .Input(<span class="string">"a: T"</span>)</span><br><span class="line">    .Input(<span class="string">"b: T"</span>)</span><br><span class="line">    .Output(<span class="string">"product: T"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_a: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_b: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"T: &#123;half, float, double, int32, complex64, complex128&#125;"</span>)</span><br><span class="line">    .SetShapeFn(shape_inference::MatMulShape)</span><br><span class="line">    .Doc(R<span class="string">"doc(</span></span><br><span class="line"><span class="string">Multiply the matrix "</span>a<span class="string">" by the matrix "</span>b<span class="string">".</span></span><br><span class="line"><span class="string">The inputs must be two-dimensional matrices and the inner dimension of</span></span><br><span class="line"><span class="string">"</span>a<span class="string">" (after being transposed if transpose_a is true) must match the</span></span><br><span class="line"><span class="string">outer dimension of "</span>b<span class="string">" (after being transposed if transposed_b is</span></span><br><span class="line"><span class="string">true).</span></span><br><span class="line"><span class="string">*Note*: The default kernel implementation for MatMul on GPUs uses</span></span><br><span class="line"><span class="string">cublas.</span></span><br><span class="line"><span class="string">transpose_a: If true, "</span>a<span class="string">" is transposed before multiplication.</span></span><br><span class="line"><span class="string">transpose_b: If true, "</span>b<span class="string">" is transposed before multiplication.</span></span><br></pre></td></tr></table></figure><p>这几行代码为 <code>MatMul</code> 操作定义了一个接口，由 <code>REGISTER_OP</code> 宏对此操作做出了如下描述：</p><ul><li>名称: <code>MatMul</code></li><li>参数: <code>a</code>, <code>b</code></li><li>属性（可选参数）: <code>transpose_a</code>, <code>transpose_b</code></li><li>模版 <code>T</code> 支持的类型: <code>half, float, double, int32, complex64, complex128</code></li><li>输出类型: 自动识别</li><li>文档</li></ul><p>这个宏没有包含任何 C++ 代码，但是它告诉了我们<strong>当在定义一个操作的时候，即使它使用模版定义，我们也需要指定特定类型 <code>T</code> 支持的类型（或属性）列表。</strong></p><p>实际上，属性 <code>.Attr(&quot;T: {half, float, double, int32, complex64, complex128}&quot;)</code> 将 <code>T</code> 的类型限制在了这个类型列表中。<br><a href="https://www.tensorflow.org/extend/adding_an_op" target="_blank" rel="noopener">tensorflow 教程</a>中提到，当时模版 <code>T</code> 时，我们需要对所有支持的重载运算在内核进行注册。这个内核会使用 CUDA 方式引用 C/C++ 函数，进行并发执行。</p><p><code>MatMul</code> 的作者可能是出于以下 2 个原因仅支持上述类型而将 <code>int64</code> 排除在外的：</p><ol><li>疏忽：这个是有可能的，毕竟 Tensorflow 的作者也是人类呀！</li><li>为了支持不能使用 <code>int64</code> 的设备，可能这个特性的内核实现不能在各种支持的硬件上运行。</li></ol><p>回到我们的问题中，已经很清楚如何解决问题了。我们需要将 <code>MatMul</code> 支持类型的参数传给它。</p><p>让我们创建 <code>attempt3.go</code> ，将所有 <code>int64</code> 的地方都改成 <code>int32</code>。</p><p>有一点需要注意：<strong>Go 封装版 tf 有自己的一套类型，基本与 Go 本身的类型 1:1 相映射。当我们要将值传入图中时，我们必须遵循这种映射关系（例如定义 <code>tf.Int32</code> 类型的 placeholder 时要传入 <code>int32</code>）。从图中取值同理。</strong></p><p><code>*tf.Tensor</code> 类型将会返回一个张量 evaluation，它包含一个 <code>Value()</code> 方法，此方法将返回一个必须转换为正确类型的 <code>interface{}</code>（这是从图的结构了解到的）。</p><p>运行 <code>go run attempt3.go</code>，得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br><span class="line">[[210] [-210]]</span><br></pre></td></tr></table></figure><p>成功了！</p><p>下面是 <code>attempt3</code> 的完整代码，你可以编译并运行它。（这是一个 Gist，如果你发现有啥可以改进的话欢迎来<a href="https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）" target="_blank" rel="noopener">https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                        </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (                                            </span><br><span class="line">	<span class="string">"fmt"</span>                                       </span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span>                                              </span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span>                                              </span><br><span class="line">)                                                   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                       </span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()                       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	<span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line">	<span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">	A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))   </span><br><span class="line">	x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))   </span><br><span class="line">	fmt.Println(A.Op.Name(), x.Op.Name())       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)            </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line">	graph, err := root.Finalize()               </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session                        </span><br><span class="line">        sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)                                           </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量             </span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor               </span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]                 </span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                       </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]                      </span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                            </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor                    </span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;                                             </span><br><span class="line">		A: matrix,                          </span><br><span class="line">		x: column,                          </span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;            </span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int32</span>))                                            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问时间：-2"><a href="#提问时间：-2" class="headerlink" title="提问时间："></a>提问时间：</h4><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>每个操作都有自己的一组关联内核。Tensorflow 是一种强类型的描述性语言，它不仅遵循 C++ 类型规则，同时要求在 op 注册时需定义好类型才能实现其功能。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Go 来定义与处理一个图让我们能够更好地理解 Tensorflow 的底层结构。通过不断地试错，我们最终解决了这个简单的问题，一步一步地掌握了图、节点以及类型系统的知识。</p><p>如果你觉得这篇文章有用，请点个赞或者分享给别人吧~</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59420951128fe1006a1960f8" target="_blank" rel="noopener">https://juejin.im/post/59420951128fe1006a1960f8</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/11/Reinforcement-Learning-notes-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/11/Reinforcement-Learning-notes-1/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">Reinforcement Learning notes(1)</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-11 14:33:00" itemprop="dateCreated datePublished" datetime="2017-06-11T14:33:00+08:00">2017-06-11</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Stanford CS229 notes 12: <a href="http://cs229.stanford.edu/notes/cs229-notes12.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes12.pdf</a></p><p><a href="//lsivh.com/img/1496555948888450.pdf">cs229-notes12.pdf</a></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>在CS229 notes 中提到了强化学习的意义：</p><p>In the reinforcement learning framework, we will instead provide our algorithms only a reward function, which indicates to the learning agent when it is doing well, and when it is doing poorly.</p><p>个人的理解就是强化学习就是让 agent 根据环境包含的信息与强化信号量判断策略的选择，同时策略的不同造成的结果会以反馈的形式产生强化信号量给 agent，最终 agent 以“得到最大化的正强化信号量”为标准，做出最佳的策略选择。</p><p>换句话说，强化学习不会给模型提供任何“正确的决策”规则，只会给 agent 从环境状态得来的强化信号量，通过这种方式，agent 在行动=&gt;评价=&gt;学习的过程中学习到了知识，学到了如何做出让评价最好的决策方式。</p><h3 id="Markov-decision-processes-MDP"><a href="#Markov-decision-processes-MDP" class="headerlink" title="Markov decision processes (MDP)"></a>Markov decision processes (MDP)</h3><p>马尔科夫决策过程为一个包含5个元素的元组</p><p>$$ MDP = (S,A,{P_{sa}},\gamma,R)$$</p><p>其中：</p><p>S 为 states，状态集，包含所有 agent 可能处于的状态。</p><p>A 为 actions，行动集，包含了所有 agent 在各种状态下可以采取的行动。</p><p>$P_{sa}$ 为概率，代表了 agent 在 s 状态下做出 a 行动的概率</p><p>$\gamma$ 的值 $\gamma in [0,1)$，称为“discount factor”，可以理解为“折算率”</p><p>R 为奖励函数（reward function），其值由$S\times A \mapsto R$或$S \mapsto R$决定。</p><p>马尔科夫决策过程即为 agent 从初状态$s_0$开始行动，在马尔科夫决策的 A（行动集）中选择一种行动方式 $a_0 \in A$，到达第二个状态$s_1$，接着选择$a_1$……</p><p>$$s_0 \overset{a_0}{\rightarrow} s_1\overset{a_1}{\rightarrow} s_2\overset{a_2}{\rightarrow} s_3\overset{a_3}{\rightarrow} …$$</p><p>这个过程的价值（payoff）记作</p><p>$$R(s_0,a_0) + \gamma R(s_1,a_1)+\gamma^2 R(s_2,a_2) + …$$</p><p>简写为</p><p>$$r_0 + \gamma r_1 + \gamma^2 r_2 + …$$</p><p>$\gamma^i$会越来越小，因此越后面的 R 权值越小。</p><p>当 MDP 确定后，每次决策时的状态、行为都是确定的，为了让 agent 在任意状态做出最佳的行为让状态尽量达到最好的情况（即获得最大的奖励值），需要确定一组策略，让整个过程的价值尽量最大化。</p><p>整个过程的期望记为：</p><p>$$E[r_0 + \gamma r_1+\gamma^2 r_2 + …]$$</p><p>将策略记为$\pi$，规定了任意情况下的$s \rightarrow a$，因此可以记为：</p><p>$$a = \pi (s)$$</p><p>这个策略的价值函数（value function）记为</p><p>$$V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2 + …| r_0=R(s),\pi]$$</p><p>上式表示的是在起点为$s$、使用策略[latex]pi[/latex]的情况下的价值函数值。</p><h4 id="状态值函数"><a href="#状态值函数" class="headerlink" title="状态值函数"></a>状态值函数</h4><h5 id="策略评价"><a href="#策略评价" class="headerlink" title="策略评价"></a>策略评价</h5><p>对上式变换：</p><p>$$V^\pi(s)=E[r_0 + \gamma r_1+\gamma^2 r_2+ …| r_0=R(s),\pi]$$</p><p>$$V^pi(s_t)=E_\pi[r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + …]$$</p><p>$$V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]$$</p><p>上式的$s_{t+1}$指的是$s_t$状态经过策略$\pi$之后到达的下一个状态。根据$P_{s\pi(s)}$对上式期望值进行展开，同时考虑在状态$s_t$下的所有策略动作情况：</p><p>$$V^\pi(s_t) = E_\pi[r_t + \gamma V^\pi(s_{t+1})]$$</p><p>$$=\sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^\pi(s_{t+1})] $$</p><p>上式中的$P(s_{t+1}|s_t,\pi(s))$指的是在$s_t$状态下进行策略$\pi(s)$到达状态 $s_{t+1}$的概率，$R(s_t,\pi(s),s_{t+1})$为从状态 $s_t$ 转移到状态 $s_{t+1}$ 的期望回报值（其实就是之前的$s_t$）。</p><p>根据贝尔曼最优化方程，有</p><p>$$V^<em>(s_t) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,pi(s)) [R(s_t,\pi(s),s_{t+1}) + \gamma V^</em>(s_{t+1})]$$</p><p>因此，对于任意一种策略$\pi$，我们都能通过这种方法对各个动作得到的价值函数值进行最大化迭代，逐渐逼近最大价值函数值。</p><p>$$<br>\text{input pi} \\<br>\text{While }\Delta &lt; \theta {\\<br>\text{tmp} = V(s)\\<br>V(s) = \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,\pi(s))[R(s_t,\pi(s),s_{t+1}) +\gamma V^*(s_{t+1})\\<br>\Delta = \max(\Delta,|V(s) - \text{tmp}|)\\<br>} \\<br>\text{output } V(s) \approx V^\pi(s)$$</p><h5 id="策略改进"><a href="#策略改进" class="headerlink" title="策略改进"></a>策略改进</h5><p>假设有$\pi$与$\pi_1$两种策略，如果$Q^\pi(s,\pi_1(s)) \geq V^\pi(s)$（也就是$V^\pi_1(s) \geq V^\pi$），那么说明$\pi_1$的效果一定比$\pi$要好。</p><p>以此为依据，可以在每个状态 s 下对决策允许集进行遍历，计算所有决策会产生的价值函数值，根据贪心策略找到产生做大价值函数值的策略$\pi^*$，它即为效果最好的策略。</p><p>$$\pi_1 = \arg \max_a Q^\pi(s,a)$$</p><p>$$=\arg \max_a \sum_{s_{t+1}} P(s_{t+1}|s_t,a) [R(s_t,a,s_{t+1}) + \gamma V^*(s_{t+1})] $$</p><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><p>由上面的策略评价进行计算，能够得到当前策略下最大的价值函数值，接着使用策略改进，得到更好的策略$\pi_1$，再接着对这个$\pi_1$再次使用策略评估……这样一遍又一遍地迭代计算，最终能得到趋近最佳值的策略价值函数值与对应的策略。</p><p><img src="/images/pasted-163.png" alt="upload successful"></p><h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p><img src="/images/pasted-164.png" alt="upload successful"></p><h3 id="值迭代与策略迭代的区别"><a href="#值迭代与策略迭代的区别" class="headerlink" title="值迭代与策略迭代的区别"></a>值迭代与策略迭代的区别</h3><p><a href="https://www.zhihu.com/question/41477987" target="_blank" rel="noopener">https://www.zhihu.com/question/41477987</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/09/解决flask慢的问题-以及开启多线程之后jpype的错误/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">解决flask慢的问题,以及开启多线程之后jpype的错误</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-09 15:54:00" itemprop="dateCreated datePublished" datetime="2017-06-09T15:54:00+08:00">2017-06-09</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Back-End/" itemprop="url" rel="index"><span itemprop="name">Back End</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>用 flask 做 API 时，发现在 client 的请求需要很长的时间才能得到响应（差不多要 20 多秒）。Google 之后得到解决方案，使用配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(threaded=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>开启多线程模式。</p><p>然而这个服务是使用 java 做的底层，用 jpype 让 python 能调用 java 的方法。flask 开启多线程之后服务报错。经过研究发现是 JVM 并没有能为新开启的线程提供服务。查阅 jpype 的文档，找到 python 线程相关部分：<a href="http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads" target="_blank" rel="noopener">http://jpype.sourceforge.net/doc/user-guide/userguide.html#python_threads</a></p><p>因此可在调用 java class 前加上一个判断语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> jpype.isThreadAttachedToJVM():</span><br><span class="line">    jpype.attachThreadToJVM()</span><br></pre></td></tr></table></figure><p>使用 isTreadAttachedToJVM 先做出判断，然后使用 attachThreadToJVM 让 JVM 能为新线程提供服务。</p><p>完成上述步骤之后，发现已经没有报错了，但是相应速度依然很慢。从服务端控制台看，早已返回了 200，但是在浏览器中迟迟收不到数据，一直是 Pending 状态。查阅资料发现 flask 默认开启 Debug 模式，会对 response 做大量分析记录，使用配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(debug=False)</span><br></pre></td></tr></table></figure><p>关闭 Debug 模式，再连接发现响应时间大大减小了，从 20 多秒减到了几百毫秒。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/05/RxJS-简介：可观察对象、观察者与操作符/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">RxJS 简介：可观察对象、观察者与操作符</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-05 11:41:47" itemprop="dateCreated datePublished" datetime="2017-06-05T11:41:47+08:00">2017-06-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>对于响应式编程来说，RxJS 是一个不可思议的工具。今天我们将深入探讨什么是 Observable（可观察对象）和 observer（观察者），然后了解如何创建自己的 operator（操作符）。</p><p>如果你之前用过 RxJS，想了解它的内部工作原理，以及 Observable、operator 是如何运作的，这篇文章将很适合你阅读。</p><h3 id="什么是-Observable（可观察对象）？"><a href="#什么是-Observable（可观察对象）？" class="headerlink" title="什么是 Observable（可观察对象）？"></a>什么是 Observable（可观察对象）？</h3><p>可观察对象其实就是一个比较特别的函数，它接受一个“观察者”（observer）对象作为参数（在这个观察者对象中有 “next”、“error”、“complete”等方法），以及它会返回一种解除与观察者关系的逻辑。例如我们自己实现的时候会使用一个简单的 “unsubscribe” 函数来实现退订功能（即解除与观察者绑定关系的逻辑）。而在 RxJS 中， 它是一个包含 <code>unsubsribe</code> 方法的订阅对象（Subscription）。</p><p>可观察对象会创建观察者对象（稍后我们将详细介绍它），并将它和我们希望获取数据值的“东西”连接起来。这个“东西”就是生产者（producer），它可能来自于 <code>click</code> 或者 <code>input</code> 之类的 DOM 事件，是数据值的来源。当然，它也可以是一些更复杂的情况，比如通过 HTTP 与服务器交流的事件。</p><p>我们稍后将要自己写一个可观察对象，以便更好地理解它！在此之前，让我们先看看一个订阅对象的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input[type=text]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`你刚刚输入了 <span class="subst">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class="line">  error: <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Oops... <span class="subst">$&#123;err&#125;</span>`</span>),</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`完成!`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个例子使用了一个 <code>&lt;input type=&quot;text&quot;&gt;</code> 节点，并将其传入 <code>Rx.Observable.fromEvent()</code> 中。当我们触发指定的事件名时，它将会返回一个输入的 <code>Event</code> 的可观察对象。（因此我们在 console.log 中用 <code>${event.target.value}</code> 可以获取输入值）</p><p>当输入事件被触发的时候，可观察对象会将它的值传给观察者。</p><h3 id="什么是-Observer（观察者）？"><a href="#什么是-Observer（观察者）？" class="headerlink" title="什么是 Observer（观察者）？"></a>什么是 Observer（观察者）？</h3><p>观察者相当容易理解。在前面的例子中，我们传入 <code>.subscribe()</code> 中的对象字面量就是观察者（订阅对象将会调用我们的可观察对象）。</p><blockquote><p><code>.subscribe(next, error, complete)</code> 也是一种合法的语法，但是我们现在研究的是对象字面量的情况。</p></blockquote><p>当一个可观察对象产生数据值的时候，它会通知观察者，当新的值被成功捕获的时候调用 <code>.next()</code>，发生错误的时候调用 <code>.error()</code>。</p><p>当我们订阅一个可观察对象的时候，它会持续不断地将值传递给观察者，直到发生以下两件事：一种是生产者告知没有更多的值需要传递了，这种情况它会调用观察者的 <code>.complete()</code> ；一种是我们（“消费者”）对之后的值不再感兴趣，决定取消订阅（unsubsribe）。</p><p>如果我们想要对可观察对象传来的值进行组成构建（compose），那么在值传达最终的 <code>.subscribe()</code> 代码块之前，需要经过一连串的可观察对象（也就是操作符）处理。这个一连串的“链”也就是我们所说的可观察对象序列。链中的每个操作符都会返回一个新的可观察对象，让我们的序列能够持续进行下去——这也就是我们所熟知的“流”。</p><h3 id="什么是-Operator（操作符）？"><a href="#什么是-Operator（操作符）？" class="headerlink" title="什么是 Operator（操作符）？"></a>什么是 Operator（操作符）？</h3><p>我们前面提到，可观察对象能够进行链式调用，也就是说我们可以像这样写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Rx.Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value)</span><br><span class="line">  .filter(<span class="function"><span class="params">value</span> =&gt;</span> value.length &gt;= <span class="number">2</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// use the `value`</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这段代码做了下面一系列事情：</p><ul><li>我们先假定用户输入了一个“a”</li><li>可观察对象将会对这个输入事件作出反应，将值传给下一个观察者</li><li>“a”被传给了订阅了我们<strong>初始</strong>可观察对象的 <code>.map()</code></li><li><code>.map()</code> 会返回一个 <code>event.target.value</code> 的新可观察对象，然后调用它观察者对象中的 <code>.next()</code></li><li><code>.next()</code> 将会调用订阅了 <code>.map()</code> 的 <code>.filter()</code>，并将 <code>.map()</code> 处理后的值传递给它</li><li><code>.filter()</code> 将会返回另一个可观察对象，<code>.filter()</code> 过滤后留下 <code>.length</code> 大于等于 2 的值，并将其传给 <code>.next()</code></li><li>我们通过 <code>.subscribe()</code> 获得了最终的数据值</li></ul><p>这短短的几行代码做了这么多的事！如果你还觉得弄不清，只需要记住：</p><p>每当返回一个新的可观察对象，都会有一个新的<strong>观察者</strong>挂载到前一个<strong>可观察对象</strong>上，这样就能通过观察者的“流”进行传值，对观察者生产的值进行处理，然后调用 <code>.next()</code> 方法将处理后的值传递给下一个观察者。</p><p>简单来说，操作符将会不断地依次返回新的可观察对象，让我们的流能够持续进行。作为用户而言，我们不需要关心什么时候、什么情况下需要创建与使用可观察对象与观察者，我们只需要用我们的订阅对象进行链式调用就行了。</p><h3 id="创建我们自己的-Observable（可观察对象）"><a href="#创建我们自己的-Observable（可观察对象）" class="headerlink" title="创建我们自己的 Observable（可观察对象）"></a>创建我们自己的 Observable（可观察对象）</h3><p>现在，让我们开始写自己的可观察对象的实现吧。尽管它不会像 Rx 的实现那么高级，但我们还是对完善它充满信心。</p><h4 id="Observable-构造器"><a href="#Observable-构造器" class="headerlink" title="Observable 构造器"></a>Observable 构造器</h4><p>首先，我们需要创建一个 Observable 构造函数，此构造函数接受且仅接受 <code>subscribe</code> 函数作为其唯一的参数。每个 Observable 实例都存储 subscribe 属性，稍后可以由观察者对象调用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observable</span>(<span class="params">subscribe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subscribe = subscribe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个分配给 <code>this.subscribe</code> 的 <code>subscribe</code> 回调都将会被我们或者其它的可观察对象调用。这样我们下面做的事情就有意义了。</p><h4 id="Observer-示例"><a href="#Observer-示例" class="headerlink" title="Observer 示例"></a>Observer 示例</h4><p>在深入探讨实际情况之前，我们先看一看基础的例子。</p><p>现在我们已经配好了可观察对象函数，可以调用我们的观察者，将 <code>1</code> 这个值传给它并订阅它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one$ = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">one$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们订阅了 Observable 实例，将我们的 observer（对象字面量）传入构造器中（之后它会被分配给 <code>this.subscribe</code>）。</p><h4 id="Observable-fromEvent"><a href="#Observable-fromEvent" class="headerlink" title="Observable.fromEvent"></a>Observable.fromEvent</h4><p>现在我们已经完成了创建自己的 Observable 的基础步骤。下一步是为 Observable 添加 <code>static</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将像使用 RxJS 一样使用我们的 Observable：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>);</span><br></pre></td></tr></table></figure><p>这意味着我们需要返回一个新的 Observable，然后将函数作为参数传递给它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码将我们的函数传入了构造器中的 <code>this.subscribe</code>。接下来，我们需要将事件监听设置好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这个 <code>observer</code> 参数是什么呢？它又是从哪里来的呢？</p><p>这个 <code>observer</code> 其实就是携带 <code>next</code>、<code>error</code>、<code>complete</code> 的对象字面量。</p><blockquote><p>这块其实很有意思。<code>observer</code> 在 <code>.subscribe()</code> 被调用之前都不会被传递，因此 <code>addEventListener</code> 在 Observable 被“订阅”之前都不会被执行。</p></blockquote><p>一旦调用 subscribe，也就会调用 Observable 构造器内的 <code>this.subscribe</code> 。它将会调用我们传入 <code>new Observable(callback)</code> 的 callback，同时也会依次将值传给我们的观察者。这样，当 Observable 做完一件事的时候，它就会用更新过的值调用我们观察者中的 <code>.next()</code> 方法。</p><p>那么之后呢？我们已经得到了初始化好的事件监听器，但是还没有调用 <code>.next()</code>。下面完成它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    element.addEventListener(name, (event) =&gt; &#123;</span><br><span class="line">      observer.next(event);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们都知道，可观察对象在被销毁前需要一个“处理后事”的函数，在我们这个例子中，我们需要移除事件监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromEvent = <span class="function">(<span class="params">element, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="function">(<span class="params">event</span>) =&gt;</span> observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> element.removeEventListener(name, callback, <span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为这个 Observable 还在处理 DOM API 和事件，因此我们还不会去调用 <code>.complete()</code>。这样在技术上就有无限的可用性。</p><p>试一试吧！下面是我们已经写好的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const node = document.querySelector(&apos;input&apos;);</span><br><span class="line">const p = document.querySelector(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">function Observable(subscribe) &#123;</span><br><span class="line">  this.subscribe = subscribe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.fromEvent = (element, name) =&gt; &#123;</span><br><span class="line">  return new Observable((observer) =&gt; &#123;</span><br><span class="line">    const callback = (event) =&gt; observer.next(event);</span><br><span class="line">    element.addEventListener(name, callback, false);</span><br><span class="line">    return () =&gt; element.removeEventListener(name, callback, false);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;);</span><br><span class="line"></span><br><span class="line">const unsubscribe = input$.subscribe(&#123;</span><br><span class="line">  next: (event) =&gt; &#123;</span><br><span class="line">    p.innerHTML = event.target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 5 秒之后自动取消订阅</span><br><span class="line">setTimeout(unsubscribe, 5000);</span><br></pre></td></tr></table></figure><p>在线示例：</p><iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/3zgv7q2g/embedded/js,html,result/" allowfullscreen frameborder="0"></iframe><h3 id="创造我们自己的-Operator（操作符）"><a href="#创造我们自己的-Operator（操作符）" class="headerlink" title="创造我们自己的 Operator（操作符）"></a>创造我们自己的 Operator（操作符）</h3><p>在我们理解了可观察对象与观察者对象的概念之后，我们可以更轻松地去创造我们自己的操作符了。我们在 <code>Observable</code> 对象原型中加上一个新的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map=function(mapFn)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法将会像 JavaScript 中的 <code>Array.prototype.map</code> 一样使用，不过它可以对任何值用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const input$ = Observable.fromEvent(node, &apos;input&apos;)</span><br><span class="line">	.map(event =&gt; event.target.value);</span><br></pre></td></tr></table></figure><p>所以我们要取得回调函数，并调用它，返回我们期望得到的数据。在这之前，我们需要拿到流中最新的数据值。</p><p>下面该做什么就比较明了了，我们要得到调用了这个 <code>.map()</code> 操作符的 Observable 实例的引用入口。我们是在原型链上编程，因此可以直接这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = function (mapFn) &#123;</span><br><span class="line">  const input = this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找找乐子吧！现在我们可以在返回的 Obeservable 中调用 subscribe：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> input.subscribe();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我们要返回 <code>input.subscribe()</code> ，因为在我们退订的时候，非订阅对象将会顺着链一直转下去，解除每个 Observable 的订阅。</p></blockquote><p>这个订阅对象将允许我们把之前 <code>Observable.fromEvent</code> 传来的值传递下去，因为它返回了构造器中含有 <code>subscribe</code> 原型的新的 Observable 对象。我们可以轻松地订阅它对数据值做出的任何更新！最后，完成通过 map 调用我们的 <code>mapFn()</code> 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">mapFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input.subscribe(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">value</span>) =&gt;</span> observer.next(mapFn(value)),</span><br><span class="line">      error: <span class="function">(<span class="params">err</span>) =&gt;</span> observer.error(err),</span><br><span class="line">      complete: <span class="function"><span class="params">()</span> =&gt;</span> observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们可以进行链式调用了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input$ = Observable.fromEvent(node, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">event</span> =&gt;</span> event.target.value);</span><br><span class="line"></span><br><span class="line">input$.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    p.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意到最后一个 <code>.subscribe()</code> 不再和之前一样传入 <code>Event</code> 对象，而是传入了一个 <code>value</code> 了吗？这说明你成功地创建了一个可观察对象流。</p><p>再试试：</p><iframe width="100%" height="300" src="//jsfiddle.net/toddmotto/0rpkchm8/embedded/js,html,result/" allowfullscreen frameborder="0"></iframe><p>希望这篇文章对你来说还算有趣~:)</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5934d2532f301e00585ea5f3" target="_blank" rel="noopener">https://juejin.im/post/5934d2532f301e00585ea5f3</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/04/动态规划/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/04/动态规划/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">动态规划</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-04 16:36:00" itemprop="dateCreated datePublished" datetime="2017-06-04T16:36:00+08:00">2017-06-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>拿着以前的笔记复习一下~</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>决策可以分为静态决策与动态决策。</p><p>其中静态决策又被称为“一次性决策”，即根据输入进行决策判断，得到相应的输出结果。如图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         u决策</span><br><span class="line">           +</span><br><span class="line">           |</span><br><span class="line">        +--v--+</span><br><span class="line">x1输入+--&gt;     +--&gt;x2输出</span><br><span class="line">        +--+--+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">        z决策效应</span><br></pre></td></tr></table></figure><p>动态决策也叫“多阶段决策”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       u1         u2                 uk                     un</span><br><span class="line">       |          |                  |                      |</span><br><span class="line">    +--v--+    +--v--+            +--v--+                +--v--+</span><br><span class="line">x1--&gt;  T1 +-x2-&gt; T2  +-x3-&gt;...xk--&gt;  Tk +-x(k+1)-&gt;...xn--&gt;  Tn  +--&gt;x(n+1)</span><br><span class="line">    +--+--+    +--v--+            +--v--+                +--v--+</span><br><span class="line">       |          |                  |                      |</span><br><span class="line">       v          v                  v                      v</span><br><span class="line">       r1         r2                 rk                     rn</span><br></pre></td></tr></table></figure><p>也可以记为$X_{k+1} = T_k(x_k,u_k)$，若系统在 k 阶段之后的决策只与$x_k$有关，而与之前做过的决策无关，则这样的决策过程称为具有<strong>无后效性的多段决策过程。</strong></p><p>多段决策过程从第 k 步到最后一步的过程称为 k-后部子过程，简称 k-子过程</p><h3 id="动态规划模型"><a href="#动态规划模型" class="headerlink" title="动态规划模型"></a>动态规划模型</h3><p>$$ \text{opt}_{u_1 \cdots u_n} R = \bigoplus_{k=1}^n r_k (x_k,u_k) $$</p><p>$$\left{<br>\begin{aligned}<br>&amp;x_{k+1} = T_k(x_k,u_k) \\<br>&amp;x_k \in X_k \\<br>&amp;u_k \in U_k \\<br>&amp;k = 1 \sim n<br>\end{aligned}<br>\right.<br>$$</p><p>opt 表示求优过程</p><p>Xk 为一个集合，表示在 k 阶段时状态所有可能取值的范围，因此称为<strong>状态可能集合</strong></p><p>Uk 为一个集合，表示在 k 阶段时决策所有可能取值的范围，称为<strong>决策允许集合</strong></p><p>一般对于不同的状态，可以选择的决策范围也不同，因此决策允许集合也记为$U_k(x_k)$</p><p>解决动态规划问题需要确定以下几个步骤：</p><p>1、确定阶段与阶段变量</p><p>2、明确状态变量与状态可能集合</p><p>3、确定决策变量与决策允许集合</p><p>4、确定状态转移方程</p><p>5、明确阶段效应和目标</p><p>其中重要的是确定状态转移方程与明确阶段相应和目标。</p><p>状态转移方程即在状态$x_k$时做出了决策$u_k(x_k)$之后系统状态的变化，这个变化会影响之后的决策过程。因此必须明确状态的转移过程，即根据问题的内在关系，明确$x_{k+1}=T_k(x_k,u_k)$中的函数Tk()。</p><p>阶段效应$r_k(x_k,u_k)$是在阶段k以$x_k$为起点发出决策$u_k$所产生的后果。明确$r_k,x_k,u_k$才能构成目标函数，目标函数由具体问题决定，例如根据具体问题确定求最大还是最小。</p><h3 id="多段决策的特点"><a href="#多段决策的特点" class="headerlink" title="多段决策的特点"></a>多段决策的特点</h3><p>1、每个阶段都要进行决策</p><p>2、相继进行的阶段决策构成决策序列</p><p>3、前一阶段的终止状态是后一阶段的起始状态</p><p>阶段 k 的最优决策不应该只是当前阶段的最优决策，而应该是 k-后部子过程的最优决策。</p><h3 id="最优性原理"><a href="#最优性原理" class="headerlink" title="最优性原理"></a>最优性原理</h3><p>无论初始状态和初始决策如何，对于之前所有决策造成的某一状态而言，剩余的决策序列必须构成最优策略。</p><p><strong>最优性原理的含义：</strong></p><p>1、最优策略的任何一部分子策略，也是相应最初状态的最优策略。</p><p>2、每个最优策略只能由最优子策略构成。</p><p>因此对于无后效多段决策过程而言，按照 k-后部子过程最优的原则来求各阶段的最优决策，这样构成的决策序列一定具有最优性原理的性质。</p><h3 id="贝尔曼函数"><a href="#贝尔曼函数" class="headerlink" title="贝尔曼函数"></a>贝尔曼函数</h3><p>阶段 k，从状态$x_k$出发，执行最优决策序列，最终到达终点时，整个 k-后部子过程中的目标函数取值被称为条件最优目标函数，即贝尔曼函数。</p><p>$$f_k(k_k)=opt_{u_k~u_n} \sum^{n}_{i=n} r_i(x_i,u_i) | k\in {1,2,3,…,n}$$</p><h3 id="动态规划基本方程、贝尔曼方程"><a href="#动态规划基本方程、贝尔曼方程" class="headerlink" title="动态规划基本方程、贝尔曼方程"></a>动态规划基本方程、贝尔曼方程</h3><p>在阶段 k时，执行任意决策$u_k$后的状态是$x_{k+1} = T_k(x_k,u_k)$。这时 k-后部子过程就缩小为了 k+1 后部子过程。根据最优性原理，k+1 后部子过程应该采取最优策略，由于无后效性，k-后部子过程的目标函数值为 $r_k(x_k,u_k)+f_{k+1}(T_k(x_k,u_k))$。根据条件最优目标函数的定义，有：</p><p>$$f_k(x_k) = opt_{u_k}{ r_k(x_k,u_k) + f_{k+1}(T_k(x_k,u_k)) }$$</p><p>此方程即为动态规划基本方程。</p><h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>1、逆序求出条件最优目标函数值集合与条件最优决策集合</p><p>2、顺序求最优目标值、最优策略和最佳路线</p><p>逆序求集合：</p><p>$$<br>\begin{aligned}<br>k=n, &amp;f_n(x_n) = \text{opt}_{u_n}{r_n(x_n,u_n) + f_{n+1}(x_{n+1})} \\<br>&amp; \because f_{n+1}(x_{n+1}) = 0 \\<br>&amp; \therefore 原式 = \text{opt}_{u_n}{r_n(x_n,u_n)} \\<br>&amp; \Rightarrow f_n(x_n) = r_n(x_n,u_n^\prime(x_n)) \\\\<br>k=n-1, &amp;f_{n-1}(x_{n-1}) = \text{opt}_{u_{n-1}}{r_{n-1}(x_{n-1},u_{n-1}) + f_{n}(x_{n})} \\<br>&amp; \because f_n(x_n) 已求出，因此根据 x_n = T_{n-1}(x_{n-1},u_{n-1})\\<br>&amp; 可得 n-1 时的 x_{n-1} \in X_{n-1} 对应的条件最有目标函数值\\<br>&amp; f_{n-1}(x_{n-1}) \\<br>&amp; \Rightarrow {f_{n-1}(x_{n-1}),u_{n-1}^\prime(x_{n-1})|x_{n-1} \in X_{n-1}} \\\\<br>k=1, &amp;f_1(x_1) = \text{opt}_{u_1}{r_1(x_1,u_1) + f_2(x_2)} \\<br>&amp; {f_1(x_1),u_1^\prime(x_1)|x_1 \in X_1} \\<br>\end{aligned}<br>$$</p><p>顺序求目标值：</p><p>$$<br>\begin{aligned}<br>x_1 确定, &amp;R^<em> = f_1(x_1) \qquad u^</em>_1(x_1) = u_1^\prime(x_1) \\<br>x_1 不确定, &amp;R^<em> = \text{opt}_{x_1 \in X_1}{f_1(x_1)} = f_1(x_1^</em>) \\<br>&amp; 得 x_1^<em>,带入求 x_2^,以此类推得 x_n^</em>,x_{n+1}^*<br>\end{aligned}<br>$$</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/05/12/别让你的偏爱拖了后腿：快拥抱箭头函数吧！/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/12/别让你的偏爱拖了后腿：快拥抱箭头函数吧！/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">别让你的偏爱拖了后腿：快拥抱箭头函数吧！</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-05-12 19:12:00" itemprop="dateCreated datePublished" datetime="2017-05-12T19:12:00+08:00">2017-05-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/pasted-153.png" alt="upload successful"></p><p>我以教 JavaScript 为生。最近我给学生上了柯里化箭头函数这个课程——这还是最开始的几节课。我认为它是一个很好用的技能，因此将这个内容提到了课程的前面。而学生们没有让我失望，比我想象中地<strong>更快地</strong>掌握了使用箭头函数进行柯里化。</p><p>如果学生们能够理解它，并且能尽快由它获益，为什么不早点将箭头函数教给他们呢？</p><blockquote><p>Note：我的课程并不适合那些从来没有接触过代码的人。大多数学生在加入我们的课程之前至少有几个月的编程经历——无论他们是自学，还是通过培训班学习，或者本身就是专业的。然而，我发现许多只有一点经验或者没有经验的年轻开发者们能够很快地接受这些主题。</p></blockquote><p>我看到很多的学生在上了 1 小时的课之后就能很熟练地使用箭头函数工作了。（如果你是<a href="https://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“和 Eric Elliott 一起学习 JavaScript”</a>培训班的同学，你可以看这个约 55 分钟的视频——<a href="https://ericelliottjs.com/premium-content/es6-curry-composition/" target="_blank" rel="noopener">ES6 的柯里化与组合</a>）。</p><p>看到学生们如此之快地掌握与应用他们新发现的柯里化方法，我想起了我在推特上发了柯里化箭头函数的帖子，然后被一群人喷“可读性差”的事。我很惊讶为什么他们会坚持这个观点。</p><p>首先，我们先来看看这个例子。我在推特发了这个函数，然后我发现有人强烈反对这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const secret = msg =&gt; () =&gt; msg;</span><br></pre></td></tr></table></figure><p>我对有人在推特上指责我在误导别人感到不可思议。我写这个函数是为了示范在 ES6 中写柯里化函数是多么的<strong>简单</strong>。它是我能想到的在 JavaScript 中<strong>最简单</strong>的实际运用与闭包表达式了。（相关阅读：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" target="_blank" rel="noopener">什么是闭包</a>）</p><p>它和下面的函数表达式等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const secret = function (msg) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>secret()</code> 是一个函数，它需要传入 <code>msg</code> 这个参数，然后会返回一个新的函数，这个函数将会返回 <code>msg</code> 的值。无论你向 <code>secret()</code> 中传入什么值，它都会利用闭包固定 <code>msg</code> 的值。</p><p>你可以这么用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mySecret = secret(&apos;hi&apos;);</span><br><span class="line">mySecret(); // &apos;hi&apos;</span><br></pre></td></tr></table></figure><p>事实证明，双箭头并没有让人感到困惑。我坚信：</p><blockquote><p>对于熟悉的人来说，单行的箭头函数是 JavaScript 表达柯里化函数<strong>最具有可读性</strong>的方法了。</p></blockquote><p>有许多人指责我，告诉我将代码写的长一些比简短的代码更容易阅读。他们有时也许是对的，但是大多数情况都错了。更长、更详细的代码不一定更容易阅读——至少，对熟悉箭头函数的人来说就是如此。</p><p>我在推特上看到的持反对意见的人，并没有像我的学生一样享受平滑的学习箭头函数的过程。在我的经验里，学生学习柯里化箭头函数就像鱼在水里生活一样。仅仅学了几天，他们就开始使用箭头了。它帮助学生们轻松地跨过了各种编程问题的鸿沟。</p><p>我没有看到学习、阅读、理解箭头函数对那些学生造成了任何的“困难”——一旦他们决定学习，只要上个大概一小时的课就能基本掌握。</p><p>他们能够很轻松地读懂柯里化箭头函数，尽管他们从来没有见过这类的东西，他们还是能够告诉我这些函数做了什么事。当我给他们布置任务后他们也能够很自如地自己完成任务。</p><p>从另一方面说，他们能够很快<strong>熟悉</strong>柯里化箭头函数，并且没有为此产生任何<strong>问题</strong>。他们阅读这些函数就像你读一句话一样，他们对其的理解让他们写出了更简单、更少 bug 的代码。</p><h3 id="为什么一些人认为传统的函数表达式看起来“更具有可读性”？"><a href="#为什么一些人认为传统的函数表达式看起来“更具有可读性”？" class="headerlink" title="为什么一些人认为传统的函数表达式看起来“更具有可读性”？"></a>为什么一些人认为传统的函数表达式看起来“更具有可读性”？</h3><p><strong>偏爱</strong>是一种显著的<a href="https://www.psychologytoday.com/blog/mind-my-money/200807/familiarity-bias-part-i-what-is-it" target="_blank" rel="noopener">人类认知偏差</a>，它会让我们在有更好的选择的情况下做出自暴自弃的选择。我们会因此无视更舒服更好的方法，习惯性地选用以前使用过的老方法。</p><p>你可以从这本书中更详细地了解“偏爱”这种心理：<a href="https://www.amazon.com/Undoing-Project-Friendship-Changed-Minds-ebook/dp/B01GI6S7EK/ref=as_li_ss_tl?ie=UTF8&amp;qid=1492606452&amp;sr=8-1&amp;keywords=the+undoing+project&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=4ebd1476f97023e8acb4bba37ea18b90" target="_blank" rel="noopener">《The Undoing Project: A Friendship that Changed Our Minds》</a>（很多情况都是我们自欺欺人）。每个软件工程师都应该读一读这本书，因为它会鼓励你辩证地去看待问题，以及鼓励你多对假设进行实验，以免掉入各种认知陷阱中。书中那些发现认知陷阱的故事也很有趣。</p><h3 id="传统的函数表达式可能会在你的代码中导致-Bug-的出现"><a href="#传统的函数表达式可能会在你的代码中导致-Bug-的出现" class="headerlink" title="传统的函数表达式可能会在你的代码中导致 Bug 的出现"></a>传统的函数表达式可能会在你的代码中导致 Bug 的出现</h3><p>今天我用 ES5 的语法重写了一个 ES6 写的柯里化箭头函数，以便发布开源模块让人们无需编译就能在老浏览器中用。然而 ES5 版本让我震惊。</p><p>ES6 版本的代码非常简短、简介、优雅——仅仅只需要 4 行。</p><p>我觉得，这件事可以发个推特，告诉大家箭头函数是一种更加优越的实现，是时候如同放弃自己的坏习惯一样，放弃传统函数表达式的写法了。</p><p>所以我发了一条推特：</p><p><img src="/images/pasted-154.png" alt="upload successful"></p><p>为了防止你看不清图片，下面贴上这个函数的文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用箭头函数柯里化</span><br><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br><span class="line">// 对比一下 ES5 风格的代码：</span><br><span class="line">var composeMixins = function () &#123;</span><br><span class="line">  var mixins = [].slice.call(arguments);</span><br><span class="line">  return function (instance, mix) &#123;</span><br><span class="line">    if (!instance) instance = &#123;&#125;;</span><br><span class="line">    if (!mix) &#123;</span><br><span class="line">      mix = function () &#123;</span><br><span class="line">        var fns = [].slice.call(arguments);</span><br><span class="line">        return function (x) &#123;</span><br><span class="line">          return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">            return fn(acc);</span><br><span class="line">          &#125;, x);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return mix.apply(null, mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的函数封装了一个 <code>pipe()</code>，它是标准的函数式编程的工具函数，通常<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" target="_blank" rel="noopener">用于组合函数</a>。这个 <code>pipe()</code> 函数在 lodash 中是 <code>lodash/flow</code>，在 Ramda 中是 <code>R.pipe()</code>，在一些函数式编程语言中它甚至本身就是一个运算符号。</p><p>每个<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0" target="_blank" rel="noopener">熟悉函数式编程</a>的人都应该很熟悉它。它的实现主要依赖于<a href="https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d" target="_blank" rel="noopener">Reduce</a>。</p><p>在这个例子中，它用来组合混合函数，不过这点无关紧要（有专门写这方面的博客文章）。我们需要注意是以下几个重要的细节：</p><p>这个函数可以将任何数量的函数混合，最终返回一个函数，这个函数在管道中应用了其它的函数——就像流水线一样。每个混合函数都将实例（<code>instance</code>）作为输入，然后在将自己传递给管道中下一个函数之前，将一些变量传入。</p><p>如果你没有传入 <code>instance</code>，它将会为你创建一个新的对象。</p><p>有时你可能会想用别的混合方式。例如，使用 <code>compose()</code> 代替 <code>pipe()</code> 来传递函数，让组合顺序反过来。</p><p>如果你不需要自定义函数混合时的行为，你可以简单地使用默认设定，使用 <code>pipe()</code> 来完成过程。</p><h3 id="事实"><a href="#事实" class="headerlink" title="事实"></a>事实</h3><p>除了可读性的区别之外，以下列举了一些与这个例子有关的<strong>客观事实</strong>：</p><ul><li>我有多年的 ES5 与 ES6 编程经验，无论是箭头函数表达式还是别的函数表达式我都很熟悉。因此“偏爱”对我来说<strong>不是</strong>一个变化无常的因素。</li><li>我没几秒就写好了 ES6 版本的代码，它没有任何 bug（它通过了所有的单元测试，因此我敢肯定这点）。</li><li>写 ES5 版本的代码花了我好几分钟。一个是几秒，一个是几分钟，差距还是挺大的。写 ES5 代码时，我有 2 次弄错了函数的作用范围；写出了 3 个 bug，然后要花时间去分别调试与修复；还有 2 次我不得不使用 <code>console.log()</code> 来弄清函数执行的情况。</li><li>ES6 版本代码仅仅只有 4 行。</li><li>ES5 版本代码有 21 行（其中真正有代码的有 17 行）。</li><li>尽管 ES5 版本的代码更加冗长，但是它比起 ES6 版本的代码来说仍然缺少了一些信息。它虽然长，但是<strong>表达的东西更少</strong>。这个问题在后面会提到。</li><li>ES6 版本代码在代码中有 2 个 speard 运算符。而 ES5 版本代码中没有这个运算符，而是使用了<strong>意义晦涩</strong>的 <code>arguments</code> 对象，它将严重影响函数内容的可读性。（不推荐原因之一）</li><li>ES6 版本代码在函数片段中定义了 <code>mix</code> 的默认值，由此你可以很清楚地看到它是参数的值。而 ES5 版本代码却混淆了这个细节问题，将它隐藏在函数体中。（不推荐原因之二）</li><li>ES6 版本代码仅有 2 层代码块，这将会帮助读者理解代码结构，以及知道如何去阅读这个代码。而 ES5 代码有 6 层代码块，复杂的层级结构会让函数结构的可读性变得很差。（不推荐原因之三）</li></ul><p>在 ES5 版本代码中，<code>pipe()</code> 占据了函数体的大部分内容——要把它们放到同一行中去简直是个荒唐的想法。非常<strong>有必要</strong>将 <code>pipe()</code> 这个函数单独抽离出来，让我们的 ES5 版本代码更具有可读性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var pipe = function () &#123;</span><br><span class="line">  var fns = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">      return fn(acc);</span><br><span class="line">    &#125;, x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var composeMixins = function () &#123;</span><br><span class="line">  var mixins = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">  return function (instance, mix) &#123;</span><br><span class="line">    if (!instance) instance = &#123;&#125;;</span><br><span class="line">    if (!mix) mix = pipe;</span><br><span class="line"></span><br><span class="line">    return mix.apply(null, mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，我觉得它更具可读性，并且更容易理解它的意思了。</p><p>让我们看看如果我们对 ES6 版本代码做一些可读性“优化”会怎么样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span><br><span class="line"></span><br><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = pipe</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>就像 ES5 版本代码的优化一样，这个“优化”后的代码更加冗长（它加入了之前没有的新变量）。与 ES5 版本代码不同，这个版本在将管道的概念抽象出来后<strong>并没有明显的提高代码可读性</strong>。不过毕竟函数里已经清楚的写明了 <code>mix</code> 这个变量，它还是更容易让人理解一些。</p><p><code>mix</code> 的定义本身在它的那一行就已经存在了，它不太可能会让阅读代码的人找不到何时结束 <code>mix</code>、剩下的代码何时执行。</p><p>而现在我们用了 2 个变量来表示同一个东西。我们因此而获益了吗？完全没有。</p><p>那么为什么 ES5 函数在对函数进行抽象之后会变得<strong>更具可读性</strong>呢？</p><p>因为之前 ES5 版本的代码<strong>明显更复杂</strong>。这种复杂度的来源是我们讨论的问题重点。我可以断言，它的复杂度的来源归根结底就是<strong>语法干扰</strong>，这种语法干扰只会让<strong>函数的本身含义变得费解</strong>，并没有别的用处。</p><p>让我们换种方法，把一些多余的变量去掉，在例子中都使用 ES6 代码，只比较<strong>箭头函数</strong>与<strong>传统函数表达式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var composeMixins = function (...mixins) &#123;</span><br><span class="line">  return function (</span><br><span class="line">    instance = &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    mix = function (...fns) &#123;</span><br><span class="line">      return function (x) &#123;</span><br><span class="line">        return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">          return fn(acc);</span><br><span class="line">        &#125;, x);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    return mix(...mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，至少我觉得它的可读性显著的提升了。我们利用 <strong>rest</strong> 语法以及<strong>默认参数</strong>语法对它进行了修改。当然，你得对 rest 语法和默认参数语法很熟悉才会觉得这个版本的代码更可读。不过即使你不了解这些，我觉得这个版本也会看起来更加<strong>有条理</strong>。</p><p>现在已经改进了许多了，但是我觉得这个版本还是比较简洁。将 <code>pipe()</code> 抽象出来，写到它自己的函数里可能会<strong>有所帮助</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const pipe = function (...fns) &#123;</span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return fns.reduce(function (acc, fn) &#123;</span><br><span class="line">      return fn(acc);</span><br><span class="line">    &#125;, x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 传统函数表达式</span><br><span class="line">const composeMixins = function (...mixins) &#123;</span><br><span class="line">  return function (</span><br><span class="line">    instance = &#123;&#125;,</span><br><span class="line">    mix = pipe</span><br><span class="line">  ) &#123;</span><br><span class="line">    return mix(...mixins)(instance);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样是不是更好了？现在 <code>mix</code> 只占了单独的一样，函数结构也更加的清晰——但是这样做不符合我的胃口，它的语法干扰实在是太多了。在现在的 <code>composeMixins()</code> 中，我觉得描述一个函数在哪结束、另一个函数从哪开始还不够清楚。</p><p>除了调用函数体之外，<code>funcion</code> 这个关键字似乎和其它的代码<strong>混淆</strong>在一起了。我的函数的真正的功能被<strong>隐藏</strong>了起来！参数的调用和函数体的起始到底在哪里？如果我仔细看也能够分析出来，但是它对我来说实在是不容易阅读。</p><p>那么如果我们去掉 <code>function</code> 这个关键字，然后通过一个<strong>大箭头</strong> <code>=&gt;</code> 指向返回值来代替 <code>return</code> 关键字，避免它们和其它关键部分混在一起，现在会怎么样呢？</p><p>我们当然可以这么做，代码会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = pipe</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>现在应该可以很清楚这段代码做了什么事了。<code>composeMixins()</code> 是一个函数，它传入了任意数量的 <code>mixins</code>，最终会返回一个得到两个额外参数（<code>instance</code> 与 <code>mix</code>）的函数。它返回了通过 <code>mixins</code> 管道组合的 <code>instance</code> 的结果。</p><p>还有一件事……如果我们对 <code>pipe()</code> 进行同样的优化，可以神奇地将它写到一行中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span><br></pre></td></tr></table></figure><p>当它在一行内被定义的时候，将它抽象成一个函数这件事反而变得不那么明了了。</p><p>另外请记住，这个函数在 Lodash、Ramda 以及其它库中都有用到，但是仅仅为了用这个函数就去 import 这些库并不是一件划得来的事。</p><p>那么我们自己写一行这个函数有必要吗？应该有的。它实际上是两个不同的函数，把它们分开会让代码更加清晰。</p><p>另一方面，如果将其写在一行中，当你看参数命名的时候，你就已经明了了其类型以及用例。我们将它写在一行，就如下面代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const composeMixins = (...mixins) =&gt; (</span><br><span class="line">  instance = &#123;&#125;,</span><br><span class="line">  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)</span><br><span class="line">) =&gt; mix(...mixins)(instance);</span><br></pre></td></tr></table></figure><p>现在让我们回头看看最初的函数。无论我们后面做了什么调整，<strong>我们都没有丢弃任何本来就有的信息</strong>。并且，通过在行内声明变量和默认值，我们还给这个函数<strong>增加了信息量</strong>，描述了这个函数是怎么使用的以及参数值是什么样子的。</p><p>ES5 版本中增加的额外的代码其实都是语法干扰。这些代码对于<strong>熟悉</strong>柯里化箭头函数的人来说<strong>没有任何有用之处</strong>。</p><p>只要你熟悉柯里化箭头函数，你就会觉得最开头的代码更加清晰并具有<strong>可读性</strong>，因为它没有多余的语法糊弄人。</p><p>柯里化箭头函数还能<strong>减少错误的藏身之处</strong>，因为它能让 bug 隐藏的部分更少。我猜想，在传统函数表达式中一定隐藏了许多的 bug，一旦你升级使用箭头函数就能找到并排除这些 bug。</p><p>我希望你的团队也能支持、学习与应用 ES6 的更加简洁的代码风格，提高工作效率。</p><p>有时，在代码中详细地进行描述是正确的行为，但通常来说，代码越少越好。如果更少的代码能够实现同样的东西，能够传达更多的信息，不用丢弃任何信息量，那么它<strong>明显</strong>更加优越。认知这些不同点的关键就是看它们表达的信息。如果加上的代码没有更多的意义，那么这种代码就不应该存在。这个道理很简单，就和自然语言的风格规范一样（不说废话）。将这种表达风格规范应用到代码中。拥抱它，你将能写出更好的代码。</p><p>一天过去，天色已黑，仍然有其它推特的回复在说 ES6 版本的代码更加缺乏可读性：</p><p><img src="/images/pasted-155.png" alt="upload successful"></p><p>我只想说：是时候熟练去掌握 ES6、柯里化与组合函数了。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p><a href="https://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“与 Eric Elliott 一起学习 JavaScript”</a>会员现在可以看这个大约 55 分钟的视频课程——<a href="https://ericelliottjs.com/premium-content/es6-curry-composition/" target="_blank" rel="noopener">ES6 柯里化与组合</a>。</p><p>如果你还不是我们的会员，你可会遗憾地错过这个机会哦！</p><p><img src="/images/pasted-156.png" alt="upload successful"></p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p><strong><em>Eric Elliott</em></strong> 是 O’Reilly 出版的<a href="http://pjabook.com" target="_blank" rel="noopener"><em>《Programming JavaScript Applications》</em></a>书籍、<a href="http://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“与 Eric Elliott 学习 JavaScript”</a>课程作者。他曾经帮助 Adobe、莱美、华尔街日报、ESPN、BBC 进行软件开发，以及帮助 Usher、Frank Ocean、Metallica 等著名音乐家做网站。</p><p>最后<del>喂狗粮</del>：</p><p><strong>他与世界上最美丽的女人在旧金山湾区共度一生。</strong></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59158c92a0bb9f005fd58fd7" target="_blank" rel="noopener">https://juejin.im/post/59158c92a0bb9f005fd58fd7</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/05/04/在-Swift-中使用闭包实现懒加载/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/04/在-Swift-中使用闭包实现懒加载/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">在 Swift 中使用闭包实现懒加载</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-05-04 11:29:38" itemprop="dateCreated datePublished" datetime="2017-05-04T11:29:38+08:00">2017-05-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="学习如何兼顾模块化与可读性来创建对象"><a href="#学习如何兼顾模块化与可读性来创建对象" class="headerlink" title="学习如何兼顾模块化与可读性来创建对象"></a>学习如何兼顾模块化与可读性来创建对象</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在我刚开始学习 iOS 开发的时候，我在 YouTube 上找了一些教程。我发现这些教程有时候会用下面这种方式来创建 UI 对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let makeBox: UIView = &#123;</span><br><span class="line"> let view = UIView()</span><br><span class="line"> return view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>作为一个初学者，我自然而然地复制并使用了这个例子。直到有一天，我的一个读者问我：“为什么你要加上<code>{}</code>呢？最后为什么要加上一对<code>()</code>呢？这是一个计算属性吗？”我哑口无言，因为我自己也不知道答案。</p><p>因此，我为过去年轻的自己写下了这份教程。说不定还能帮上其他人的忙。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>这篇教程有一下三个目标：第一，了解如何像前面的代码一样，非常规地创建对象；第二，知道编在写 Swfit 代码时，什么时候该使用 <code>lazy var</code>；第三，快加入我的邮件列表呀。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>为了让你能轻松愉快地和我一起完成这篇教程，我强烈推荐你先了解下面这几个概念。</p><ol><li><a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564" target="_blank" rel="noopener"><strong>闭包</strong></a></li><li><a href="https://juejin.im/post/58e4ac5d44d904006d2a9a19" target="_blank" rel="noopener"><strong>捕获列表与循环引用 [weak self]</strong></a></li><li><strong>面向对象程序设计</strong></li></ol><h3 id="创建-UI-组件"><a href="#创建-UI-组件" class="headerlink" title="创建 UI 组件"></a>创建 UI 组件</h3><p>在我介绍“非常规”方法之前，让我们先复习一下“常规”方法。在 Swift 中，如果你要创建一个按钮，你应该会这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设定尺寸</span><br><span class="line">let buttonSize = CGRect(x: 0, y: 0, width: 100, height: 100)</span><br><span class="line"></span><br><span class="line">// 创建控件</span><br><span class="line">let bobButton = UIButton(frame: buttonSize)</span><br><span class="line">bobButton.backgroundColor = .black</span><br><span class="line">bobButton.titleLabel?.text = &quot;Bob&quot;</span><br><span class="line">bobButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>这样做<strong>没问题</strong>。</p><p>假设现在你要创建另外三个按钮，你很可能会把上面的代码复制，然后把变量名从 <code>bobButton</code> 改成 <code>bobbyButton</code>。</p><p>这未免也太枯燥了吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// New Button </span><br><span class="line">let bobbyButton = UIButton(frame: buttonSize)</span><br><span class="line">bobbyButton.backgroundColor = .black</span><br><span class="line">bobbyButton.titleLabel?.text = &quot;Bob&quot;</span><br><span class="line">bobbyButton.titleLabel?.textColor = .white</span><br></pre></td></tr></table></figure><p>为了方便，你可以：</p><p><img src="/images/pasted-152.png" alt="upload successful"></p><p>使用快捷键：ctrl-cmd-e 来完成这个工作。</p><p>如果你不想做重复的工作，你也可以创建一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func createButton(enterTitle: String) -&gt; UIButton &#123;</span><br><span class="line"> let button = UIButton(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = enterTitle</span><br><span class="line"> return button</span><br><span class="line">&#125;</span><br><span class="line">createButton(enterTitle: &quot;Yoyo&quot;) //  👍</span><br></pre></td></tr></table></figure><p>然而，在 iOS 开发中，很少会看到一堆一模一样的按钮。因此，这个函数需要接受更多的参数，如背景颜色、文字、圆角尺寸、阴影等等。你的函数最后可能会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func createButton(title: String, borderWidth: Double, backgrounColor, ...) -&gt; Button</span><br></pre></td></tr></table></figure><p>但是，即使你为这个函数加上了默认参数，上面的代码依然不理想。这样的设计降低了代码的可读性。因此，比起这个方法，我们还是采用上面那个”单调“的方法为妙。</p><p>到底有没有办法让我们既不那么枯燥，还能让代码更有条理呢？当然咯。我们现在只是复习你过去的做法——是时候更上一层楼，展望你未来的做法了。</p><h3 id="介绍”非常规“方法"><a href="#介绍”非常规“方法" class="headerlink" title="介绍”非常规“方法"></a>介绍”非常规“方法</h3><p>在我们使用”非常规“方法创建 UI 组件之前，让我们先回答一下最开始那个读者的问题。<code>{}</code>是什么意思，它是一个<code>计算属性</code>吗？</p><p><strong>当然不是，它只是一个闭包</strong>。</p><p>首先，让我来示范一下如何用闭包来创建一个对象。我们设计一个名为<code>Human</code>的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Human &#123;</span><br><span class="line"> init() &#123;</span><br><span class="line">  print(&quot;Born 1996&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让你看看怎么用闭包创建对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let createBob = &#123; () -&gt; Human in</span><br><span class="line"> let human = Human()</span><br><span class="line"> return human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let babyBob = createBob() // &quot;Born 1996&quot;</span><br></pre></td></tr></table></figure><p><strong>如果你不熟悉这段语法，请先停止阅读这篇文章，去看看</strong> <a href="https://blog.bobthedeveloper.io/no-fear-closure-in-swift-3-with-bob-72a10577c564" target="_blank" rel="noopener"><strong>Fear No Closure with Bob</strong></a> <strong>充充电吧。</strong></p><p>解释一下，<code>createBob</code> 是一个类型为 <code>()-&gt; Human</code> 的闭包。你已经通过调用 <code>createBob()</code> 创建好了一个 <code>babyBob</code> 实例。</p><p>然而，这样做你创建了两个常量：<code>createBob</code> 与 <code>babyBob</code>。如何把所有的东西都放在一个声明中呢？请看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let bobby = &#123; () -&gt; Human in</span><br><span class="line"> let human = Human()</span><br><span class="line"> return human</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>现在，这个闭包通过在最后加上 <code>()</code> 执行了自己，<code>bobby</code> 现在被赋值为一个 <code>Human</code> 对象。干的漂亮！</p><p><strong>现在你已经学会了使用闭包来创建一个对象</strong></p><p>让我们应用这个方法，模仿上面的例子来创建一个 UI 对象吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bobView = &#123; () -&gt; UIView in</span><br><span class="line"> let view = UIView()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> return view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>很好，我们还能让它更简洁。实际上，我们不需要为闭包指定类型，我们只需要指定 <code>bobView</code> 实例的类型就够了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let bobbyView: **UIView** = &#123;</span><br><span class="line"> let view = UIView()</span><br><span class="line"> view.backgroundColor = .black</span><br><span class="line"> return view</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>Swift 能够通过关键字 <code>return</code> 推导出这个闭包的类型是 <code>() -&gt; UIView</code>。</p><p>现在看看，上面的例子已经和我之前害怕的“非常规方式”一样了。</p><h3 id="使用闭包创建的好处"><a href="#使用闭包创建的好处" class="headerlink" title="使用闭包创建的好处"></a>使用闭包创建的好处</h3><p>我们已经讨论了直接创建对象的单调和使用构造函数带来的问题。现在你可能会想“为什么我非得用闭包来创建？”</p><h4 id="重复起来更容易"><a href="#重复起来更容易" class="headerlink" title="重复起来更容易"></a>重复起来更容易</h4><p>我不喜欢用 Storyboard，我比较喜欢复制粘贴用代码来创建 UI 对象。实际上，在我的电脑里有一个“代码库”。假设库里有个按钮，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myButton: UIButton = &#123;</span><br><span class="line"> let button = UIButton(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = &quot;Button&quot;</span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = </span><br><span class="line"> button.layer.masksToBounds = true</span><br><span class="line">return button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>我只需要把它整个复制，然后把名字从 <code>myButton</code> 改成 <code>newButtom</code> 就行了。在我用闭包之前，我得重复地把 <code>myButton</code> 改成 <code>newButtom</code> ，甚至要改上七八遍。我们虽然可以用 Xcode 的快捷键，但为啥不使用闭包，让这件事更简单呢？</p><h4 id="看起来更简洁"><a href="#看起来更简洁" class="headerlink" title="看起来更简洁"></a>看起来更简洁</h4><p>由于对象对象会自己编好组，在我看来它更加的简洁。让我们对比一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用闭包创建 </span><br><span class="line">let leftCornerButton: UIButton = &#123;</span><br><span class="line"> let button = UIButton(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = &quot;Button&quot;</span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = </span><br><span class="line"> button.layer.masksToBounds = true</span><br><span class="line">return button</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">let rightCornerButton: UIButton = &#123;</span><br><span class="line"> let button = UIButton(frame: buttonSize)</span><br><span class="line"> button.backgroundColor = .black</span><br><span class="line"> button.titleLabel?.text = &quot;Button&quot;</span><br><span class="line"> button.titleLabel?.textColor = .white</span><br><span class="line"> button.layer.cornerRadius = </span><br><span class="line"> button.layer.masksToBounds = true</span><br><span class="line">return button</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>vs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 手动创建</span><br><span class="line">let leftCornerButton = UIButton(frame: buttonSize)</span><br><span class="line">leftCornerButton.backgroundColor = .black</span><br><span class="line">leftCornerButton.titleLabel?.text = &quot;Button&quot;</span><br><span class="line">leftCornerButton.titleLabel?.textColor = .white</span><br><span class="line">leftCornerButton.layer.cornerRadius = </span><br><span class="line">leftCornerButton.layer.masksToBounds = true</span><br><span class="line"></span><br><span class="line">let rightCornerButton = UIButton(frame: buttonSize)</span><br><span class="line">rightCornerButton.backgroundColor = .black</span><br><span class="line">rightCornerButton.titleLabel?.text = &quot;Button&quot;</span><br><span class="line">rightCornerButton.titleLabel?.textColor = .white</span><br><span class="line">rightCornerButton.layer.cornerRadius = </span><br><span class="line">rightCornerButton.layer.masksToBounds = true</span><br></pre></td></tr></table></figure><p>尽管使用闭包创建对象要多出几行，但是比起要在 <code>rightCornerButton</code> 或者 <code>leftCornerButton</code> 后面狂加属性，我还是更喜欢在 <code>button</code> 后面加属性。</p><p><strong>实际上如果按钮的命名特别详细时，用闭包创建对象还可以少几行。</strong></p><p><strong>恭喜你，你已经完成了我们的第一个目标</strong></p><h3 id="懒加载的应用"><a href="#懒加载的应用" class="headerlink" title="懒加载的应用"></a>懒加载的应用</h3><p>辛苦了！现在让我们来看看这个教程的第二个目标吧。</p><p>你可能看过与下面类似的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class IntenseMathProblem &#123;</span><br><span class="line"> lazy var complexNumber: Int = &#123;</span><br><span class="line">  // 请想象这儿要耗费很多CPU资源</span><br><span class="line">  1 * 1</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lazy</code> 的作用是，让 <code>complexNumber</code> 属性只有在你试图访问它的时候才会被计算。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let problem = IntenseMathProblem </span><br><span class="line">problem()  // 此时complexNumber没有值</span><br></pre></td></tr></table></figure><p>没错，现在 <code>complexNumber</code> 没有值。然而，一旦你访问这个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">problem().complexNumber // 现在回返回1</span><br></pre></td></tr></table></figure><p><code>lazy var</code> 经常用于数据库排序或者从后端取数据，因为你并不想在创建对象的时候就把所有东西都计算、排序。</p><p><strong>实际上，由于对象太大了导致 RAM 撑不住，你的手机就会崩溃。</strong></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>以下是 <code>lazy var</code> 的应用：</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SortManager &#123;</span><br><span class="line"> lazy var sortNumberFromDatabase: [Int] = &#123;</span><br><span class="line">  // 排序逻辑</span><br><span class="line">  return [1, 2, 3, 4]</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CompressionManager &#123;</span><br><span class="line"> lazy var compressedImage: UIImage = &#123;</span><br><span class="line">  let image = UIImage()</span><br><span class="line">  // 压缩图片的</span><br><span class="line">  // 逻辑</span><br><span class="line">  return image</span><br><span class="line"> &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lazy的一些规定"><a href="#Lazy的一些规定" class="headerlink" title="Lazy的一些规定"></a><code>Lazy</code>的一些规定</h3><ol><li>你不能把 <code>lazy</code> 和 <code>let</code> 一起用，因为用 <code>lazy</code> 时没有初值，只有当被访问时才会获得值。</li><li>你不能把它和 <code>计算属性</code> 一起用，因为在你修改任何与 <code>lazy</code> 的计算属性有关的变量时，计算属性都会被重新计算（耗费 CPU 资源）。</li><li><code>Lazy</code> 只能是结构或类的成员。</li></ol><h3 id="Lazy-能被捕获吗？"><a href="#Lazy-能被捕获吗？" class="headerlink" title="Lazy 能被捕获吗？"></a>Lazy 能被捕获吗？</h3><p>如果你读过我的前一篇文章<a href="https://juejin.im/post/58e4ac5d44d904006d2a9a19" target="_blank" rel="noopener">《Swift 闭包和代理中的循环引用》</a>，你就会明白这个问题。让我们试一试吧。创建一个名叫 <code>BobGreet</code> 的类，它有两个属性：一个是类型为 <code>String</code> 的 <code>name</code>，一个是类型为 <code>String</code> 但是使用闭包创建的 <code>greeting</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class BobGreet &#123;</span><br><span class="line"> var name = &quot;Bob the Developer&quot;</span><br><span class="line"> lazy var greeting: String = &#123;</span><br><span class="line">  return &quot;Hello, \(self.name)&quot;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line">deinit &#123; </span><br><span class="line">  print(&quot;I&apos;m gone, bruh 🙆&quot;)&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包<strong>可能</strong>对 <code>BobGuest</code> 有强引用，让我们尝试着 deallocate 它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bobGreet: BobGreet? = BobClass()</span><br><span class="line">bobGreet?.greeting</span><br><span class="line">bobClass = nil // I&apos;m gone, bruh 🙆</span><br></pre></td></tr></table></figure><p>不用担心 <code>[unowned self]</code>，闭包并没有对对象存在引用。相反，它仅仅是在闭包内复制了 <code>self</code>。如果你对前面的代码声明有疑问，可以读读 <a href="https://blog.bobthedeveloper.io/swift-capture-list-in-closures-e28282c71b95" target="_blank" rel="noopener">Swift Capture Lists</a> 来了解更多这方面的知识。👍</p><h3 id="最后的唠叨"><a href="#最后的唠叨" class="headerlink" title="最后的唠叨"></a>最后的唠叨</h3><p>我在准备这篇教程的过程中也学到了很多，希望你也一样。感谢你们的热情❤️！不过这篇文章还剩一点：我的最后一个目标。如果你希望加入我的邮件列表以获得更多有价值的信息的话，你可以点 <a href="https://boblee.typeform.com/to/oR9Nt2" target="_blank" rel="noopener"><strong>这里</strong></a>注册。</p><p>正如封面照片所示，我最近买了 Magic Keyboard 和 Magic Mouse。它们超级棒，帮我提升了很多的效率。你可以在 <a href="http://amzn.to/2noHxgl" target="_blank" rel="noopener">这儿</a>买鼠标，在 <a href="http://amzn.to/2noHxgl" target="_blank" rel="noopener">这儿</a>买键盘。我才不会因为它们的价格心疼呢。😓</p><blockquote><p><a href="https://github.com/bobthedev/Blog_Lazy_Init_with_Closures" target="_blank" rel="noopener">本文的源码</a></p></blockquote><h3 id="我将要参加-Swift-讨论会"><a href="#我将要参加-Swift-讨论会" class="headerlink" title="我将要参加 Swift 讨论会"></a>我将要参加 Swift 讨论会</h3><p>我将在 6 月 1 日至 6 月 2 日 参加我有生以来的第一次讨论会 @<a href="https://twitter.com/SwiftAveiro" target="_blank" rel="noopener">SwiftAveir</a>， 我的朋友 <a href="https://twitter.com/NSMyself" target="_blank" rel="noopener">Joao</a>协助组织了这次会议，所以我非常 excited。你可以点<a href="http://swiftaveiro.xyz" target="_blank" rel="noopener">这儿</a>了解这件事 的详情！</p><h4 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h4><blockquote><p>函数式编程简介 (<a href="https://blog.bobthedeveloper.io/intro-to-swift-functional-programming-with-bob-9c503ca14f13" target="_blank" rel="noopener">Blog</a>)</p></blockquote><blockquote><p>我最爱的 XCode 快捷键 (<a href="https://blog.bobthedeveloper.io/intro-to-swift-functional-programming-with-bob-9c503ca14f13" target="_blank" rel="noopener">Blog</a> )</p></blockquote><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>我是一名来自首尔的 iOS 课程教师，你可以在 <a href="https://instagram.com/bobthedev" target="_blank" rel="noopener">Instagram</a> 上了解我。我会经常在 <a href="https://facebook.com/bobthedeveloper" target="_blank" rel="noopener">Facebook Page</a> 投稿，投稿时间一般在北京时间上午9点（Sat 8pm EST）。</p><hr><blockquote><p>发布于掘金 <a href="https://juejin.im/post/590a9eeab123db00549776ee" target="_blank" rel="noopener">https://juejin.im/post/590a9eeab123db00549776ee</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/05/04/ES6-模块原生支持在浏览器中落地，是时候该重新考虑打包了吗？/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/04/ES6-模块原生支持在浏览器中落地，是时候该重新考虑打包了吗？/" class="post-title-link" itemprop="https://lsvih.com/page/6/index.html">ES6 模块原生支持在浏览器中落地，是时候该重新考虑打包了吗？</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-05-04 11:17:00" itemprop="dateCreated datePublished" datetime="2017-05-04T11:17:00+08:00">2017-05-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/pasted-145.png" alt="upload successful"></p><p>最近一段日子，编写高效的 JavaScript 应用变得越来越复杂。早在几年前，大家都开始合并脚本来减少 HTTP 请求数；后来有了压缩工具，人们为了压缩代码而缩短变量名，甚至连代码的最后一字节都要省出来。</p><p>今天，我们有了 <a href="https://blog.engineyard.com/2016/tree-shaking" target="_blank" rel="noopener">tree shaking</a> 和各种模块打包器，我们为了不在首屏加载时阻塞主进程又开始进行代码分割，加快<a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank" rel="noopener">交互时间</a>。我们还开始转译一切东西：感谢 Babel，让我们能够在现在就使用未来的特性。</p><p>ES6 模块由 ECMAScript 标准制定，<a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="noopener">定稿有些时日了</a>。社区为它写了很多的文章，讲解如何通过 Babel 使用它们，以及 <code>import</code> 和 Node.js 的 <code>require</code> 的区别。但是要在浏览器中真正实现它还需要一点时间。我惊喜地发现 Safari 在它的 technology preview 版本中第一个装载了 ES6 模块，并且 Edge 和 Firefox Nightly 版本也将要支持 ES6 模块——虽然目前还不支持。在使用 <code>RequireJS</code> 和 <code>Browserify</code> 之类的工具后（还记得关于 <a href="https://addyosmani.com/writing-modular-js/" target="_blank" rel="noopener">AMD 与 CommonJS 的讨论吗</a>？），至少看起来浏览器终于能支持模块了。让我们来看看明朗的未来带来了怎样的礼物吧！🎉</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>构建 web 应用的常用方式就是使用由 Browserify、Rollup、Webpack 等工具构建的代码包（bundle）。而不使用 SPA（单页面应用）技术的网站则通常由服务端生成 HTML，在其中引入一个 JavaScript 代码包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;ES6 modules tryout&lt;/title&gt;</span><br><span class="line">    &lt;!-- defer to not block rendering --&gt;</span><br><span class="line">    &lt;script src=&quot;dist/bundle.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们使用 Webpack 打包的代码包中包括了 3 个 JavaScript 文件，这些文件使用了 ES6 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// app/index.js</span><br><span class="line">import dep1 from &apos;./dep-1&apos;;</span><br><span class="line"></span><br><span class="line">function getComponent () &#123;</span><br><span class="line">  var element = document.createElement(&apos;div&apos;);</span><br><span class="line">  element.innerHTML = dep1();</span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(getComponent());</span><br><span class="line"></span><br><span class="line">// app/dep-1.js</span><br><span class="line">import dep2 from &apos;./dep-2&apos;;</span><br><span class="line"></span><br><span class="line">export default function() &#123;</span><br><span class="line">  return dep2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// app/dep-2.js</span><br><span class="line">export default function() &#123;</span><br><span class="line">  return &apos;Hello World, dependencies loaded!&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 app 将会显示“Hello world”。在下文中显示“Hello world”即表示脚本加载成功。</p><h3 id="装载一个代码包（bundle）"><a href="#装载一个代码包（bundle）" class="headerlink" title="装载一个代码包（bundle）"></a>装载一个代码包（bundle）</h3><p>配置使用 Webpack 创建一个代码包相对来说比较直观。在构建过程中，除了打包和使用 UglifyJS 压缩 JavaScript 文件之外并没有做别的什么事。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./app/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJSPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3 个基础文件比较小，加起来只有 347 字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ll app</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff    75B Mar 16 19:33 dep-1.js</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff    75B Mar  7 21:56 dep-2.js</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff   197B Mar 16 19:33 index.js</span><br></pre></td></tr></table></figure><p>在我通过 Webpack 构建之后，我得到了一个 856 字节的代码包，大约增大了 500 字节。增加这么些字节还是可以接受的，这个代码包与我们平常生产环境中做代码装载没啥区别。感谢 Webpack，我们已经可以使用 ES6 模块了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 4a237b1d69f142c78884</span><br><span class="line">Version: webpack 2.2.1</span><br><span class="line">Time: 114ms</span><br><span class="line">Asset       Size        Chunks  Chunk Names</span><br><span class="line">bundle.js   856 bytes   0       [emitted]  main</span><br><span class="line">  [0] ./app/dep-1.js 78 bytes &#123;0&#125;[built]</span><br><span class="line">  [1] ./app/dep-2.js 75 bytes &#123;0&#125;[built]</span><br><span class="line">  [2] ./app/index.js 202 bytes &#123;0&#125;[built]</span><br></pre></td></tr></table></figure><h2 id="使用原生支持的-ES6-模块的新设定"><a href="#使用原生支持的-ES6-模块的新设定" class="headerlink" title="使用原生支持的 ES6 模块的新设定"></a>使用原生支持的 ES6 模块的新设定</h2><p>现在，我们得到了一个“传统的打包代码”，现在所有还不支持 ES6 模块的浏览器都支持这种打包的代码。我们可以开始玩一些有趣的东西了。让我们在 <code>index.html</code> 中加上一个新的 script 元素指向 ES6 模块，为其加上 <code>type=&quot;module&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;ES6 modules tryout&lt;/title&gt;&lt;!-- in case ES6 modules are supported --&gt;&lt;script src=&quot;app/index.js&quot;type=&quot;module&quot;&gt;&lt;/script&gt;&lt;script src=&quot;dist/bundle.js&quot;defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- ... --&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>然后我们在 Chrome 中看看，发现并没有发生什么事。</p><p><img src="/images/pasted-146.png" alt="upload successful"></p><p>代码包还是和之前一样加载，“Hello world!” 也正常显示。虽然没看到效果，但是这说明浏览器可以接受这种它们并不理解的命令而不会报错，这是极好的。Chrome 忽略了这个它无法判断类型的 script 元素。</p><p>接下来，让我们在 Safari technology preview 中试试：</p><p><img src="/images/pasted-147.png" alt="upload successful"></p><p>遗憾的是，它并没有显示另外的“Hello world”。造成问题的原因是构建工具与原生 ES 模块的差异：Webpack 是在构建的过程中找到那些需要 include 的文件，而 ES 模块是在浏览器中运行的时候才去取文件的，因此我们需要为此指定正确的文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// app/index.js</span><br><span class="line"></span><br><span class="line">// 这样写不行</span><br><span class="line">// import dep1 from &apos;./dep-1&apos;;</span><br><span class="line"></span><br><span class="line">// 这样写能正常工作</span><br><span class="line">import dep1 from &apos;./dep-1.js&apos;;</span><br></pre></td></tr></table></figure><p>改了文件路径之后它能正常工作了，但事实上 Safari Preview 加载了代码包，以及三个独立的模块，这意味着我们的代码被执行了两次。</p><p><img src="/images/pasted-148.png" alt="upload successful"></p><p>这个问题的解决方案就是加上 <code>nomodule</code> 属性，我们可以在加载代码包的 script 元素里加上这个属性。这个属性<a href="https://github.com/whatwg/html/commit/a828019152213ae72b0ed2ba8e35b1c472091817" target="_blank" rel="noopener">是最近才加入标准中的</a>，Safari Preview 也是在<a href="https://trac.webkit.org/changeset/211078/webkit" target="_blank" rel="noopener">一月底</a>才支持它的。这个属性会告诉 Safari，这个 script 是当不支持 ES6 模块时的“退路”。在这个例子中，浏览器支持 ES6 模块因此加上这个属性的 script 元素中的代码将不会执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;ES6 modules tryout&lt;/title&gt;</span><br><span class="line">    &lt;!-- in case ES6 modules are supported --&gt;</span><br><span class="line">    &lt;script src=&quot;app/index.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- in case ES6 modules aren&apos;t supported --&gt;</span><br><span class="line">    &lt;script src=&quot;dist/bundle.js&quot; defer nomodule&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-149.png" alt="upload successful"></p><p>现在好了。通过结合使用 <code>type=&quot;module&quot;</code> 与 <code>nomodule</code>，我们现在可以在不支持 ES6 模块的浏览器中加载传统的代码包，在支持 ES6 模块的浏览器中加载 JavaScript 模块。</p><p>你可以在 <a href="http://es-module-on.stefans-playground.rocks/" target="_blank" rel="noopener">es-module-on.stefans-playground.rocks</a> 查看这个尚在制定的规范。</p><h3 id="模块与脚本的不同"><a href="#模块与脚本的不同" class="headerlink" title="模块与脚本的不同"></a>模块与脚本的不同</h3><p>这儿有几个问题。首先，JavaScript 在 ES6 模块中运行与平常在 script 元素中不同。Axel Rauschmayer 在他的<a href="http://exploringjs.com/es6/ch_modules.html#sec_modules-vs-scripts" target="_blank" rel="noopener">探索 ES6</a>一书中很好地讨论了这个问题。我推荐你点击上面的链接阅读这本书，但是在此我先快速地总结一下主要的不同点：</p><ul><li>ES6 模块默认在严格模式下运行（因此你不需要加上 <code>use strict</code> 了）。</li><li>最外层的 <code>this</code> 指向 <code>undefined</code>（而不是 window）。</li><li>最高级变量是 module 的局部变量（而不是 global）。</li><li>ES6 模块会在浏览器完成 HTML 的分析之后异步加载与执行。</li></ul><p>我认为，这些特性是巨大进步。模块是局部的——这意味着我们不再需要到处使用 IIFE 了，而且我们不用再担心全局变量泄露。而且默认在严格模式下运行，意味着我们可以在很多地方抛弃 <code>use strict</code> 声明。</p><blockquote><p>译注：IIFE 全称 immediately-invoked function expression，即立即执行函数，也就是大家熟知的在函数后面加括号。</p></blockquote><p>从改善性能的观点来看（可能是最重要的进步），<strong>模块默认会延迟加载与执行</strong>。因此我们将不再会不小心给我们的网站加上了阻碍加载的代码，使用 <code>type=&quot;module&quot;</code> 的 script 元素也不再会有 <a href="https://www.stevesouders.com/blog/2010/06/01/frontend-spof/" target="_blank" rel="noopener">SPOF</a> 问题。我们也可以给它加上一个 <code>async</code> 属性，它将会覆盖默认的延迟加载行为。不过使用 <code>defer</code> <a href="https://calendar.perfplanet.com/2016/prefer-defer-over-async/" target="_blank" rel="noopener">在现在也是一个不错的选择</a>。</p><blockquote><p>译注：SPOF 全称 Single Points Of Failure——单点故障</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- not blocking with defer default behavior --&gt;</span><br><span class="line">&lt;script src=&quot;app/index.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- executed after HTML is parsed --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  console.log(&apos;js module&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- executed immediately --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&apos;standard module&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果你想详细了解这方面内容，可以阅读 <a href="https://html.spec.whatwg.org/multipage/scripting.html#the-script-element" target="_blank" rel="noopener">script 元素说明</a>，这篇文章简单易读，并且包含了一些示例。</p><h2 id="压缩纯-ES6-代码"><a href="#压缩纯-ES6-代码" class="headerlink" title="压缩纯 ES6 代码"></a>压缩纯 ES6 代码</h2><p>还没完！我们现在能为 Chrome 提供压缩过的代码包，但是还不能为 Safari Preview 提供单独压缩过的文件。我们如何让这些文件变得更小呢？UglifyJS 能完成这项任务吗？</p><p>然而必须指出，UglifyJS 并不能完全处理好 ES6 代码。虽然它有个 <code>harmony</code> 开发版分支（<a href="https://github.com/mishoo/UglifyJS2/tree/harmony" target="_blank" rel="noopener">地址</a>）支持ES6，但不幸的是在我写这 3 个 JavaScript 文件的时候它并不能正常工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ uglifyjs dep-1.js -o dep-1.min.js</span><br><span class="line">Parse error at dep-1.js:3,23</span><br><span class="line">export default function() &#123;</span><br><span class="line">                      ^</span><br><span class="line">SyntaxError: Unexpected token: punc (()</span><br><span class="line">// ..</span><br><span class="line">FAIL: 1</span><br></pre></td></tr></table></figure><p>但是现在 UglifyJS 几乎存在于所有工具链中，那全部使用 ES6 编写的工程应该怎么办呢？</p><p>通常的流程是使用 Babel 之类的工具将代码转换为 ES5，然后使用 Uglify 对 ES5 代码进行压缩处理。但是在这篇文章里我不想使用 ES5 翻译工具，因为我们现在是要寻找面向未来的处理方式！Chrome 已经<a href="https://kangax.github.io/compat-table/es6/#chrome59" target="_blank" rel="noopener">覆盖了 97% ES6 规范</a> ，而 Safari Preview 版<a href="https://kangax.github.io/compat-table/es6/#safari10_1" target="_blank" rel="noopener">自 verion 10 之后已经 100% 很好地支持 ES6</a>了。</p><p>我在推特中提问是否有能够处理 ES6 的压缩工具，<a href="https://twitter.com/larsgraubner" target="_blank" rel="noopener">Lars Graubner</a> 告诉我可以使用 <a href="https://github.com/babel/babili" target="_blank" rel="noopener">Babili</a>。使用 Babili，我们能够轻松地对 ES6 模块进行压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// app/dep-2.js</span><br><span class="line"></span><br><span class="line">export default function() &#123;</span><br><span class="line">  return &apos;Hello World. dependencies loaded.&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// dist/modules/dep-2.js</span><br><span class="line">export default function()&#123;return &apos;Hello World. dependencies loaded.&apos;&#125;</span><br></pre></td></tr></table></figure><p>使用 Babili CLI 工具，可以轻松地分别压缩各个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ babili app -d dist/modules</span><br><span class="line">app/dep-1.js -&gt; dist/modules/dep-1.js</span><br><span class="line">app/dep-2.js -&gt; dist/modules/dep-2.js</span><br><span class="line">app/index.js -&gt; dist/modules/index.js</span><br></pre></td></tr></table></figure><p>最终结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll dist</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff   856B Mar 16 22:32 bundle.js</span><br><span class="line"></span><br><span class="line">$ ll dist/modules</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff    69B Mar 16 22:32 dep-1.js</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff    68B Mar 16 22:32 dep-2.js</span><br><span class="line">-rw-r--r--  1 stefanjudis  staff   161B Mar 16 22:32 index.js</span><br></pre></td></tr></table></figure><p>代码包仍然是大约 850B，所有文件加起来大约是 300B。我没有使用 GZIP，因为<a href="http://webmasters.stackexchange.com/questions/31750/what-is-recommended-minimum-object-size-for-gzip-performance-benefits" target="_blank" rel="noopener">它并不能很好地处理小文件</a>。（我们稍后会提到这个）</p><h2 id="能通过-rel-preload-来加速-ES6-的模块加载吗？"><a href="#能通过-rel-preload-来加速-ES6-的模块加载吗？" class="headerlink" title="能通过 rel=preload 来加速 ES6 的模块加载吗？"></a>能通过 rel=preload 来加速 ES6 的模块加载吗？</h2><p>对单个 JS 文件进行压缩取得了很好的效果。文件大小从 856B 降低到了 298B，但是我们还能进一步地加快加载速度。通过使用 ES6 模块，我们可以装载更少的代码，但是看看瀑布图你会发现，request 会按照模块的依赖链一个一个连续地加载。</p><p>那如果我们像之前在浏览器中对代码进行预加载那样，用 <code>&lt;link rel=&quot;preload&quot; as=&quot;script&quot;&gt;</code> 元素告知浏览器要加载额外的 request，是否会加快模块的加载速度呢？在 Webpack 中，我们已经有了类似的工具，比如 Addy Osmani 的 <a href="https://github.com/GoogleChrome/preload-webpack-plugin" target="_blank" rel="noopener">Webpack 预加载插件</a>可以对分割的代码进行预加载，那 ES6 模块有没有类似的方法呢？如果你还不清楚 <code>rel=&quot;preload&quot;</code> 是如何运作的，你可以先阅读 Yoav Weiss 在 Smashing Magazine 发表的相关文章：<a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="noopener">点击阅读</a></p><p>但是，ES6 模块的预加载并不是那么简单，他们与普通的脚本有很大的不同。那么问题来了，对一个 link 元素加上 <code>rel=&quot;preload&quot;</code> 将会怎样处理 ES6 模块呢？它也会取出所有的依赖文件吗？这个问题显而易见（可以），但是使用 <code>preload</code> 命令加载模块，需要解决更多浏览器的内部实现问题。<a href="https://twitter.com/domenic" target="_blank" rel="noopener">Domenic Denicola</a> 在<a href="https://github.com/whatwg/fetch/issues/486" target="_blank" rel="noopener">一个 GitHub issue</a> 中讨论了这方面的问题，如果你感兴趣的话可以点进去看一看。但是事实证明，使用 <code>rel=&quot;preload&quot;</code> 加载脚本与加载 ES6 模块是截然不同的。可能以后最终的解决方案是用另一个 <code>rel=&quot;modulepreload&quot;</code> 命令来专门加载模块。在本文写作时，<a href="https://github.com/whatwg/html/pull/2383" target="_blank" rel="noopener">这个 pull request</a> 还在审核中，你可以点进去看看未来我们可能会怎样进行模块的预加载。</p><h2 id="加入真实的依赖"><a href="#加入真实的依赖" class="headerlink" title="加入真实的依赖"></a>加入真实的依赖</h2><p>仅仅 3 个文件当然没法做一个真正的 app，所以让我们给它加一些真实的依赖。<a href="https://lodash.com/" target="_blank" rel="noopener">Lodash</a> 根据 ES6 模块对它的功能进行了分割，并分别提供给用户。我取出其中一个功能，然后使用 Babili 进行压缩。现在让我们对 <code>index.js</code> 文件进行修改，引入这个 Lodash 的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import dep1 from &apos;./dep-1.js&apos;;</span><br><span class="line">import isEmpty from &apos;./lodash/isEmpty.js&apos;;</span><br><span class="line"></span><br><span class="line">function getComponent() &#123;</span><br><span class="line">  const element = document.createElement(&apos;div&apos;);</span><br><span class="line">  element.innerHTML = dep1() + &apos; &apos; + isEmpty([]);</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.appendChild(getComponent());</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>isEmpty</code> 基本上没有被使用，但是在加上它的依赖后，我们可以看看发生了什么：</p><p><img src="/images/pasted-150.png" alt="upload successful"></p><p>可以看到 request 数量增加到了 40 个以上，页面在普通 wifi 下的加载时间从大约 100 毫秒上升到了 400 到 800 毫秒，加载的数据总大小在没有压缩的情况下增加到了大约 12KB。可惜的是 <a href="https://www.webpagetest.org/" target="_blank" rel="noopener">WebPagetest</a> 在 Safari Preview 中不可用，我们没法给它做可靠的标准检测。</p><p>但是，Chrome 收到打包后的 JavaScript 数据比较小，只有大约 8KB。</p><p><img src="/images/pasted-151.png" alt="upload successful"></p><p>这 4KB 的差距是不能忽视的。你可以在 <a href="https://lodash-module-on.stefans-playground.rocks/" target="_blank" rel="noopener">lodash-module-on.stefans-playground.rocks</a> 找到本示例。</p><h3 id="压缩工作仅对大文件表现良好"><a href="#压缩工作仅对大文件表现良好" class="headerlink" title="压缩工作仅对大文件表现良好"></a>压缩工作仅对大文件表现良好</h3><p>如果你仔细看上面 Safari 开发者工具的截图，你可能会注意到传输后的文件大小其实比源码还要大。在很大的 JavaScript app 中这个现象会更加明显，一堆的小 Chunk 会造成文件大小的很大不同，因为 GZIP 并不能很好地压缩小文件。</p><p>Khan Academy 在前一段时间<a href="http://engineering.khanacademy.org/posts/js-packaging-http2.htm" target="_blank" rel="noopener">探究了同样的问题</a>，他是用 HTTP/2 进行研究的。装载更小的文件能够很好地确保缓存命中率，但到最后它一般都会作为一个权衡方案，而且它的效果会被很多因素影响。对于一个很大的代码库来说，分解成若干个 chunk（一个 <em>vendor</em> 文件和一个 app bundle）是理所当然的，但是要装载数千个不能被压缩的小文件可能并不是一种明智的方法。</p><h3 id="Tree-shaking-是个超-COOL-的技术"><a href="#Tree-shaking-是个超-COOL-的技术" class="headerlink" title="Tree shaking 是个超 COOL 的技术"></a>Tree shaking 是个超 COOL 的技术</h3><p>必须要说：感谢非常新潮的 tree shaking 技术，通过它，构建进程可以将没有使用过以及没有被其它模块引用的代码删除。第一个支持这个技术的构建工具是 Rollup，现在 Webpack 2 也支持它——<a href="https://medium.freecodecamp.com/tree-shaking-es6-modules-in-webpack-2-1add6672f31b#22c4" target="_blank" rel="noopener">只要我们在 babel 中禁用 <code>module</code> 选项</a>。</p><p>我们试着改一改 <code>dep-2.js</code>，让它包含一些不会在 <code>dep-1.js</code> 中使用的东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default function() &#123;</span><br><span class="line">  return &apos;Hello World. dependencies loaded.&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const unneededStuff = [</span><br><span class="line">  &apos;unneeded stuff&apos;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>Babili 只会压缩文件， Safari Preview 在这种情况下会接收到这几行没有用过的代码。而另一方面，Webpack 或者 Rollup 打的包将不会包含这个 <code>unnededStuff</code>。Tree shaking 省略了大量代码，它毫无疑问应当被用在真实的产品代码库中。</p><h2 id="尽管未来很明朗，但是现在的构建过程仍然不会变动"><a href="#尽管未来很明朗，但是现在的构建过程仍然不会变动" class="headerlink" title="尽管未来很明朗，但是现在的构建过程仍然不会变动"></a>尽管未来很明朗，但是现在的构建过程仍然不会变动</h2><p>ES6 模块即将到来，但是直到它最终在各大主流浏览器中实现前，我们的开发并不会发生什么变化。我们既不会装载一堆小文件来确保压缩率，也不会为了使用 tree shaking 和死码删除来抛弃构建过程。<strong>前端开发现在及将来都会一如既往地复杂</strong>。</p><p>不要把所有东西都进行分割然后就假设它会改善性能。我们即将迎来 ES6 模块的浏览器原生支持，但是这不意味着我们可以抛弃构建过程与合适的打包策略。在我们 Contentful 这儿，将继续坚持我们的构建过程，以及继续使用我们的 <a href="https://www.contentful.com/developers/docs/javascript/" target="_blank" rel="noopener">JavaScript SDKs</a> 进行打包。</p><p>然而，我们必须承认现在前端的开发体验仍然良好。JavaScript 仍在进步，最终我们将能够使用语言本身提供的模块系统。在几年后，原生模块对 JavaScript 生态的影响以及最佳实践方法将会是怎样的呢？让我们拭目以待。</p><h2 id="其它资源"><a href="#其它资源" class="headerlink" title="其它资源"></a>其它资源</h2><ul><li><a href="https://blog.hospodarets.com/native-ecmascript-modules-the-first-overview" target="_blank" rel="noopener">ES6 模块系列文章</a> 作者：Serg Hospodarets</li><li><a href="http://exploringjs.com/" target="_blank" rel="noopener">《探索 ES6》</a> 的 <a href="http://exploringjs.com/es6/ch_modules.html" target="_blank" rel="noopener">模块章节</a></li></ul><blockquote><p>发布于掘金 <a href="https://juejin.im/post/590a990a5c497d005852cf61" target="_blank" rel="noopener">https://juejin.im/post/590a990a5c497d005852cf61</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">lsvih</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">138</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">165</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">lsvih</span></div><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div><div class="footer-custom"><a target="_blank" rel="external nofollow" href="http://www.miitbeian.gov.cn">京ICP备18029472号</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.5.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>