<!DOCTYPE html><html class="theme-next pisces"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0"><link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.5.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"6U6P1RGK4F",apiKey:"b14e73cdd627eabe947b5decbe14850f",indexName:"lsvih",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="My note"><meta property="og:url" content="https://lsvih.com/page/4/index.html"><meta property="og:site_name" content="My note"><meta property="og:locale" content="default"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="My note"><link rel="canonical" href="https://lsvih.com/page/4/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>My note – lsvih</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My note</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">lsvih</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/11/03/Spotify-每周推荐功能：基于机器学习的音乐推荐/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/11/03/Spotify-每周推荐功能：基于机器学习的音乐推荐/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Spotify 每周推荐功能：基于机器学习的音乐推荐</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-11-03 10:16:14" itemprop="dateCreated datePublished" datetime="2017-11-03T10:16:14+08:00">2017-11-03</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在每周周一，超过 1 亿位 Spotify 用户会收到一份新鲜的歌曲播放列表。这个自定义列表中包含了 30 首用户从来没听过，但可能会喜欢上的歌曲。这个神奇的功能被称为“每周推荐（Discover Weekly）”。</p><p>我是 Spotify 的忠实粉丝，尤其喜欢它的每周推荐功能。因为，它让我感觉到我被<strong>重视</strong>着。它比谁都了解我的音乐品味，而且每周的推荐都<strong>刚好</strong>令我满足。如果没有它，我可能一辈子都找不到一些我非常喜欢的歌曲。</p><p>如果你苦于找不到想听的音乐，请让我隆重介绍我最好的虚拟伙伴：</p><p><img src="/images/pasted-241.png" alt="upload successful"></p><p>事实证明，痴迷于每周推荐的用户不仅只有我一个 —— 许多用户都为它痴狂，这足以让 Spotify 重新思考其发展重点，将更多的资源投入播放列表推荐算法中。</p><p>每周推荐功能于 2015 亮相，从那时开始，我就非常渴望了解它是如何运作的（我是他们公司的粉丝，所以常常假设自己在 Spotify 工作并研究他们的产品）。在经过三个星期的疯狂搜索之后，我得以瞟到了其帷幕后的一丝真容。</p><p>那么 Spotify 是如何做出每周为每个用户选出 30 首歌这个惊人的工作的呢？让我们先看一看其它一些音乐服务商是如何进行音乐推荐的，然后分析为什么 Spotify 做的更好。</p><hr><p><img src="/images/pasted-242.png" alt="upload successful"></p><p>早在 2000 年，Songza 就开始使用<strong>人工编辑</strong>来进行在线音乐策展（curation，策划并展示）。“人工编辑”意味着需要一些”音乐专家“团队或者其它管理员手动将他们认为很好听的歌放到歌单中去。（后来 Beats Music 也实行了同样的策略）。虽然人工编辑运作的很好，但是它需要手动操作并且过于简单，<strong>无法考虑到每个听众个人音乐品味的差别</strong>。</p><p>如 Songza 一样，Pandora 也是音乐策展的元老之一。它采用的方法较为先进，使用<strong>人工标注歌曲属性</strong>的方法。也就是说，有一组人在听歌之后，为每首歌选择一些描述性的词，对各个曲目进行了标注。然后，Pandora 就能利用代码简单地对标注进行筛选，得到比较类似的歌单。</p><p>与此同时，麻省理工学院媒体实验室开发出了名为”The Echo Nest“的智能音乐助手，开创了一种更加先进的个性化音乐推荐方式。The Echo Nest 使用<strong>算法分析各个音乐音频与文本的内容</strong>，使其能进行音乐识别、个性化推荐、创建歌单以及进行分析。</p><p>此外，至今依然存在的 Last.fm 采用了一种名为<strong>协同过滤</strong>的不同的方法。它可以识别用户可能喜欢的音乐。稍后会详细提到它。</p><hr><p>以上就是<strong>其它</strong>音乐策展服务进行推荐的方法。那么 Spotify 是如何造出它们神奇的引擎，如何做出更加符合用户口味的推荐的呢？</p><h2 id="Spotify-的-3-种推荐模型"><a href="#Spotify-的-3-种推荐模型" class="headerlink" title="Spotify 的 3 种推荐模型"></a>Spotify 的 3 种推荐模型</h2><p>实际上 Spotify 并没有使用某个革命性的推荐模型 —— 与此相反，<strong>他们是将一些其它服务中单一使用的最佳策略混合起来，创建了自己独特、强大的发现引擎。</strong></p><p>Spotify 每周推荐的开发者主要采用了如下三种类型的推荐：</p><ol><li><strong>协同过滤</strong>模型（就是 Last.fm 最开始使用的模型），通过分析<strong>你的</strong>行为与<strong>他人</strong>的行为进行运作。</li><li><strong>自然语言处理（NLP）</strong>模型，用于分析<strong>文本</strong>。</li><li><strong>音频</strong> 模型，用于分析<strong>原始音轨</strong>。</li></ol><p><img src="/images/pasted-243.png" alt="upload successful"></p><p>下面让我们深入了解上述各个推荐模型吧！</p><hr><h2 id="推荐模型-1：协同过滤"><a href="#推荐模型-1：协同过滤" class="headerlink" title="推荐模型 #1：协同过滤"></a>推荐模型 #1：协同过滤</h2><p><img src="/images/pasted-244.png" alt="upload successful"></p><p>首先简述一些背景：当人们听见”协同推荐“这个词的时候，大多会想起 <strong>Netflix</strong> 这个首批采用协同过滤推荐模型的公司。他们使用用户对影片的评星来确定将什么影片推荐给<strong>其它</strong>喜好相似的用户。</p><p>当 Netflix 成功使用这种推荐方法之后，开始迅速发展。现在通常被认为是尝试使用推荐模型的鼻祖。</p><p>与 Netflix 不同，Spotify 没有让用户对音乐进行评星。他们采用的数据是<strong>隐式反馈</strong> —— 具体来说，包括对用户听歌的<strong>流数据进行统计</strong>，以及收集一些其它的流数据，包括用户是否将歌曲保存到他们自己的歌单、在听完歌之后是否访问了歌手的主页等等。</p><p>那么什么是协同过滤，它又是如何运作的呢？这儿用下面这个简短的对话来做个简述：</p><p><img src="/images/pasted-245.png" alt="upload successful"></p><p>图中发生了什么？图中的两个人都有一些喜欢的歌曲 - 左边的人喜欢歌曲 P、Q、R 及 S；右边的人喜欢歌曲 Q、R、S 及 T。</p><p>协同过滤就像用这些数据说：</p><p><strong>”Emmmmm，你们都喜欢 Q、R、S 三首歌，所以你们可能是类似的用户。所以，你应该会喜欢对方爱听而你还没听过的歌。“</strong></p><p>也就是说，会建议右边的人去听歌曲 P 试试，建议左边的人去听听歌曲 T。这很简单吧！</p><p>但 Spotify 是如何将这种方法落到实处，用于由<strong>百万级别用户</strong>的喜好歌曲来计算<strong>百万级别用户</strong>的推荐的呢？</p><p><strong>……应用数学矩阵，然后使用 Python 库来实现。</strong></p><p><img src="/images/pasted-246.png" alt="upload successful"></p><p>在实际情况中，你在看到的这个矩阵是<strong>巨大无比</strong>的，<strong>矩阵中的每一行都代表了 Spotify 的 1.4 亿用户</strong>（如果你也用 Spotify，那你也会是这个矩阵的一行），<strong>每列代表了 Spotify 数据库中的 3000 万首歌</strong>。</p><p>接着，Python 库会长时间、缓慢地对矩阵按照以下分离公式进行计算：</p><p><img src="/images/pasted-247.png" alt="upload successful"></p><p>在它完成计算之后，我们会得到两种向量，在这里用 X 与 Y 表示。<strong>X 是用户向量</strong>，代表了单个用户的口味；<strong>Y 是歌曲向量</strong>，代表了一首歌的属性。</p><p><img src="/images/pasted-248.png" alt="upload successful"></p><p>现在，我们有了 1.4 亿条用户向量以及 3000 万条歌曲向量。这些向量的内容实质上就是一堆数字，本身没有任何意义。但是对它们进行对比就能起到巨大的作用。</p><p>为了找到哪些用户和我有着最相似的口味，协同过滤会将我的向量和其它每个用户的向量进行对比，最终找到与我最相近的用户。同样的，对 Y 向量进行比较，可以找到与你正在听的歌最相近的歌。</p><p>协同过滤的效果相当不错，但 Spotify 没有满足于此，他们知道通过增加一些其它的引擎可以使得效果更好。下面让我们看看 NLP。</p><hr><h2 id="推荐模型-2：自然语言处理（NLP）"><a href="#推荐模型-2：自然语言处理（NLP）" class="headerlink" title="推荐模型 #2：自然语言处理（NLP）"></a>推荐模型 #2：自然语言处理（NLP）</h2><p>Spotify 采用的第二种推荐模型是<strong>自然语言处理（NLP）模型</strong>。顾名思义，这种模型的数据来源就是传统意义上的<strong>文字</strong> —— 这些文字来源于歌曲的元数据、新闻文章、博客，以及互联网中的其它文本。</p><p><img src="/images/pasted-249.png" alt="upload successful"></p><p>NLP 是一种让计算机理解人类语言的能力，是一个庞大的领域。在这儿可以采用一些情感分析 API 来实现。</p><p>NLP 背后的机制已经超出了本文的讨论范围。不过我们可以这么来大致概括：Spotify 爬虫不断地查找与音乐有关的博客以及各种文本，并了解人们对特定艺术家及歌曲的看法 —— 谈到这些歌曲人们通常会用什么形容词和语言，以及会同时提到哪些<strong>其他</strong>的艺术家及歌曲。</p><p>虽然我不知道 Spotify 处理数据的细节，但我知道 the Echo Nest 是如何与他们进行协同工作的。他们会将语言处理封装为“文化向量”或者“高频短语”。每个艺术家及歌曲都有着数以千计的高频短语，且每天都在变化。每个短语都有一个权重，用于表示这个短语的重要性（大致来说，就是某人描述这个音乐时会用这个短语的概率）。</p><p><img src="/images/pasted-250.png" alt="upload successful"></p><p>the Echo Nest 使用的“文化向量”与“高频短语”，Brian Whitman 提供表格</p><p>接下来与协同过滤一样，NLP 模型会使用这些短语和权重为每首歌构建一个表示向量，这样就能判断两首歌是否相似了。酷不酷炫？</p><hr><h2 id="推荐模型-3：原始音频模型"><a href="#推荐模型-3：原始音频模型" class="headerlink" title="推荐模型 #3：原始音频模型"></a>推荐模型 #3：原始音频模型</h2><p><img src="/images/pasted-251.png" alt="upload successful"></p><p>在开始本章之前，你可能会问：</p><blockquote><p>我们已经在前两个模型中应用了足够多的数据，为什么还需要分析音频本身呢？</p></blockquote><p>首先，引入这第三个模型能使这个惊人的推荐服务的准确率得到进一步的提升。但实际上，使用这个模型还有第二种目的：与前两个模型不同，<strong>原始音频模型可以用于处理<em>新</em>歌</strong>。</p><p>举个例子，你的歌手朋友将他的新歌传上了 Spotify，然而他仅有 50 名听众，如果要使用协同过滤显然人数太少了。并且他还没有火起来，在互联网上任何角落都没有被提到过，因此 NLP 模型也没法为他发挥作用。不过幸运的是原始音频模型不会在乎这是新歌还是老歌，有了它的帮助，你朋友的歌就有可能和那些流行的歌一起被加入每周推荐歌单了！</p><p>接下来解释“如何”对如此抽象的<strong>原始音频</strong>进行分析。</p><p>…使用 <strong>卷积神经网络（CNN）</strong>!</p><p>卷积神经网络正是人脸识别背后使用的技术。在 Spotify 这个场景中，工程师们使用音频数据来代替像素。下面是神经网络一中结构的实例：</p><p><img src="/images/pasted-252.png" alt="upload successful"></p><p>这个特制的神经网络有 4 层<strong>卷积层</strong>，它们在图的左边，看起来像很厚的木板；它还有 3 层<strong>全连接层</strong>，它们在图的右边，看起来像很窄的木板。输入值是音频帧的频率的表示，在图中以光谱图的形式表示。</p><p>音频帧通过这些卷积层后，在最后一个卷积层边你可以看到一个“全局时间池化”层。这个池化层沿整个时间轴进行池化，高效地根据统计学找出在歌曲的时间序列中找到的特征。</p><p>在此之后，神经网络会输出它对一首歌的理解，其中包括各种类似<strong>时间戳、调性、风格、节奏、音量</strong>等典型特征。下图为 Daft Punk 的 “Around the World” 一曲中截取 30 秒片段的数据。</p><p><img src="/images/pasted-253.png" alt="upload successful"></p><p>图片版权：<a href="http://docs.echonest.com.s3-website-us-east-1.amazonaws.com/_static/AnalyzeDocumentation.pdf" target="_blank" rel="noopener">Tristan Jehan &amp; David DesRoches (The Echo Nest)</a></p><p>最终，这些由一首歌理解到的各种关键的信息可以让 Spotify 理解不同的歌中的一些本质的相似之处，由此基于用户的听歌历史推断出此用户可能会喜欢这首新歌。</p><hr><p>以上概况了推荐模型中的三个基本组成部分。正是由这些推荐模型组成的推荐 pipeline，最终构成了强大的每周推荐歌单功能！</p><p><img src="/images/pasted-254.png" alt="upload successful"></p><p>当然，这些推荐模型还与 Spotify 更大的生态系统息息相关，这个生态系统中包含了<strong>海量</strong>的数据，使用大量的 Hadoop 集群对推荐系统践行规模化运作，使得这些引擎能够在大尺度、无穷尽的互联网中顺利地分析音乐相关文章以及无比庞大的音频文件。</p><p>我希望本文的信息能满足你的好奇心（就像我的好奇心被满足了一样）。现在我正在通过我个性化的每周推荐找到我喜欢的音乐，了解以及欣赏它背后的各种机器学习知识。🎶</p><hr><p>**资源：</p><ul><li><a href="https://www.slideshare.net/MrChrisJohnson/from-idea-to-execution-spotifys-discover-weekly/31-1_0_0_0_1" target="_blank" rel="noopener">From Idea to Execution: Spotify’s Discover Weekly</a> (Chris Johnson, ex-Spotify)</li><li><a href="https://www.slideshare.net/erikbern/collaborative-filtering-at-spotify-16182818/10-Supervised_collaborative_filtering_is_pretty" target="_blank" rel="noopener">Collaborative Filtering at Spotify</a> (Erik Bernhardsson, ex-Spotify)</li><li><a href="http://benanne.github.io/2014/08/05/spotify-cnns.html" target="_blank" rel="noopener">Recommending music on Spotify with deep learning</a> (Sander Dieleman)</li><li><a href="https://notes.variogr.am/2012/12/11/how-music-recommendation-works-and-doesnt-work/" target="_blank" rel="noopener"> How music recommendation works — and doesn’t work</a> (Brian Whitman, co-founder of The Echo Nest)</li><li><a href="http://blog.galvanize.com/spotify-discover-weekly-data-science/" target="_blank" rel="noopener">Ever Wonder How Spotify Discover Weekly Works? Data Science</a> (Galvanize)</li><li><a href="https://qz.com/571007/the-magic-that-makes-spotifys-discover-weekly-playlists-so-damn-good/" target="_blank" rel="noopener">The magic that makes Spotify’s Discover Weekly playlists so damn good</a> (Quartz)</li><li><a href="http://docs.echonest.com.s3-website-us-east-1.amazonaws.com/_static/AnalyzeDocumentation.pdf" target="_blank" rel="noopener">The Echo Nest’s Analyzer Documentation</a></li></ul><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/59fbd0d9518825299a468a8b" target="_blank" rel="noopener">https://juejin.im/post/59fbd0d9518825299a468a8b</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/16/Keras-中构建神经网络的-5-个步骤/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/10/16/Keras-中构建神经网络的-5-个步骤/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Keras 中构建神经网络的 5 个步骤</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-10-16 12:57:27" itemprop="dateCreated datePublished" datetime="2017-10-16T12:57:27+08:00">2017-10-16</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>使用 Keras 创建、评价深度神经网络非常的便捷，不过你需要严格地遵循几个步骤来构建模型。</p><p>在本文中我们将一步步地探索在 Keras 中创建、训练、评价深度神经网络，并了解如何使用训练好的模型进行预测。</p><p>在阅读完本文后你将了解：</p><ul><li>如何在 Keras 中定义、编译、训练以及评价一个深度神经网络。</li><li>如何选择、使用默认的模型解决回归、分类预测问题。</li><li><p>如何使用 Keras 开发并运行你的第一个多层感知机网络。</p></li><li><p><strong>2017 年 3 月更新</strong>：将示例更新至 Keras 2.0.2 / TensorFlow 1.0.1 / Theano 0.9.0。</p></li></ul><p><img src="/images/pasted-240.png" alt="upload successful"></p><p>题图版权由 <a href="https://www.flickr.com/photos/dxhawk/6842278135/" target="_blank" rel="noopener">Martin Stitchener</a> 所有。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>下面概括一下我们将要介绍的在 Keras 中构建神经网络模型的 5 个步骤。</p><ol><li>定义网络。</li><li>编译网络。</li><li>训练网络。</li><li>评价网络。</li><li>进行预测。</li></ol><p><img src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2016/07/5-Step-Life-Cycle-for-Neural-Network-Models-in-Keras.png" alt="Keras 中构建神经网络的 5 个步骤"></p><p>Keras 中构建神经网络的 5 个步骤</p><h2 id="想要了解更多使用-Python-进行深度学习的知识？"><a href="#想要了解更多使用-Python-进行深度学习的知识？" class="headerlink" title="想要了解更多使用 Python 进行深度学习的知识？"></a>想要了解更多使用 Python 进行深度学习的知识？</h2><p>免费订阅 2 周，收取我的邮件，探索 MLP、CNN 以及 LSTM 吧！（附带样例代码）</p><p>现在点击注册还能得到免费的 PDF 版教程。</p><p><a href="https://machinelearningmastery.leadpages.co/leadbox/142d6e873f72a2%3A164f8be4f346dc/5657382461898752/" target="_blank" rel="noopener">点击这里开始你的小课程吧！</a></p><h2 id="第一步：定义网络"><a href="#第一步：定义网络" class="headerlink" title="第一步：定义网络"></a>第一步：定义网络</h2><p>首先要做的就是定义你的神经网络。</p><p>在 Keras 中，可以通过一系列的层来定义神经网络。这些层的容器就是 Sequential 类。（译注：序贯模型）</p><p>第一步要做的就是创建 Sequential 类的实例。然后你就可以按照层的连接顺序创建你所需要的网络层了。</p><p>例如，我们可以做如下两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(2))</span><br></pre></td></tr></table></figure><p>此外，我们也可以通过创建一个层的数组，并将其传给 Sequential 构造器来定义模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layers = [Dense(2)]</span><br><span class="line">model = Sequential(layers)</span><br></pre></td></tr></table></figure><p>网络的第一层必须要定义预期输入维数。指定这个参数的方式有许多种，取决于要建造的模型种类，不过在本文的多层感知机模型中我们将通过 <code>input_dim</code> 属性来指定它。</p><p>例如，我们要定义一个小型的多层感知机模型，这个模型在可见层中具有 2 个输入，在隐藏层中有 5 个神经元，在输出层中有 1 个神经元。这个模型可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(5, input_dim=2))</span><br><span class="line">model.add(Dense(1))</span><br></pre></td></tr></table></figure><p>你可以将这个序贯模型看成一个管道，从一头喂入数据，从另一头得到预测。</p><p>这种将通常互相连接的层分开，并作为单独的层加入模型是 Keras 中一个非常有用的概念，这样可以清晰地表明各层在数据从输入到输出的转换过程中起到的职责。例如，可以将用于将各个神经元中信号求和、转换的激活函数单独提取出来，并将这个 Activation 对象同层一样加入 Sequential 模型中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(5, input_dim=2))</span><br><span class="line">model.add(Activation(&apos;relu&apos;))</span><br><span class="line">model.add(Dense(1))</span><br><span class="line">model.add(Activation(&apos;sigmoid&apos;))</span><br></pre></td></tr></table></figure><p>输出层激活函数的选择尤为重要，它决定了预测值的格式。</p><p>例如，以下是一些常用的预测建模问题类型，以及它们可以在输出层使用的结构和标准的激活函数：</p><ul><li><strong>回归问题</strong>：使用线性的激活函数 “linear”，并使用与与输出数量相匹配的神经元数量。</li><li><strong>二分类问题</strong>：使用逻辑激活函数 “sigmoid”，在输出层仅设一个神经元。</li><li><strong>多分类问题</strong>：使用 Softmax 激活函数 “softmax”；假如你使用的是 one-hot 编码的输出格式的话，那么每个输出对应一个神经元。</li></ul><h2 id="第二步：编译网络"><a href="#第二步：编译网络" class="headerlink" title="第二步：编译网络"></a>第二步：编译网络</h2><p>当我们定义好网络之后，必须要对它进行编译。</p><p>编译是一个高效的步骤。它会将我们定义的层序列通过一系列高效的矩阵转换，根据 Keras 的配置转换成能在 GPU 或 CPU 上执行的格式。</p><p>你可以将编译过程看成是对你网络的预计算。</p><p>无论是要使用优化器方案进行训练，还是从保存的文件中加载一组预训练权重，只要是在定义模型之后都需要编译，因为编译步骤会将你的网络转换为适用于你的硬件的高效结构。此外，进行预测也是如此。</p><p>编译步骤需要专门针对你的网络的训练设定一些参数，设定训练网络使用的优化算法 以及用于评价网络通过优化算法最小化结果的损失函数尤为重要。</p><p>下面的例子对定义好的用于回归问题的模型进行编译时，指定了随机梯度下降（sgd）优化算法，以及均方差（mse）算是函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;sgd&apos;, loss=&apos;mse&apos;)</span><br></pre></td></tr></table></figure><p>预测建模问题的种类也会限制可以使用的损失函数类型。</p><p>例如，下面是几种不同的预测建模类型对应的标准损失函数：</p><ul><li><strong>回归问题</strong>：均方差误差 “_mse_”。</li><li><strong>二分类问题</strong>：对数损失（也称为交叉熵）“_binary_crossentropy_”。</li><li><strong>多分类问题</strong>：多类对数损失 “_categorical_crossentropy_”。</li></ul><p>你可以查阅 <a href="http://keras.io/objectives/" target="_blank" rel="noopener">Keras 支持的损失函数</a>。</p><p>最常用的优化算法是随机梯度下降，不过 Keras 也支持<a href="http://keras.io/optimizers/" target="_blank" rel="noopener">其它的一些优化算法</a>。</p><p>以下几种优化算法可能是最常用的优化算法，因为它们的性能一般都很好：</p><ul><li><strong>随机梯度下降</strong> “_sgd_” 需要对学习率以及动量参数进行调参。</li><li><strong>ADAM</strong> “_adam_” 需要对学习率进行调参。</li><li><strong>RMSprop</strong> “_rmsprop_” 需要对学习率进行调参。</li></ul><p>最后，你还可以指定在训练模型过程中除了损失函数值之外的特定指标。一般对于分类问题来说，最常收集的指标就是准确率。需要收集的指标由设定数组中的名称决定。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;sgd&apos;, loss=&apos;mse&apos;, metrics=[&apos;accuracy&apos;])</span><br></pre></td></tr></table></figure><h2 id="第三步：训练网络"><a href="#第三步：训练网络" class="headerlink" title="第三步：训练网络"></a>第三步：训练网络</h2><p>在网络编译完成后，就能对它进行训练了。这个过程也可以看成是调整权重以拟合训练数据集。</p><p>训练网络需要制定训练数据，包括输入矩阵 X 以及相对应的输出 y。</p><p>在此步骤，将使用反向传播算法对网络进行训练，并使用在编译时制定的优化算法以及损失函数来进行优化。</p><p>反向传播算法需要指定训练的 Epoch（回合数、历元数）、对数据集的 exposure 数。</p><p>每个 epoch 都可以被划分成多组数据输入输出对，它们也称为 batch（批次大小）。batch 设定的数字将会定义在每个 epoch 中更新权重之前输入输出对的数量。这种做法也是一种优化效率的方式，可以确保不会同时加载过多的输入输出对到内存（显存）中。</p><p>以下是一个最简单的训练网络的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=&apos;sgd&apos;, loss=&apos;mse&apos;, metrics=[&apos;accuracy&apos;])</span><br></pre></td></tr></table></figure><p>在训练网络之后，会返回一个历史对象（History oject），其中包括了模型在训练中各项性能的摘要（包括每轮的损失函数值及在编译时制定收集的指标）。</p><h2 id="第四步：评价网络"><a href="#第四步：评价网络" class="headerlink" title="第四步：评价网络"></a>第四步：评价网络</h2><p>在网络训练完毕之后，就可以对其进行评价。</p><p>可以使用训练集的数据对网络进行评价，但这种做法得到的指标对于将网络进行预测并没有什么用。因为在训练时网络已经“看”到了这些数据。</p><p>因此我们可以使用之前没有“看”到的额外数据集来评估网络性能。这将提供网络在未来对没有见过的数据进行预测的性能时的估测。</p><p>评价模型将会评价所有测试集中的输入输出对的损失值，以及在模型编译时指定的其它指标（例如分类准确率）。本步骤将返回一组评价指标结果。</p><p>例如，一个在编译时使用准确率作为指标的模型可以在新数据集上进行评价，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss, accuracy = model.evaluate(X, y)</span><br></pre></td></tr></table></figure><h2 id="第五步：进行预测"><a href="#第五步：进行预测" class="headerlink" title="第五步：进行预测"></a>第五步：进行预测</h2><p>最后，如果我们对训练后的模型的性能满意的话，就能用它来对新的数据做预测了。</p><p>这一步非常简单，直接在模型上调用 predict() 函数，传入一组新的输入即可。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predictions = model.predict(x)</span><br></pre></td></tr></table></figure><p>预测值将以网络输出层定义的格式返回。</p><p>在回归问题中，这些由线性激活函数得到的预测值可能直接就符合问题需要的格式。</p><p>对于二分类问题，预测值可能是一组概率值，这些概率说明了数据分到第一类的可能性。可以通过四舍五入（K.round）将这些概率值转换成 0 与 1。</p><p>而对于多分类问题，得到的结果可能也是一组概率值（假设输出变量用的是 one-hot 编码方式），因此它还需要用 <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html" target="_blank" rel="noopener">argmax 函数</a>将这些概率数组转换为所需要的单一类输出。</p><h2 id="End-to-End-Worked-Example"><a href="#End-to-End-Worked-Example" class="headerlink" title="End-to-End Worked Example"></a>End-to-End Worked Example</h2><p>让我们用一个小例子将以上的所有内容结合起来。</p><p>我们将以 Pima Indians 糖尿病发病二分类问题为例。你可以在 <a href="https://archive.ics.uci.edu/ml/datasets/Pima+Indians+Diabetes" target="_blank" rel="noopener">UCI 机器学习仓库</a>中下载此数据集。</p><p>该问题有 8 个输入变量，需要输出 0 或 1 的分类值。</p><p>我们将构建一个包含 8 个输入的可见层、12 个神经元的隐藏层、rectifier 激活函数、1 个神经元的输出层、sigmoid 激活函数的多层感知机神经网络。</p><p>我们将对网络进行 100 epoch 次训练，batch 大小设为 10，使用 ADAM 优化算法以及对数损失函数。</p><p>在训练之后，我们使用训练数据对模型进行评价，然后使用训练数据对模型进行单独的预测。这么做是为了方便起见，一般来说我们都会使用额外的测试数据集进行评价，用新的数据进行预测。</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Keras 多层感知机神经网络样例</span><br><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Dense</span><br><span class="line">import numpy</span><br><span class="line"># 加载数据</span><br><span class="line">dataset = numpy.loadtxt(&quot;pima-indians-diabetes.csv&quot;, delimiter=&quot;,&quot;)</span><br><span class="line">X = dataset[:,0:8]</span><br><span class="line">Y = dataset[:,8]</span><br><span class="line"># 1. 定义网络</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(12, input_dim=8, activation=&apos;relu&apos;))</span><br><span class="line">model.add(Dense(1, activation=&apos;sigmoid&apos;))</span><br><span class="line"># 2. 编译网络</span><br><span class="line">model.compile(loss=&apos;binary_crossentropy&apos;, optimizer=&apos;adam&apos;, metrics=[&apos;accuracy&apos;])</span><br><span class="line"># 3. 训练网络</span><br><span class="line">history = model.fit(X, Y, epochs=100, batch_size=10)</span><br><span class="line"># 4. 评价网络</span><br><span class="line">loss, accuracy = model.evaluate(X, Y)</span><br><span class="line">print(&quot;\nLoss: %.2f, Accuracy: %.2f%%&quot; % (loss, accuracy*100))</span><br><span class="line"># 5. 进行预测</span><br><span class="line">probabilities = model.predict(X)</span><br><span class="line">predictions = [float(round(x)) for x in probabilities]</span><br><span class="line">accuracy = numpy.mean(predictions == Y)</span><br><span class="line">print(&quot;Prediction Accuracy: %.2f%%&quot; % (accuracy*100))</span><br></pre></td></tr></table></figure><p>运行样例，会得到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">768/768 [==============================] - 0s - loss: 0.5219 - acc: 0.7591</span><br><span class="line">Epoch 99/100</span><br><span class="line">768/768 [==============================] - 0s - loss: 0.5250 - acc: 0.7474</span><br><span class="line">Epoch 100/100</span><br><span class="line">768/768 [==============================] - 0s - loss: 0.5416 - acc: 0.7331</span><br><span class="line">32/768 [&gt;.............................] - ETA: 0s</span><br><span class="line">Loss: 0.51, Accuracy: 74.87%</span><br><span class="line">Prediction Accuracy: 74.87%</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们探索了使用 Keras 库进行深度学习时构建神经网络的 5 个步骤。</p><p>此外，你还学到了：</p><ul><li>如何在 Keras 中定义、编译、训练以及评价一个深度神经网络。</li><li>如何选择、使用默认的模型解决回归、分类预测问题。</li><li>如何使用 Keras 开发并运行你的第一个多层感知机网络。</li></ul><p>你对 Keras 的神经网络模型还有别的问题吗？或者你对本文还有什么建议吗？请在评论中留言，我会尽力回答。</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/59e43b5b6fb9a0452a3b5f4f" target="_blank" rel="noopener">https://juejin.im/post/59e43b5b6fb9a0452a3b5f4f</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/13/Javascript-中多样的-this/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/10/13/Javascript-中多样的-this/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Javascript 中多样的 this</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-10-13 15:14:22" itemprop="dateCreated datePublished" datetime="2017-10-13T15:14:22+08:00">2017-10-13</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/pasted-239.png" alt="upload successful"></p><p>本文将尽量解释清楚 JavaScript 中最基础的部分之一：执行上下文（execution context）。如果你经常使用 JS 框架，那理解 <code>this</code> 更是锦上添花。但如果你想更加认真地对待编程的话，理解上下文无疑是非常重要的。</p><p>我们可以像平常说话一样来使用 <code>this</code>。例如：我会说“我妈很不爽，这（this）太糟糕了”，而不会说“我妈很不爽，我妈很不爽这件事太糟糕了”。理解了 <code>this</code> 的上下文，才会理解我们为什么觉得很糟糕。</p><p>现在试着把这个例子与编程语言联系起来。在 Javascript 中，我们将 <code>this</code> 作为一个快捷方式，一个引用。它指向其所在上下文的某个对象或变量。</p><p>现在这么说可能会让人不解，不过很快你就能理解它们了。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a><strong>全局上下文</strong></h2><p>如果你和某人聊天，在刚开始对话、没有做介绍、没有任何上下文时，他对你说：“这（this）太糟糕了”，你会怎么想？大多数情况人们会试图将“这（this）”与周围的事物、最近发生的事情联系起来。</p><p>对于浏览器来说也是如此。成千上万的开发者在没有上下文的情况下使用了 <code>this</code>。我们可怜的浏览器只能将 <code>this</code> 指向一个全局对象（大多数情况下是 window）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 15;</span><br><span class="line">console.log(this.a);</span><br><span class="line">// =&gt; 15</span><br><span class="line">console.log(window.a);</span><br><span class="line">// =&gt; 15</span><br></pre></td></tr></table></figure><p>[以上代码需在浏览器中执行]</p><p>函数外部的任何地方都为全局上下文，<code>this</code> 始终指向全局上下文（window 对象）。</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>以真实世界来类比，函数上下文可以看成句子的上下文。“我妈很不爽，这（this）很不妙。”我们都知道这句话中的 <code>this</code> 是什么意思。其它句子中同样可以使用 <code>this</code>，但是由于其处于所处上下文不同因而意思全然不同。例如，“风暴来袭，这（this）太糟糕了。”</p><p>JavaScript 的上下文与对象有关，它取决于函数被执行时所在的对象。因此 <code>this</code> 会指向被执行函数所在的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line"></span><br><span class="line">function gx () &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fx () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fy () &#123;</span><br><span class="line">    return window.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(gx() === window);</span><br><span class="line">// =&gt; True</span><br><span class="line">console.log(fx());</span><br><span class="line">// =&gt; 20</span><br><span class="line">console.log(fy());</span><br><span class="line">// =&gt; 20</span><br></pre></td></tr></table></figure><p><code>this</code> 由函数被调用的方式决定。如你所见，上面的所有函数都是在全局上下文中被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.f());</span><br><span class="line">// =&gt; 37</span><br></pre></td></tr></table></figure><p>当一个函数是作为某个对象的方法被调用时，它的 <code>this</code> 指向的就是这个方法所在的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function fx () &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    method: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var x_obj = &#123;</span><br><span class="line">    y_obj: &#123;</span><br><span class="line">        method: function () &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(fx() === window);</span><br><span class="line">// =&gt; True — 我们仍处于全局上下文中。</span><br><span class="line">console.log(obj.method() === window);</span><br><span class="line">// =&gt; False — 函数作为一个对象的方法被调用。</span><br><span class="line">console.log(obj.method() === obj);</span><br><span class="line">// =&gt; True — 函数作为一个对象的方法被调用。</span><br><span class="line">console.log(x_obj.y_obj.method() === x_obj)</span><br><span class="line">// =&gt; False — 函数作为 y_obj 对象的方法被调用，因此 `this` 指向的是 y_obj 的上下文。</span><br></pre></td></tr></table></figure><p><strong>例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f2 () &#123;</span><br><span class="line">  &apos;use strict&apos;; </span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f2() === undefined);</span><br><span class="line">// =&gt; True</span><br></pre></td></tr></table></figure><p>在严格模式下，全局作用域的函数在全局作用域被调用时，<code>this</code> 为 <code>undefined</code>。</p><p><strong>例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function fx () &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    method: fx</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.method() === window);</span><br><span class="line">// =&gt; False</span><br><span class="line">console.log(obj.method() === obj);</span><br><span class="line">// =&gt; True</span><br></pre></td></tr></table></figure><p>与前面的例子一样，无论函数是如何被定义的，在这儿它都是作为一个对象方法被调用。</p><p><strong>例 6</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    method: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sec_obj = &#123;</span><br><span class="line">    method: obj.method</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(sec_obj.method() === obj);</span><br><span class="line">// =&gt; False</span><br><span class="line">console.log(sec_obj.method() === sec_obj);</span><br><span class="line">// =&gt; True</span><br></pre></td></tr></table></figure><p><code>this</code> 是动态的，它可以由一个对象指向另一个对象。</p><p><strong>例 7</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var shop = &#123;</span><br><span class="line">  fruit: &quot;Apple&quot;,</span><br><span class="line">  sellMe: function() &#123;</span><br><span class="line">    console.log(&quot;this &quot;, this.fruit);</span><br><span class="line">// =&gt; this Apple</span><br><span class="line">    console.log(&quot;shop &quot;, shop.fruit);</span><br><span class="line">// =&gt; shop Apple</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shop.sellMe()</span><br></pre></td></tr></table></figure><p>我们既能通过 <code>shop</code> 对象也能通过 <code>this</code> 来访问 <code>fruit</code> 属性。</p><p><strong>例 8</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Foo = function () &#123;</span><br><span class="line">    this.bar = &quot;baz&quot;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line"></span><br><span class="line">console.log(foo.bar); </span><br><span class="line">// =&gt; baz</span><br><span class="line">console.log(window.bar);</span><br><span class="line">// =&gt; undefined</span><br></pre></td></tr></table></figure><p>现在情况不同了。<code>new</code> 操作符创建了一个对象的实例。因此函数的上下文设置为这个被创建的对象实例。</p><h2 id="Call、apply、bind"><a href="#Call、apply、bind" class="headerlink" title="Call、apply、bind"></a>Call、apply、bind</h2><p>依旧以真实世界举例：“这（this）太糟糕了，因为我妈开始不爽了。”</p><p>这三个方法可以让我们在任何期许的上下文中执行函数。让我们举几个例子看看它们的用法：</p><p><strong>例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var bar = &quot;xo xo&quot;;</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">    bar: &quot;lorem ipsum&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test () &#123;</span><br><span class="line">    return this.bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test());</span><br><span class="line">// =&gt; xo xo — 我们在全局上下文中调用了 test 函数。</span><br><span class="line">console.log(test.call(foo)); </span><br><span class="line">// =&gt; lorem ipsum — 通过使用 `call`，我们在 foo 对象的上下文中调用了 test 函数。</span><br><span class="line">console.log(test.apply(foo));</span><br><span class="line">// =&gt; lorem ipsum — 通过使用 `apply`，我们在 foo 对象的上下文中调用了 test 函数。</span><br></pre></td></tr></table></figure><p>这两种方法都能让你在任何需要的上下文中执行函数。</p><p><code>apply</code> 可以让你在调用函数时将参数以不定长数组的形式传入，而 <code>call</code> 则需要你明确参数。</p><p><strong>例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line"></span><br><span class="line">function test () &#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bound = test.bind(document);</span><br><span class="line"></span><br><span class="line">console.log(bound()); </span><br><span class="line">// =&gt; undefined — 在 document 对象中没有 a 这个变量。</span><br><span class="line">console.log(bound.call(window)); </span><br><span class="line">// =&gt; undefined — 在 document 对象中没有 a 这个变量。在这个情况中，call 不能改变上下文。</span><br><span class="line"></span><br><span class="line">var sec_bound = test.bind(&#123;a: 15&#125;)</span><br><span class="line"></span><br><span class="line">console.log(sec_bound())</span><br><span class="line">// =&gt; 15 — 我们创建了一个新对象 &#123;a:15&#125;，并在此上下文中调用了 test 函数。</span><br></pre></td></tr></table></figure><p><code>bind</code> 方法返回的函数的下上文会被永久改变。<br>在使用 bind 之后，其上下文就固定了，无论你再使用 call、apply 或者 bind 都无法再改变其上下文。</p><h2 id="箭头函数（ES6）"><a href="#箭头函数（ES6）" class="headerlink" title="箭头函数（ES6）"></a><strong>箭头函数（ES6）</strong></h2><p>箭头函数是 ES6 中的一个新语法。它是一个非常方便的工具，不过你需要知道，在箭头函数中的上下文与普通函数中的上下文的定义是不同的。让我们举例看看。</p><p><strong>例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = (() =&gt; this);</span><br><span class="line">console.log(foo() === window); </span><br><span class="line">// =&gt; True</span><br></pre></td></tr></table></figure><p>当我们使用箭头函数时，<code>this</code> 会保留其封闭范围的上下文。</p><p><strong>例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;method: () =&gt; this&#125;;</span><br><span class="line"></span><br><span class="line">var sec_obj = &#123;</span><br><span class="line">  method: function() &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.method() === obj);</span><br><span class="line">// =&gt; False</span><br><span class="line">console.log(obj.method() === window);</span><br><span class="line">// =&gt; True</span><br><span class="line">console.log(sec_obj.method() === sec_obj);</span><br><span class="line">// =&gt; True</span><br></pre></td></tr></table></figure><p>请注意箭头函数与普通函数的不同点。在这个例子中使用箭头函数时，我们仍然处于 window 上下文中。<br>我们可以这么看：</p><blockquote><p><em>x =&gt; this.y equals function (x) { return this.y }.bind(this)</em></p></blockquote><p>可以将箭头函数看做其始终 <code>bind</code> 了函数外层上下文的 <code>this</code>，因此不能将它作为构造函数使用。下面的例子也说明了其不同之处。</p><p><strong>例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;global&quot;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line"> method: function () &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     a: &quot;inside method&quot;,</span><br><span class="line">     normal: function() &#123;</span><br><span class="line">       return this.a;</span><br><span class="line">     &#125;,</span><br><span class="line">     arrowFunction: () =&gt; this.a</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;,</span><br><span class="line"> a: &quot;inside obj&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj.method().normal());</span><br><span class="line">// =&gt; inside method</span><br><span class="line">console.log(obj.method().arrowFunction());</span><br><span class="line">// =&gt; inside obj</span><br></pre></td></tr></table></figure><p>当你了解了函数中动态（dynamic） <code>this</code> 与词法（lexical）<code>this</code> ，在定义新函数的时候请三思。如果函数将作为一个方法被调用，那么使用动态 <code>this</code>；如果它作为一个子程序（subroutine）被调用，则使用词法 <code>this</code>。</p><blockquote><p>译注：了解动态作用域与词法作用域可<a href="http://www.cnblogs.com/xiaohuochai/p/5700095.html" target="_blank" rel="noopener">阅读此文章</a></p></blockquote><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a><strong>相关阅读</strong></h2><ul><li><a href="http://www.joshuakehn.com/2011/10/20/Understanding-JavaScript-Context.html" target="_blank" rel="noopener">http://www.joshuakehn.com/2011/10/20/Understanding-JavaScript-Context.html</a></li><li><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" target="_blank" rel="noopener">http://ryanmorr.com/understanding-scope-and-context-in-javascript/</a></li><li><a href="https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c" target="_blank" rel="noopener">https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c</a></li><li><a href="http://2ality.com/2012/04/arrow-functions.html" target="_blank" rel="noopener">http://2ality.com/2012/04/arrow-functions.html</a></li></ul><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/59e066d551882578c3411908" target="_blank" rel="noopener">https://juejin.im/post/59e066d551882578c3411908</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/12/Slide-of-Information-Extraction-In-Illicit-Web-Domains-used-in-workshop/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/10/12/Slide-of-Information-Extraction-In-Illicit-Web-Domains-used-in-workshop/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Slide of 'Information Extraction In Illicit Web Domains' used in workshop.</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-10-12 22:06:00" itemprop="dateCreated datePublished" datetime="2017-10-12T22:06:00+08:00">2017-10-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><iframe src="https://lsvih.github.io/workshop/17-10-11/Information%20Extraction%20in%20Illicit%20Web%20Domains.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/10/11/Information-Extraction-in-Illicit-Web-Domains-论文笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/10/11/Information-Extraction-in-Illicit-Web-Domains-论文笔记/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Information Extraction in Illicit Web Domains 论文笔记</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-10-11 00:27:00" itemprop="dateCreated datePublished" datetime="2017-10-11T00:27:00+08:00">2017-10-11</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>Kejriwal M, Szekely P. Information Extraction in Illicit Web Domains[J]. 2017.</p></blockquote><h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><p>论文作者为南加大维特比学院的 Mayank Kejriwal 和 Pedro Szekely，发表于 WWW 2017。</p><h3 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h3><p>建立了稳定可靠的信息提取系统（Information Extraction System），用以从非法领域的网页中抽取有用的实体信息。将建立的模型应用于真实数据集得到的结果比 baseline（设定为 CRF）的 F-Score 高了 18%。</p><h3 id="论文提纲"><a href="#论文提纲" class="headerlink" title="论文提纲"></a>论文提纲</h3><ol><li>论文简介</li><li>描述了一些 IE system 的相关工作</li><li>详细描述了此文章所使用的模型</li><li>实验评估</li><li>总结工作</li></ol><h4 id="一、论文简介"><a href="#一、论文简介" class="headerlink" title="一、论文简介"></a>一、论文简介</h4><p>作者首先简介了构建领域知识图谱（knowledge graph）所需要做的工作：</p><ol><li><p>领域发现。来源可以为爬虫或领域本体库。</p><blockquote><p>爬虫部分引用了 S. Chakrabarti. Mining the Web: Discovering knowledge from hypertext data. Elsevier, 2002.<br>领域本体库部分引用了 A. Zouaq and R. Nkambou. A survey of domain ontology engineering: methods and tools. In Advances in intelligent tutoring systems, pages 103–119. Springer, 2010.</p></blockquote></li><li><p>有了数据源后，使用 IE system 抽取相关结构化数据。作者简述了基于统计学习的信息抽取方法：使用 CRF 序列标注、以及在数据量大的情况下使用深层神经网络,目的为抽取命名实体与关系（extraction of name entities and relationships）。</p><blockquote><p>神经网络部分引用 R. Collobert and J. Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In Proceedings of the 25th international conference on Machine learning, pages 160–167. ACM, 2008.</p></blockquote><p>当 IE system 在跨领域 Web 数据源（cross-domain Web source，以维基百科为例）和传统领域（以生物学为例）表现优秀时，在一些“动态领域”（dynamic domain）中表现一般。这些领域包括：news feed、自媒体、广告、在线市场以及一些非法领域（如人口贩卖 human trafficking）等。</p></li><li>非法领域的信息抽取之所以难做是因为在非法网站中常常会对信息进行混淆、非随机地对一些常用词进行错误拼写、OOV（out of vocabulary，非登录词）及生僻词高频出现、有时候还非随机使用Unicode 字符，且相关网页中正文分布稀疏、网页结构各异。与传统领域中（如聊天记录、Twitter 等）规律的信息不同，这些信息正文在非法网站中基本上是独一无二的。此论文仅讨论人口贩卖领域，不过在另一些在暗网中存在 Web 服务的非法领域（如武器贩卖、恐怖袭击、假货等）也可以适用。</li><li><p>接着举了两个典型例子说明上面的情况：<br>eg1. Hey gentleman im neWYOrk and i’m looking for generous…<br>eg2. AVAILABLE NOW! ?? - (4 two 4) six 5 two - 0 9 three 1 - 21</p></li><li><p>因此传统领域 IE system 的包装归纳学习系统（wrapper induction systems）不能在这些领域中正常工作，只能将数据给调查员和领域专家进行分析。<br>作者归纳：此论文分析了传统的 IE system 在动态的、非法的领域中的不适用性，因此提出了一种不依赖于传统信息提取系统、可在小样本 Web 数据集上正常运行的方法。</p></li><li>简介这种方法。此方法包含了两个步骤：<br>1) 第一步，使用召回率很高的识别器（用于识别地址、年龄等）为所有页面做候选标注（candidate annotations）。如下图所示</li></ol><p><img src="/images/pasted-224.png" alt="upload successful"></p><p>2) 第二步，使用一种无特征的监督学习算法，基于随机映射学习单词表示的意思。用此算法对上面的候选标注进行二分类，分为正确与不正确。</p><ol start="7"><li>简述贡献：创建了一种轻量级的、无特征的信息提取系统，可以适用于各种各样的非法领域。且这种方法很容易实现，无需大范围地调参，效果随数据集增大而增强，适用部署于流数据。且此方法在刚开始做领域发现的小数据集上也表现良好，在遇到超大 web 数据集时依然稳定。</li><li>简述 baseline，基于 CRF 的最新的 Stanford Named Entity Resolution system，包含关于人口贩卖的预训练数据。</li></ol><h4 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h4><p>Open IE</p><blockquote><p>N. Kushmerick. Wrapper induction for information extraction. PhD thesis, University of Washington, 1997.<br>M. Banko, M. J. Cafarella, S. Soderland,M. Broadhead, and O. Etzioni. Open information extraction from the web. In IJCAI, volume 7, pages 2670–2676, 2007.<br>ADRMine<br>B. Han, P. Cook, and T. Baldwin. Text-based twitter user geolocation prediction. Journal of Artificial Intelligence Research, 49:451–500, 2014.<br>A. Nikfarjam, A. Sarker, K. OaˆA ̆Z ́Connor, R. Ginn, and G. Gonzalez. Pharmacovigilance from social media: mining adverse drug reaction mentions using sequence labeling with word embedding cluster features. Journal of the American Medical Informatics Association, page ocu041, 2015.</p></blockquote><p>在此之前还没有工作对无特征、低监督的 web 非法领域信息提取进行研究。</p><h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>总体的架构如上图 Figure 1 所示。模型有两个输入端，一个是包含有关兴趣领域的 Web 页面集，一个是有着高召回率的识别器。在此论文中假定模型初始化时的数据集很小，接着会有很多的数据不断地加入到数据集中（即模仿流数据条件）。首先将给定一个初始的数据集，其中已经人工标注好了 10-100 条数据的属性（假定为城市、姓名、年龄），模型将根据此数据集在没有做特征工程的情况下学习出一个信息提取系统。</p><blockquote><p>此处数据条数有疑问</p></blockquote><p>需要注意的是需要分析的 Web 页面大多是多领域结合，因此在处理页面时不仅需要不断将新的页面加入数据集中，还要由初始数据集进行概念漂移（concept drift）以适应各种新的情况。</p><h5 id="1-预处理过程"><a href="#1-预处理过程" class="headerlink" title="1 预处理过程"></a>1 预处理过程</h5><p>爬取相关网页，使用 RTE（Readability Text Extractor）对 HTML 文本进行正文提取。对 RTE 进行调参，将其调至高召回率。由于 Web 网页的结构多样，因此正文中可能会存在许多无关内容（包括一些无用的数字及 Unicode 字符等等）。RTE 最终会返回一组字符串集，字符串集中包含以句子为单位的内容。</p><blockquote><p>RTE 给了网址：<a href="https://www.readability.com/developers/api" target="_blank" rel="noopener">https://www.readability.com/developers/api</a></p></blockquote><p>接下来使用 NLTK 对 RTE 返回内容的每个句子分别进行分词。</p><h5 id="2-词向量表示"><a href="#2-词向量表示" class="headerlink" title="2 词向量表示"></a>2 词向量表示</h5><p>接下来作者使用 CRF 序列标注模型对已标注数据进行学习（详细内容在后面）。但是由于数据集实在太少，CRF 的效果并不好。<br>为了避免 CRF 出现的状态，又为了避免工作量极大的页面标注，作者使用了非监督算法，以低维空间来表示页面中所有词的全集。在此使用了嵌入算法（embedding algorithms），作者在此提及了 Word2Vec 和 Bollegala 的算法和一种更简单的算法（random indexing）。</p><blockquote><p>Word2Vec 引用了 T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations of words and phrases and their compositionality. In Advances in neural information processing systems, pages 3111–3119, 2013.<br>Bollegala 算法引用了 D. Bollegala, T. Maehara, and K.-i. Kawarabayashi. Embedding semantic relations into word representations. arXiv preprint arXiv:1505.00161, 2015.<br>random indexing 引用了 M. Sahlgren. An introduction to random indexing. In Methods and applications of semantic indexing workshop at the 7th international conference on terminology and knowledge engineering, TKE, volume 5, 2005.<br>最终作者选用了“最简单”的 RI（random indexing）算法。此算法可以保证向量在表示时，即使是在低维空间中点与点间依然能够保持足够的距离。RI 算法最开始本来是为了增量降维（incremental dimensionality reduction）设计的。RI 算法定义如下：</p></blockquote><p>$d \in \mathbb{Z}^+$ -&gt; 向量维数<br>$r \in [0,1]$ -&gt; 定义为 +1 或 -1 的概率</p><p>对于一个词向量（这里应该叫做 token 向量，因为在这个情景中 nltk 并不能很好地进行正确分词）来说，随机选择 $[d <em>r]$ 个维度设定为 +1，随机选择 $[d </em>r]$ 个维度设定为 -1，其余 $d - 2 [d * r]$ 个维度设定为 0。</p><p>由于在此场景下数据均为噪音很多的流数据，因此只考虑较短的上下文范围。由此确定 RI 算法的滑动窗口大小。滑动窗口定义如下：</p><p>给定一组数量为 $|t|$ 的单位元素 $t$，以及一个窗口基准位置 $0 &lt; i &lt; |t|$，则可以定义一个滑动窗口 $(u, v)$。滑动窗口内的所有元素记为 $S$，将基准位置的特征词挖去：$S - t[i]$，得到滑动窗口全集。滑动窗口的位置坐标为 $[max(i-u,1),min(i+v,|t|)]$。</p><p><img src="/images/pasted-226.png" alt="upload successful"></p><p>上图为使用 RI 算法，设定滑动窗口大小设定为 (2,2) 时产生的 Token 向量。</p><p>作者对于原始的 RI 算法进行了一些改进，改动内容如下：</p><p>原始 RI 算法在求某特征词上下文向量时没有进行任何权重计算，直接对上下文非特征词的词向量进行了求和。也就是说，对于单词 w 来说，其表示向量进行了 $\vec{w}_{i+1} = \vec{w}_i + \vec{a}$ 计算。但是对于非法领域来说，在此情景中会出现大量独特的 token ，包括且不仅限于罕见单词、Unicode 符号、HTML tag、数字序列（如电话号码）等。这些 token 可能在文本全集中仅仅会出现一次或少数几次，因此它们产生的表示向量也会很少出现。作者为了避免这种情况的出现，预先定义了一些“高权重单位”（compound unit）</p><p>为了定义这种高权重单位的值，作者对于上下文中 token 可能出现的一些“罕见”情况进行了定义，定义如下：</p><table><thead><tr><th>Name</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>High-idf-units</td><td>低词频单元</td><td>单元内的单词词频低于设定值$\theta$（默认为 1%）</td></tr><tr><td>Pure-num-units</td><td>纯数字单元</td><td>只包含数字的单元</td></tr><tr><td>Alpha-num-units</td><td>字母-数字混合单元</td><td>至少包含 1 个数字与 1 个字母的单元</td></tr><tr><td>Pure-punct-units</td><td>纯符号单元</td><td>只包含标点符号的单元</td></tr><tr><td>Alpha-punct-units</td><td>字母-符号混合单元</td><td>至少包含 1 个字母与 1 个符号的单元</td></tr><tr><td>Nonascii-unicode-units</td><td>非 ASCII 字符单元</td><td>只包含非 ASCII 字符的单元</td></tr></tbody></table><p>以上 6 种“罕见”的单元就是“高权重单位”。</p><p>作者在这儿举了个例子：有个单词为“rare”它在文中出现的词频低于某个设定值（如 1%），它根据上表可以定义为 High-idf-units。</p><p>作者对 RI 算法根据上面的定义进行了一定修改：RI 算法在计算上下文向量时，仅使用上面 6 中高权重单元的表示向量进行计算。也就是说，每个 token 最终都可以根据上面 6 中高权重单元的向量的线性计算得到自己的独特向量 $\vec{w}_C$。</p><p>个人认为作者这样做丢失了很多可能会有用的信息，但是这样可以在本来整体信息就不多的非法领域网页 Web 正文中最大可能地提取高敏感信息。如果之后对这种方法进行改进的话，可以在这块找出更多高敏感信息的模式特征，或者使用改造过的 word2vec 等其它算法进行尝试。</p><h5 id="3-应用高召回率识别器"><a href="#3-应用高召回率识别器" class="headerlink" title="3 应用高召回率识别器"></a>3 应用高召回率识别器</h5><p>此处的“识别器”指的是对单一属性进行识别的函数。作者在此给出了相关定义：</p><p>对于某个属性 A，它的识别器 $R_A$ 为一个函数，该函数接受一组 token，该组数据记为 t。给定两个输入值 i 与 j（$j \geq i$），分别代表 t 中的两个位置。如果 t 的 t[i]:t[j] 子集为 A 属性的 instance 则返回 True，否则返回 False。</p><p>值得注意的是在上面的定义中，识别器并不能识别出 token 中所隐藏的 instance。在平常的 IE system 中所使用的识别器一般都是 recall 和 precision 都相对较高的。在现在这个情境中，识别器不再追求纯粹的准确率（评判标准为 recall 与 precision），而是尽量少丢失一些信息。因此作者选用了有着高 recall 的识别器对文本进行识别标注，在后面一步再去使用监督学习分类来改进这一步产生的候选标注的 precision。</p><p><img src="/images/pasted-227.png" alt="upload successful"></p><h5 id="4-使用监督学习根据上下文进行分类"><a href="#4-使用监督学习根据上下文进行分类" class="headerlink" title="4 使用监督学习根据上下文进行分类"></a>4 使用监督学习根据上下文进行分类</h5><p>在此之前，已经通过高 recall 的识别器将大多数有可能正确的有意义实体给识别出来，因此需要应用分类器对前一步骤得到的各个实体进行分类以提高最终结果精确度。</p><p>由识别器得到一系列的标注（标注可以为单独的 token，也可以是一组连续的 token），将各个标注所在的滑动窗口 (u,v)-context 取出其上下文，求其向量表示，上下文向量的无权重和（unweighted sum）来表示这些标注的上下文向量。</p><p>接着，对这些向量应用 l2 正则，使用监督学习分类器（如随机森林）对其进行分类。</p><h4 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a>四、实验评估</h4><h5 id="1-数据集与评价标准"><a href="#1-数据集与评价标准" class="headerlink" title="1 数据集与评价标准"></a>1 数据集与评价标准</h5><p><img src="/images/pasted-228.png" alt="upload successful"></p><p>表 2：数据集用量</p><p>作者描述，数据集来自于 DARPA MEMEX 项目。（网址：<a href="http://www.darpa.mil/program/memex）" target="_blank" rel="noopener">http://www.darpa.mil/program/memex）</a></p><p><img src="/images/pasted-229.png" alt="upload successful"></p><p>表 3：5 种类别的标准数据集</p><p>baseline 与本文的分类器都将对上表包含的 5 种类型的数据进行分类标注。</p><p>本文的标准数据集来自于数据集。对数据集应用高 recall 识别器，再对识别器得到的结果进行人工标注。</p><h5 id="2-系统描述"><a href="#2-系统描述" class="headerlink" title="2 系统描述"></a>2 系统描述</h5><p>根据上文所述，本文构建的 Information Extraction System 对于每种属性都由两个部分组成：高 recall 识别器与用于裁剪标记的分类器。作者实验室为此构建了 4 中高 recall 的识别器，分别为:</p><p>GeoNames-Cities<br>GeoNames-States<br>RegEx-Ages<br>Dictionary-Names</p><p>其中前两种识别器的数据集来自于<a href="http://www.geonames.org/，在此处引用了" target="_blank" rel="noopener">http://www.geonames.org/，在此处引用了</a> M. Wick and C. Boutreux. Geonames. GeoNames Geographical Database, 2011。</p><p>对于年龄识别，开发了 <a href="https://github.com/usc-isi-i2/dig-age-extractor" target="_blank" rel="noopener">https://github.com/usc-isi-i2/dig-age-extractor</a></p><blockquote><p>阅读代码发现原理特别简单，单纯的匹配数字</p></blockquote><p>对于姓名属性，作者收集了各种语言的姓名于数据集中，数据集地址：<br><a href="https://github.com/usc-isi-i2/dig-dictionaries/tree/master/person-names" target="_blank" rel="noopener">https://github.com/usc-isi-i2/dig-dictionaries/tree/master/person-names</a></p><h5 id="3-baseline"><a href="#3-baseline" class="headerlink" title="3 baseline"></a>3 baseline</h5><p>作者使用 Stanford Named Entity Recognition system(NER) 作为其 baseline。</p><blockquote><p>此处引用 J. R. Finkel, T. Grenager, and C. Manning. Incorporating non-local information into information extraction systems by gibbs sampling. In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 363–370. Association for Computational Linguistics, 2005.</p></blockquote><p>并使用为其使用了一个预训练数据集（脚标 12）。对于新数据集使用 baseline 模型进行重训练，随机采样 30% 与 70% 数据集作为训练集，其余数据作为测试集。baseline 的设置如下表所示：</p><p><img src="/images/pasted-230.png" alt="upload successful"><br>表 4：斯坦福 NER 在模型重训练时的参数设置</p><h5 id="4-相关参数"><a href="#4-相关参数" class="headerlink" title="4 相关参数"></a>4 相关参数</h5><p>词向量表示中，使用 100 维，低词频词的词频比例阈值设为 0.01。（这些参数作者说是根据之前的相关论文设定的，但是在这儿没有引用具体论文）。滑动窗口大小设置为 (2,2)，作者在此描述尝试使用了更大的滑动窗口但是没有很好的效果。</p><p>分类器采用随机森林分类，树数量为 10，变量重要性度量方式为 Gini 指数法，找出最佳的 20 个特征进行分类，使用 ANOVA（方差分析）作为评估函数。</p><p><strong>评估指标</strong>：准确率、回归率与 F1 指标</p><p><strong>实验环境</strong>：iMac，4GHz Intel core i7，32 GB RAM，Scikit-learn v0.18</p><h5 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5 实验结果"></a>5 实验结果</h5><p>直接贴论文中实验结果的指标表格：</p><p><img src="/images/pasted-231.png" alt="upload successful"></p><p>表 5：baseline 与此系统在训练 30% 数据时的 PRF 指标</p><p><img src="/images/pasted-232.png" alt="upload successful"></p><p>表 6：baseline 与此系统在训练 70% 数据时的 PRF 指标</p><p><img src="/images/pasted-233.png" alt="upload successful"></p><p>表 7：训练 30% 数据时，此系统在不同全集中的 F1 指标</p><p><img src="/images/pasted-234.png" alt="upload successful"></p><p>表 8：训练 70% 数据时，此系统在不同全集中的 F1 指标</p><p><img src="/images/pasted-235.png" alt="upload successful"></p><p>图 5：训练 30% 数据时，在姓名属性识别中，使用不同特征数量得到的 PRF 指标变化折线图</p><p><img src="/images/pasted-236.png" alt="upload successful"></p><p>表 9：系统识别城市名称的一些样例</p><h5 id="6-讨论"><a href="#6-讨论" class="headerlink" title="6 讨论"></a>6 讨论</h5><p>（作者”解释“了前面我关于为什么不使用 word2vec 的疑惑）作者表示，他也不清楚为啥不能使用 word2vec 之类更具适应性的算法来代替 Random Indexing 算法。不过表 7 与表 8 可以看到 Random Indexing 算法在不断加入更多网站的情况下表现仍然稳定。</p><p><img src="/images/pasted-237.png" alt="upload successful"></p><p>表 10：在一万数据集与全集中 Random Indexing 算法找到的相似语义样例</p><p>由表 10 可以看到 Random Indexing 算法在不同数据集大小下表现的鲁棒性，给出的相似语义词依然较为准确。</p><p><img src="/images/pasted-238.png" alt="upload successful"></p><p>图 6：城市名称上下文分类时的可视化图（不同的颜色表示在标准数据集中的标签）</p><p>使用 t-SNE 工具对数据进行可视化，得到上图。</p><blockquote><p>t-SNE 工具引用了 L. v. d. Maaten and G. Hinton. Visualizing data using t-sne. Journal of Machine Learning Research, 9(Nov):2579–2605, 2008.</p></blockquote><p>由图可见，分类器对城市名称正负例分类效果良好。另外可以观察到图中有许多点各自又组成了一些”子聚类“（sub-cluster），这些点来自于上下文比较相似的数据。</p><p>最后，作者表示他们在后来的工作中对一些不常见的属性（例如一些领域特定属性）进行了测试，仍然得到了相似的性能。因此这种方法在各种情况都适用。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作者提出了一种轻量、特征不可知的信息提取方式，适用于非法 Web 领域。这种方法基于初始本体集中构建的向量表示，与使用高 recall 的分类器结合，得到了良好的结果。实验结果表明这种方法相对于其 baseline（CRF）有明显的提升。论文中的各种代码都在 github 上进行了公开。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/27/Uber-机器学习平台-—-米开朗基罗/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/27/Uber-机器学习平台-—-米开朗基罗/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">Uber 机器学习平台 — 米开朗基罗</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-09-27 20:04:46" itemprop="dateCreated datePublished" datetime="2017-09-27T20:04:46+08:00">2017-09-27</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Uber 工程师们一直致力于开发各种新技术，以让客户得到有效、无缝的用户体验。现在，他们正在加大对人工智能、机器学习领域的投入来实现这个愿景。在 Uber，工程师们开发出了一个名为“米开朗基罗”（Michelangelo）的机器学习平台，它是一个内部的“MLaaS”（机器学习即服务）平台，用以降低机器学习开发的门槛，并能根据不同的商业需求对 AI 进行拓展与缩放，就有如客户使用 Uber 打车一样方便。</p><p>米开朗基罗平台可以让公司内部团队无缝构建、部署与运行 Uber 规模的机器学习解决方案。它旨在覆盖全部的端到端机器学习工作流，包括：数据管理、训练模型、评估模型、部署模型、进行预测、预测监控。此系统不仅支持传统的机器学习模型，还支持时间序列预测以及深度学习。</p><p>米开朗基罗在 Uber 投产约一年时间，已经成为了 Uber 工程师、数据科学家真正意义上的“平台”，现在有数十个团队在此平台上构建、部署模型。实际上，米开朗基罗平台现在部署于多个 Uber 数据中心并使用专用硬件，用于为公司内最高负载的在线服务提供预测功能。</p><p>本文将介绍米开朗基罗以及其产品用例，并简单通过这个强大的 MLaaS 系统介绍整个机器学习工作流。</p><h2 id="米开朗基罗背后的动机"><a href="#米开朗基罗背后的动机" class="headerlink" title="米开朗基罗背后的动机"></a>米开朗基罗背后的动机</h2><p>在米开朗基罗平台出现前，Uber 的工程师和数据科学家们在构建、部署一些公司需要，并且能根据实际操作进行规模拓展的机器学习模型时，遇到了很多挑战。那时他们试图使用各种各样的工具来创建预测模型（如 R 语言、<a href="http://scikit-learn.org/stable/" target="_blank" rel="noopener">scikit-learn</a>、自定义算法等），此时工程团队会构建一些一次性的系统以使用这些模型进行预测。因此，在 Uber 内能够在短时间内使用各种开源工具构建出框架的数据科学家与工程师少之又少，限制了机器学习在公司内的应用。</p><p>具体来说，那时没有建立一个可靠、统一、pipeline 可复用的系统用于创建、管理、训练、预测规模化数据。因此在那时，不会有人做出数据科学家的台式机跑不了的模型，也没有一个规范的结果存储方式，要将几个实验结果进行对比也是相当困难的事情。更重要的是，那时没有一种将模型部署到生产环境的确定方法。因此，大多数情况下都是相关的工程团队不得不为手中的项目开发定制的服务容器。这时，他们注意到了这些迹象符合由 Scully 等人记录的<a href="https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf" target="_blank" rel="noopener">机器学习的反模式</a>一文的描述。</p><p>米开朗基罗旨在将整个团队的工作流程和工具标准化，通过端对端系统让整个公司的用户都能轻松构建、运行大型机器学习系统。但是工程师们的目标不仅限于解决这些直观的问题，更是要创立一个能与业务共同发展的体系。</p><p>当工程师们于 2015 年年中开始构建米开朗基罗系统时，他们也开始解决一些规模化模型训练以及一些将模型部署于生产环境容器的问题。接着，他们专注于构建能够更好进行管理、共享特征 pipeline 的系统。而最近，他们的重心转移到了开发者生产效率 — 如何加速从想法到产品模型的实现以及接下来的快速迭代。</p><p>下一节将通过一个样例来介绍如何使用米开朗基罗构建、部署一个模型，用于解决 Uber 的某种特定问题。虽然下面重点讲的是 <a href="https://www.ubereats.com/" target="_blank" rel="noopener">UberEATS</a> 中的具体用例，但是这个平台也管理着公司里其他针对多种预测用例的类似模型。</p><h2 id="用例：UberEATS-送餐到家时间预估模型"><a href="#用例：UberEATS-送餐到家时间预估模型" class="headerlink" title="用例：UberEATS 送餐到家时间预估模型"></a>用例：UberEATS 送餐到家时间预估模型</h2><p>UberEATS 在米开朗基罗中有数个模型在运行，包括送餐到达时间预测、搜索排行、搜索自动完成、餐厅排行等。送餐到达时间预测模型能够预测准备膳食、送餐以及送餐过程中的各个阶段所需的时间。</p><p><img src="/images/pasted-214.png" alt="upload successful"></p><p>图 1：UberEATS app 提供了估测外卖送达时间的功能，此功能由基于米开朗基罗构建的机器学习模型驱动。</p><p>预测外卖的送达时间（ETD）并不是一件简单的事情。当 UberEATS 用户下单时，订单将被送到餐厅进行处理。餐厅需要确认订单，根据订单的复杂度以及餐厅的繁忙程度准备餐品，这一步自然要花费一些时间。在餐品快要准备完毕的时候，Uber 外卖员出发去取餐。接着，外卖员需要开车到达餐厅、找到停车场、进餐厅取餐、回到车里、开车前往客户家（这个步骤耗时取决于路线、交通等因素）、找到车位、走到客户家门口，最终完成交货。UberEATS 的目标就是预测这个复杂的多阶段过程的总时间，并在各个步骤重新计算 ETD。</p><p>在米开朗基罗平台上，UberEATS 数据科学家们使用了 GBDT（梯度提升决策树）回归模型来预测这种端到端的送达时间。此模型使用的特征包括请求信息（例如时间、送餐地点）、历史特征（例如餐厅在过去 7 天中的平均餐食准备时间）、以及近似实时特征（例如最近一小时的平均餐食准备时间）。此模型部署于 Uber 数据中心的米开朗基罗平台提供的容器中，通过 UberEATS 微服务提供网络调用。预测结果将在餐食准备及送达前展示给客户。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>米开朗基罗系统由一些开源系统和内置组件组成。主要使用的开源组件有 <a href="http://hadoop.apache.org/" target="_blank" rel="noopener">HDFS</a>、<a href="https://spark.apache.org/" target="_blank" rel="noopener">Spark</a>、<a href="http://samza.apache.org/" target="_blank" rel="noopener">Samza</a>、<a href="http://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>、<a href="https://spark.apache.org/mllib/" target="_blank" rel="noopener">MLLib</a>、<a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">XGBoost</a>、<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>。在条件允许的前提下，开发团队更倾向于使用一些成熟的开源系统，并会进行 fork、定制化，如果有需求的话也会对其进行贡献。如果找不到合适的开源解决方案，他们也会自己构建一些系统。</p><p>米开朗基罗系统建立与 Uber 的数据及计算基础设施之上，它们提供了一个“数据湖”，其中包含了 Uber 所有的事务和日志数据。由 Kafka 对 Uber 的所有服务日志进行采集汇总，使用 Cassandra 集群管理的 Samza 流计算引擎以及 Uber 内部服务进行计算与部署。</p><p>在下一节中将以 UberEATS 的 ETD 模型为例，简单介绍系统的各个层次，说明米开朗基罗的技术细节。</p><h2 id="机器学习工作流"><a href="#机器学习工作流" class="headerlink" title="机器学习工作流"></a>机器学习工作流</h2><p>在 Uber，大多数的机器学习用例（包括一些正在做的工作，例如分类、回归以及时间序列预测等）都有着一套同样的工作流程。这种工作流程可以与具体实现分离，因此很容易进行拓展以支持新的算法和框架（例如最新的深度学习框架）。它还适用于各种不同预测用例的部署模式（如在线部署与离线部署，在车辆中使用与在手机中使用）。</p><p>米开朗基罗专门设计提供可拓展、可靠、可重用、易用的自动化工具，用于解决下面 6 步工作流：</p><ol><li>管理数据</li><li>训练模型</li><li>评估模型</li><li>部署模型</li><li>预测结果</li><li>预测监控</li></ol><p>下面将详细介绍米开朗基罗的架构是如何促进工作流中的各个步骤的。</p><h2 id="管理数据"><a href="#管理数据" class="headerlink" title="管理数据"></a>管理数据</h2><p>找出良好的特征经常是是机器学习最难的部分，工程师们也发现整个机器学习解决方案中最费时费力的部分就是构建及管理数据管道。</p><p>因此，平台应提供一套标准工具以构建数据管道，生成特征，对数据集进行标记（用于训练及再训练），以及提供无标记特征数据用以预测，这些工具需要与公司的数据湖、数据中心以及公司的在线数据服务系统进行深度的整合。构建出来的数据管道必须具有可缩放性以及足够的性能，能够监控数据流以及数据质量，为各种在线/离线训练与预测都提供全面的支持。这些工具还应该能通过团队共享的方式生成特征，以减少重复工作并提高数据质量。此外，这些工具应当提供强有力的保护措施，鼓励用户去采用最好的方式使用工具（例如，保证在训练时和预测时都采用同一批次生成的数据）。</p><p>米开朗基罗的数据管理组件分为在线管道和离线管道。目前，离线管道主要用于为批量模型训练以及批量预测作业提供数据；在线管道主要为在线、低时延预测作业提供数据（以及之后会为在线学习系统提供支持）。</p><p>此外，工程师们还为数据管理层新加了一个特征存储系统，可以让各个团队共享、发现高质量的数据特征以解决他们的机器学习问题。工程师们发现，Uber 的许多模型都是用了类似或相同的特征，而在不同组织的团队以及团队里的不同项目中共享特征是一件很有价值的事情。</p><p><img src="/images/pasted-215.png" alt="upload successful"></p><p>图 2：数据预处理管道将数据存入特征库以及训练数据仓库中。</p><h3 id="离线部署"><a href="#离线部署" class="headerlink" title="离线部署"></a>离线部署</h3><p>Uber 的事务与日志数据会“流入”一个 HDFS 数据湖中，可以使用 Spark 和 Hive SQL 的计算作业轻松调用这些数据。平台提供了容器与计划任务两种方式运行常规作业，用于计算项目内部的私有特征或将其发布至特征存储库（见后文）与其他团队共享。当计划任务运行批量作业或通过别的方式触发批量作业时，作业将被整合传入数据质量监控工具，此工具能够快速回溯找出问题出在 pipeine 中的位置，判明是本地代码的问题还是上游代码的问题导致的数据错误。</p><h3 id="在线部署"><a href="#在线部署" class="headerlink" title="在线部署"></a>在线部署</h3><p>在线部署的模型将无法访问 HDFS 存储的数据，因此，一些需要在 Uber 生产服务的支撑数据库中读取的特征很难直接用于这种在线模型（例如，无法直接查询 UberEATS 的订单服务去计算某餐厅某特定时间段平均膳食准备时间）。因此，工程师们将在线模型需要的特征预计算并存储在 Cassandra 中，线上模型可以低延迟读取这些数据。</p><p>在线部署支持两种计算系统：批量预计算与近实时计算，详情如下：</p><ul><li><strong>批量预计算</strong>。这个系统会定期进行大批量计算，并将 HDFS 中的特征历史记录加载进 Cassandra 数据库中。这样做虽然很简单粗暴，但是如果需要的特征对实时性要求不高（比如允许隔几小时更新一次），那么效果还是很好的。这个系统还能保证在批处理管道中用于训练和服务的数据是同批次的。UberEATS 就采用了这个系统处理一部分特征，如“餐厅过去七天的膳食平均准备时间”。</li><li><strong>近实时计算</strong>。这个系统会将相关指标发布至 Kafka 系统，接着运行 Samza 流计算作业以低时延生成所有特征。接着这些特征将直接存入 Cassandra 数据库用于提供服务，并同时备份至 HDFS 用于之后的训练作业。和批量预计算系统一样，这样做同样能保证提供服务和进行训练的数据为同一批次。为了避免这个系统的冷启动，工程师们还专门为这个系统制作了一个工具，用于“回填”数据与基于历史记录运行批处理生成训练数据。UberEATS 就使用了这种近实时计算 pipeline 来得到如“餐厅过去一小时的膳食平均准备时间”之类的特征。</li></ul><h3 id="共享特征库"><a href="#共享特征库" class="headerlink" title="共享特征库"></a>共享特征库</h3><p>工程师们发现建立一个集中的特征库是很有用的，这样 Uber 的各个团队可以使用其他团队创建和管理的可靠的特征，且特征可以被分享。从大方向上看，它做到了以下两件事情：</p><ol><li>它可以让用户轻松地将自己构建的特征存入共享特征库中（只需要增加少许元数据，如添加者、描述、SLA 等），另外它也能让一些特定项目使用的特征以私有形式存储。</li><li>只要特征存入了特征库，那之后再用它就十分简单了。无论是在线模型还是离线模型，都只要简单地在模型配置中写上特征的名称就行了。系统将会从 HDFS 取出正确的数据，进行处理后返回相应的特征集既可以用于模型训练，也可以用于批量预测或者从 Cassandra 取值做在线预测。</li></ol><p>目前，Uber 的特征库中有大约 10000 个特征用于加速机器学习工程的构建，公司的各个团队还在不断向其中增加新的特征。特征库中的特征每天都会进行自动计算与更新。</p><p>未来，工程师们打算构建自动化系统，以进行特征库搜索并找出解决给定预测问题的最有用的特征。</p><p><strong>用于特征选择及转换的领域特定语言（DSL）。</strong></p><p>由数据 pipeline 生成的特征与客户端服务传来的特征经常不符合模型需要的数据格式，而且这些数据时常会缺失一些值，需要对其进行填充；有时候，模型可能只需要传入的特征的一个子集；还有的时候，将传入的时间戳转换为 小时/天 或者 天/周 会在模型中起到更好的效果；另外，还可能需要对特征值进行归一化（例如减去平均值再除以标准差）。</p><p>为了解决这些问题，工程师们为建模人员创造了一种 DSL（领域特定语言），用于选择、转换、组合那些用于训练或用于预测的特征。这种 DSL 为 Scala 的子集，是一种纯函数式语言，包含了一套常用的函数集，工程师们还为这种 DSL 增加了自定义函数的功能。这些函数能够从正确的地方取出特征（离线模型从数据 pipeline 取特征值，在线模型从客户请求取特征值，或是直接从特征库中取出特征）。</p><p>此外，DSL 表达式是模型配置的一部分，在训练时取特征的 DSL 与在与测试时用的 DSL 需要保持一致，以确保任何时候传入模型的特征集的一致性。</p><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>目前平台支持离线、大规模分布式训练，包括决策树、线性模型、逻辑模型、无监督模型（<a href="https://en.wikipedia.org/wiki/K-means_clustering" target="_blank" rel="noopener">k-means</a>）、时间序列模型以及深度神经网络。工程师们将定期根据用户的需求增加一些由 Uber <a href="https://www.uber.com/info/ailabs/" target="_blank" rel="noopener">AI 实验室</a>新开发的模型。此外，用户也可以自己提供模型类型，包括自定义训练、评价以及提供服务的代码。分布式模型训练系统可以规模化处理数十亿的样本数据，也可以处理一些小数据集进行快速迭代。</p><p>一个模型的配置包括模型类型、超参、数据源、特征 DSL，以及计算资源需求（需要的机器数量、内存用量、是否使用 GPU 等）。这些信息将用于配置运行在 <a href="https://yarnpkg.com/" target="_blank" rel="noopener">YARN</a> 或 <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Mesos</a> 集群上的训练作业。</p><p>在模型训练完毕之后，系统会将其计算得到的性能指标（例如 ROC 曲线和 PR 曲线）进行组合，得到一个模型评价报告。在训练结束时，系统会将原始配置、学习到的参数以及评价包括存回模型库，用于分析与部署。</p><p>除了训练单个模型之外，米开朗基罗系统还支持对分块模型等各种模型进行超参搜索。以分块模型为例，以分块模型为例，系统会根据用户配置自动对训练数据进行分块，对每个分块训练一个模型；在有需要的时候再将各个分块模型合并到父模型中（例如，先对每个城市数据进行训练，如果无法得到准确的市级模型时再将其合并为国家级模型）。</p><p>训练作业可以通过 Web UI 或者 API 进行配置与管理（通常使用 <a href="http://jupyter.org/" target="_blank" rel="noopener">Jupyter notebook</a>）。大多数团队都使用 API 以及流程管理工具来对他们的模型进行定期重训练。</p><p><img src="/images/pasted-216.png" alt="upload successful"></p><p>图 3：模型训练作业使用特征库与数据训练仓库中的数据集来训练模型，接着将模型存入模型库中。</p><h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><p>训练模型可以看成是一种寻找最佳特征、算法、超参以针对问题建立最佳模型的探索过程。在得到用例的理想模型前，训练数百种模型而一无所获也是常有的事。虽然这些失败的模型最终不能用于生产，但它们可以指导工程师们更好地进行模型配置，从而获得更好的性能。追踪这些训练过的模型（例如谁、何时训练了它们，用了什么数据集、什么超参等），对它们的性能进行评估、互相对比，可以为平台带来更多的价值与机会。不过要处理如此之多的模型，也是一个极大的挑战。</p><p>米开朗基罗平台中训练的每个模型都需要将以下信息作为版本对象存储在 Cassandra 的模型库中：</p><ul><li>谁训练的模型。</li><li>训练模型的开始时间与结束时间。</li><li>模型的全部配置（包括用了什么特征、超参的设置等）。</li><li>引用训练集和测试集。</li><li>描述每个特征的重要性。</li><li>模型准确性评价方法。</li><li>模型每个类型的标准评价表或图（例如 ROC 曲线图、PR 曲线图，以及二分类的混淆矩阵等）。</li><li>模型所有学习到的参数。</li><li>模型可视化摘要统计。</li></ul><p>用户可以通过 Web UI 或者使用 API 轻松获取这些数据，用以检查单个模型的详细情况或者对多个模型进行比较。</p><h3 id="模型准确率报告"><a href="#模型准确率报告" class="headerlink" title="模型准确率报告"></a>模型准确率报告</h3><p>回归模型的准确率报告会展示标准的准确率指标与图表；分类模型的准确率报告则会展示不同的分类集合，如图 4 图 5 所示：</p><p><img src="/images/pasted-217.png" alt="upload successful"></p><p>图 4：回归模型的报告展示了与回归相关的性能指标。</p><p><img src="/images/pasted-218.png" alt="upload successful"></p><p>图 5：二分类模型报告展示了分类相关的性能指标。</p><h3 id="可视化决策树"><a href="#可视化决策树" class="headerlink" title="可视化决策树"></a>可视化决策树</h3><p>决策树作为一种重要的模型类型，工程师们为其提供了可视化工具，以帮助建模者更好地理解模型的行为原理，并在建模者需要时帮助其进行调试。例如在一个决策树模型中，用户可以浏览每个树分支，看到其对于整体模型的重要程度、决策分割点、每个特征对于某个特定分支的权重，以及每个分支上的数据分布等变量。用户可以输入一个特征值，可视化组件将会遍历整个决策树的触发路径、每个树的预测、整个模型的预测，将数据展示成类似下图的样子：</p><p><img src="/images/pasted-219.png" alt="upload successful"></p><p>图 6：使用强大的树可视化组件查看树模型。</p><h3 id="特征报告"><a href="#特征报告" class="headerlink" title="特征报告"></a>特征报告</h3><p>米开朗基罗提供了特征报告，在报告中使用局部依赖图以及混合直方图展示了各个特征对于模型的重要性。选中两个特征可以让用户看到它们之间相互的局部依赖图表，如下所示：</p><p><img src="/images/pasted-220.png" alt="upload successful"></p><p>图 7：在特征报告中可以看到的特征、对模型的重要性以及不同特征间的相关性。</p><h3 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h3><p>米开朗基罗支持使用 UI 或 API 端对端管理模型的部署。一个模型可以有下面三种部署方式：</p><ol><li><strong>离线部署</strong>。模型将部署于离线容器中，使用 Spark 作业，根据需求或计划任务进行批量预测。</li><li><strong>在线部署</strong>。模型将部署于在线预测服务集群（集群通常为使用负载均衡部署的数百台机器），客户端可以通过网络 RPC 调用发起单个或批量的预测请求。</li><li><strong>部署为库</strong>。工程师们希望能在服务容器中运行模型。可以将其整合为一个库，也可以通过 Java API 进行调用（在下图中没有展示此类型，不过这种方式与在线部署比较类似）。</li></ol><p><img src="/images/pasted-221.png" alt="upload successful"></p><p>图 8：模型库中的模型部署于在线及离线容器中用于提供服务。</p><p>上面所有情况中，所需要的模型组件（包括元数据文件、模型参数文件以及编译好的 DSL）都将被打包为 ZIP 文件，使用 Uber 的标准代码部署架构将其复制到 Uber 数据中心的相关数据上。预测服务容器将会从磁盘自动加载新模型，并自动开始处理预测请求。</p><p>许多团队都自己写了自动化脚本，使用米开朗基罗 API 进行一般模型的定期再训练及部署。例如 UberEATS 的送餐时间预测模型就由数据科学家和工程师通过 Web UI 控制进行训练与部署。</p><h3 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h3><p>一旦模型部署于服务容器并加载成功，它就可以开始用于对数据管道传来的特征数据或用户端发来的数据进行预测。原始特征将通过编译好的 DSL 传递，如有需要也可以对 DSL 进行修改以改进原始特征，或者从特征存储库中拉取一些额外的特征。最终构造出的特征向量会传递给模型进行评分。如果模型为在线模型，预测结果将通过网络传回给客户端。如果模型为离线模型，预测结果将被写回 Hive，之后可以通过下游的批处理作业或者直接使用 SQL 查询传递给用户，如下所示：</p><p><img src="/images/pasted-222.png" alt="upload successful"></p><p>图 9：在线预测服务及离线预测服务使用一组特征向量生成预测结果。</p><h3 id="引用模型"><a href="#引用模型" class="headerlink" title="引用模型"></a>引用模型</h3><p>在米开朗基罗平台中可以同时向服务容器部署多个模型。这也使得从旧模型向新模型进行无痛迁移以及对模型进行 A/B 测试成为可能。在服务中，可以由模型的 UUID 以及一个在部署时可指定的 tag（或者别名）识别不同的模型。以一个在线模型为例，客户端服务会将特征向量与需要使用的模型 UUID 或者 tag 同时发送给服务容器；如果使用的是 tag，服务容器会使用此 tag 对应的最新部署的模型进行预测。如果使用的是多个模型，所有对应的模型都将对各批次的数据进行预测，并将 UUID 和 tag 与预测结果一同传回，方便客户端进行筛选过滤。</p><p>如果在部署一个新模型替换旧模型时用了相同的事物（例如用了一些同样的特征），用户可以为新模型设置和旧模型一样的 tag，这样容器就会立即开始使用新模型。这可以让用户只需要更新模型，而不用去修改他们的客户端代码。用户也可以通过设置 UUID 来部署新模型，再将客户端或中间件配置中旧模型的 UUID 换成新的，逐步将流量切换到新模型去。</p><p>如果需要对模型进行 A/B 测试，用户可以通过 UUID 或者 tag 轻松地部署竞争模型，再使用客户端服务中的 Uber 实验框架将部分流量导至各个模型，再对性能指标进行评估。</p><h3 id="规模缩放与时延"><a href="#规模缩放与时延" class="headerlink" title="规模缩放与时延"></a>规模缩放与时延</h3><p>由于机器学习模型是无状态的，且不需要共享任何东西，因此，无论是在线模式还是离线模式下对它们进行规模缩放都是一件轻而易举的事情。如果是在线模型，工程师可以简单地给预测服务集群增加机器，使用负载均衡器分摊负载。如果是离线预测，工程师可以给 Spark 设置更多的 executor，让 Spark 进行并行管理。</p><p>在线服务的延迟取决于模型的类型与复杂度以及是否使用从 Cassandra 特征库中取出的特征。在模型不需要从 Cassandra 取特征的情况下，P95 测试延迟小于 5 毫秒。在需要从 Cassandra 取特征时，P95 测试延迟仍小于 10 毫秒。目前用量最大的模型每秒能提供超过 250000 次预测。</p><h3 id="预测监控"><a href="#预测监控" class="headerlink" title="预测监控"></a>预测监控</h3><p>当模型训练完成并完成评价之后，使用的数据都将是历史数据。监控模型的预测情况，是确保其在未来正常工作的重要保障。工程师需要确保数据管道传入的是正确的数据，并且生产环境没有发生变化，这样模型才能够进行准确的预测。</p><p>为了解决这个问题，米开朗基罗系统会自动记录并将部分预测结果加入到数据 pipeline 的标签中去，有了这些信息，就能得到持续的、实时的模型精确度指标。在回归模型中，会将 R^2/<a href="https://en.wikipedia.org/wiki/Coefficient_of_determination" target="_blank" rel="noopener">决定系数</a>、<a href="https://www.kaggle.com/wiki/RootMeanSquaredLogarithmicError" target="_blank" rel="noopener">均方根对数误差</a>（RMSLE）、<a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" target="_blank" rel="noopener">均方根误差</a>（RMSE）以及<a href="https://en.wikipedia.org/wiki/Mean_absolute_error" target="_blank" rel="noopener">平均绝对值误差</a>发布至 Uber 的实时监控系统中，用户可以分析指标与时间关系的图标，并设置阈值告警：</p><p><img src="/images/pasted-223.png" alt="upload successful"></p><p>图 10：对预测结果进行采样，与观测结果进行比较得到模型准确指标。</p><h3 id="管理层、API、Web-UI"><a href="#管理层、API、Web-UI" class="headerlink" title="管理层、API、Web UI"></a>管理层、API、Web UI</h3><p>米开朗基罗系统的最后一个重要部分就是 API 层了，它也是整个系统的大脑。API 层包含一个管理应用，提供了 Web UI 以及网络 API 两种访问方式，并与 Uber 的监控、报警系统相结合。同时该层还包含了用于管理批量数据管道、训练作业、批量预测作业、模型批量部署以及在线容器的工作流系统。</p><p>米开朗基罗的用户可以通过 Web UI、REST API 以及监控、管理工具直接与这些组件进行交互。</p><h2 id="米开朗基罗平台之后的构建工作"><a href="#米开朗基罗平台之后的构建工作" class="headerlink" title="米开朗基罗平台之后的构建工作"></a>米开朗基罗平台之后的构建工作</h2><p>工程师们打算在接下来几个月继续扩展与加强现有的系统，以支持不断增长的用户和 Uber 的业务。随着米开朗基罗平台各个层次的不断成熟，他们计划开发更高层的工具与服务，以推动机器学习在公司内部的发展，更好地支持商业业务：</p><ul><li><strong>AutoML</strong>。这是将会成为一个自动搜寻与发现模型配置的系统（包括算法、特征集、超参值等），可以为给定问题找到表现最佳的模型。该系统还会自动构建数据管道，根据模型的需要生成特征与标签。目前工程师团队已经通过特征库、统一的离线在线数据管道、超参搜索特征解决了此系统的一大部分问题。AutoML 系统可以加快数据科学的早期工作，数据科学家们只需要指定一组标签和一个目标函数，接着就能高枕无忧地使用 Uber 的数据找到解决问题的最佳模型了。这个系统的最终目标就是构建更智能的工具，简化数据科学家们的工作，从而提高生产力。</li><li><strong>模型可视化</strong>。对于机器学习，尤其是深度学习，理解与调试模型现在变得越来越重要。虽然工程师们已经首先为树状模型提供了可视化工具，但是还需要做更多的工作，帮助数据科学家理解、debug、调整他们的模型，得到真正令人信服的结果。</li><li><strong>在线学习</strong>。Uber 的机器学习模型大多数直接受到 Uber 产品的实时影响。这也意味着这些模型需要能够在复杂、不断变化的真实世界中运行。为了保证模型在变化环境中的准确性，这些模型需要随着环境一同进化；现在，各个团队会在米开朗基罗平台上定期对模型进行重训练。一个完整的平台式解决方案应该让用户能够轻松地对模型进行升级、快速训练及评价，有着更精细的监控及报警系统。虽然这将是一个很大的工程，但是早前的研究结果表明，构建完成在线学习系统可能会带来巨大的收益。</li><li><strong>分布式深度学习</strong>。越来越多的 Uber 机器学习系统开始使用深度学习实现。定义与迭代深度学习模型的工作流与标准的工作流有着很大的区别，因此需要平台对其进行额外的支持。深度学习需要处理更大的数据集，需要不同的硬件支持（例如 GPU），因此它更需要分布式学习的支持，以及与更具弹性的资源管理堆栈进行紧密结合。</li></ul><p>如果你对挑战规模化机器学习有兴趣，欢迎申请<a href="https://www.uber.com/careers/list/?city=all&amp;country=all&amp;keywords=machine+learning+platform+team&amp;subteam=all&amp;team=all" target="_blank" rel="noopener">Uber 机器学习平台团队</a> ！</p><p>作者简介：Jeremy Hermann 是 Uber 机器学习平台团队的工程经理，Mike Del Balso 是 Uber 机器学习平台团队的产品经理。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59c8b4d56fb9a00a4843b2a6" target="_blank" rel="noopener">https://juejin.im/post/59c8b4d56fb9a00a4843b2a6</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/10/处理unbalanced-parenthesis情形，对正则字符串进行转义/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/10/处理unbalanced-parenthesis情形，对正则字符串进行转义/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">处理unbalanced parenthesis情形，对正则字符串进行转义</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-09-10 02:00:14" itemprop="dateCreated datePublished" datetime="2017-09-10T02:00:14+08:00">2017-09-10</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Back-End/" itemprop="url" rel="index"><span itemprop="name">Back End</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>使用 python re 处理数据时，程序提示“unbalanced parenthesis”，中文意思即为“不平衡的括号”。查看代码发现，在定义正则时使用了这样的做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(<span class="string">r"123"</span> + str + <span class="string">"123"</span>)</span><br></pre></td></tr></table></figure><p>然后排查发现数据中有几个例外的 str 含有括号，这些括号没有经过处理就直接传入了正则表达式中，变成了类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r&quot;123this is str)123&quot;</span><br></pre></td></tr></table></figure><p>的数据，造成错误。</p><p>翻阅 python re 文档发现，可以使用 re.escape 对字符串进行正则转义。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is str)</span><br></pre></td></tr></table></figure><p>可以转成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this\ is\ str\)</span><br></pre></td></tr></table></figure><p>这样传入正则就不会出现问题了。</p><blockquote><p>以后写正则如果还要传字符串进去一定要细心这类问题</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/07/低成本将你的网站切换为-HTTPS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/07/低成本将你的网站切换为-HTTPS/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">低成本将你的网站切换为 HTTPS</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-09-07 19:13:46" itemprop="dateCreated datePublished" datetime="2017-09-07T19:13:46+08:00">2017-09-07</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Google 的 Search Console 小组最近向所有站长发了一封 email，警告 Google Chrome 将从 10 月起，在包含表单但没有使用安全措施的网站中显示警告信息。</p><p>下图为我收件箱里的通知：</p><p><img src="/images/pasted-199.png" alt="upload successful"></p><p>如果你的网站还不支持 HTTPS，那这个通知就直接与你相关。即使你的网站并没有用到表单，也应当早日将网站迁移为 HTTPS。因为现在这项措施只不过是 Google“标识非安全网站”策略的第一步。他们在消息中明确表示：</p><blockquote><p>这个新的警告仅仅是将所有通过 HTTP 提供服务的页面标记为“不安全”的长期计划的一部分。</p></blockquote><p><img src="/images/pasted-200.png" alt="upload successful"></p><p>问题在于：安装 SSL 证书、将网站 URL 从 HTTP 转换为 HTTPS、以及将所有链接和图像链接等都换成 HTTPS 并不是一项简单的任务。谁会为了自己的个人网站去费时费钱呢？</p><p>我使用 GitHub Pages 免费托管了一系列的网站和项目，其中的一部分还使用了自定义域名。因此，我想看看我能否快速、低成本地将这些网站从 HTTP 迁移为 HTTPS。最后我找到了一种相对简单且低成本的方案，希望能够帮助到你们。下面让我们来探究一下这种方法吧。</p><h2 id="对-GitHub-Pages-强制启用-HTTPS"><a href="#对-GitHub-Pages-强制启用-HTTPS" class="headerlink" title="对 GitHub Pages 强制启用 HTTPS"></a>对 GitHub Pages 强制启用 HTTPS</h2><p>托管在 GitHub Pages 上的网站可以通过设置很方便地启用 HTTPS。进入项目设置页面，勾上“Enforce HTTPS”即可。</p><p><img src="/images/pasted-201.png" alt="upload successful"></p><h2 id="但我们仍然需要-SSL"><a href="#但我们仍然需要-SSL" class="headerlink" title="但我们仍然需要 SSL"></a>但我们仍然需要 SSL</h2><p>第一步十分的简单，但它并不符合 Google 对安全网站定义的要求。我们启用了 HTTPS 设置，但是没有为使用<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">自定义域名</a>的网站安装、提供 SSL 证书。直接使用 GitHub Pages 提供的网址的站点已经完全符合要求了，但是使用自定义域名的站点必须要进行一些额外的步骤，让其在域名的层面上使用安全证书。</p><p>还有个问题，SSL 证书虽然并不贵，但也需要花一笔钱，在你尽可能希望降低成本时可不想为此增加花费。所以得找个办法解决这个问题。</p><h2 id="我们可以通过-CDN-免费试用-SSL！"><a href="#我们可以通过-CDN-免费试用-SSL！" class="headerlink" title="我们可以通过 CDN 免费试用 SSL！"></a>我们可以通过 CDN 免费试用 SSL！</h2><p>在这儿就不得不提 Cloudflare 了。Cloudflare 是一个内容分发网络（CDN）提供商，同时它也提供分布式域名服务，这也意味着我们可以利用他们的网络来设置 HTTPS。使用这个服务真正的好处在于他们提供了免费的方案，让这一切成为可能。</p><p>另外，值得一提的是在 CSS-Tricks 论坛里也有<a href="https://css-tricks.com/?s=cdn" target="_blank" rel="noopener">许多帖子</a>描述了使用 CDN 的好处。虽然这篇文章中主要探讨的是安全性问题，但其实 CDN 除了能帮你使用 HTTPS 之外，还是降低服务器负载、<a href="https://css-tricks.com/adding-a-cdn-to-your-website/" target="_blank" rel="noopener">提升网站性能</a>的绝佳方式。</p><p>在下文中，我将简述我使用 Cloudflare 连接 Github Pages 的步骤。如果你还没有 Cloudflare 账号，你可以<a href="https://www.cloudflare.com/a/sign-up" target="_blank" rel="noopener">点击这儿注册账号</a>再跟着步骤操作。</p><h3 id="第一步：选择“-Add-Site”选项"><a href="#第一步：选择“-Add-Site”选项" class="headerlink" title="第一步：选择“+ Add Site”选项"></a>第一步：选择“+ Add Site”选项</h3><p>首先，我们需要告诉 Cloudflare 我们使用的域名。Cloudflare 将会扫描 DNS 记录，以验证域名是否存在，并检查域名的公开信息。</p><p><img src="/images/pasted-202.png" alt="upload successful"></p><h3 id="第二步：查看-DNS-记录"><a href="#第二步：查看-DNS-记录" class="headerlink" title="第二步：查看 DNS 记录"></a>第二步：查看 DNS 记录</h3><p>Cloudflare 扫描 DNS 记录后会将结果展示出来供你查看。如果 Cloudflare 认为这些信息符合要求，就会在“Status”列中显示一个橙色的云的图标。你需要检查这份报告，确认其中的信息与你在域名注册商中留的信息相符，如果没问题的话，点击“Continue”按钮继续。</p><p><img src="/images/pasted-203.png" alt="upload successful"></p><h3 id="第三步：获取免费方案"><a href="#第三步：获取免费方案" class="headerlink" title="第三步：获取免费方案"></a>第三步：获取免费方案</h3><p>Cloudflare 会询问你需要哪种级别的服务。瞧~你可以在这儿选择“免费”选项。</p><p><img src="/images/pasted-204.png" alt="upload successful"></p><h3 id="第四步：更新域名解析服务器（NS-服务器）"><a href="#第四步：更新域名解析服务器（NS-服务器）" class="headerlink" title="第四步：更新域名解析服务器（NS 服务器）"></a>第四步：更新域名解析服务器（NS 服务器）</h3><p>这一步中，Cloudflare 给我们提供了其服务器地址，我们要做的就是将这个地址粘贴到自己的域名注册商中的 DNS 设置里。</p><p><img src="/images/pasted-205.png" alt="upload successful"></p><p>这一步其实并不困难，但你可能会有些疑惑。你的域名注册商可能会提供这一步的操作指南。例如<a href="https://www.godaddy.com/help/set-nameservers-for-domains-hosted-and-registered-with-godaddy-12316" target="_blank" rel="noopener">点此查看 GoDaddy 的指南</a>，了解如何通过他们的服务更新域名解析服务器。</p><p>完成这一步之后，你的域名将会很快被映射到 Cloudflare 的服务器上，这些服务器将成为域名与 Github Pages 之间的中间层。不过，这一步需要耗费一些时间，Cloudflare 可能需要 24 小时来处理这个请求。</p><p><strong>如果你没有用主域名，而是用了子域名来使用 GitHub Pages</strong>，则需要额外进行一步操作。打开你的 GitHub Pages 设置页面，在 DNS 设置中添加一条 CNAME 记录，设置它指向 <code>&lt;your-username&gt;.github.io</code>，其中 <code>&lt;your-username&gt;</code> 是你的 Github 账号。此外，你需要在 GitHub 项目的根目录下添加一个文件名为 CNAME 的无后缀名文本文档，其内容为你的域名。</p><p>下面的屏幕截图为在 Cloudflare 设置中将 GitHub Pages 子域名添加为 CNAME 记录的例子：</p><p><img src="/images/pasted-206.png" alt="upload successful"></p><h3 id="第五步：在-Cloudflare-中启用-HTTPS"><a href="#第五步：在-Cloudflare-中启用-HTTPS" class="headerlink" title="第五步：在 Cloudflare 中启用 HTTPS"></a>第五步：在 Cloudflare 中启用 HTTPS</h3><p>现在，我们从技术上说已经为 GitHub Pages 启用了 HTTPS，但是我们还需要在 Cloudflare 中做同样的事。Cloudflare 把这个功能称为“Crypto”，不仅强制开启了 HTTPS，还提供了我们梦寐以求的 SSL 证书。现在先让我们为 HTTPS 启用 Crypto，之后的步骤中我们会获取到证书的。</p><p><img src="/images/pasted-207.png" alt="upload successful"></p><p>开启“Always use HTTPS”选项：</p><p><img src="/images/pasted-208.png" alt="upload successful"></p><p>此时，任何来自浏览器的 HTTP 请求都会被切换成更安全的 HTTPS。我们离“取悦” Google Chrome 又进了一步。</p><h3 id="第六步：使用-CDN"><a href="#第六步：使用-CDN" class="headerlink" title="第六步：使用 CDN"></a>第六步：使用 CDN</h3><p>我们现在正在用 CDN 来获取 SSL 证书，所以我们还可以利用它的性能优势来得到更多的好处。我们可以通过自动压缩文件、延长浏览器缓存过期时间来提升网站性能。</p><p>选择“Speed”选项，允许 Cloudflare 自动压缩网站资源：</p><p><img src="/images/pasted-209.png" alt="upload successful"></p><p>我们还可以通过设置浏览器缓存过期时间来最大化地提升性能：</p><p><img src="/images/pasted-210.png" alt="upload successful"></p><p>将过期时间设置为比默认选项更长，可以让浏览器在访问网站时不再需要每次都去请求那些没有变更过的网站资源。这将让访客在一个月内再次访问你的网站时节省额外的下载量。</p><h3 id="第七步：使用安全的外部资源"><a href="#第七步：使用安全的外部资源" class="headerlink" title="第七步：使用安全的外部资源"></a>第七步：使用安全的外部资源</h3><p>如果你的网站还使用了一些外部资源（我们很多人都这么做），那么还需要确保这些外部资源是安全的。例如，如果你使用了一个 Javascript 框架，但没有使用 HTTPS 源，那么 Google Chrome 将会认为其降低了我们网站的安全性，因此我们需要对其进行改进。</p><p>如果你使用的外部资源不提供 HTTPS 源，那么你可以考虑自己对其进行托管。反正我们现在已经有了 CDN，做托管服务的负载并不成问题。</p><h3 id="第八步：激活-SSL"><a href="#第八步：激活-SSL" class="headerlink" title="第八步：激活 SSL"></a>第八步：激活 SSL</h3><p>已经做到这一步啦！我们已经在 GitHub Pages 设置中开启了 HTTPS，现在还缺少自定义域名与 GitHub Pages 的连接证书。Cloudflare 提供了免费的 SSL 证书，我们可以在网站中使用它。</p><p>打开 Cloudflare 的 Crypto 设置页面，确认 SSL 证书处于激活状态：</p><p><img src="/images/pasted-211.png" alt="upload successful"></p><p>如果证书处于激活状态，在主菜单中切换到“Page Rules”页面，选择“Create Page Rule”选项：</p><p><img src="/images/pasted-212.png" alt="upload successful"></p><p>然后点击“Add a Setting”，选择“Always use HTTPS”选项：</p><p><img src="/images/pasted-213.png" alt="upload successful"></p><p>点击“Save and Deply”，恭喜你！现在，我们拥有了一个在 Google Chrome 眼中完全安全的网站，并且在迁移的过程中我们并不需要接触、修改很多代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Google 这样推进 HTTPS 意味着前端开发者们在开发自己的网站、公司网站、客户网站的时候需要优先考虑 SSL 支持。这一举措将会促使我们将站点向 HTTPS 迁移。而使用 CDN 可以让我们使用免费的 SSL 并提升网站性能，如此超值的事何乐而不为呢？</p><p>你记录过迁移到 HTTPS 的经历吗？在评论里留言你的迁移方法，让我们相互对比吧。</p><p>享受你的既安全又快速的网站吧！</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59b129365188253da63829ad" target="_blank" rel="noopener">https://juejin.im/post/59b129365188253da63829ad</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/04/在-Airbnb-使用机器学习预测房源的价格/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/04/在-Airbnb-使用机器学习预测房源的价格/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">在 Airbnb 使用机器学习预测房源的价格</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-09-04 15:16:04" itemprop="dateCreated datePublished" datetime="2017-09-04T15:16:04+08:00">2017-09-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/pasted-191.png" alt="upload successful"><br><strong>位于希腊爱琴海伊莫洛维里的一个 Airbnb 民宿的美好风景</strong></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>数据产品一直是 Airbnb 服务的重要组成部分，不过我们很早就意识到开发一款数据产品的成本是很高的。例如，个性化搜索排序可以让客户更容易发现中意的房屋，智能定价可以让房东设定更具竞争力的价格。然而，需要许多数据科学家和工程师付出许多时间和精力才能做出这些产品。</p><p>最近，Airbnb 机器学习的基础架构进行了改进，使得部署新的机器学习模型到生产环境中的成本降低了许多。例如，我们的 ML Infra 团队构建了一个通用功能库，这个库让用户可以在他们的模型中应用更多高质量、经过筛选、可复用的特征。数据科学家们也开始将一些自动化机器学习工具纳入他们的工作流中，以加快模型选择的速度以及提高性能标准。此外，ML Infra 还创建了一个新的框架，可以自动将 Jupyter notebook 转换成 Airflow pipeline 能接受的格式。</p><p>在本文中，我将介绍这些工具是如何协同运作来加快建模速度，从而降低开发 LTV 模型（预测 Airbnb 民宿价格）总体成本的。</p><h3 id="什么是-LTV？"><a href="#什么是-LTV？" class="headerlink" title="什么是 LTV？"></a>什么是 LTV？</h3><p>LTV 全称 Customer Lifetime Value，意为“客户终身价值”，是电子商务、市场公司中很流行的一种概念。它定义了在未来一个时间段内用户预期为公司带来的收益，通常以美元为单位。</p><p>在一些例如 Spotify 或者 Netflix 之类的电子商务公司里，LTV 通常用于制定产品定价（例如订阅费等）。而在 Airbnb 之类的市场公司里，知晓用户的 LTV 将有助于我们更有效地分配营销渠道的预算，更明确地根据关键字做在线营销报价，以及做更好的类目细分。</p><p>我们可以根据过去的数据来<a href="https://medium.com/swlh/diligence-at-social-capital-part-3-cohorts-and-revenue-ltv-ab65a07464e1" target="_blank" rel="noopener">计算历史值</a>，当然也可以进一步使用机器学习来预测新登记房屋的 LTV。</p><h3 id="LTV-模型的机器学习工作流"><a href="#LTV-模型的机器学习工作流" class="headerlink" title="LTV 模型的机器学习工作流"></a>LTV 模型的机器学习工作流</h3><p>数据科学家们通常比较熟悉和机器学习任务相关的东西，例如特征工程、原型制作、模型选择等。然而，要将一个模型原型投入生产环境中需要的是一系列数据工程技术，他们可能对此不太熟练。</p><p><img src="/images/pasted-192.png" alt="upload successful"></p><p>不过幸运的是，我们有相关的机器学习工具，可以将具体的生产部署工作流从机器学习模型的分析建立中分离出来。如果没有这些神奇的工具，我们就无法轻松地将模型应用于生产环境。下面将通过 4 个主题来分别介绍我们的工作流以及各自用到的工具：</p><ul><li><strong>特征工程</strong>：定义相关特征</li><li><strong>原型设计与训练</strong>：训练一个模型原型</li><li><strong>模型选择与验证</strong>：选择模型以及调参</li><li><strong>生产部署</strong>：将选择好的模型原型投入生产环境使用</li></ul><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><blockquote><p><strong>使用工具：Airbnb 内部特征库 — Zipline</strong></p></blockquote><p>任何监督学习项目的第一步都是去找到会影响到结果的相关特征，这一个过程被称为特征工程。例如在预测 LTV 时，特征可以是某个房源房屋在接下来 180 天内的可使用天数所占百分比，或者也可以是其与同市场其它房屋定价的差异。</p><p>在 Airbnb 中，要做特征工程一般得从头开始写 Hive 查询语句来创建特征。但是这个工作相当无聊，而且需要花费很多时间。因为它需要一些特定的领域知识和业务逻辑，也因此这些特征 pipeline 并不容易共享或复用。为了让这项工作更具可扩展性，我们开发了 <strong>Zipline</strong> —— 一个训练特征库。它可以提供不同粒度级别（例如房主、客户、房源房屋及市场级别）的特征。</p><p>这个内部工具“<strong>多源共享</strong>”的特性让数据科学家们可以在过去的项目中找出大量高质量、经过审查的特征。如果没有找到希望提取的特征，用户也可以写一个配置文件来创建他自己需要的特征：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">source: &#123;</span><br><span class="line">  type: hive</span><br><span class="line">  query:&quot;&quot;&quot;</span><br><span class="line">    SELECT</span><br><span class="line">        id_listing as listing</span><br><span class="line">      , dim_city as city</span><br><span class="line">      , dim_country as country</span><br><span class="line">      , dim_is_active as is_active</span><br><span class="line">      , CONCAT(ds, &apos; 23:59:59.999&apos;) as ts</span><br><span class="line">    FROM</span><br><span class="line">      core_data.dim_listings</span><br><span class="line">    WHERE</span><br><span class="line">      ds BETWEEN &apos;&#123;&#123; start_date &#125;&#125;&apos; AND &apos;&#123;&#123; end_date &#125;&#125;&apos;</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  dependencies: [core_data.dim_listings]</span><br><span class="line">  is_snapshot: true</span><br><span class="line">  start_date: 2010-01-01</span><br><span class="line">&#125;</span><br><span class="line">features: &#123;</span><br><span class="line">  city: &quot;City in which the listing is located.&quot;</span><br><span class="line">  country: &quot;Country in which the listing is located.&quot;</span><br><span class="line">  is_active: &quot;If the listing is active as of the date partition.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构建训练集时，Zipline 将会找出训练集所需要的特征，自动的按照 key 将特征组合在一起并填充数据。在构造房源 LTV 模型时，我们使用了一些 Zipline 中已经存在的特征，还自己写了一些特征。模型总共使用了 150 多个特征，其中包括：</p><ul><li><strong>位置</strong>：国家、市场、社区以及其它地理特征</li><li><strong>价格</strong>：过夜费、清洁费、与相似房源的价格差异</li><li><strong>可用性</strong>：可过夜的总天数，以及房主手动关闭夜间预订的占比百分数</li><li><strong>是否可预订</strong>：预订数量及过去 X 天内在夜间订房的数量</li><li><strong>质量</strong>：评价得分、评价数量、便利设施</li></ul><p><img src="/images/pasted-193.png" alt="upload successful"></p><p>实例数据集</p><p>在定义好特征以及输出变量之后，就可以根据我们的历史数据来训练模型了。</p><h3 id="原型设计与训练"><a href="#原型设计与训练" class="headerlink" title="原型设计与训练"></a>原型设计与训练</h3><blockquote><p><strong>使用工具：Python 机器学习库</strong> — <a href="http://scikit-learn.org/stable/" target="_blank" rel="noopener"><strong>scikit-learn</strong></a></p></blockquote><p>以前面的训练集为例，我们在做训练前先要对数据进行一些预处理：</p><ul><li><strong>数据插补</strong>：我们需要检查是否有数据缺失，以及它是否为随机出现的缺失。如果不是随机现象，我们需要弄清楚其根本原因；如果是随机缺失，我们需要填充空缺数据。</li><li><strong>对分类进行编码</strong>：通常来说我们不能在模型里直接使用原始的分类，因为模型并不能去拟合字符串。当分类数量比较少时，我们可以考虑使用 <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank" rel="noopener">one-hot encoding</a> 进行编码。如果分类数量比较多，我们就会考虑使用 <a href="https://www.kaggle.com/general/16927" target="_blank" rel="noopener">ordinal encoding</a>, 按照分类的频率计数进行编码。</li></ul><p>在这一步中，我们还不知道最有效的一组特征是什么，因此编写可快速迭代的代码是非常重要的。如 <a href="http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" target="_blank" rel="noopener">Scikit-Learn</a>、<a href="https://spark.apache.org/docs/latest/ml-pipeline.html" target="_blank" rel="noopener">Spark</a> 等开源工具的 pipeline 结构对于原型构建来说是非常方便的工具。Pipeline 可以让数据科学家们设计蓝图，指定如何转换特征、训练哪一个模型。更具体来说，可以看下面我们 LTV 模型的 pipeline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">transforms = []</span><br><span class="line"></span><br><span class="line">transforms.append(</span><br><span class="line">    (&apos;select_binary&apos;, ColumnSelector(features=binary))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">transforms.append(</span><br><span class="line">    (&apos;numeric&apos;, ExtendedPipeline([</span><br><span class="line">        (&apos;select&apos;, ColumnSelector(features=numeric)),</span><br><span class="line">        (&apos;impute&apos;, Imputer(missing_values=&apos;NaN&apos;, strategy=&apos;mean&apos;, axis=0)),</span><br><span class="line">    ]))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for field in categorical:</span><br><span class="line">    transforms.append(</span><br><span class="line">        (field, ExtendedPipeline([</span><br><span class="line">            (&apos;select&apos;, ColumnSelector(features=[field])),</span><br><span class="line">            (&apos;encode&apos;, OrdinalEncoder(min_support=10))</span><br><span class="line">            ])</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">features = FeatureUnion(transforms)</span><br></pre></td></tr></table></figure><p>在高层设计时，我们使用 pipeline 来根据特征类型（如二进制特征、分类特征、数值特征等）来指定不同特征中数据的转换方式。最后使用 <a href="http://scikit-learn.org/stable/modules/generated/sklearn.pipeline.FeatureUnion.html" target="_blank" rel="noopener">FeatureUnion</a> 简单将特征列组合起来，形成最终的训练集。</p><p>使用 pipeline 开发原型的优势在于，它可以使用 <a href="http://scikit-learn.org/stable/data_transforms.html" target="_blank" rel="noopener">data transforms</a> 来避免繁琐的数据转换。总的来说，这些转换是为了确保数据在训练和评估时保持一致，以避免将原型部署到生产环境时出现的数据不一致。</p><p>另外，pipeline 还可以将数据转换过程和训练模型过程分开。虽然上面代码中没有，但数据科学家可以在最后一步指定一种 <a href="http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="noopener">estimator（估值器）</a>来训练模型。通过尝试使用不同的估值器，数据科学家可以为模型选出一个表现最佳的估值器，减少模型的样本误差。</p><h3 id="模型选择与验证"><a href="#模型选择与验证" class="headerlink" title="模型选择与验证"></a>模型选择与验证</h3><blockquote><p><strong>使用工具：各种</strong><a href="https://medium.com/airbnb-engineering/automated-machine-learning-a-paradigm-shift-that-accelerates-data-scientist-productivity-airbnb-f1f8a10d61f8" target="_blank" rel="noopener"><strong>自动机器学习</strong></a><strong>框架</strong></p></blockquote><p>如上一节所述，我们需要确定候选模型中的哪个最适合投入生产。为了做这个决策，我们需要在模型的可解释性与复杂度中进行权衡。例如，稀疏线性模型的解释性很好，但它的复杂度太低了，不能很好地运作。一个足够复杂的树模型可以拟合各种非线性模式，但是它的解释性很差。这种情况也被称为<a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener"><strong>偏差（Bias）和方差（Variance）的权衡</strong></a>。</p><p><img src="/images/pasted-194.png" alt="upload successful"></p><p>上图引用自 James、Witten、Hastie、Tibshirani 所著《R 语言统计学习》</p><p>在保险、信用审查等应用中，需要对模型进行解释。因为对模型来说避免无意排除一些正确客户是很重要的事。不过在图像分类等应用中，模型的高性能比可解释更重要。</p><p>由于模型的选择相当耗时，我们选择采用各种<a href="https://medium.com/airbnb-engineering/automated-machine-learning-a-paradigm-shift-that-accelerates-data-scientist-productivity-airbnb-f1f8a10d61f8" target="_blank" rel="noopener">自动机器学习</a>工具来加速这个步骤。通过探索大量的模型，我们最终会找到表现最好的模型。例如，我们发现 <a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">XGBoost</a> (XGBoost) 明显比其他基准模型（比如 mean response 模型、岭回归模型、单一决策树）的表现要好。</p><p><img src="/images/pasted-195.png" alt="upload successful"></p><p>上图：我们通过比较 RMSE 可以选择出表现更好的模型</p><p>鉴于我们的最初目标是预测房源价格，因此我们很舒服地在最终的生产环境中使用 XGBoost 模型，比起可解释性它更注重于模型的弹性。</p><h3 id="生产部署"><a href="#生产部署" class="headerlink" title="生产部署"></a>生产部署</h3><blockquote><p><strong>使用工具：Airbnb 自己写的 notebook 转换框架 — ML Automator</strong></p></blockquote><p>如开始所说，构建生产环境工作流和在笔记本上构建一个原型是完全不同的。例如，我们如何进行定期的重训练？我们如何有效地评估大量的实例？我们如何建立一个 pipeline 以随时监视模型性能？</p><p>在 Airbnb，我们自己开发了一个名为 <strong>ML Automator</strong> 的框架，它可以自动将 Jupyter notebook 转换为 <a href="https://medium.com/airbnb-engineering/airflow-a-workflow-management-platform-46318b977fd8" target="_blank" rel="noopener">Airflow</a> 机器学习 pipeline。该框架专为熟悉使用 Python 开发原型，但缺乏将模型投入生产环境经验的数据科学家准备。</p><p><img src="/images/pasted-196.png" alt="upload successful"></p><p>ML Automator 框架概述（照片来源：Aaron Keys）</p><ul><li>首先，框架要求用户在 notebook 中指定模型的配置。该配置将告诉框架如何定位训练数据表，为训练分配多少计算资源，以及如何计算模型评价分数。</li><li>另外，数据科学家需要自己写特定的 <strong>fit</strong> 与 <strong>transform</strong> 函数。fit 函数指定如何进行训练，而 transform 函数将被 Python UDF 封装，进行分布式计算（如果有需要）。</li></ul><p>下面的代码片段展示了我们 LTV 模型中的 <strong>fit</strong> 与 <strong>transform</strong> 函数。fit 函数告诉框架需要训练 XGBoost 模型，同时转换器将根据我们之前定义的 pipeline 转换数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(X_train, y_train)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> multiprocessing</span><br><span class="line">    <span class="keyword">from</span> ml_helpers.sklearn_extensions <span class="keyword">import</span> DenseMatrixConverter</span><br><span class="line">    <span class="keyword">from</span> ml_helpers.data <span class="keyword">import</span> split_records</span><br><span class="line">    <span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBRegressor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> model</span><br><span class="line"></span><br><span class="line">    model = &#123;&#125;</span><br><span class="line">    n_subset = N_EXAMPLES</span><br><span class="line">    X_subset = &#123;k: v[:n_subset] <span class="keyword">for</span> k, v <span class="keyword">in</span> X_train.iteritems()&#125;</span><br><span class="line">    model[<span class="string">'transformations'</span>] = ExtendedPipeline([</span><br><span class="line">                (<span class="string">'features'</span>, features),</span><br><span class="line">                (<span class="string">'densify'</span>, DenseMatrixConverter()),</span><br><span class="line">            ]).fit(X_subset)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并行使用转换器</span></span><br><span class="line">    Xt = model[<span class="string">'transformations'</span>].transform_parallel(X_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并行进行模型拟合</span></span><br><span class="line">    model[<span class="string">'regressor'</span>] = XGBRegressor().fit(Xt, y_train)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="comment"># return dictionary</span></span><br><span class="line">    <span class="keyword">global</span> model</span><br><span class="line">    Xt = model[<span class="string">'transformations'</span>].transform(X)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'score'</span>: model[<span class="string">'regressor'</span>].predict(Xt)&#125;</span><br></pre></td></tr></table></figure><p>一旦 notebook 完成，ML Automator 将会把训练好的模型包装在 <a href="http://www.florianwilhelm.info/2016/10/python_udf_in_hive/" target="_blank" rel="noopener">Python UDF</a> 中，并创建一个如下图所示的 <a href="https://airflow.incubator.apache.org/" target="_blank" rel="noopener">Airflow</a> pipeline。数据序列化、定期重训练、分布式评价等数据工程任务都将被载入到日常批处理作业中。因此，这个框架显著降低了数据科学家将模型投入生产的成本，就像有一位数据工程师在与科学家一起工作一样！</p><p><img src="/images/pasted-197.png" alt="upload successful"></p><p>我们 LTV 模型在 Airflow DAG 中的图形界面，运行于生产环境中</p><p><strong>Note：除了模型生产化之外，还有一些其它项目（例如跟踪模型随着时间推移的性能、使用弹性计算环境建模等）我们没有在这篇文章中进行介绍。这些都是正在进行开发的热门领域。</strong></p><h3 id="经验与展望"><a href="#经验与展望" class="headerlink" title="经验与展望"></a>经验与展望</h3><p>过去的几个月中，我们的数据科学家们与 ML Infra 密切合作，产生了许多很好的模式和想法。我们相信这些工具将会为 Airbnb 开发机器学习模型开辟新的范例。</p><ul><li><strong>首先，显著地降低了模型的开发成本</strong>：通过组合各种不同的独立工具的优点（Zipline 用于特征工程、Pipeline 用于模型原型设计、AutoML 用于模型选择与验证，以及最后的 ML Automator 用于模型生产化），我们大大减短了模型的开发周期。</li><li><strong>其次，notebook 的设计降低了入门门槛</strong>：还不熟悉框架的数据科学家可以立即得到大量的真实用例。在生产环境中，可以确保 notebook 是正确、自解释、最新的。这种设计模式受到了新用户的好评。</li><li><strong>因此，团队将更愿意关注机器学习产品的 idea</strong>：在本文撰写时，我们还有其它几支团队在采用类似的方法探索机器学习产品的 idea：为检查房源队列进行排序、预测房源是否会增加合伙人、自动标注低质量房源等等。</li></ul><p>我们对这个框架和它带来的新范式的未来感到无比的兴奋。通过缩小原型与生产环境间的差距，我们可以让数据科学家和数据工程师更多去追求端到端的机器学习项目，让我们的产品做得更好。</p><hr><p><strong>想使用或者一起开发这些机器学习工具吗？我们正在寻找 </strong><a href="https://www.airbnb.com/careers/departments/data-science-analytics" target="_blank" rel="noopener"><strong>能干的你加入我们的数据科学与分析团队</strong></a><strong>！</strong></p><hr><p><strong>特别感谢参与这项工作的Data Science＆ML Infra团队的成员：</strong><a href="https://www.linkedin.com/in/aaronkeys/" target="_blank" rel="noopener"><em>Aaron Keys</em></a><em>, </em><a href="https://www.linkedin.com/in/brad-hunter-497621a/" target="_blank" rel="noopener"><em>Brad Hunter</em></a><em>, </em><a href="https://www.linkedin.com/in/hamelhusain/" target="_blank" rel="noopener"><em>Hamel Husain</em></a><em>, </em><a href="https://www.linkedin.com/in/jiaying-shi-a2142733/" target="_blank" rel="noopener"><em>Jiaying Shi</em></a><em>, </em><a href="https://www.linkedin.com/in/krishnaputtaswamy/" target="_blank" rel="noopener"><em>Krishna Puttaswamy</em></a><em>, </em><a href="https://www.linkedin.com/in/michael-m-a37b1932/" target="_blank" rel="noopener"><em>Michael Musson</em></a><em>, </em><a href="https://www.linkedin.com/in/nicholashandel/" target="_blank" rel="noopener"><em>Nick Handel</em></a><em>, </em><a href="https://www.linkedin.com/in/vzanoyan/" target="_blank" rel="noopener"><em>Varant Zanoyan</em></a><em>, </em><a href="https://www.linkedin.com/in/vquoss/" target="_blank" rel="noopener"><em>Vaughn Quoss</em></a><em> 等人。另外感谢 </em><a href="https://www.linkedin.com/in/thegarytang/" target="_blank" rel="noopener"><em>Gary Tang</em></a><em>, </em><a href="https://medium.com/@jasonkgoodman" target="_blank" rel="noopener"><em>Jason Goodman</em></a><em>, </em><a href="https://twitter.com/jtfeng" target="_blank" rel="noopener"><em>Jeff Feng</em></a><em>, </em><a href="https://medium.com/@lpettingill" target="_blank" rel="noopener"><em>Lindsay Pettingill</em></a><em> 给本文提的意见。</em></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59acfc336fb9a0249471e47d" target="_blank" rel="noopener">https://juejin.im/post/59acfc336fb9a0249471e47d</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/09/02/在-Go-语言中增强-Cookie-的安全性/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/02/在-Go-语言中增强-Cookie-的安全性/" class="post-title-link" itemprop="https://lsvih.com/page/4/index.html">在 Go 语言中增强 Cookie 的安全性</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-09-02 17:32:00" itemprop="dateCreated datePublished" datetime="2017-09-02T17:32:00+08:00">2017-09-02</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在我开始学习 Go 语言时已经有一些 Web 开发经验了，但是并没有直接操作 Cookie 的经验。我之前做过 Rails 开发，当我不得不需要在 Rails 中读写 Cookie 时，并不需要自己去实现各种安全措施。</p><p>瞧瞧，Rails 默认就自己完成了大多数的事情。你不需要设置任何 CSRF 策略，也无需特别去加密你的 Cookie。在新版的 Rails 中，这些事情都是它默认帮你完成的。</p><p>而使用 Go 语言开发则完全不同。在 Golang 的默认设置中，这些事都不会帮你完成。因此，当你想要开始使用 Cookie 时，了解各种安全措施、为什么要使用这些措施、以及如何将这些安全措施集成到你的应用中是非常重要的事。希望本文能帮助你做到这一点。</p><p><strong>注意：我并不想引起关于 Go 与 Reils 两者哪种更好的论战。两者各有优点，但在本文中我希望能着重讨论 Cookie 的防护，而不是去争论 Rails 和 Go 哪个好。</strong></p><h2 id="什么是-Cookie？"><a href="#什么是-Cookie？" class="headerlink" title="什么是 Cookie？"></a>什么是 Cookie？</h2><p>在进入 Cookie 防护相关的内容前，我们必须要理解 Cookie 究竟是什么。从本质上说，Cookie 就是存储在终端用户计算机中的键值对。因此，使用 Go 创建一个 Cookie 需要做的事就是创建一个包含键名、键值的 <a href="https://golang.org/pkg/net/http/#Cookie" target="_blank" rel="noopener">http.Cookie</a> 类型字段，然后调用 <a href="https://golang.org/pkg/net/http/#SetCookie" target="_blank" rel="noopener">http.SetCookie</a> 函数通知终端用户的浏览器设置该 Cookie。</p><p>写成代码之后，它看起来类似于这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func someHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">  c := http.Cookie&#123;</span><br><span class="line">    Name: &quot;theme&quot;,</span><br><span class="line">    Value: &quot;dark&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">  http.SetCookie(w, &amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>http.SetCookie</code> 函数并不会返回错误，但它可能会静默地移除无效的 Cookie，因此使用它并不是什么美好的经历。但它既然这么设计了，就请你在使用这个函数的时候一定要牢记它的特性。</p></blockquote><p>虽然这好像是在代码中“设定”了一个 Cookie，但其实我们只是在我们返回 Response 时发送了一个 <code>&quot;Set-Cookie&quot;</code> 的 Header，从而定义需要设置的 Cookie。我们不会在服务器上存储 Cookie，而是依靠终端用户的计算机创建与存储 Cookie。</p><p>我要强调上面这一点，因为它存在非常严重的安全隐患：我们<strong>不能</strong>控制这些数据，而终端用户的计算机（以及用户）才能控制这些数据。</p><p>当读取与写入终端用户控制的数据时，我们都需要十分谨慎地对数据进行处理。恶意用户可以删除 Cookie、修改存储在 Cookie 中的数据，甚至我们可能会遇到<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">中间人攻击</a>，即当用户向服务器发送数据时，另有人试图窃取 Cookie。</p><h2 id="Cookie-的潜在安全问题"><a href="#Cookie-的潜在安全问题" class="headerlink" title="Cookie 的潜在安全问题"></a>Cookie 的潜在安全问题</h2><p>根据我的经验，Cookie 相关的安全性问题大致分为以下五大类。下面我们先简单地看一看，本文的剩余部分将详细讨论每个分类的细节问题与解决对策。</p><p><strong>1. Cookie 窃取</strong> - 攻击者会通过各种方式来试图窃取 Cookie。我们将讨论如何防范、规避这些方式，但是归根结底我们并不能完全阻止设备上的物理类接触。</p><p><strong>2. Cookie 篡改</strong> - Cookie 中存储的数据可以被用户有意或无意地修改。我们将讨论如何验证存储在 Cookie 中的数据确实是我们写入的合法数据</p><p><strong>3. 数据泄露</strong> - Cookie 存储在终端用户的计算机上，因此我们需要清楚地意识到什么数据是能存储在 Cookie 中的，什么数据是不能存储在 Cookie 中的，以防其发生数据泄露。</p><p><strong>4. 跨站脚本攻击（XSS）</strong> - 虽然这条与 Cookie 没有直接关系，但是 XSS 攻击在攻击者能获取 Cookie 时危害更大。我们应该考虑在非必须的时候限制脚本访问 Cookie。</p><p><strong>5. 跨站请求伪造（CSRF）</strong> - 这种攻击常常是由于使用 Cookie 存储用户登录会话造成的。因此我们将讨论在这种情景下如何防范这种攻击。</p><p>如我前面所说，在下文中我们将分别解决这些问题，让你最终能够专业地将你的 Cookie 装进保险柜。</p><h2 id="Cookie-窃取"><a href="#Cookie-窃取" class="headerlink" title="Cookie 窃取"></a>Cookie 窃取</h2><p>Cookie 窃取攻击就和它字面意思一样 —— 某人窃取了正常用户的 Cookie，然后一般用来将自己伪装成那个正常用户。</p><p>Cookie 通常是被以下方式中的某种窃取：</p><ol><li><a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">中间人攻击</a>，或者是类似的其它攻击方式，归纳一下就是攻击者拦截你的 Web 请求，从中窃取 Cookie。</li><li>取得硬件的访问权限。</li></ol><p>阻止中间人攻击的终极方式就是当你的网站使用 Cookie 时，使用 SSL。使用 SSL 时，由于中间人无法对数据进行解密，因此外人基本上没可能在请求的中途获取 Cookie。</p><p>可能你会觉得“哈哈，中间人攻击不太可能…”，我建议你看看 <a href="http://codebutler.com/firesheep" target="_blank" rel="noopener">firesheep</a>，这个简单的工具，它足以说明在使用公共 wifi 时窃取未加密的 Cookie 是一件很轻松的事情。</p><p>如果你想确保这种事情不发生在你的用户中，<strong>请使用 SSL！</strong>试试使用 <a href="https://caddyserver.com/" target="_blank" rel="noopener">Caddy Server</a> 进行加密吧。它经过简单的配置就能投入生产环境中。例如，你可以使用下面四行代码轻松让你的 Go 应用使用代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calhoun.io &#123;</span><br><span class="line">  gzip</span><br><span class="line">  proxy / localhost:3000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 Caddy 会为你自动处理所有与 SSL 有关的事务。</p><p>防范通过访问硬件来窃取 Cookie 是十分棘手的事情。我们不能强制我们的用户使用高安全性系统，也不能逼他们为电脑设置密码，所以总会有他人坐在电脑前偷走 Cookie 的风险。此外，Cookie 也可能被病毒窃取，比如用户打开了某些钓鱼邮件时就会出现这种情况。</p><p>不过这些都容易被发现。例如，如果有人偷了你的手表，当你发现表不在手上时你立马就会注意到它被偷了。然而 Cookie 还可以被复制，这样任何人都不会意识到它已经丢了。</p><p>虽然不是万无一失，但你还是可以用一些技术来猜测 Cookie 是否被盗了。例如，你可以追踪用户的登录设备，要求他们重新输入密码。你还可以跟踪用户的 IP 地址，当其在可疑地点登录时通知用户。</p><p>所有的这些解决方案都需要后端做更多的工作来追踪数据，如果你的应用需要处理一些敏感信息、金钱，或者它的收益可观的话，请在安全方面投入更多精力。</p><p>也就是说，对于大多数只是作为过渡版本的应用来说，使用 SSL 就足够了。</p><h2 id="Cookie-篡改（也叫用户伪造数据）"><a href="#Cookie-篡改（也叫用户伪造数据）" class="headerlink" title="Cookie 篡改（也叫用户伪造数据）"></a>Cookie 篡改（也叫用户伪造数据）</h2><p>请直面这种情况 —— 可能有一些混蛋突然就想看看你设的 Cookie，然后修改它的值。也可能他是出于好奇才这么做的，但是还是请你为这种可能发生的情况做好准备。</p><p>在一些情景中，我们对此并不在意。例如，我们给用户定义一种主题设置时，并不会关心用户是否改变了这个设置。当这个 Cookie 过期时，就会恢复默认的主题设置，并且如果用户设置其为另一个有效的主题时我们可以让他正常使用那个主题，这并不会对系统造成任何损失。</p><p>但是在另一些情况下，我们需要格外小心。编辑会话 Cookie 冒充另一个用户产生的危害比改个主题大得多。我们绝不想看到张三假装自己是李四。</p><p>我们将介绍两种策略来检测与防止 Cookie 被篡改。</p><h4 id="1-对数据进行数字签名"><a href="#1-对数据进行数字签名" class="headerlink" title="1. 对数据进行数字签名"></a>1. 对数据进行数字签名</h4><p>对数据进行数字签名，即对数据增加一个“签名”，这样能让你校验数据的可靠性。这种方法并不需要对终端用户的数据进行加密或隐藏，只要对 Cookie 增加必要的签名数据，我们就能检测到用户是否修改数据。</p><p>这种保护 Cookie 的方法原理是哈希编码 —— 我们对数据进行哈希编码，接着将数据与它的哈希编码同时存入 Cookie 中。当用户发送 Cookie 给我们时，再对数据进行哈希计算，验证此时的哈希值与原始哈希值是否匹配。</p><p>我们当然不会想看到用户也创建一个新的哈希来欺骗我们，因此你可以使用一些类似 HMAC 的哈希算法来使用秘钥对数据进行哈希编码。这样就能防范用户同时编辑数据与数字签名（即哈希值）。</p><blockquote><p><a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Tokens(JWT)</a> 默认内置了数字签名功能，因此你可能对这种方法比较熟悉。</p></blockquote><p>在 Go 中，可以使用类似 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">securecookie</a> 之类的 package，你可以在创建 <code>SecureCookie</code> 时使用它来保护你的 Cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用 32 字节或 64 字节的 hashKey</span><br><span class="line">// 此处为了简洁故设为了 “very-secret”</span><br><span class="line">var hashKey = []byte(&quot;very-secret&quot;)</span><br><span class="line">var s = securecookie.New(hashKey, nil)</span><br><span class="line"></span><br><span class="line">func SetCookieHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">  encoded, err := s.Encode(&quot;cookie-name&quot;, &quot;cookie-value&quot;)</span><br><span class="line">  if err == nil &#123;</span><br><span class="line">    cookie := &amp;http.Cookie&#123;</span><br><span class="line">      Name:  &quot;cookie-name&quot;,</span><br><span class="line">      Value: encoded,</span><br><span class="line">      Path:  &quot;/&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    http.SetCookie(w, cookie)</span><br><span class="line">    fmt.Fprintln(w, encoded)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在另一个处理 Cookie 的函数中同样使用 SecureCookie 对象来读取 Cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func ReadCookieHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">  if cookie, err := r.Cookie(&quot;cookie-name&quot;); err == nil &#123;</span><br><span class="line">    var value string</span><br><span class="line">    if err = s.Decode(&quot;cookie-name&quot;, cookie.Value, &amp;value); err == nil &#123;</span><br><span class="line">      fmt.Fprintln(w, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上样例来源于 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">http://www.gorillatoolkit.org/pkg/securecookie</a>.</strong></p><blockquote><p>注意：这儿的数据并不是进行了加密，而只是进行了编码。我们会在“数据泄露”一章讨论如何对数据进行加密。</p></blockquote><p>这种模式还需要注意的是，如果你使用这种方式进行身份验证，请遵循 JWT 的模式，将登录过期日期和用户数据同时进行签名。你不能只凭 Cookie 的过期日期来判断登录是否有效，因为存储在 Cookie 上的日期并未经过签名，且用户可以创建一个永不过期的新 Cookie，将原 Cookie 的内容复制进去就得到了一个永远处于登录状态的 Cookie。</p><h4 id="2-进行数据混淆"><a href="#2-进行数据混淆" class="headerlink" title="2. 进行数据混淆"></a>2. 进行数据混淆</h4><p>还有一种解决方案可以隐藏数据并防止用户造假。例如，不要这样存储 Cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 别这么做</span><br><span class="line">http.Cookie&#123;</span><br><span class="line">  Name: &quot;user_id&quot;,</span><br><span class="line">  Value: &quot;123&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以存储一个值来映射存在数据库中的真实数据。通常使用 Session ID 或者 remember token 来作为这个值。例如我们有一个名为 <code>remember_tokens</code> 的表，这样存储数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remember_token: LAKJFD098afj0jasdf08jad08AJFs9aj2ASfd1</span><br><span class="line">user_id: 123</span><br></pre></td></tr></table></figure><p>在 Cookie 中，我们仅存储这个 remember token。如果用户想伪造 Cookie 也会无从下手。它看上去就是一堆乱码。</p><p>之后当用户要登陆我们的应用时，再根据 remember token 在数据库中查询，确定用户具体的登录状态。</p><p>为了让此措施正常工作，你需要确保你的混淆值有以下特性：</p><ul><li>能映射到用户数据（或其它资源）</li><li>随机</li><li>熵值高</li><li>可被无效化（例如在数据库中删除、修改 token 值）</li></ul><p>这种方法也有一个缺点，就是在用户访问每个需要校验权限的页面时都得进行数据库查询。不过这个缺点很少有人注意，而且可以通过缓存等技术来减小数据库查询的开销。这种方法的升级版就是 JWT，应用这种方法你可以随时使会话无效化。</p><p><strong>注意：尽管目前 JWT 收到了大多数 JS 框架的追捧，但上文这种方法是我了解的最常用的身份验证策略。</strong></p><h2 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h2><p>在真正出现数据泄露前，通常需要另一种攻击向量 —— 例如 Cookie 窃取。然而还是很难去正确地判断并提防数据泄露的发生。因为仅仅是 Cookie 发生了泄露并不意味着攻击者也得到了用户的账户密码。</p><p>无论何时，都应当减少存储在 Cookie 中的敏感数据。绝不要将用户密码之类的东西存在 Cookie 中，即使密码已经经过了编码也不要这么做。<a href="https://hackernoon.com/your-node-js-authentication-tutorial-is-wrong-f1a3bf831a46#2491" target="_blank" rel="noopener">这篇文章</a> 给出了几个开发者无意间将敏感数据存储在 Cookie 或 JWT 中的实例，由于（JWT 的 payload）是 base64 编码，没有经过任何加密，因此任何人都可以对其进行解码。</p><p>出现数据泄露可是犯了大错。如果你担心你不小心存储了一些敏感数据，我建议你使用如 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/securecookie" target="_blank" rel="noopener">securecookie</a> 之类的 package。</p><p>前面我们讨论了如何对你的 Cookie 进行数字签名，其实 <code>securecookie</code> 也可以用于加密与解密你的 Cookie 数据，让你的数据不能被轻易地解码并读取。</p><p>使用这个 package 进行加密，你只需要在创建 <code>SecureCookie</code> 实例时传入一个“块秘钥”（blockKey）即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var hashKey = []byte(&quot;very-secret&quot;)</span><br><span class="line">// 增加这一部分进行加密</span><br><span class="line">var blockKey = []byte(&quot;a-lot-secret&quot;)</span><br><span class="line">var s = securecookie.New(hashKey, blockKey)</span><br></pre></td></tr></table></figure><p>其它所有东西都和前面章节的数字签名中的样例一致。</p><p>再次提醒，你<strong>不应该</strong>在 Cookie 中存储任何敏感数据，尤其不能存储密码之类的东西。加密仅仅是一项为数据增加一部分安全性，使其成为”半敏感数据“数据的技术而已。</p><h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">跨站脚本（Cross-site scripting）</a>也经常被记为 XSS，及有人试图将一些不是你写的 JavaScript 代码注入你的网站中。但由于其攻击的机理，你无法知道正在浏览器中运行的 JavaScript 代码到底是不是你的服务器提供的代码。</p><p>无论何时，你都应该尽量去阻止 XSS 攻击。在本文中我们不会深入探讨这种攻击的具体细节，但是<strong>以防万一</strong>我建议你在非必要的情况下禁止 JavaScript 访问 Cookie 的权限。在你需要这个权限的时候你可以随时开启它，所以不要让它成为你的网站安全性脆弱的理由。</p><p>在 Go 中完成这点很简单，只需要在创建 Cookie 时设置 <code>HttpOnly</code> 字段为 true 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie := http.Cookie&#123;</span><br><span class="line">  // true 表示脚本无权限，只允许 http request 使用 Cookie。</span><br><span class="line">  // 这与 Http 与 Https 无关。</span><br><span class="line">  HttpOnly: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h2><p>CSRF 发生的情况为某个用户访问别人的站点，但那个站点有一个能提交到你的 web 应用的表单。由于终端用户提交表单时的操作不经由脚本，因此浏览器会将此请求设为用户进行的操作，将 Cookie 附上表单数据同时发送。</p><p>乍一看似乎这没什么问题，但是如果外部网站发送一些用户不希望发送的数据时会发生什么呢？例如，badsite.com 中有个表单，会提交请求将你的 100 美元转到他们的账户中，而 chase.com 希望你在它这儿登录你的银行账户。这可能会导致在终端用户不知情的情况下钱被转走。</p><p>Cookie 不会直接导致这样的问题，不过如果你使用 Cookie 作为身份验证的依据，那你需要使用 Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/csrf" target="_blank" rel="noopener">csrf</a> 之类的 package 来避免 CSRF 攻击。</p><p>这个 package 将会提供一个 CSRF token，插入你网站的每个表单中，当表单中不含 token 时，<code>csrf</code> package 中间件将会阻止表单的提交，使得别的网站不能欺骗用户在他们那儿向你的网站提交表单。</p><p><strong>更多关于 CSRF 攻击的资料请参阅：</strong></p><ul><li><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank" rel="noopener">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a>)</li><li><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a></li></ul><h2 id="在非必要时限制-Cookie-的访问权限"><a href="#在非必要时限制-Cookie-的访问权限" class="headerlink" title="在非必要时限制 Cookie 的访问权限"></a>在非必要时限制 Cookie 的访问权限</h2><p>我们要讨论的最后一件事与特定的攻击无关，更像是一种指导原则。我建议在使用 Cookie 时尽量限制其权限，仅在你需要时开发相关权限。</p><p>前面讨论 XSS 时我也简单的提到过这点，但一般的观点是你需要尽可能限制对 Cookie 的访问。例如，如果你的 Web 应用没有使用子域名，那你就不应该赋予 Cookie 所有子域的权限。不过这是 Cookie 的默认值，因此其实你什么都不用做就能将 Cookie 的权限限制在某个特定域中。</p><p>但是，如果你需要与子域共享 Cookie，你可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c := Cookie&#123;</span><br><span class="line">  // 根据主机模式的默认设置，Cookie 进行的是精确域名匹配。</span><br><span class="line">  // 因此请仅在需要的时候开启子域名权限！</span><br><span class="line">  // 下面的代码可以让 Cookie 在 yoursite.com 的任何子域下工作：</span><br><span class="line">  Domain: &quot;yoursite.com&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>欲了解更多有关域的信息，请参阅 <a href="https://tools.ietf.org/html/rfc6265#section-5.1.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6265#section-5.1.3</a>。你也可以在这儿阅读源码，参阅其默认设置：<a href="https://golang.org/src/net/http/cookie.go#L157" target="_blank" rel="noopener">https://golang.org/src/net/http/cookie.go#L157</a>.</strong></p><p><strong>你可以参阅 <a href="https://stackoverflow.com/questions/18492576/share-cookie-between-subdomain-and-domain" target="_blank" rel="noopener">这个 stackoverflow 的问题</a> 了解更多信息，弄明白为什么在为子域使用 Cookie 时不需要提供子域前缀.此外 Go 源码链接中也可以看到如果你提供前缀名的话会被自动去除。</strong></p><p>除了将 Cookie 的权限限制在特定域上之外，你还可以将 Cookie 限制于某个特定的目录路径中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := Cookie&#123;</span><br><span class="line">  // Defaults 设置为可访问应用的任何路径，但你也可以</span><br><span class="line">  // 进行如下设置将其限制在特定子目录下：</span><br><span class="line">  Path: &quot;/app/&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有你也可以对其设置路径前缀，例如 <code>/blah/</code>，你可以参阅下面这篇文章了解更多这个字段的使用方法：<a href="https://tools.ietf.org/html/rfc6265#section-5.1.4" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6265#section-5.1.4</a>.</p><h2 id="为什么我不使用-JWT？"><a href="#为什么我不使用-JWT？" class="headerlink" title="为什么我不使用 JWT？"></a>为什么我不使用 JWT？</h2><p>就知道肯定会有人提出这个问题，下面让我简单解释一下。</p><p>可能有很多人和你说过，Cookie 的安全性与 JWT 一样。但实际上，Cookie 与 JWT 解决的并不是相同的问题。比如 JWT 可以存储在 Cookie 中，这和将其放在 Header 中的实际效果是一样的。</p><p>另外，Cookie 可用于无需验证的数据，在这种情况下了解如何增加 Cookie 的安全性也是必要的。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59aa7a4d6fb9a0249c007e16" target="_blank" rel="noopener">https://juejin.im/post/59aa7a4d6fb9a0249c007e16</a></p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">lsvih</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">138</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">165</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">lsvih</span></div><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div><div class="footer-custom"><a target="_blank" rel="external nofollow" href="http://www.miitbeian.gov.cn">京ICP备18029472号</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.5.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>