<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lsvih.com","root":"/","images":"/images","scheme":"Pisces","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"algolia":{"appID":"6U6P1RGK4F","apiKey":"b14e73cdd627eabe947b5decbe14850f","indexName":"lsvih","hits":{"per_page":10}}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="My note">
<meta property="og:url" content="https://lsvih.com/page/4/index.html">
<meta property="og:site_name" content="My note">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="lsvih">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lsvih.com/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>My note - lsvih</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142893470-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-142893470-1');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">My note</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">lsvih</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-about"><a href="https://cv.lsvih.com/" rel="noopener" target="_blank"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lsvih</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">211</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lsvih" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lsvih" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lsvih@qq.com" title="E-Mail → mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/" class="post-title-link" itemprop="url">Algorithms for Non-negative Matrix Factorization，非负矩阵分解 论文翻译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-10-30 03:08:00" itemprop="dateCreated datePublished" datetime="2018-10-30T03:08:00+08:00">2018-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>NIPS 2000 经典论文 非负矩阵分解算法 翻译</p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>非负矩阵分解（NMF）是一种可以有效处理多变量数据的方法。本文介绍、分析了两种不同的 NMF 算法，这两种算法仅在更新规则（update rule）中使用的乘性因子（multiplicative factor）有所区别。其中一种可以对传统的最小二乘误差进行最小化（minimize），而另一种可以对广义 Kullback-Leibler 散度（KL 散度）进行最小化。可以使用与证明最大化期望算法收敛性类似的辅助函数来证明这两种算法的单调收敛性。这两种算法均可理解为用斜向最陡下降法（diagonally rescaled gradient descent）对因子进行最优化，以保证算法收敛。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PCA、矢量量化（Vector Quantization）等无监督学习算法可以理解为在不同约束条件下对数据矩阵进行分解。根据其约束的不同，分解所得的因子的会表现出大相径庭的性质。比如，PCA 仅使用了弱正交约束，从而得到非常分散的表示，对这些表示使用消去法来产生多样性；矢量量化使用一种严格的全局最优型约束，最终会得到互斥的数据聚类原型。</p>
<p>我们之前已经证明过，在矩阵分解用于学习数据的部分表示中，非负性（non-negative）是一种非常有用的约束。学习得到的非负基向量是分散的，但仍可通过稀疏的组合，在重建时得到效果良好的表达向量。在本文中，我们详细分析了这两种用于在数据中学习最优的非负因子的数值算法。</p>
<h2 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h2><p>下面我们正式开始分析如何用算法解决以下问题：</p>
<p><strong>在非负矩阵分解（NMF）中</strong>，给定非负矩阵V，找到非负矩阵因子W和H，使得：</p>
<script type="math/tex; mode=display">(1):  V\approx WH</script><p>NMF 可以应用下面的方法用于对多变量数据进行统计分析。给定一组多变量的 n 维数据向量，其向量位于一个 $n\times x$ 矩阵 V 的列中（m 表示数据集中的示例数）。然后将此矩阵近似分解为 $n\times r$ 的 W 矩阵与 $r\times m$的 H 矩阵。通常 r 要小于 n 或 m，以使 W 和 H 小于原始矩阵 V。最终得到的是原始数据矩阵的压缩形态。</p>
<p>公式(1)中约等于的意义在于它可以将公式逐列用 $v\approx Wh$ 来表示，其中 v 和 h 是矩阵 V 和矩阵 H 的对应的列。也就是说，每个数据向量 v 近似地由矩阵 W 的各列线性组合而成，同时用 h 的分量进行加权。因此可以被认为 W 包含了对 V 中的数据的线性近似优化的基向量。由于要使用少量的基向量来表示大量的数据向量，因此只有在基向量发现数据中的潜在结构时才能实现较好的近似。</p>
<p>本文不会涉及关于 NMF 的应用，而会侧重于在技术方面探讨非负矩阵分解的技术。当然，已经有许多其它的矩阵分解方式在数值线性代数中得到了广泛的研究，但是以前的大多数工作都不适用于非负性约束情况。</p>
<p>在此，我们讨论了基于迭代更新 W 和 H 的两种 NMF 算法。由于这两种算法易于实现，同时能保证其收敛性，因此它们在现实情况中非常实用。其他算法可能在总计算时间方面更有效率，但是更难实现，并且很难推广到不同的代价函数（cost function）。因子与我们类似的算法，已经被用于对发射断层扫描和天文图像进行反卷积（deconvolution）。</p>
<p>在我们算法的每次迭代中，会用当前值乘某些取决于公式(1)中的“近似程度”的因数，来找到 W 或 H 的新值。我们可以证明“近似程度”会随着不断应用这些乘法更新规则而单调减小。这正意味着更新规则的重复迭代可以保证矩阵分解算法收敛到局部最优。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>为了找到$ V\approx WH  $的近似解，我们首先需要定义一个代价函数，用以量化近似的程度。可以使用两个非负矩阵 A 和 B 的距离来构造此代价函数。一种使用的距离度量方法为：计算 A  和 B 之间的欧几里得距离（Euclidean distance）的平方值。</p>
<script type="math/tex; mode=display">(2): ||A-B||^2 = \sum_{ij}(A_{ij} - B_{ij})^2</script><p>此公式下界为 0，仅当 A=B 时距离消失。</p>
<p>另一种实用的度量方式为：</p>
<script type="math/tex; mode=display">(3): D(A||B) = \sum_{ij}(A_{ij} \log{\frac{A_{ij}}{B_{ij}}} - A_{ij}+B_{ij})</script><p>与欧几里得距离相同，它的下界也为 0，且在 A=B 时距离消失。但它不能被称为“距离”，因为这个式子在 A 与 B 中并不对称，因此我们将其称为 A 对于 B 的“散度”（divergence）。它可以归纳为 KL 散度或者相对熵，当 $\sum_{ij}A_{ij}=\sum_{ij}B_{ij}=1$ 时，A 与 B 可以看做是标准化的概率分布。</p>
<p>现在，我们可以按照以下两种公式来将 NMF 化为最优化问题：</p>
<p><strong>最优化问题1</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $||V - WH||^2$。</p>
<p><strong>最优化问题2</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $D(V||WH)$。</p>
<p>虽然方程 $||V - WH||^2$ 和 $D(V||WH)$ 在只考虑 W 或 H 之一时为凸，但在同时考虑 WH 两个变量时不为凸。因此，寻找一种可以找到全局最小值的算法去解决以上两个最优化问题是不切实际的。但是，还有许多数值优化方法可以用于寻找局部最小值。</p>
<p>虽然梯度下降法（Gradient descent）的收敛速度很慢，但它的实现最为简单。其它方法（比如共轭梯度法）可以更快地收敛（至少在局部最小值附近会更快），但是它们比梯度下降更复杂。此外，梯度下降方法的收敛对步长的选择非常敏感，这对于大规模应用十分不利。</p>
<h2 id="乘法更新规则"><a href="#乘法更新规则" class="headerlink" title="乘法更新规则"></a>乘法更新规则</h2><p>我们发现在解决上述两个最优化问题时，在速度与实现难度中权衡，“乘法更新规则”是一种综合性能很好方法。</p>
<p><strong>定理1</strong>：欧几里得距离 $||V-WH||$ 在下面的更新规则中呈非增：</p>
<script type="math/tex; mode=display">(4): H_{a\mu} \leftarrow H_{a\mu}\frac{(W^T V)_{a\mu}}{(W^T W H)_{a\mu}}</script><script type="math/tex; mode=display">(4): W_{ia} \leftarrow W_{ia}\frac{(V H^T)_{ia}}{(W H H^T)_{ia}}</script><p>在上述更新规则中，W 与 H 在距离公式的驻点上时，欧几里得距离将固定不动。</p>
<p><strong>定理2</strong>：散度 $D(V|WH)$ 在下面的更新规则中呈非增：</p>
<script type="math/tex; mode=display">(5): H_{a\mu} \leftarrow H_{a\mu}\frac{\frac{\sum_{i}W_{ia}V_{i\mu}}{WH_{i\mu}}}{\sum_k W_{ka}}</script><script type="math/tex; mode=display">(5): W_{ia} \leftarrow W_{ia}\frac{\frac{\sum_{\mu}H_{a\mu}V_{i\mu}}{WH_{i\mu}}}{\sum_v H_{av}}</script><p>在上述更新规则中，W 和 H 在散度公式的驻点上时，散度将不再更新。</p>
<p>上述定理的证明将在后面给出。我们可以发现，每次更新都是乘以一个因子。特别地，当V = WH时，可以直观地看出这个乘数因子是一样的，当更新规则固定时，才会得到完美的分解。</p>
<h2 id="乘法与加法更新规则"><a href="#乘法与加法更新规则" class="headerlink" title="乘法与加法更新规则"></a>乘法与加法更新规则</h2><p>可以将乘法更新与梯度下降更新进行对比。特别的，对 H 进行更新以减小平方距离可以记为：</p>
<script type="math/tex; mode=display">(6):H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[(W^TV)_{a\mu} - (W^T WH)_{a\mu}]</script><p>如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $||V-WH||$。</p>
<p>如果我们按照斜向最陡调整变量，并设置：</p>
<script type="math/tex; mode=display">(7): \eta_{a\mu}=\frac{H_{a\mu}}{(W^TWH)_{a\mu}}</script><p>就能得到定理 1 中给出的 H 更新规则。注意，该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p>
<p>对于散度公式，我们按照下述公式调整斜向最陡梯度下降：</p>
<script type="math/tex; mode=display">(8): H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[\sum_{i}W_{ia}\frac{V_{i\mu}}{(WH)_{i\mu}}-\sum_{i}W_{ia}]</script><p>同样的，如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $D(V||WH)$。如果设置：</p>
<script type="math/tex; mode=display">(9): \eta_{a\mu} = \frac{H_{a\mu}}{\sum_i W_{ia}}</script><p>那么就能得到定理 2 中给出的 H 更新规则。该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p>
<p>由于我们对 $\eta_{a\mu}$ 的取值并不够小，看起来不能保证这种调整过后的梯度下降的代价函数减小。不过让人惊讶的是，如下节所示，上述假设是事实。</p>
<h2 id="收敛证明"><a href="#收敛证明" class="headerlink" title="收敛证明"></a>收敛证明</h2><p>我们将使用一个类似于 EM 算法的辅助函数来证明定理 1 与定理 2。</p>
<p><strong>定义 1</strong>：$G(h,h’)$ 是 $F(h)$ 的辅助函数，满足以下条件成立：</p>
<script type="math/tex; mode=display">(10): G(h,h')\geq F(h), G(h,h)=F(h)</script><p>根据下面的引理，此辅助函数是一个有用的概念。（在图1中的插图也显示了这一点）</p>
<p><strong>引理 1</strong>：如果 G 为辅助函数，则 F 在下述更新时为非增：</p>
<script type="math/tex; mode=display">(11): h^{t+1} = \arg\min_{h}G(h,h^t)</script><p><strong>证明</strong>：$F(h^{t+1}) \leq G(h^{t+1}, h^t) \leq G(h^t,h^t) = F(h^t)$</p>
<p>请注意，只有在$h^t$为$G(h,h^t)$的全局最小值时满足$F(h^{t+1})=F(h^t)$。如果 F 的导数存在，且在$h^{t}$的邻域连续，也就是说$\nabla F(h^t) = 0 $。因此通过公式11反复更新，我们就能得到目标函数收敛的局部最小值 $h_{min} = \arg\min_h F(h)$</p>
<script type="math/tex; mode=display">(12): F(h_{min}) \leq ... F(h^{t+1})\leq F(h^t) ... \leq F(h_2) \leq F(h_1) \leq F(h_0)</script><p><img src="/images/15408401601646.jpg" alt="-w663"></p>
<p>下面，我们证明如何为$||V-WH||$与$D(V,WH)$定义适当的辅助函数$G(h,h^t)$。定理 1 与定理 2 可以直接遵循公式 11 的更新规则。</p>
<p><strong>引理 2</strong>：如果$K(h^t)$为对角矩阵，</p>
<script type="math/tex; mode=display">(13): K_{ab}(h^t) = \delta_{ab}\frac{W^T Wh^t}{h^t_a}</script><p>则</p>
<script type="math/tex; mode=display">(14): G(h,h^t)=F(h^t)+(h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T K(h^t)(h-h^t)</script><p>为</p>
<script type="math/tex; mode=display">(15): F(h)=\frac{1}{2} \sum_i(v_i- \sum_a W_{ia} h_a)^2</script><p>的辅助函数。</p>
<p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。为了证明此不等式，需要将</p>
<script type="math/tex; mode=display">(16): F(h) = F(h^t) + (h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T(W^TW)(h-h^t)</script><p>与公式 14 进行对比，发现 $G(h,h’) \geq F(h)$ 等价于</p>
<script type="math/tex; mode=display">(17): 0 \leq (h-h^t)^T[K(h^t) - W^TW](h-h^t)</script><p>为证明半正定情况，考虑矩阵：</p>
<script type="math/tex; mode=display">(18): M_{ab}(h^t)=h_a^t(K(h^t)-W^TW)_{ab}h_b^t</script><p>仅是$K-W^TW$的调整形式。因此，仅当 M 符合下列公式时，$K-W^TW$具有半正定性：</p>
<script type="math/tex; mode=display">(19):v^T Mv = \sum_{ab}v_a M_{ab} v_b \\
(20):=\sum_{ab}h^t_a(W^TW)_{ab}h^t_bv_a^2-v_ah^t_a(W^TW)_{ab}h_b^tv_b \\
(21):=\sum_{ab}(W^TW)_{ab}h_a^th_b^t[\frac{1}{2}v_a^2 + \frac{1}{2}v_b^2 - v_av_b] \\
(22):=\frac{1}{2}\sum_{ab}(W^TW)_{ab}h_a^th_b^t(v_a-v_b)^2 \\
(23):\geq 0</script><p>现在，我们可以证明定理 1 的收敛性。</p>
<p><strong>定理 1 证明</strong>：使用公式14的结果替换公式11中的$G(h,h^t)$，得到更新规则：</p>
<script type="math/tex; mode=display">(24): h^{t+1}=h^t - K(h^t)^{-1} \nabla F(h^t)</script><p>因为公式14为辅助函数，根据引理1，F 在更新规则中为非增。将上式完整的写下来，可以得到：</p>
<script type="math/tex; mode=display">(25): h^{t+1}_a= h^{t}_a \frac{(W^Tv)_a}{(W^TWh^t)_a}</script><p>反转引理 1 与引理 2 中 W 和 H 的角色，F 可以以类似的方法证明在 W 的更新规则下为非增。</p>
<p>接下来，我们为散度代价方程寻找辅助函数。</p>
<p><strong>引理 3</strong>：定义</p>
<script type="math/tex; mode=display">(26): G(h,h^t)=\sum_i(v_i \log{v_i} - v_i) + \sum_{ia} W_{ia}h_a \\
(27):-\sum_{ia}v_i\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b} (\log{W_{ia} h_a - \log{\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b}}})</script><p>为</p>
<script type="math/tex; mode=display">(28): F(h)=\sum_i v_i \log(\frac{v_i}{\sum_a W_{ia} h_a})- v_i + \sum_a W_{ia} h_a</script><p>的辅助函数。</p>
<p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。我们通过对数函数的凸性来推导此不等式：</p>
<script type="math/tex; mode=display">(29): -\log \sum_a W_{ia} h_a \leq -\sum_a a_a \log \frac{ W_{ia} h_a}{a_a}</script><p>上式对所有的联合求合数 $a_a$ 均成立。设</p>
<script type="math/tex; mode=display">(30): a_a =\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b}</script><p>可以得到：</p>
<script type="math/tex; mode=display">(31): -\log \sum_a W_{ia} h_a \leq - \sum_a \frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} (\log W_{ia} h_a - \log\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} )</script><p>上面的不等式遵循 $G(h,h’) \geq F(h)$。</p>
<p>定理 2 的证明遵循引理 1 及其应用：</p>
<p><strong>定理 2 证明</strong>：要令 $G(h,h^t)$ 最小化，则需要将梯度设为 0 来求出 h：</p>
<script type="math/tex; mode=display">(32): \frac{dG(h,h^t)}{dh_a} = - \sum_i v_i \frac{ W_{ia} h_a^t}{\sum_b W_{ib} h_b^t} \frac{1}{h_a} + \sum_i W_{ia} = 0</script><p>因此，公式 11 采取的更新规则应当如下所示：</p>
<script type="math/tex; mode=display">(33): h_a^{t+1} = \frac{h_a^t}{\sum_b W_{kb}} \sum_i \frac{v_i}{\sum_b W_{ib}h_b^t} W_{ia}</script><p>因为 G 为辅助函数，公式 28 中的 F 在更新规则中为非增。用矩阵形式重写上述公式，发现与 公式 5 的更新规则等价。反转 W 和 H 的角色，可以以类似的方法证明 F 在 W 的更新规则下为非增。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们已经证明了在公式 4 与公式 5 中应用更新规则，可以找到问题 1 与问题 2 的局部最优解。借助定义合适的辅助函数证明了函数的收敛性。我们将把这些证明推广到更复杂的约束条件下去。更新规则在计算上非常容易实现，有望进行广泛的应用。</p>
<p>感谢贝尔实验室的支持，以及 Carlos Brody, Ken Clarkson, Corinna Cortes, Roland Freund, Linda Kaufman, Yann Le Cun, Sam Roweis, Larry Saul, Margaret Wright 的帮助与讨论。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/10/29/%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/29/%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">关键词规则生成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-10-29 11:25:00" itemprop="dateCreated datePublished" datetime="2018-10-29T11:25:00+08:00">2018-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>提取关键词将得到一系列的词库，要将这些词应用于文本筛查、分类则必须要对这些词进行拆分、组合，形成特定的规则，再应用这些规则对文本进行匹配，得到某文本所对应的模式。</p>
<p>要生成规则，即需要从系列关键词通过某些算法找出在不同样本文本下关键词的共有特征（或规律），再对多种特征（或规律）进行组合得到某种策略，最终通过策略对目标文本进行判定。因此关键词规则生成可以总结为以下几个主要步骤：</p>
<ol>
<li>关键词特征或规律查找</li>
<li>策略生成</li>
<li>策略优化与化简</li>
</ol>
<p>对于关键词特征与规律的查找，可以视为机器学习中的分类问题的反向过程。分类问题简要来说即给定标注样本，通过特征训练，得到一个可适用于同类样本的分类策略。常用的分类方法包括决策树、SVM、神经网络等方法。</p>
<p>决策树算法是常用的数据分类算法。决策树算法具有以下优点：</p>
<ol>
<li>决策树算法中学习简单的决策规则建立决策树模型的过程非常容易理解</li>
<li>决策树模型可以可视化，非常直观</li>
<li>应用范围广，可用于分类和回归，而且非常容易做多类别的分类</li>
<li>能够处理数值型和连续的样本特征</li>
</ol>
<p>由于它生成分类策略的可解释性，以及树状结构的可编辑性，在本步骤中可选用决策树算法作为样本分类策略。</p>
<p>下图为对某样本文本进行决策树（CART）生成的分类器策略可视化图像：</p>
<p><img src="/images/15407837052758.jpg" alt="-w889"></p>
<p>可以从图片中看出，决策树算法根据样本标注训练而成了对应的基于关键词的文本分类器。此分类器策略为清晰的树状结构，每个节点代表一个判断条件，每个树杈代表一个条件分支。为了得到在特定计算性能高、可解释性更好的策略，需要对其进行进一步的策略挖掘及精简。</p>
<p>由于决策树得到的策略为树状结构，因此在这种结构上的进一步策略挖掘可选用盲目搜索算法；又由于此模型为树状结构，最终分类落于叶子节点中，故采用深度优先搜索（DFS）对此树的路径进行检索，进一步优化策略。</p>
<p>在决策树得到的规则通过深度优先搜索之后，会得到一系列的组别，每个组别中包含各个关键词的“与”和“或”两种逻辑关系。在目标文本中使用时，即可通过这些逻辑关系的匹配找出对应的模式。</p>
<p>但由于决策树得到的策略叶子节点通常较多（如上图所示），通过深度优先搜索得到的策略也非常繁杂，最终生成得到的规则也会非常复杂，因此还可以进行进一步的策略化简。</p>
<p>在此步骤中，实质上是对多个逻辑代数运算及逻辑代数复合运算组合而成的逻辑函数进行化简。逻辑函数的化简方法一般有如下三种：</p>
<ol>
<li>公式化简法</li>
<li>卡诺图法</li>
<li>Q-M 法</li>
</ol>
<p>由于在此步骤实际应用时逻辑规则较为繁杂，且“与”—“或”逻辑对较多，比起公式化简法或卡诺图法，Q-M 算法在选取出可以覆盖逻辑规则真值的最小质蕴涵项时更能发挥优势。</p>
<p>最终，通过决策树算法生成树、对决策树进行深度优先搜索得到包含“与”、“或”的分类逻辑、对分类逻辑应用 Q-M 算法，最终得到了包含“与”、“或”、“非”三种逻辑关系的可解释性强、精简的规则。</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一个树结构，其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。运用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p>
<p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树算法是通过一系列规则对数据进行分类的过程。</p>
<p>决策树算法构造决策树来发现数据中蕴涵的分类规则．如何构造精度高、规模小的决策树是决策树算法的核心内容。决策树构造可以分两步进行：</p>
<p>第一步，决策树的生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集。</p>
<p>第二步，决策树的剪枝：决策树的剪枝是对上一阶段生成的决策树进行检验、校正和修下的过程，主要是用新的样本数据集（称为测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除。</p>
<p>在第一步决策树的生成中，需要确定树杈的分裂属性（即在多个自变量中，优先选择哪个自变量进行分叉）。而采用何种计算方式选择树杈决定了决策树算法的类型，典型的分裂属性的选择的方法有 ID3 算法、C4.5 算法、CART 算法三种，三种决策树算法选择树杈的方式是不一样的。</p>
<h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><p>ID3 算法是目前决策树算法中较有影响力的算法，于 1986 年由 Quinlan 提出。该算法只是一个启发式算法。ID3 算法的核心是判断测试哪个属性为最佳的分类属性。ID3 算法选择分裂后信息增益最大的属性进行分裂，以信息增益度量属性选择。ID3 算法中常用到的两个概念是熵和信息增益。</p>
<p>熵是刻画任意样本例集的纯度，如果目标属性具有 m 个不同的值，那么 D 相对于 m 这个状态的分类的熵定义为：</p>
<script type="math/tex; mode=display">\text{inf}\ o(D) = -\sum^m_{i=1}p_i \log_2 (P_i)</script><p>其中 Pi 表示 Pi 是 m 类别的比例。</p>
<p>一个属性的信息增益就是由于使用这个属性分割样例而导致的期望熵降低，更精确来讲，一个属性A相对样本例集合S的信息增益 Gain(S，A) 被定义为：</p>
<script type="math/tex; mode=display">gain(A) = info(D) - infoA(D)</script><p>A 对 D 划分的期望信息为：</p>
<script type="math/tex; mode=display">\text{inf}\ o_A(D) = \sum^v_{j=1} \frac{|D_j|}{|D|} \text{inf}\ o(D_j)</script><p>ID3 算法不足之处是只能处理离散型数据，信息增益的选择分裂属性的方式会偏向选择具有大量值得属性。</p>
<h3 id="C4-5-算法"><a href="#C4-5-算法" class="headerlink" title="C4.5 算法"></a>C4.5 算法</h3><p>ID3 算法在实际应用中存在一些问题，于是 Quilan 在保留 ID3 算法优点基础上提出了 C4.5 算法，C4.5 算法只是 ID3 算法的改进算法。C4.5 算法采用最大信息增益率的属性被选为分裂属性。C4.5 算法中用到了“分裂信息”这一概念，该概念可以表示为：</p>
<script type="math/tex; mode=display">split\_ \text{inf}\ o_A(D) = -\sum^v_{j=1} \frac{|D_j|}{|D|} \log_2\frac{|D_j|}{|D|}</script><p>信息增益率的定义是：</p>
<script type="math/tex; mode=display">gain\_ratio(A) = \frac{gainA}{split\_\text{inf}\ o(A)}</script><p>C4.5 算法是对 ID3 算法的一种改进，改进后可以计算连续型属性的值。对于连续型属性的值，只需将连续型变量由小到大递增排序，取相邻连个值的中点作为分裂点，然后按照离散型变量计算信息增益的方法计算信息增益，取其中最大的信息增益作为最终的分裂点。</p>
<p>C4.5 算法继承了 ID3 算法的优点，并在以下几方面对 ID3 算法进行了改进：</p>
<ul>
<li><p>用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；</p>
</li>
<li><p>在树构造过程中进行剪枝；</p>
</li>
<li><p>能够完成对连续属性的离散化处理；能够对不完整的数据进行处理。</p>
</li>
</ul>
<h3 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h3><p>CART 算法选择分裂属性的方式首先要计算不纯度，然后利用不纯度计算 Gini 指标，然后计算有效子集的不纯度和 Gini 指标，选择最小的 Gini 指标作为分裂属性。</p>
<script type="math/tex; mode=display">Gini(D) = 1 - \sum^n_{i=0}(\frac{Di}{D})^2</script><script type="math/tex; mode=display">Gini(D|A) = \sum^n_{i=0} \frac{Di}{D} Gini(D i)</script><p>由于 CART 算法在处理离散数据上具有优势，因此对于关键词规则的生成可选用此方法生成决策树。</p>
<h2 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h2><p>搜索算法可分为盲目搜索算法和启发式搜索算法两种，二者的区别在于：启发式搜索算法的每一步都试图向着目标状态方向进行搜索，而盲目搜索算法则是每一步按照固定的规则进行搜索，然后判断是否达到目标状态。相比之下，启发式搜索算法克服了盲目搜索算法的盲目性问题。</p>
<p>虽然启发式搜索算法可以解决盲目搜索算法的盲搜索问题，但是在实际问题求解中，缺少一些必要的信息来构建启发式搜索算法，此时采用盲目搜索算法仍然是解决问题的有效手段。盲目搜索算法有两种：一种按照广度优先展开搜索树的搜索算法，叫广度优先搜索法；另一种则是按照深度优先展开搜索的搜索算法，叫深度优先搜索法算法。</p>
<p>深度优先搜索算法是优先扩展尚未扩展的且具有最大深度的节点；广度优先搜索法是在扩展完第 K 层的节点后才扩展 K+1 层的节点。在此应用深度优先搜索算法。</p>
<p>假设初始状态是图中所有顶点未曾被访问，从图中某个顶点 i 出发，访问此顶点，然后依次从 i 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 i 有路径的顶点都被访问为止。若此时图中尚有顶点未被访问，则另选图中未曾访问的顶点为起始点，重复上述过程，直至图中所有顶点都被访问为止。在节点遍历过程中，应该注意节点的回溯搜索以及避免节点被重复搜索。</p>
<p>在搜索过程中，如何避免被搜过的节点不被重复搜索以及节点的回溯是主要难点。根据关联矩阵以及深度优先搜索算法，从节点 i 搜索出节点 j，如果节点 j 已经被搜索过，那么修改关联矩阵中对应节点 i 和节点 j 的元素为 0，并返回节点 i 重新搜索与之相联的另一节点。当节点 j 是该条树枝的最后一个节点时，修改关联矩阵中相应的元素，并且返回节点 i 重新搜索与之相连的另一树枝。依此类推，直至遍历所有节点，也就是关联矩阵的所有元素都变为 0 时，停止搜索。在遍历各节点的同时，根据节点的先后顺序以及树枝集合，合理地安排各节点坐标。其搜索过程逻辑如下图所示：</p>
<p><img src="/images/15407837517781.jpg" alt="-w241"></p>
<h2 id="Q-M-算法"><a href="#Q-M-算法" class="headerlink" title="Q-M 算法"></a>Q-M 算法</h2><p>在得到只包含“与”、“或”的逻辑函数之后，可对逻辑进行更进一步的简化与合并，并加上“非”逻辑来使得逻辑函数更具解释性。</p>
<p>下图为一个简单逻辑函数的卡诺图，101 项被覆盖了 3 次，明显可对函数进行化简。</p>
<p><img src="/images/15407837648773.jpg" alt="-w386"></p>
<p>Q-M 算法是由 Quine 和 Mccluskey 提出的一种系统列表化简法。这种化简方法和卡诺图化简法的基本思想大致相同, 是通过找出函数 F 的全部质蕴涵项、必要质蕴涵项以及最简质蕴涵项集来求得最简表达式。</p>
<p>下面为蕴含项与质蕴涵项的定义：</p>
<p>蕴涵项：在函数的“与”—“或”表达式中，每个“与”项被称为该函数的蕴涵项。显然在函数卡诺图中，任何一个  1 方格所对应的最小项或者卡诺圈中的 $2^n$ 个 1 方格所对应的“与”项都是函数的蕴涵项。</p>
<p>质蕴涵项：若函数的一个蕴涵项不是该函数中其它蕴涵项的子集，则此蕴涵项称为质蕴涵项，简称为质项。显然在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈不可能被其它更大的卡诺圈包含，那么该卡诺圈所对应的“与”项为质蕴涵项。</p>
<p>必要质蕴涵项：若函数的一个质蕴涵项所包含的某一个最小项不被函数的其它任何质蕴涵项包含，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项。在函数卡诺图中，若某个卡诺圈包含了不可能被任何其它卡诺圈包含的 1 方格，那么该卡诺圈所对应的“与”项为必要质蕴涵项。</p>
<p>一般的化简步骤是：  </p>
<p>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每—个最小项。</p>
<p>第二步：找出函数的全部质蕴涵项。先将 n 个变量函数中的相邻最小项合并，消去相异的—个变量，得到 (n-1) 个变量的“与”项，再将相邻的 (n-1) 个变量的“与”项合并，消去相异的变量，得到 (n-2) 个变量的“与”项。依此类推，直到不能再合并为止。所得到的全部不能再合并的“与”项（包括不能合并的最小项），即所要求的全部质蕴涵项。</p>
<p>第三步：找出函数的必要质蕴涵项。 </p>
<p>第四步：找出函数的最小覆盖。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/08/28/Python-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/28/Python-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Python 的多线程与多进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-28 15:04:00" itemprop="dateCreated datePublished" datetime="2018-08-28T15:04:00+08:00">2018-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="初学者的并行编程指南"><a href="#初学者的并行编程指南" class="headerlink" title="初学者的并行编程指南"></a>初学者的并行编程指南</h2><p><img src="/images/pasted-322.png" alt="upload successful"></p>
<p>在参加 Kaggle 的 <a target="_blank" rel="noopener" href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space">Understanding the Amazon from Space</a> 比赛时，我试图对自己代码的各个部分进行加速。速度在 Kaggle 比赛中至关重要。高排名常常需要尝试数百种模型结构与超参组合，能在一个持续一分钟的 epoch 中省出 10 秒都是一个巨大的胜利。</p>
<p>让我吃惊的是，数据处理是最大的瓶颈。我用了 Numpy 的矩阵旋转、矩阵翻转、缩放及裁切等操作，在 CPU 上进行运算。Numpy 和 Pytorch 的 DataLoader 在某些情况中使用了并行处理。我同时会运行 3 到 5 个实验，每个实验都各自进行数据处理。但这种处理方式看起来效率不高，我希望知道我是否能用并行处理来加快所有实验的运行速度。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/08/28/Python-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/07/23/%E4%BD%BF%E7%94%A8-PhpFastCache-%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/23/%E4%BD%BF%E7%94%A8-PhpFastCache-%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">使用 PhpFastCache 提升网站性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-07-23 02:48:00" itemprop="dateCreated datePublished" datetime="2018-07-23T02:48:00+08:00">2018-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将与你一同探索 PhpFastCache 库，来为你的 PHP 应用实现缓存功能。通过缓存功能，能够提升网站的整体性能与页面加载速度。</p>
<h2 id="什么是-PhpFastCache？"><a href="#什么是-PhpFastCache？" class="headerlink" title="什么是 PhpFastCache？"></a>什么是 PhpFastCache？</h2><p>PhpFastCache 是一个能让你轻松在 PHP 应用中实现缓存功能的库。它的功能强大，且简单易用，提供了一些 API 以无痛实现缓存策略。</p>
<p>PhpFastCache 不是一个纯粹的传统文件系统式缓存。它支持各种各样的文件适配器（Files Adapter），可以让你选择 Memcache、Redis、MongoDB、CouchDB 等高性能的后端服务。</p>
<p>让我们先总览一遍最流行的适配器：</p>
<ul>
<li>文件系统</li>
<li>Memcache、Redis 和 APC</li>
<li>CouchDB 和 MongoDB</li>
<li>Zend Disk Cache 和 Zend Memory Cache</li>
</ul>
<p>如果你用的文件适配器不在上面的列表中，也可以简单地开发一个自定义驱动，插入到系统中，同样也能高效地运行。</p>
<p>除了基本功能外，PhpFastCache 还提供了事件机制，可以让你对预定义好的事件进行响应。例如，当某个事物从缓存中被删除时，你可以接收到这个事件，并去刷新或删除相关的数据。</p>
<p>在下面的章节中，我们将通过一些示例来了解如何安装及配置 PhpFastCache。</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在本节中，我们将了解如何安装及配置 PhpFastCache。下面是几种将它集成进项目的方法。</p>
<p>如果你嫌麻烦，仅准备下载这个库的 <strong>.zip</strong> 或者 <strong>.tar.gz</strong> 文件，可以去<a target="_blank" rel="noopener" href="https://www.phpfastcache.com/">官方网站</a>直接下载。</p>
<p>或者你也可以用 Composer 包的方式来安装它。这种方式更好，因为在之后的维护和升级时会更方便。如果你还没有安装 Composer，需要先去安装它。</p>
<p>当你安装好 Composer 之后，可以用以下命令下载 PhpFastCache：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$composer</span> require phpfastcache/phpfastcache</span><br></pre></td></tr></table></figure>
<p>命令完成后，你会得到一个 vendor 目录，在此目录中包括了全部 PhpFastCache 所需的文件。另外，如果你缺失了 PhpFastCache 依赖的库或插件，Composer 会提醒你先去安装依赖。</p>
<p>你需要找到 <code>composer.json</code> 文件，它类似于下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;require&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;phpfastcache/phpfastcache&quot;</span>: <span class="string">&quot;^6.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论你通过什么方式来安装的 PhpFastCache，都要在应用中 include <strong>autoload.php</strong> 文件。</p>
<p>如果你用的是基于 Composer 的工作流，<strong>autoload.php</strong> 文件会在 <strong>vendor</strong> 目录中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;&#123;YOUR_APP_PATH&#125;/vendor/autoload.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>另外，如果你是直接下载的 <strong>.zip</strong> 和 <strong>.tar.gz</strong>，<strong>autoload.php</strong> 的路径会在 <strong>src/autoload.php</strong>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;&#123;YOUR_APP_PATH&#125;/src/autoload.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>只要完成上面的操作，就能开始进行缓存，享受 PhpFastCache 带来的好处了。在下一章节中，我们将以一个简单的示例来介绍如何在你的应用中使用 PhpFastCache。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>前面我提到过，PhpFastCache 支持多种文件适配器进行缓存。在本节中，我会以文件系统和 Redis 这两种文件适配器为例进行介绍。</p>
<h3 id="使用文件适配器进行缓存"><a href="#使用文件适配器进行缓存" class="headerlink" title="使用文件适配器进行缓存"></a>使用文件适配器进行缓存</h3><p>创建 <strong>file_cache_example.php</strong> 文件并写入下面的代码。在此我假设你使用的是 Composer workflow，因此 <strong>vendor</strong> 目录会与 <strong>file_cache_example.php</strong> 文件同级。如果你是手动安装的 PhpFastCache，需要根据实际情况修改文件结构。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with &quot;file system&quot; adapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for &quot;files&quot; adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">&quot;path&quot;</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">&quot;/cache&quot;</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line"><span class="variable">$objFilesCache</span> = CacheManager::getInstance(<span class="string">&#x27;files&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$key</span> = <span class="string">&quot;welcome_message&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with &quot;welcome_message&quot; key</span></span><br><span class="line"><span class="variable">$CachedString</span> = <span class="variable">$objFilesCache</span>-&gt;getItem(<span class="variable">$key</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null(<span class="variable">$CachedString</span>-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn&#x27;t exist</span></span><br><span class="line">    <span class="variable">$numberOfSeconds</span> = <span class="number">60</span>;</span><br><span class="line">    <span class="variable">$CachedString</span>-&gt;set(<span class="string">&quot;This website uses PhpFastCache!&quot;</span>)-&gt;expiresAfter(<span class="variable">$numberOfSeconds</span>);</span><br><span class="line">    <span class="variable">$objFilesCache</span>-&gt;save(<span class="variable">$CachedString</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Already in cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们一块一块地来理解代码。首先看到的是将 <strong>autoload.php</strong> 文件引入，然后导入要用到的 namespace：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br></pre></td></tr></table></figure>
<p>当你使用文件缓存的时候，最好提供一个目录路径来存放缓存系统生成的文件。下面的代码就是做的这件事：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for &quot;files&quot; adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">&quot;path&quot;</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">&quot;/cache&quot;</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>当然，你需要确保 <strong>cache</strong> 目录存在且 web server 有写入权限。</p>
<p>接下来，我们将缓存对象实例化，用 <strong>welcome_message</strong> 加载对应的缓存对象。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line"><span class="variable">$objFilesCache</span> = CacheManager::getInstance(<span class="string">&#x27;files&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$key</span> = <span class="string">&quot;welcome_message&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with &quot;welcome_message&quot; key</span></span><br><span class="line"><span class="variable">$CachedString</span> = <span class="variable">$objFilesCache</span>-&gt;getItem(<span class="variable">$key</span>);</span><br></pre></td></tr></table></figure>
<p>如果缓存中不存在此对象，就将它以 60s 过期时间加入缓存，并从缓存中读取与展示它。如果它存在于缓存中，则直接获取：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_null(<span class="variable">$CachedString</span>-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn&#x27;t exist</span></span><br><span class="line">    <span class="variable">$numberOfSeconds</span> = <span class="number">60</span>;</span><br><span class="line">    <span class="variable">$CachedString</span>-&gt;set(<span class="string">&quot;This website uses PhpFastCache!&quot;</span>)-&gt;expiresAfter(<span class="variable">$numberOfSeconds</span>);</span><br><span class="line">    <span class="variable">$objFilesCache</span>-&gt;save(<span class="variable">$CachedString</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Already in cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常容易上手对吧！你可以试着自己去运行一下这个程序来查看结果。</p>
<p>当你第一次运行这个程序时，应该会看到以下输出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not <span class="keyword">in</span> cache yet, we <span class="keyword">set</span> <span class="keyword">it</span> <span class="keyword">in</span> cache <span class="keyword">and</span> <span class="keyword">try</span> <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">it</span> <span class="keyword">from</span> cache!</span><br><span class="line">The value <span class="keyword">of</span> welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure>
<p>之后再运行的时候，输出会是这样：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Already in cache!</span><br><span class="line">The value of welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure>
<p>现在就能随手实现文件系统缓存了。在下一章节中，我们将模仿这个例子来使用 Redis Adapter 实现缓存。</p>
<h3 id="使用-Redis-Adapter-进行缓存"><a href="#使用-Redis-Adapter-进行缓存" class="headerlink" title="使用 Redis Adapter 进行缓存"></a>使用 Redis Adapter 进行缓存</h3><p>假定你在阅读本节前已经安装好了 Redis 服务，并让它运行在 6379 默认端口上。</p>
<p>下面进行配置。创建 <strong>redis_cache_example.php</strong> 文件并写入以下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with &quot;redis&quot; adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Make sure php-redis extension is installed along with Redis server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for &quot;redis&quot; adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;port&quot;</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line"><span class="variable">$objRedisCache</span> = CacheManager::getInstance(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$key</span> = <span class="string">&quot;welcome_message&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with &quot;welcome_message&quot; key</span></span><br><span class="line"><span class="variable">$CachedString</span> = <span class="variable">$objRedisCache</span>-&gt;getItem(<span class="variable">$key</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null(<span class="variable">$CachedString</span>-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn&#x27;t exist</span></span><br><span class="line">    <span class="variable">$numberOfSeconds</span> = <span class="number">60</span>;</span><br><span class="line">    <span class="variable">$CachedString</span>-&gt;set(<span class="string">&quot;This website uses PhpFastCache!&quot;</span>)-&gt;expiresAfter(<span class="variable">$numberOfSeconds</span>);</span><br><span class="line">    <span class="variable">$objRedisCache</span>-&gt;save(<span class="variable">$CachedString</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Already in cache!&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The value of welcome_message:&quot;</span> . <span class="variable">$CachedString</span>-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，除了初始化 Redis 适配器的配置一段之外，这个文件与之前基本一样。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for &quot;redis&quot; adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;port&quot;</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>当然如果你要在非本机运行 Redis 服务，需要根据需求修改 host 与 port 的设置。</p>
<p>运行 <strong>redis_cache_example.php</strong> 文件来查看它的工作原理。你也可以在 Redis CLI 中查看输出。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; KEYS *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;welcome_message&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上就是使用 Redis 适配器的全部内容。你可以去多试试其它不同的适配器和配置！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了 PhpFastCache 这个 PHP 中非常热门的库。在文章前半部分，我们讨论了它的基本知识以及安装和配置。在文章后半部分，我们通过几个例子来详细演示了前面提到的概念。</p>
<p>希望你喜欢这篇文章，并将 PhpFastCache 集成到你即将开发的项目中。随时欢迎提问和讨论！</p>
<blockquote>
<p>掘金：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b54d01be51d4517c5649965">https://juejin.im/post/5b54d01be51d4517c5649965</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/07/04/%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%85%83%E7%BB%84%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8D%87-Python-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/04/%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%85%83%E7%BB%84%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8D%87-Python-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/" class="post-title-link" itemprop="url">使用多重赋值与元组解包提升 Python 代码的可读性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-07-04 10:16:00" itemprop="dateCreated datePublished" datetime="2018-07-04T10:16:00+08:00">2018-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>无论是教导新手还是资深 Python 程序员，我都发现 <strong>很多 Python 程序员没有充分利用多重赋值这一特性</strong>。</p>
<p>多重赋值（也经常被称为元组解包或者可迭代对象解包）能让你在一行代码内同时对多个变量进行赋值。这种特性在学习时看起来很简单，但在真正需要使用时再去回想它可能会比较麻烦。</p>
<p>在本文中，将介绍什么是多重赋值，举一些常用的多重赋值的样例，并了解一些较少用、常被忽视的多重赋值用法。</p>
<p>请注意在本文中会用到 <a target="_blank" rel="noopener" href="https://cito.github.io/blog/f-strings/">f-strings</a> 这种 Python 3.6 以上版本才有的特性，如果你的 Python 版本较老，可以使用字符串的 <code>format</code> 方法来代替这种特性。</p>
<h2 id="多重赋值的实现原理"><a href="#多重赋值的实现原理" class="headerlink" title="多重赋值的实现原理"></a>多重赋值的实现原理</h2><p>在本文中，我将使用“多重赋值”、“元组解包”、“迭代对象解包”等不同的词，但他们其实表示的是同一个东西。</p>
<p>Python 的多重赋值如下所示：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="symbol">x</span>, <span class="symbol">y</span> = <span class="number">10</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>在这儿我们将 <code>x</code> 设为了 <code>10</code>，<code>y</code> 设为了 <code>20</code>。</p>
<p>从更底层的角度看，我们其实是创建了一个 <code>10, 20</code> 的元组，然后遍历这个元组，将拿到的两个数字按照顺序分别赋给 <code>x</code> 与 <code>y</code>。</p>
<p>写成下面这种语法应该更容易理解：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="comment">(x, y)</span> = <span class="comment">(10, 20)</span></span><br></pre></td></tr></table></figure>
<p>在 Python 中，元组周围的括号是可以忽略的，因此在“多重赋值”（写成上面这种元组形式的语法）时也可以省去。下面几行代码都是等价的：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="symbol">x</span>, <span class="symbol">y</span> = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">&gt;&gt;&gt; <span class="symbol">x</span>, <span class="symbol">y</span> = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; (<span class="symbol">x</span>, <span class="symbol">y</span>) = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">&gt;&gt;&gt; (<span class="symbol">x</span>, <span class="symbol">y</span>) = (<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>多重赋值常被直接称为“元组解包”，因为它在大多数情况下都是用于元组。但其实我们可以用除了元组之外的任何可迭代对象进行多重赋值。下面是使用列表（list）的结果：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x, y = [<span class="number">10</span>, <span class="number">20</span>]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x</span></span><br><span class="line">10</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">y</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>下面是使用字符串（string）的结果：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="symbol">x</span>, <span class="symbol">y</span> = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="symbol">x</span></span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="symbol">y</span></span><br><span class="line"><span class="string">&#x27;i&#x27;</span></span><br></pre></td></tr></table></figure>
<p>任何可以用于循环的东西都能和元组解包、多重赋值一样被“解开”。</p>
<p>下面是另一个可以证明多重赋值能用于任何数量、任何变量（甚至是我们自己创建的对象）的例子：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">point = <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x, y, z = point</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">print(x, y, z)</span></span><br><span class="line">10 20 30</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">(x, y, z) = (z, y, x)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">print(x, y, z)</span></span><br><span class="line">30 20 10</span><br></pre></td></tr></table></figure>
<p>请注意，在上面例子中的最后一行我们仅交换了变量的名称。多重赋值可以让我们轻松地实现这种情形。</p>
<p>下面我们将讨论如何使用多重赋值。</p>
<h2 id="在-for-循环中解包"><a href="#在-for-循环中解包" class="headerlink" title="在 for 循环中解包"></a>在 for 循环中解包</h2><p>你会经常在 <code>for</code> 循环中看到多重赋值。下面举例说明：</p>
<p>先创建一个字典（dict）：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">person_dictionary = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;Trey&quot;</span>, <span class="string">&#x27;company&#x27;</span>: <span class="string">&quot;Truthful Technology LLC&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>下面这种循环遍历字典的方法比较少见：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> person_dictionary.items():</span><br><span class="line">    print(<span class="string">f&quot;Key <span class="subst">&#123;item[<span class="number">0</span>]&#125;</span> has value <span class="subst">&#123;item[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>但你会经常看到 Python 程序员通过多重赋值来这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> person_dictionary.items():</span><br><span class="line">    print(<span class="string">f&quot;Key <span class="subst">&#123;key&#125;</span> has value <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当你在 for 循环中写 <code>for X in Y</code> 时，其实是告诉 Python 在循环的每次遍历时都对 <code>X</code> 做一次赋值。与用 <code>=</code> 符号赋值一样，这儿也可以使用多重赋值。</p>
<p>这种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> person_dictionary.items():</span><br><span class="line">    print(<span class="string">f&quot;Key <span class="subst">&#123;key&#125;</span> has value <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在本质上与这种写法是一致的：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">item</span> <span class="keyword">in</span> person_dictionary.<span class="keyword">items</span>():</span><br><span class="line">    key, <span class="built_in">value</span> = <span class="keyword">item</span></span><br><span class="line">    print(f<span class="string">&quot;Key &#123;key&#125; has value &#123;value&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>与前一个例子相比，我们其实就是去掉了一个没有必要的额外赋值。</p>
<p>因此，多重赋值在用于将字典元素解包为键值对时十分有用。此外，它还在其它地方也可以使用：</p>
<p>在内置函数 <code>enumerate</code> 的值拆分成对时，也是多重赋值的一个很有用的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_file):</span><br><span class="line">    print(<span class="string">f&quot;Line <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>还有 <code>zip</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> color, ratio <span class="keyword">in</span> <span class="built_in">zip</span>(colors, ratios):</span><br><span class="line">    print(<span class="string">f&quot;It&#x27;s <span class="subst">&#123;ratio*<span class="number">100</span>&#125;</span>% <span class="subst">&#123;color&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (product, price, color) <span class="keyword">in</span> <span class="built_in">zip</span>(products, prices, colors):</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;product&#125;</span> is <span class="subst">&#123;color&#125;</span> and costs $<span class="subst">&#123;price:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果你还对 <code>enumerate</code> 和 <code>zip</code> 不熟悉，请参阅作者之前的文章 <a target="_blank" rel="noopener" href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes in Python</a>。</p>
<p>有些 Python 新手经常在 <code>for</code> 循环中看到多重赋值，然后就认为它只能与循环一起使用。但其实，多重赋值不仅可以用在循环赋值时，还可以用在其它任何需要赋值的地方。</p>
<h2 id="替代硬编码索引"><a href="#替代硬编码索引" class="headerlink" title="替代硬编码索引"></a>替代硬编码索引</h2><p>很少有人在代码中对索引进行硬编码（比如 <code>point[0]</code>、<code>items[1]</code>、<code>vals[-1]</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f&quot;The first item is <span class="subst">&#123;items[<span class="number">0</span>]&#125;</span> and the last item is <span class="subst">&#123;items[-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当你在 Python 代码中看到有硬编码索引时，一般都可以设法<strong>使用多重赋值来让你的代码更具可读性</strong>。</p>
<p>下面是一些使用了硬编码索引的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reformat_date</span>(<span class="params">mdy_date_string</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reformat MM/DD/YYYY string into YYYY-MM-DD string.&quot;&quot;&quot;</span></span><br><span class="line">    date = mdy_date_string.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;date[<span class="number">2</span>]&#125;</span>-<span class="subst">&#123;date[<span class="number">0</span>]&#125;</span>-<span class="subst">&#123;date[<span class="number">1</span>]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过多重赋值，分别对月、天、年三个变量进行赋值，让代码更具可读性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reformat_date</span>(<span class="params">mdy_date_string</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reformat MM/DD/YYYY string into YYYY-MM-DD string.&quot;&quot;&quot;</span></span><br><span class="line">    month, day, year = mdy_date_string.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>-<span class="subst">&#123;month&#125;</span>-<span class="subst">&#123;day&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>因此当你准备对索引进行硬编码时，请停下来想一想是不是应该用多重赋值来改善代码的可读性。</p>
<h2 id="多重赋值是十分严格的"><a href="#多重赋值是十分严格的" class="headerlink" title="多重赋值是十分严格的"></a>多重赋值是十分严格的</h2><p>在我们对可迭代对象进行解包时，多重赋值的条件是非常严格的。</p>
<p>如果将一个较大的可迭代对象解包到一组数量更小的对象中，会报下面的错误：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">x</span>, <span class="keyword">y</span> = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="built_in">line</span> <span class="number">1</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">ValueError: too many <span class="built_in">values</span> <span class="keyword">to</span> unpack (expected <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果将一个较小的可迭代对象解包到一组数量更多的对象中，会报下面的错误：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">x</span>, <span class="keyword">y</span>, <span class="keyword">z</span> = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="built_in">line</span> <span class="number">1</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">ValueError: not enough <span class="built_in">values</span> <span class="keyword">to</span> unpack (expected <span class="number">3</span>, got <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这种严格的限制其实很棒，如果我们在处理元素时出现了非预期的对象数量，多重赋值会直接报错，这样我们就能发现一些还没有被发现的 bug。</p>
<p>举个例子。假设我们有一个简单的命令行程序，通过原始的方式接受参数，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">new_file = sys<span class="selector-class">.argv</span>[<span class="number">1</span>]</span><br><span class="line">old_file = sys<span class="selector-class">.argv</span>[<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(f<span class="string">&quot;Copying &#123;new_file&#125; to &#123;old_file&#125;&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这个程序希望接受两个参数，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_program<span class="selector-class">.py</span> file1<span class="selector-class">.txt</span> file2.txt</span><br><span class="line">Copying file1<span class="selector-class">.txt</span> to file2.txt</span><br></pre></td></tr></table></figure>
<p>但如果在运行程序时输入了三个参数，也不会有任何报错：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_program<span class="selector-class">.py</span> file1<span class="selector-class">.txt</span> file2<span class="selector-class">.txt</span> file3.txt</span><br><span class="line">Copying file1<span class="selector-class">.txt</span> to file2.txt</span><br></pre></td></tr></table></figure>
<p>由于我们没有验证接收到的参数是否为 2 个，因此不会报错。</p>
<p>如果使用多重赋值来代替硬编码索引，在赋值时将会验证程序是否真的接收到了期望个数的参数：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="literal">_</span>, <span class="keyword">new</span><span class="type">_file</span>, old_file = sys.argv</span><br><span class="line">print(f<span class="string">&quot;Copying &#123;new_file&#125; to &#123;old_file&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 我们用了一个名为 <code>_</code> 的变量，意思是我们不想关注 <code>sys.argv[0]</code>（对应的是我们程序的名称）。用 <code>_</code> 对象来忽略不需关注的变量是一种常用的语法。</p>
<h2 id="替代数组拆分"><a href="#替代数组拆分" class="headerlink" title="替代数组拆分"></a>替代数组拆分</h2><p>根据上文，我们一直多重赋值可以用来代替硬编码的索引，并且它严格的条件可以确保我们处理的元组或可迭代对象的大小是正确的。</p>
<p>此外，多重赋值还能用于代替硬编码的数组拆分。</p>
<p>“拆分”是一种手动将 list 或其它序列中的部分元素取出的方法、</p>
<p>下面是一种用数字索引进行“硬编码”拆分的方法：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all_after_first</span> = items[<span class="number">1</span>:]</span><br><span class="line"><span class="attr">all_but_last_two</span> = items[:-<span class="number">2</span>]</span><br><span class="line"><span class="attr">items_with_ends_removed</span> = items[<span class="number">1</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>当你在拆分时发现没有在拆分索引中用到变量，那么就能用多重赋值来替代它。为了实现多重赋值拆分数组，我们将用到一个之前没提过的特性：<code>*</code> 符号。</p>
<p><code>*</code> 符号于 Python 3 中加入了多重赋值的语法中，它可以让我们在解包时拿到“剩余”的元素：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">first, *rest = numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">rest</span></span><br><span class="line">[2, 3, 4, 5, 6]</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">first</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>因此，<code>*</code> 可以让我们在取数组末尾时替换硬编码拆分。</p>
<p>下面两行是等价的：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">beginning</span>, <span class="keyword">last</span> = numbers[:<span class="number">-1</span>], numbers[<span class="number">-1</span>]</span><br><span class="line">&gt;&gt;&gt; *<span class="keyword">beginning</span>, <span class="keyword">last</span> = numbers</span><br></pre></td></tr></table></figure>
<p>下面两行也是等价的：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; head, middle, tail = numbers[<span class="number">0</span>], numbers[<span class="number">1</span>:-<span class="number">1</span>], numbers[<span class="number">-1</span>]</span><br><span class="line">&gt;&gt;&gt; head, *middle, tail = numbers</span><br></pre></td></tr></table></figure>
<p>有了 <code>*</code> 和多重赋值之后，你可以替换一切类似于下面这样的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span>(<span class="selector-tag">sys</span><span class="selector-class">.argv</span><span class="selector-attr">[0]</span>, <span class="selector-tag">sys</span><span class="selector-class">.argv</span><span class="selector-attr">[1:]</span>)</span><br></pre></td></tr></table></figure>
<p>可以写成下面这种更具自描述性的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">program_name, *arguments = sys.argv</span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(program_name, arguments)</span></span></span><br></pre></td></tr></table></figure>
<p>总之，如果你写了硬编码的拆分代码，请考虑一下你可以用多重赋值来让这些拆分的逻辑更加清晰。</p>
<h2 id="深度解包"><a href="#深度解包" class="headerlink" title="深度解包"></a>深度解包</h2><p>这个特性是 Python 程序员长期以来经常忽略的一个东西。它虽然不如我之前提到的几种多重复值用法常用，但是当你用到它的时候会深刻体会到它的好处。</p>
<p>在前文，我们已经看到多重赋值用于解包元组或者其它的可迭代对象，但还没看过它<strong>更进一步</strong>地进行深度解包。</p>
<p>下面例子中的多重赋值是<strong>浅度</strong>的，因为它只进行了一层的解包：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">color, point = (<span class="string">&quot;red&quot;</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">color</span></span><br><span class="line">&#x27;red&#x27;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">point</span></span><br><span class="line">(1, 2, 3)</span><br></pre></td></tr></table></figure>
<p>而下面这种多重赋值可以认为是<strong>深度</strong>的，因为它将 <code>point</code> 元组也进一步解包成了 <code>x</code>、<code>y</code>、<code>z</code> 变量：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">color, (x, y, z) = (<span class="string">&quot;red&quot;</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">color</span></span><br><span class="line">&#x27;red&#x27;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">y</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>上面的例子可能比较让人迷惑，所以我们在赋值语句两端加上括号来让这个例子更加明了：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (<span class="name">color</span>, (<span class="name">x</span>, y, z)) = (<span class="string">&quot;red&quot;</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到在第一层解包时得到了两个对象，但是这个语句将第二个对象再次解包，得到了另外的三个对象。然后将第一个对象及新解出的三个对象赋值给了新的对象（<code>color</code>、<code>x</code>、<code>y</code>、<code>z</code>）。</p>
<p>下面以这两个 list 为例：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_points = [(1, 2), (3, 4), (5, 6)]</span><br><span class="line">end_points = [(<span class="string">-1</span>, <span class="string">-2</span>), (<span class="string">-3</span>, 4), (<span class="string">-6</span>, <span class="string">-5</span>)]</span><br></pre></td></tr></table></figure>
<p>下面的代码是举例用浅层解包来处理上面的两个 list：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">start</span>, <span class="function"><span class="keyword">end</span> <span class="title">in</span> <span class="title">zip</span>(<span class="title">start_points</span>, <span class="title">end_points</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">start</span>[<span class="number">0</span>] == -<span class="keyword">end</span>[<span class="number">0</span>] <span class="keyword">and</span> <span class="built_in">start</span>[<span class="number">1</span>] == -<span class="keyword">end</span>[<span class="number">1</span>]:</span><br><span class="line">        print(f<span class="string">&quot;Point &#123;start[0]&#125;,&#123;start[1]&#125; was negated.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面用深度解包来做同样的事情：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> (x<span class="number">1</span>, y<span class="number">1</span>), (x<span class="number">2</span>, y<span class="number">2</span>) in zip(start_points, end_points):</span><br><span class="line">    <span class="attribute">if</span> x<span class="number">1</span> == -x<span class="number">2</span> and y<span class="number">1</span> == -y<span class="number">2</span>:</span><br><span class="line">        <span class="attribute">print</span>(f<span class="string">&quot;Point &#123;x1&#125;,&#123;y1&#125; was negated.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>请注意在第二个例子中，在处理对象时，对象的类型明显更加清晰易懂。深度解包让我们可以明显的看到，在每次循环中我们都会收到两个二元组。</p>
<p>深度解包通常会在每次得到多个元素的嵌套循环中使用。例如，你能在同时使用 <code>enumerate</code> 与 <code>zip</code> 时应用深度多重赋值：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">items</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i, (<span class="keyword">first</span>, <span class="keyword">last</span>) <span class="keyword">in</span> enumerate(zip(<span class="keyword">items</span>, reversed(<span class="keyword">items</span>))):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">first</span> != <span class="keyword">last</span>:</span><br><span class="line">        raise ValueError(f<span class="string">&quot;Item &#123;i&#125; doesn&#x27;t match: &#123;first&#125; != &#123;last&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>前面我提到过多重赋值对于可迭代对象的大小以及解包的大小是非常严格的，在复读解包中我们也可以利用这点<strong>严格控制可迭代对象的大小</strong>。</p>
<p>这么写可以正常运行：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2), (-1, -2))</span><br><span class="line">&gt;&gt;&gt; points<span class="comment">[0]</span><span class="comment">[0]</span> == -points<span class="comment">[1]</span><span class="comment">[0]</span> and points<span class="comment">[0]</span><span class="comment">[1]</span> == -point<span class="comment">[1]</span><span class="comment">[1]</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>这种看起来 bug 的代码也能正常运行：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))</span><br><span class="line">&gt;&gt;&gt; points<span class="comment">[0]</span><span class="comment">[0]</span> == -points<span class="comment">[1]</span><span class="comment">[0]</span> and points<span class="comment">[0]</span><span class="comment">[1]</span> == -point<span class="comment">[1]</span><span class="comment">[1]</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>这种写法也能运行：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">points = ((<span class="number">1</span>, <span class="number">2</span>), (-<span class="number">1</span>, -<span class="number">2</span>))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">(x1, y1), (x2, y2) = points</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x1 == -x2 <span class="keyword">and</span> y1 == -y2</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>但是这样不行：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>), (-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>), (<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&gt;&gt;&gt; (x1, y1), (x2, y2) = points</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="built_in">line</span> <span class="number">1</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">ValueError: too many <span class="built_in">values</span> <span class="keyword">to</span> unpack (expected <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在给变量多重赋值时我们其实也对可迭代对象做了一次特殊的断言（assert）。因此多重赋值既能让别人更容易理清你的代码（<strong>因为有着更好的代码可读性</strong>），也能让电脑更好地理解你的代码（<strong>因为对代码进行了确认保证了正确性</strong>）。</p>
<h2 id="使用-list-类型语法"><a href="#使用-list-类型语法" class="headerlink" title="使用 list 类型语法"></a>使用 list 类型语法</h2><p>在前文我提到的多重赋值都用的是元组类型的语法（tuple-like），但其实多重赋值可以用于任何可迭代对象。而这种类似元组的语法也使得多重赋值常被称为“元组解包”。而更准确地来说，多重赋值应该叫做“可迭代对象解包”。</p>
<p>前文中我还没有提到过，多重赋值可以写成 list 类型的语法（list-like）。</p>
<p>下面是一个应用 list 语法的最简单多重赋值示例：</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">[x, y, z] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">x</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这种写法看起来很奇怪。为什么在元组语法之外还要允许这种 list 语法呢？</p>
<p>我也很少使用这种特性，但它在一些特殊情况下能让代码更加<strong>简洁</strong>。</p>
<p>举例，假设我有下面这种代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">def</span> <span class="selector-tag">most_common</span>(items):</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">Counter</span>(items)<span class="selector-class">.most_common</span>(<span class="number">1</span>)<span class="selector-attr">[0]</span><span class="selector-attr">[0]</span></span><br></pre></td></tr></table></figure>
<p>我们用心良苦的同事决定用深度多重赋值将代码重构成下面这样：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most<span class="constructor">_common(<span class="params">items</span>)</span>:</span><br><span class="line">    (value, times_seen), = <span class="constructor">Counter(<span class="params">items</span>)</span>.most<span class="constructor">_common(1)</span></span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<p>看到赋值语句左侧的最后一个逗号了吗？很容易会将它漏掉，而且这个逗号让代码看起来不伦不类。这个逗号在这段代码中是做什么事的呢？</p>
<p>此处的尾部逗号其实是构造了一个单元素的元组，然后对此处进行深度解包。</p>
<p>可以将上面的代码换种写法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most<span class="constructor">_common(<span class="params">items</span>)</span>:</span><br><span class="line">    ((value, times_seen),) = <span class="constructor">Counter(<span class="params">items</span>)</span>.most<span class="constructor">_common(1)</span></span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<p>这种写法让深度解包的语法更加明显了。但我更喜欢下面这种写法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most<span class="constructor">_common(<span class="params">items</span>)</span>:</span><br><span class="line">    <span class="literal">[(<span class="identifier">value</span>, <span class="identifier">times_seen</span>)]</span> = <span class="constructor">Counter(<span class="params">items</span>)</span>.most<span class="constructor">_common(1)</span></span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<p>赋值中的 list 语法让它更加的清晰，可以明确看出我们将一个单元素可迭代对象进行了解包，并将单元素又解包并赋值给 <code>value</code> 与 <code>times_seen</code> 对象。</p>
<p>当我看到这种代码时，可以非常确定我们解包的是一个单元组 list（事实上代码做的也正是这个）。我们在此处用了 collections 模组中的 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter</a> 对象。<code>Counter</code> 对象的 <code>most_common</code> 方法可以让我们指定返回 list 的长度。在此处我们将 list 限制为仅返回一个元素。</p>
<p>当你在解包有很多的值的结构（比如说 list）或者有确定个数值的结构（比如说元组）时，可以考虑用 list 语法来对这些类似 list 的结构进行解包，这样能让代码更加具有“语法正确性”。</p>
<p>如果你乐意，还可以用对类 list 结构使用 list 语法解包时应用一些 list 的语法（常见的例子为在多重赋值时使用 <code>*</code> 符号）：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [<span class="keyword">first</span>, *<span class="built_in">rest</span>] = numbers</span><br></pre></td></tr></table></figure>
<p>我自己其实不常用这种写法，因为我没有这个习惯。但如果你觉得这种写法有用，可以考虑在你自己的代码中用上它。</p>
<p>结论：当你在代码中用多重赋值时，可以考虑在何时的时候用 list 语法来让你的代码更具自解释性并更加简洁。这有时也能提升代码的可读性。</p>
<h2 id="不要忘记这些多重赋值的用法"><a href="#不要忘记这些多重赋值的用法" class="headerlink" title="不要忘记这些多重赋值的用法"></a>不要忘记这些多重赋值的用法</h2><p>多重赋值可以提高代码的可读性与正确性。它能使你代码<strong>更具自描述性</strong>，同时也可以对正在进行解包的可迭代对象的<strong>大小</strong>进行隐式断言。</p>
<p>据我观察，人们经常忘记多重赋值可以<strong>替换硬编码索引</strong>，以及<strong>替换硬编码拆分</strong>（用 <code>*</code> 语法）。深度多重赋值，以及同时使用元组语法和 list 语法也常被忽视。</p>
<p>认清并记住所有多重赋值的用例是很麻烦的。请随意使用本文作为你使用多重赋值的参考指南。</p>
<blockquote>
<p>juejin: <a target="_blank" rel="noopener" href="https://juejin.im/post/5b3c2cf1e51d451925625b94">https://juejin.im/post/5b3c2cf1e51d451925625b94</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/06/04/%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/04/%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F/" class="post-title-link" itemprop="url">什么是 JavaScript 生成器？如何使用生成器？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-06-04 16:47:00" itemprop="dateCreated datePublished" datetime="2018-06-04T16:47:00+08:00">2018-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg" alt=""></p>
<p>在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。</p>
<h3 id="什么是-JavaScript-生成器？"><a href="#什么是-JavaScript-生成器？" class="headerlink" title="什么是 JavaScript 生成器？"></a>什么是 JavaScript 生成器？</h3><p>生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。</p>
<p>上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 <strong>for 循环</strong>之类的迭代器有什么区别。</p>
<p>下面是一个 <strong>for 循环</strong>的例子，它会在执行后立刻返回一些值。这段代码其实就是简单地生成了 0-5 这些数字。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 它将会立刻返回 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>现在看看生成器函数。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * generatorForLoop(num) &#123;</span><br><span class="line">  <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; num; i += <span class="number">1</span>) &#123;</span><br><span class="line">    yield console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const genForLoop = generatorForLoop(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">genForLoop.<span class="keyword">next</span>(); <span class="regexp">//</span> 首先 console.log - <span class="number">0</span></span><br><span class="line">genForLoop.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">genForLoop.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line">genForLoop.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="number">3</span></span><br><span class="line">genForLoop.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>它做了什么？它实际上只是对上面例子中的 <strong>for 循环</strong>做了一点改动，但产生了很大的变化。这种变化是由生成器最重要的特性造成的 —— 只有在需要的时候它才会产生下一个值，而不会一次性产生所有的值。在某些情景下，这种特性十分方便。</p>
<h3 id="生成器语法"><a href="#生成器语法" class="headerlink" title="生成器语法"></a>生成器语法</h3><p>如何定义一个生成器函数呢？下面列出了各种可行的定义方法，不过万变不离其宗的是在函数关键词后加上一个星号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = *<span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> generator = ()* =&gt; &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="function">(<span class="params">*</span>) =&gt;</span> &#123;&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>如上面的例子所示，我们并不能使用箭头函数来创建一个生成器。</p>
<p>下面将生成器作为方法（method）来创建。定义方法与定义函数的方式是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  *<span class="function"><span class="title">generator</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  * <span class="function"><span class="title">generator</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  *<span class="function"><span class="title">generator</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  * <span class="function"><span class="title">generator</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>现在让我们一起看看新的关键词 <code>yield</code>。它有些类似 <code>return</code>，但又不完全相同。<code>return</code> 会在完成函数调用后简单地将值返回，在 <code>return</code> 语句之后你无法进行任何操作。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">with</span><span class="constructor">Return(<span class="params">a</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">5</span>;</span><br><span class="line">  return a + b;</span><br><span class="line">  b = <span class="number">6</span>; <span class="comment">// 不可能重新定义 b 了</span></span><br><span class="line">  return a<span class="operator"> * </span>b; <span class="comment">// 这儿新的值没可能返回了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span><span class="constructor">Return(6)</span>; <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">with</span><span class="constructor">Return(6)</span>; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>而 <code>yield</code> 的工作方式却不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">withYield</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">yield</span> a + b;</span><br><span class="line">  b = <span class="number">6</span>; <span class="comment">// 在第一次调用后仍可以重新定义变量</span></span><br><span class="line">  <span class="keyword">yield</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calcSix = withYield(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">calcSix.next().value; <span class="comment">// 11</span></span><br><span class="line">calcSix.next().value; <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>
<p>用 <code>yield</code> 返回的值只会返回一次，当你再次调用同一个函数的时候，它会执行至下一个 <code>yield</code> 语句处（译者注：前面的 <code>yield</code> 不再返回东西了）。</p>
<p>在生成器中，我们通常会在输出时得到一个对象。这个对象有两个属性：<code>value</code> 与 <code>done</code>。如你所想，<code>value</code> 为返回值，<code>done</code> 则会显示生成器是否完成了它的工作。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">*</span> <span class="string">generator()</span> &#123;</span><br><span class="line">  <span class="string">yield</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">const</span> <span class="string">gen</span> <span class="string">=</span> <span class="string">generator();</span></span><br><span class="line"></span><br><span class="line"><span class="string">gen.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">5</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="string">gen.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="string">undefined</span>, <span class="attr">done:</span> <span class="literal">true</span>&#125;</span><br><span class="line"><span class="string">gen.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="string">undefined</span>, <span class="attr">done:</span> <span class="literal">true</span>&#125; <span class="bullet">-</span> <span class="string">之后的任何调用都会返回相同的结果</span></span><br></pre></td></tr></table></figure>
<p>在生成器中，不仅可以使用 <code>yield</code>，也可以使用 <code>return</code> 来返回同样的对象。但是，在函数执行到第一个 <code>return</code> 语句的时候，生成器将结束它的工作。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>; <span class="regexp">//</span> 到不了这个 <span class="keyword">yield</span> 了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yield-委托迭代"><a href="#yield-委托迭代" class="headerlink" title="yield 委托迭代"></a>yield 委托迭代</h4><p>带星号的 <code>yield</code> 可以将它的工作委托给另一个生成器。通过这种方式，你就能将多个生成器连接在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* anotherGenerator(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">gen.next().value; <span class="comment">// 2</span></span><br><span class="line">gen.next().value; <span class="comment">// 3</span></span><br><span class="line">gen.next().value; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>在开始下一节前，我们先观察一个第一眼看上去比较奇特的行为。</p>
<p>下面是正常的代码，不会报出任何错误，这表明 <code>yield</code> 可以在 <code>next()</code> 方法调用后返回传递的值：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arr) &#123;</span><br><span class="line">  <span class="keyword">for</span> (const i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">yield</span>;</span><br><span class="line">    <span class="keyword">yield</span>(<span class="keyword">yield</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator([<span class="number">0</span>,<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;0&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;A&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;A&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;A&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;A&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;A&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;A&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;1&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;B&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;B&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;B&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;B&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(<span class="string">&#x27;B&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;B&quot;</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你可以看到 <code>yield</code> 默认是 <code>undefined</code>，但如果我们在调用 <code>yield</code> 时传递了任何值，它就会返回我们传入的值。我们将很快利用这个特性。</p>
<h4 id="初始化与方法"><a href="#初始化与方法" class="headerlink" title="初始化与方法"></a>初始化与方法</h4><p>生成器是可以被复用的，但是你需要对它们进行初始化。还好初始化的方法十分简单。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params">arg = <span class="string">&#x27;Nothing&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen0 = <span class="built_in">generator</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> gen1 = <span class="built_in">generator</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> gen2 = <span class="keyword">new</span> <span class="built_in">generator</span>(); <span class="comment">// 不 OK</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">generator</span>().next(); <span class="comment">// 可以运行，但每次都会从头开始运行</span></span><br></pre></td></tr></table></figure>
<p>如上所示，<code>gen0</code> 与 <code>gen1</code> 不会互相影响，<code>gen2</code> 完全不会运行（会报错）。因此初始化对于保证程序流程的状态是十分重要的。</p>
<p>下面让我们一起看看生成器给我们提供的方法。</p>
<p><strong>next() 方法</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">3</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125; 之后所有的 <span class="keyword">next</span> 调用都会返回同样的输出</span><br></pre></td></tr></table></figure>
<p>这是最常用的方法。它每次被调用时都会返回下一个对象。在生成器工作结束时，<code>next()</code> 会将 <code>done</code> 属性设为 <code>true</code>，<code>value</code> 属性设为 <code>undefined</code>。</p>
<p>我们不仅可以用 <code>next()</code> 来迭代生成器，还可以用 <code>for of</code> 循环来一次得到生成器所有的值（而不是对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">in</span> arr)</span><br><span class="line">    <span class="keyword">yield</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> g <span class="keyword">of</span> gen) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(g); <span class="comment">// 0 -&gt; 1 -&gt; 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>但它不适用于 <code>for in</code> 循环，并且不能直接用数字下标来访问属性：<code>generator[0] = undefined</code>。</p>
<p><strong>return() 方法</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">return</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br><span class="line">gen.<span class="keyword">return</span>(<span class="string">&#x27;Heeyyaa&#x27;</span>); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="string">&quot;Heeyyaa&quot;</span>, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125; - 在 <span class="keyword">return</span>() 之后的所有 <span class="keyword">next</span>() 调用都会返回相同的输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>return()</code> 将会忽略生成器中的任何代码。它会根据传值设定 <code>value</code>，并将 <code>done</code> 设为 <code>true</code>。任何在 <code>return()</code> 之后进行的 <code>next()</code> 调用都会返回 <code>done</code> 属性为 <code>true</code> 的对象。</p>
<p><strong>throw() 方法</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="built_in">generator</span>();</span><br><span class="line"></span><br><span class="line">gen.<span class="keyword">throw</span>(<span class="string">&#x27;Something bad&#x27;</span>); <span class="comment">// 会报错 Error Uncaught Something bad</span></span><br><span class="line">gen.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>throw()</code> 做的事非常简单 —— 就是抛出错误。我们可以用 <code>try-catch</code> 来处理。</p>
<h4 id="自定义方法的实现"><a href="#自定义方法的实现" class="headerlink" title="自定义方法的实现"></a>自定义方法的实现</h4><p>由于我们无法直接访问 <code>Generator</code> 的 constructor，因此如何增加新的方法需要另外说明。下面是我的方法，你也可以用不同的方式实现：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generator</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;constructor: GeneratorFunction, <span class="built_in">next</span>: ƒ, <span class="keyword">return</span>: ƒ, throw: ƒ, Symbol(Symbol.toStringTag): <span class="string">&quot;Generator&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">// 由于 Generator 不是一个全局变量，因此我们只能这么写：</span><br><span class="line">generator.prototype.__proto__.<span class="built_in">math</span> = <span class="function"><span class="keyword">function</span><span class="params">(e = 0)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e * Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;<span class="built_in">math</span>: ƒ, constructor: GeneratorFunction, <span class="built_in">next</span>: ƒ, <span class="keyword">return</span>: ƒ, throw: ƒ, …&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line">gen.<span class="built_in">math</span>(<span class="number">1</span>); // <span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure>
<h4 id="生成器的用途"><a href="#生成器的用途" class="headerlink" title="生成器的用途"></a>生成器的用途</h4><p>在前面，我们用了已知迭代次数的生成器。但如果我们不知道要迭代多少次会怎么样呢？为了解决这个问题，需要在生成器函数中创建一个无限循环。下面以一个会返回随机数的函数为例进行演示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">randomFrom</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">yield</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRandom = randomFrom(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">getRandom.next().value; <span class="comment">// 返回随机的一个数</span></span><br></pre></td></tr></table></figure>
<p>这是个简单的例子。下面来举一些更复杂的函数为例，我们要写一个节流（throttle）函数。如果你还不知道节流函数是什么，请参阅<a target="_blank" rel="noopener" href="https://medium.com/@_jh3y/throttling-and-debouncing-in-javascript-b01cad5c8edf">这篇文章</a>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">throttle</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timerID = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerID);</span><br><span class="line">    timerID = <span class="built_in">setTimeout</span>(func.bind(<span class="built_in">window</span>, arg), time);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    throttled(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thr = throttle(<span class="built_in">console</span>.log, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">thr.next(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">thr.next(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 返回 &#123;value: undefined, done: false&#125; ，然后 1 秒后输出 &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><br>还有没有更好的利用生成器的例子呢？如果你了解递归，那你肯定听过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fibonacci_number">斐波那契数列</a>。通常我们是用递归来解决这个问题的，但有了生成器后，可以这样写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">*</span> <span class="string">fibonacci(seed1,</span> <span class="string">seed2)</span> &#123;</span><br><span class="line">  <span class="string">while</span> <span class="string">(true)</span> &#123;</span><br><span class="line">    <span class="string">yield</span> <span class="string">(()</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">      <span class="string">seed2</span> <span class="string">=</span> <span class="string">seed2</span> <span class="string">+</span> <span class="string">seed1;</span></span><br><span class="line">      <span class="string">seed1</span> <span class="string">=</span> <span class="string">seed2</span> <span class="bullet">-</span> <span class="string">seed1;</span></span><br><span class="line">      <span class="string">return</span> <span class="string">seed2;</span></span><br><span class="line">    &#125;<span class="string">)();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">const</span> <span class="string">fib</span> <span class="string">=</span> <span class="string">fibonacci(0,</span> <span class="number">1</span><span class="string">);</span></span><br><span class="line"><span class="string">fib.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">1</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="string">fib.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">2</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="string">fib.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">3</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="string">fib.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">5</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br><span class="line"><span class="string">fib.next();</span> <span class="string">//</span> &#123;<span class="attr">value:</span> <span class="number">8</span>, <span class="attr">done:</span> <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不再需要递归了！我们可以在需要的时候获得数列中的下一个数字。</p>
<h4 id="将生成器用在-HTML-上"><a href="#将生成器用在-HTML-上" class="headerlink" title="将生成器用在 HTML 上"></a>将生成器用在 HTML 上</h4><p>既然是讨论 JavaScript，那显然要用生成器来操作下 HTML。</p>
<p>假设有一些 HTML 块需要处理，可以使用生成器来轻松实现。（当然除了生成器之外还有很多方法可以做到）</p>
<p>我们只需要少许代码就能完成此需求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strings = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.string&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> className = <span class="string">&#x27;darker&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">addClassToEach</span>(<span class="params">elements, className</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> <span class="built_in">Array</span>.from(elements))</span><br><span class="line">    <span class="keyword">yield</span> el.classList.add(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addClassToStrings = addClassToEach(strings, className);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (addClassToStrings.next().done)</span><br><span class="line">    el.target.classList.add(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>仅有 5 行逻辑代码。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还有更多使用生成器的方法。例如，在进行异步操作或者按需循环时生成器也非常有用。</p>
<p>我希望这篇文章能帮你更好地理解 JavaScript 生成器。</p>
<blockquote>
<p>掘金地址：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b14faf2f265da6e4d5af3b9">https://juejin.im/post/5b14faf2f265da6e4d5af3b9</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/05/19/%E5%8F%AF%E7%94%A8%E4%BD%86%E6%9C%80%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-HTML5-%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/19/%E5%8F%AF%E7%94%A8%E4%BD%86%E6%9C%80%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-HTML5-%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">可用但最不常见的 HTML5 标签</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-19 21:33:00" itemprop="dateCreated datePublished" datetime="2018-05-19T21:33:00+08:00">2018-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>&lt;!DOCTYPE html&gt;</code> HMLT5 于 2014 年 10 月由万维网联盟（W3C）发布，旨在通过改进 HTML 语言来支持最新的多媒体设备，在保证计算机与设备（如 Web 浏览器，解析器等）可解析的前提下增强对人类的可读性。</p>
<p><img src="/images/pasted-321.png" alt="upload successful"></p>
<p>我可以确定你们都已经在使用 HTML5 做网页了，并且会使用一些常见的标签，如 <code>&lt;header&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code> 和 <code>&lt;footer&gt;</code> 等等，除此之外，还有一些不常用的标签是有助于正确使用 HTML5 的语义化开发。</p>
<p>在此我将其中一些最重要的标签列出来，希望能帮助你遵循 HTML5 语义进行开发。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/05/19/%E5%8F%AF%E7%94%A8%E4%BD%86%E6%9C%80%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-HTML5-%E6%A0%87%E7%AD%BE/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/05/16/%E7%94%B1-Node-js-%E5%8F%91%E9%80%81-Web-%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/16/%E7%94%B1-Node-js-%E5%8F%91%E9%80%81-Web-%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/" class="post-title-link" itemprop="url">由 Node.js 发送 Web 推送通知</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-16 22:03:00" itemprop="dateCreated datePublished" datetime="2018-05-16T22:03:00+08:00">2018-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service workers API</a> 可以让你直接由 Node.js 应用向 Chrome 浏览器发送推送通知。<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/web-push"><code>web-push</code> npm 模组</a>可以让你免去 <a target="_blank" rel="noopener" href="https://www.pubnub.com/">PubNub</a> 之类的中间商，直接推送消息。本文将在前端使用原生 JavaScript，在后端使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/express">Express</a> 框架，通过一个“Hello, World”级别的样例来带你了解如何进行 web 推送通知。最终的效果如下图所示。本项目的全部源码可在 <a target="_blank" rel="noopener" href="https://github.com/vkarpov15/web-push-demo">GitHub</a> 查阅。</p>
<p><img src="/images/pasted-318.png" alt="upload successful"></p>
<h2 id="鉴权及配置服务端"><a href="#鉴权及配置服务端" class="headerlink" title="鉴权及配置服务端"></a>鉴权及配置服务端</h2><p>要设置 web 推送，必须先创建 <a target="_blank" rel="noopener" href="https://blog.mozilla.org/services/2016/04/04/using-vapid-with-webpush/">VAPID keys</a>。VAPID keys 用于识别是谁发送了推送消息。npm 的 <code>web-push</code> 模组能够<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/web-push#command-line">帮助你生成 VAPID keys</a>，下面我们将安装 <code>web-push</code> 及其依赖，并使用 <code>web-push generate-vapid-keys</code> 来创建 VAPID keys。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express@4.16.3 web-push@3.3.0 body-parser@1.18.2 express-static@1.2.5</span><br><span class="line">+ express@4.16.3</span><br><span class="line">+ web-push@3.3.0</span><br><span class="line">+ body-parser@1.18.2</span><br><span class="line">+ express-static@1.2.5</span><br><span class="line">added 62 packages in 1.42s</span><br><span class="line">$</span><br><span class="line">$ ./node_modules/.bin/web-push generate-vapid-keys</span><br><span class="line">=======================================</span><br><span class="line">Public Key:</span><br><span class="line">BOynOrGhgkj8Bfk4hsFENAQYbnqqLSigUUkCNaBsAmNuH6U9EWywR1JIdxBVQOPDbIuTaj0tVAQbczNLkC5zftw</span><br><span class="line">Private Key:</span><br><span class="line">&lt;OMITTED&gt;</span><br><span class="line">=======================================</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>如果你需要支持低版本浏览器，那么还要获取 <a target="_blank" rel="noopener" href="https://medium.com/@jasminejacquelin/integrating-push-notifications-in-your-node-react-web-app-4e8d8190a52c#9a53">GCM API key</a>，但在桌面版 Chrome 63 或更高版本中不需要它。</p>
<p>下面创建 <code>index.js</code> 文件，其中包含你的服务。你需要使用 <code>require()</code> 导入 web-push 模组，并配置刚才的 VAPID keys。配置相当简单，将 VAPID keys 存放在 <code>PUBLIC_VAPID_KEY</code> 与 <code>PRIVATE_VAPID_KEY</code> 环境变量中即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpush = <span class="built_in">require</span>(<span class="string">&#x27;web-push&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> publicVapidKey = process.env.PUBLIC_VAPID_KEY;</span><br><span class="line"><span class="keyword">const</span> privateVapidKey = process.env.PRIVATE_VAPID_KEY;</span><br><span class="line"><span class="comment">// 此处换成你自己的邮箱</span></span><br><span class="line">webpush.setVapidDetails(<span class="string">&#x27;mailto:val@karpov.io&#x27;</span>, publicVapidKey, privateVapidKey);</span><br></pre></td></tr></table></figure>
<p>下一步，为 Express 应用添加一个名为 <code>/subscribe</code> 的端点。浏览器中的 JavaScript 将会发送一个 body 中包含 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription"><code>PushSubscription</code> 对象</a>的 HTTP 请求。为了用 <code>webpush.sendNotification()</code> 发送推送通知，你需要获取 <code>PushSubscription</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>).json());</span><br><span class="line">app.post(<span class="string">&#x27;/subscribe&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = req.body;</span><br><span class="line">  res.status(<span class="number">201</span>).json(&#123;&#125;);</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">title</span>: <span class="string">&#x27;test&#x27;</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(subscription);</span><br><span class="line">  webpush.sendNotification(subscription, payload).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error.stack);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上就是服务端需要做的全部配置。你可以在 <a target="_blank" rel="noopener" href="https://github.com/vkarpov15/web-push-demo/blob/master/index.js">GitHub</a> 查阅完整代码。现在，我们就要创建客户端 <code>client.js</code> 与一个 service worker —— <code>worker.js</code> 了。</p>
<h2 id="客户端与-Service-Worker"><a href="#客户端与-Service-Worker" class="headerlink" title="客户端与 Service Worker"></a>客户端与 Service Worker</h2><p>首先，使用 <a target="_blank" rel="noopener" href="http://npmjs.com/package/express-static"><code>express-static</code> npm 模组</a>，<a target="_blank" rel="noopener" href="https://github.com/vkarpov15/web-push-demo/blob/b356e53c1468c5611b9c4722411af3839bafc360/index.js#L26">对 Express 应用进行配置</a>，为客户端部署静态资源，将静态资源部署在服务的最顶级目录下。<br>需要注意的是要在处理 <code>/subscribe</code> 路由之后再调用这个 <code>app.use()</code>，否则 Express 将不会根据你的配置处理路由，而是会去查找 <code>subscribe.html</code> 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;express-static&#x27;</span>)(<span class="string">&#x27;./&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>接着，创建 <code>index.html</code> 文件，这个文件将部署为你的应用的入口。文件中仅有的关键之处就是 <code>&lt;script&gt;</code> 标签，它将加载客户端 JavaScript 代码；其余部分都无关紧要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Push Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/client.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Service Worker Demo</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在你的入口做好了。创建一个名为 <code>client.js</code> 的文件。<a target="_blank" rel="noopener" href="https://github.com/vkarpov15/web-push-demo/blob/b356e53c1468c5611b9c4722411af3839bafc360/client.js">这个文件</a> 将告知浏览器初始化你的 service worker 并向 <code>/subscribe</code> 发送 HTTP 请求。由于支持 service workers 的浏览器也应该能支持 async 与 await，因此上述示例中使用了 <a target="_blank" rel="noopener" href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html">async/await</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里写死的 public key 要换成你自己的。</span></span><br><span class="line"><span class="keyword">const</span> publicVapidKey = <span class="string">&#x27;BOynOrGhgkj8Bfk4hsFENAQYbnqqLSigUUkCNaBsAmNuH6U9EWywR1JIdxBVQOPDbIuTaj0tVAQbczNLkC5zftw&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Registering service worker&#x27;</span>);</span><br><span class="line">  run().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Registering service worker&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> registration = <span class="keyword">await</span> navigator.serviceWorker.</span><br><span class="line">    register(<span class="string">&#x27;/worker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;/&#x27;</span>&#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Registered service worker&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Registering push&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> subscription = <span class="keyword">await</span> registration.pushManager.</span><br><span class="line">    subscribe(&#123;</span><br><span class="line">      userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// `urlBase64ToUint8Array()` 函数与以下网址中的描述一致</span></span><br><span class="line">      <span class="comment">// https://www.npmjs.com/package/web-push#using-vapid-key-for-applicationserverkey</span></span><br><span class="line">      applicationServerKey: urlBase64ToUint8Array(publicVapidKey)</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Registered push&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Sending push&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&#x27;/subscribe&#x27;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(subscription),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Sent push&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，你需要实现 <code>client.js</code> 所加载的 <code>worker.js</code> 文件。<br>这个文件是 service worker 逻辑所在之处。当订阅者接受到一个推送消息时，service worker 将收到一个 <a target="_blank" rel="noopener" href="https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications#handling_the_push_event_in_the_service_worker">‘push’ 事件</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Loaded service worker!&#x27;</span>);</span><br><span class="line">self.addEventListener(<span class="string">&#x27;push&#x27;</span>, <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = ev.data.json();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Got push&#x27;</span>, data);</span><br><span class="line">  self.registration.showNotification(data.title, &#123;</span><br><span class="line">    body: <span class="string">&#x27;Hello, World!&#x27;</span>,</span><br><span class="line">    icon: <span class="string">&#x27;http://mongoosejs.com/docs/images/mongoose5_62x30_transparent.png&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>好了！配置正确的环境变量并启动你的服务：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">env</span> PUBLIC_VAPID_KEY=<span class="string">&#x27;OMITTED&#x27;</span> <span class="keyword">env</span> PRIVATE_VAPID_KEY=<span class="string">&#x27;OMITTED&#x27;</span> node .</span><br></pre></td></tr></table></figure>
<p>在 Chrome 中访问 <code>http://localhost:3000</code>，你应该可以看到下面的推送通知！</p>
<p><img src="/images/pasted-319.png" alt="upload successful"></p>
<p>这种通知不仅在 Chrome 中可用，在 <a target="_blank" rel="noopener" href="https://support.mozilla.org/en-US/kb/push-notifications-firefox">Firefox</a> 也可以用同样的代码实现。</p>
<p><img src="/images/pasted-320.png" alt="upload successful"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Web 推送只是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service workers</a> 带来的诸多好处的其中一种。<br>通过一个 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/web-push">npm 模组</a>，你就能给大多数现代浏览器推送通知。下次你要为你的 web 应用增加推送通知功能的时候，记得用 service workers 哦！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/05/11/Deconvolutional-Paragraph-Representation-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/11/Deconvolutional-Paragraph-Representation-Learning/" class="post-title-link" itemprop="url">Deconvolutional Paragraph Representation Learning</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-11 14:32:00" itemprop="dateCreated datePublished" datetime="2018-05-11T14:32:00+08:00">2018-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在许多自然语言处理应用中，从长文本序列中学习其潜在的语义表示是重要的第一步。RNN 已经成为了这个任务的基石。然而，随着文本长度的增加，RNN 的解码重建（decoding、reconstraction）的质量也随之降低。因此，我们提出了一个 seq2seq、由纯粹的卷积与反卷积结构构成的自动编码框架，它没有上述 RNN 的问题，同时计算效率也很高。另外，此方法简单易行，可以在许多应用中作为一块积木使用。我们可以证明，此框架在重构长文本任务中的效果比 RNN 更好。同时，在半监督文本分类及文本摘要任务中的评价指标表明此框架能更好地利用无标注长文本数据。</p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>学习句子或多个句子组成的段落是自然语言处理的一项重要任务，它常常是实现其它任务（如情感分析、机器翻译、对话系统、文本摘要等）的基础。从数据中学习句子的表示使用的是编码器 - 解码器结构。在标准的自动编码步骤中，首先由输入序列的 embedding 编码为向量表示，再解码到原始域重建输入序列。近期在 RNN 中，LSTM 及其变体在许多依赖句子表示的学习任务中取得了巨大的成功。</p>
<p>基于 RNN 的方法通常将句子递归建模为含有隐藏单元的马尔可夫过程，其中每个输入句子的单词都是由前一个单词及隐藏单元的状态生成的，通过 emission 与 transition 运算建模为神经网络。原则上，输入序列的神经元表示应当包含了足够的输入序列结构的信息，才能在之后通过解码恢复原句。然而由于 RNN 的递归性质，基于 RNN 将句子完全表示为向量存在着挑战。典型的问题是，RNN 在训练时是基于之前的置信单词的状态来生成序列中的单词，而不是由编码后的向量表示解码整个句子。现在已经证明这种强制性的策略（teacher forcing training）是有必要的，因为它可以让 RNN 的输出接近于置信序列。然而，由于在重建序列时 RNN 允许解码器使用置信信息，削弱了编码器独立生成向量表示的能力，导致编码后的表示没能携带足够的信息来引导解码器在没有其它指引的情况下进行解码。为了解决这个问题，[19] 提出了一种在训练过程中的采样方法，从同时使用潜在表示与置信信号进行学习逐渐转换为仅用编码的潜在表示进行学习。但 [20] 表明，这种计划采样本质上是一种不一致训练策略，在实际使用中会产生不稳定的结果，最终导致训练无法收敛。</p>
<p>在推理时，在遇到无法使用置信信号的句子时，仅能通过前一个单词及表示向量的状态来生成新的单词。此时，解码的错误随着序列长度的增加而成比例增加。这也意味着，在处理句子时，一旦出现一个错误，后续生成的句子将错的更离谱。这种现象是 [19] 中的 exposure bias 产生的。</p>
<p>我们提出了一种简单而强大的纯卷积结构，用于学习句子的表示。比较方便的是，由于这个结构中不含 RNN，因此 teacher forcing training 与 exposure bias 的问题自然就不存在了。这种方法使用 CNN 作为编码器，deCNN 作为解码器。我们认为，这种结构通过多层 CNN 迫使潜在表示从整个句子中提取信息，由此在不适用 RNN 解码器的情况下实现较高的重建质量。这种多层 CNN 能够让表示向量从整个句子中抽取信息而无需考虑句子长度，这也使它可以应用于长句子或段落相关任务。此外，由于这种结构不涉及递归编码及解码，因此可以使用图形处理单元（GPU）的特定卷积原语进行高效并行化，与 RNN 模型相比显著减少了计算成本。</p>
<h3 id="2-自动编码卷积文本模型"><a href="#2-自动编码卷积文本模型" class="headerlink" title="2 自动编码卷积文本模型"></a>2 自动编码卷积文本模型</h3><h4 id="2-1-卷积编码器"><a href="#2-1-卷积编码器" class="headerlink" title="2.1 卷积编码器"></a>2.1 卷积编码器</h4><p>用 $w^t$ 表示给定句子中的第 t 个词，将每个词 $w^t$ 进行 embedding，映射为 k 维的词向量 $x_t = W_e[w^t]$，其中 $ W_e \in \mathbb{R}^{k \times V} $ 为一个已经学习好的 Word embedding 矩阵，V 为单词数量；用 $ W_e[v]$ 来表示 $W_e$ 的第 v 列。$W_e$ 中的所有列都经过 l2-norm 处理，例如 $ ||W_e[v]||_2 = 1, \forall v $。在经过 embedding 之后，一个长度为 T 的句子（经过 padding）可以在将 embedding 进行 concat 后表示为 $X \in \mathbb{R}^{k \times T}$；其中 $x_t$ 为 X 的第 t 列。</p>
<p>对于句子做编码，我们采用了类似 [24] 中的 CNN 结构，这个结构最初是为做图像处理任务设计的。这个 CNN 结构包含 L 个层（L - 1 个卷积层，第 L 层为全连接层），此结构最后可以将一个输入句子转化为一个定长的表示向量 h。层 $l \in \{1, … ,L\}$ 由学习到的滤波器 $p_l$ 组成。对于第一层中的第 i 个滤波器来说，相当于对 X 进行一个步长（stride）为 $r^{(1)}$、滤波器为 $W_c^{(i,1)} \in \mathbb{R}^{k \times h}$ 的卷积运算（式中的 h 代表卷积滤波器的大小）。这一系列操作会生成一个潜在特征映射：$c^{(i,1)}=\gamma(X <em> W_c^{(i,1)} + b^{(i,1)}) \in \mathbb{R}^{(T-h)/r^{(1)}+1}$，其中 $\gamma(.)$ 为非线性激活函数，$b^{(i,1)} \in \mathbb{R}^{(T-h)/r^{(1)}+1}$ ，</em> 符号代表了卷积操作。在我们的实验中，$\gamma(.)$ 为 ReLU。需要注意的是，最初的 embedding 维数 k 在经过第一层卷积层后就发生了变化，$c^{(i,1)} \in \mathbb{R}^{(T-h)/r^{(1)}+1}$ for i = 1,…,p1。在第一层将 p1 滤波器得到的结果进行拼接，就得到了一个特征映射，$C^{(1)}= [c^{(1,1)}… c^{(p1,1)}] \in \mathbb{R}^{p_1 \times [(T-h)/r^{(1)}+1]}$。</p>
<p>在第一个卷积层之后，我们对得到的特征映射 $C^{(1)}$ 使用同样的滤波器大小 h 进行卷积操作，并在这 L - 1 层中不断重复此操作。每次操作都能将空间维数降低为 $T^{(l+1)}=[(T^{(l)} - h)/r^{(l)} + 1]$（$r^{(l)}$ 为步长，$T^{(l)}$ 为空间维数大小，l 为第 l 层，[] 为向下取整函数）。在最后一层 L 中，得到了特征映射 $C^{(L-1)}$，将其送入全连接层中制造潜在表示向量 h。在实现时，我们直接用了一个滤波器大小等于 $T^{(L-1)}$（不考虑 h）的卷积层，它就相当于一个全连接层。这个实现上的 trick 在 [24] 中有所使用。这个最后一层将所有的空间坐标 $T^{(L-1)}$ 汇聚成为标量特征，使用滤波器 $\{W_c^{(i,l)}\}$ for i=1,…,p1 and l=1,…,L 将句子的子结构依次封装为了向量表示。其中 $W_c^{(i,l)}$ 表示层 l 的滤波器 i。这也意味着提取出来的特征的维度是固定的，与输入句子的长度无关。</p>
<p><img src="/images/pasted-317.png" alt="upload successful"></p>
<p>图1，卷积自动编码结构。编码器：将输入序列展开为 embedding 矩阵 X，接着通过多个卷积层编码器压缩为表示向量 h，在最后一层中将向量折叠去除空间维度。解码器：将表示向量 h 送入多个反卷积解码器，以 X 为目标，使用余弦相似度交叉熵损失函数重建 $\hat{X}$。</p>
<p>在最后一层有 $p_L$ 个滤波器，将会构造出 $p_L$ 维的表示向量。对于输入句子来说，也记为 $h=C^{(L)}$。例如，在图一中，编码器由 L=3 个层构成，句子长度为 T=60，embedding 维数为 k=300，不同层的步长 $\{ r^{(1)},r^{(2)},r^{(3)} \} = \{2,2,1\}$ ，滤波器大小 $h = \{5,5,12\}$，滤波器数量 $\{p_1,p_2,p_3 \}=\{300,600,500\}$。中间层得到的特征映射 $C^{(1)}$ 和 $C^{(2)}$ 的大小分别为 $\{28 \times 300,12 \times 600\}$。最后的特征映射大小为 1 x 500，对应的正是潜在表示向量 h。</p>
<p>从概念上看，较低层中的滤波器捕捉的是原始的句子信息（h-gram，类似于图像处理中的边缘信息），而叫高层中的滤波器捕捉的是更复杂的语言特征，比如语义和句法结构等（类似于图像处理中的图像元素）。这种自底向上的结构通过分层堆叠文本片段（h-gram）作为构建表示向量 h 的积木。这种方法在思路上类似于通过 concrete syntax trees [26] 对语言的语法结构进行建模。不过，我们没有事先去指定某种语法结构（比如英语），而是通过多层 CNN 网络提取此结构。</p>
<h4 id="2-2-反卷积解码器"><a href="#2-2-反卷积解码器" class="headerlink" title="2.2 反卷积解码器"></a>2.2 反卷积解码器</h4><p>我们按照一定步长应用卷积的变体 - 反卷积操作（比如 convolutional transpose），用于解码表示向量 h，将其还原至原来的文本域。随着反卷积的不断进行，向量的空间高度也不断增加，如图1所示，和之前描述的卷积操作刚好相反。空间维数首先展开至与卷积层的 L-1 层相同，接着逐渐展开为 $T^{(l+1)} = (T^{(l)}-1)*r^{(l)} + h$ for l=1,…直到第 L 个反卷积层（此层与卷积编码器的输入层相对应）。第 L 反卷积层的输出目标是重建 Word embedding 矩阵 $\hat{X}$。与 $W_e$ 一样，$\hat{X}$ 的每一列都经由 l2-norm 处理。</p>
<p>用 $\hat{w}^t$ 来表示重建后句子 $\hat{s}$ 中的第 t 个单词，$\hat{w}^t$ 为 v 的概率可表示为：</p>
<script type="math/tex; mode=display">p(\hat{w}^t = v) = \frac{\exp[\tau^{-1}D_{cos}(\hat{x}^t,W_e[v])]}{\sum_{v'\in V}\exp[\tau^{-1}D_{cos}(\hat{x}^t,W_e[v'])]}</script><p>式中，$D_{cos}(x,y)$ 代表余弦相似度，计算方法为 $\frac{&lt;{x,y}&gt;}{||x||||y||}$ ，$W_e[v]$ 是 $W_e$ 的第 v 列，$\hat{x}^t$ 是 $\hat{X}$ 的第 t 列，$\tau$ 是一个正数，我们将其定义为 temperature parameter [27]。此参数类似于 Dirichlet 分布的浓度参数，控制着概率向量 $[p(\hat{w}^t = 1)…p(\hat{w}^t = V)]$ 的扩散，较大的 $\tau$ 值会鼓励概率均匀地分布，较小的 $\tau$ 值会鼓励概率稀疏并集中。在实验中，我们设定 $\tau = 0.01$。此外在我们的实验中，余弦相似度可直接由经由 l2-norm 的 $W_e$ 与 $\hat{X}$ 内积得到。</p>
<h4 id="2-3-模型学习"><a href="#2-3-模型学习" class="headerlink" title="2.3 模型学习"></a>2.3 模型学习</h4><p>上述卷积自动编码器的目标可以记为所有句子（$s \in D$）的词级别的对数似然：</p>
<script type="math/tex; mode=display">\iota^{\alpha e} = \sum_{d \in D} \sum_t \log p(\hat{w}^t_d = w^t_d)</script><p>上述式子中，D 表示句子的集合。为了简单起见，使用随机梯度下降对式中的最大对数似然进行优化。实现相关的细节将在实验一节中详细描述。请注意，上述工作与之前的相关工作有两处不同：i) [22,28] 中使用了池化与上池化（pooling,unpooling）操作，而我们用了卷积与反卷积；ii) 更重要的是，[22,28] 没有像我们前面的步骤一样使用余弦相似度来重建句子，而是使用了基于 RNN 的解码器。我们将在第 3 节中更详细地讨论相关工作。在早期的实验（论文中未写出）中，我们使用了池化与上池化，但是没有观察到显著的性能提升；而卷积/反卷积运算则在内存占用方面更具效率。与标准的 LSTM RNN 自动编码器进行对比，两者参数数量大致相同，但我们的结构在单片 NVIDIA TITAN X GPU 上计算速度相当快（详见实验一节）。原因是 CNN 通过 cuDNN 原语处理有着很高的并行效率。</p>
<p><strong>反卷积解码器与 RNN 解码器的对比：</strong> 这种结构可以视为 NLP 模型的一种补充结构。与标准的基于 LSTM 的解码器相反，反卷积与 RNN 的区别在于它有着不严格的序列依赖性。具体来说，RNN 生成一个单词需要一个隐藏单元的向量，以递归的方式在整句中顺序地积累信息（长效信息主要依赖于向下权重）；而反卷积解码器，解码时的生成仅依赖一个封装了整个句子信息的表示向量，没有指定顺序结构。因此，对于语言生成任务，RNN 解码器会比反卷积解码器生成相关性更好的文本；与之相反，反卷积解码器在计算长句、远距离依赖的情况效果更好，因此在分类特征提取与文本摘要任务中更加有用。</p>
<h4 id="2-4-半监督分类与摘要"><a href="#2-4-半监督分类与摘要" class="headerlink" title="2.4 半监督分类与摘要"></a>2.4 半监督分类与摘要</h4><p>识别相关主题或情绪以及从用户生成的内容（如博客、产品评论等）生成摘要最近获得了大量的关注[1, 3, 4, 30, 31, 13, 11]。在大多数实际情况下，未标注数据非常丰富，但实际上很少能充分发挥这些未标注数据的潜力。以此为契机，我们希望能补充一些稀缺但更有价值的标注数据，以提高监督学习模型的泛化能力。无论是标注数据还是未标注数据，上述模型可以通过提取未标注数据，学习它们的潜在表示，捕获其语义信息。这可以将任务分为两步，在监督训练之前进行上述步骤。近期，应用这种思路的基于 RNN 的方法已经被广泛使用，并在许多任务中获得了 state-of-the-art 的效果 [1, 3, 4, 30, 31]。此外，还可以构建一个分类器与自动编码解码器联合的分类模型，对潜在向量表示 h 进行分类，详见 [32, 33]。</p>
<p>又比如，在产品评论中，每个评论可能包含了数百个词，这对基于 RNN 的序列编码器来说有着一定的困难。因为 RNN 需要在文本中滑动并抽取信息，这会导致信息的丢失，在长句子中更为严重[34]。另外，在训练过程中解码用到了置信的真实信息，这可能导致无法完全保留来自输入文本的所有信息，而这些丢失的信息对于重建句子、分类、摘要来说是至关重要的。</p>
<p>我们考虑将这个卷积自动编码解码结构应用于长句、段落的半监督学习任务中。我们将半监督问题视作 [35] 中的多任务学习问题，同时训练序列编码器与监督模型，而不是像 [1, 3] 中那样预训练无监督模型。理论上来说，这种联合训练方法得到的段落 embedding 向量会保持重建与分类的能力。</p>
<h3 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3 相关工作"></a>3 相关工作</h3><p>之前的工作 [22, 28, 21, 38, 39] 已经考虑了将 CNN 用作为一些 NLP 任务的编码器了。一般来说，基于 CNN 的编码器结构会使用一个单一的卷积层再加上池化层。这种结构在给定卷积滤波窗口大小为 h 时，实质上就是做了一个识别特定 h-gram 结构的检测器。从原理看，我们这种架构中的深层结构可以让高层学习到更复杂的语言特征。</p>
<h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h3><p>实验结果图：</p>
<p><img src="/images/15258102755361.jpg" alt=""></p>
<p><img src="/images/15258102868772.jpg" alt=""></p>
<p><img src="/images/15258102990486.jpg" alt=""></p>
<p><img src="/images/15258103106207.jpg" alt=""></p>
<p><img src="/images/15258103206038.jpg" alt=""></p>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h3><p>我们提出了一种只使用卷积与反卷积运算的用于文本模型的通用结构。这种结构没有进行序列条件生成，因此避免了 teacher forcing training 与 exposure bias 问题。这种方法可以将段落完全压缩至潜在表示向量中，此向量也能解压缩重建原始输入序列。总的来说，这种方法实现了高质量的长段落重建，并优于现有的拼写矫正算法、半监督序列分类算法、文本摘要算法，且减少了计算成本。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] Andrew M Dai and Quoc V Le. Semi-supervised sequence learning. In NIPS, 2015.</p>
<p>[2] Quoc Le and Tomas Mikolov. Distributed representations of sentences and documents. In ICML, 2014.</p>
<p>[3] Rie Johnson and Tong Zhang. Supervised and Semi-Supervised Text Categorization using LSTM for Region Embeddings. arXiv, February 2016.</p>
<p>[4] Takeru Miyato, Andrew M Dai, and Ian Goodfellow. Adversarial Training Methods for Semi-Supervised Text Classiﬁcation. In ICLR, May 2017.</p>
<p>[5] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural Machine Translation by Jointly Learning to Align and Translate. In ICLR, 2015.</p>
<p>[6] Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In EMNLP, 2014.</p>
<p>[7] Fandong Meng, Zhengdong Lu, Mingxuan Wang, Hang Li, Wenbin Jiang, and Qun Liu. Encoding source language with convolutional neural network for machine translation. In ACL, 2015.</p>
<p>[8] Tsung-Hsien Wen, Milica Gasic, Nikola Mrksic, Pei-Hao Su, David Vandyke, and Steve Young. Semantically conditioned lstm-based natural language generation for spoken dialogue systems. arXiv, 2015.</p>
<p>[9] Jiwei Li, Will Monroe, Alan Ritter, Michel Galley, Jianfeng Gao, and Dan Jurafsky. Deep reinforcement learning for dialogue generation. arXiv, 2016.</p>
<p>[10] Jiwei Li, Will Monroe, Tianlin Shi, Alan Ritter, and Dan Jurafsky. Adversarial learning for neural dialogue generation. arXiv:1701.06547, 2017.</p>
<p>[11] Ramesh Nallapati, Bowen Zhou, Cicero Nogueira dos santos, Caglar Gulcehre, and Bing Xiang. Abstractive Text Summarization Using Sequence-to-Sequence RNNs and Beyond. In CoNLL, 2016.</p>
<p>[12] Shashi Narayan, Nikos Papasarantopoulos, Mirella Lapata, and Shay B Cohen. Neural Extractive Summarization with Side Information. arXiv, April 2017.</p>
<p>[13] Alexander M Rush, Sumit Chopra, and Jason Weston. A Neural Attention Model for Abstractive Sentence Summarization. In EMNLP, 2015.</p>
<p>[14] Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In NIPS, 2014.</p>
<p>[15] Tomas Mikolov, Martin Karaﬁát, Lukas Burget, Jan Cernock`y, and Sanjeev Khudanpur. Recurrent neural network based language model. In INTERSPEECH, 2010.</p>
<p>[16] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. In Neural computation, 1997.</p>
<p>[17] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv, 2014.</p>
<p>[18] Ronald J Williams and David Zipser. A learning algorithm for continually running fully recurrent neural networks. Neural computation, 1(2):270–280, 1989.</p>
<p>[19] Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and Noam Shazeer. Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.</p>
<p>[20] Ferenc Huszár. How (not) to train your generative model: Scheduled sampling, likelihood, adversary? arXiv, 2015.</p>
<p>[21] Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling sentences. In ACL, 2014.</p>
<p>[22] Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.</p>
<p>[23] Ishaan Gulrajani, Kundan Kumar, Faruk Ahmed, Adrien Ali Taiga, Francesco Visin, David Vazquez, and Aaron Courville. Pixelvae: A latent variable model for natural images. arXiv, 2016.</p>
<p>[24] Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. arXiv, 2015.</p>
<p>[25] Vinod Nair and Geoffrey E Hinton. Rectiﬁed linear units improve restricted boltzmann machines. In ICML, pages 807–814, 2010.</p>
<p>[26] Ian Chiswell and Wilfrid Hodges. Mathematical logic, volume 3. OUP Oxford, 2007.</p>
<p>[27] Emil Julius Gumbel and Julius Lieblein. Statistical theory of extreme values and some practical applications: a series of lectures. 1954.</p>
<p>[28] Ronan Collobert, Jason Weston, Léon Bottou, Michael Karlen, Koray Kavukcuoglu, and Pavel Kuksa. Natural language processing (almost) from scratch. In JMLR, 2011.</p>
<p>[29] Sharan Chetlur, Cliff Woolley, Philippe Vandermersch, Jonathan Cohen, John Tran, Bryan Catanzaro, and Evan Shelhamer. cudnn: Efﬁcient primitives for deep learning. arXiv, 2014.</p>
<p>[30] Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alex Smola, and Eduard Hovy. Hierarchical attention networks for document classiﬁcation. In NAACL, 2016.</p>
<p>[31] Adji B Dieng, Chong Wang, Jianfeng Gao, and John Paisley. TopicRNN: A Recurrent Neural Network with Long-Range Semantic Dependency. In ICLR, 2016.</p>
<p>[32] Diederik P Kingma, Shakir Mohamed, Danilo Jimenez Rezende, and Max Welling. Semi-supervised learning with deep generative models. In NIPS, 2014.</p>
<p>[33] Yunchen Pu, Zhe Gan, Ricardo Henao, Xin Yuan, Chunyuan Li, Andrew Stevens, and Lawrence Carin.</p>
<p>Variational autoencoder for deep learning of images, labels and captions. In NIPS, 2016.</p>
<p>[34] Sepp Hochreiter, Yoshua Bengio, Paolo Frasconi, and Jürgen Schmidhuber. Gradient ﬂow in recurrent nets: the difﬁculty of learning long-term dependencies, 2001.</p>
<p>[35] Richard Socher, Jeffrey Pennington, Eric H Huang, Andrew Y Ng, and Christopher D Manning. Semisupervised recursive autoencoders for predicting sentiment distributions. In EMNLP. Association for Computational Linguistics, 2011.</p>
<p>[36] Samuel R Bowman, Luke Vilnis, Oriol Vinyals, Andrew M Dai, Rafal Jozefowicz, and Samy Bengio. Generating sentences from a continuous space. arXiv, 2015.</p>
<p>[37] Zichao Yang, Zhiting Hu, Ruslan Salakhutdinov, and Taylor Berg-Kirkpatrick. Improved Variational Autoencoders for Text Modeling using Dilated Convolutions. arXiv, February 2017.</p>
<p>[38] Baotian Hu, Zhengdong Lu, Hang Li, and Qingcai Chen. Convolutional neural network architectures for matching natural language sentences. In NIPS, 2014.</p>
<p>[39] Rie Johnson and Tong Zhang. Effective use of word order for text categorization with convolutional neural networks. In NAACL HLT, 2015.</p>
<p>[40] Jost Tobias Springenberg, Alexey Dosovitskiy, Thomas Brox, and Martin Riedmiller. Striving for simplicity: The all convolutional net. arXiv, 2014.</p>
<p>[41] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015.</p>
<p>[42] Stanislau Semeniuta, Aliaksei Severyn, and Erhardt Barth. A Hybrid Convolutional Variational Autoencoder for Text Generation. arXiv, February 2017.</p>
<p>[43] Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray Kavukcuoglu. Neural machine translation in linear time. arXiv, 2016.</p>
<p>[44] Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language Modeling with Gated Convolutional Networks. arXiv, December 2016.</p>
<p>[45] J. Gehring, M. Auli, D. Grangier, D. Yarats, and Y. N. Dauphin. Convolutional Sequence to Sequence Learning. arXiv, May 2017.</p>
<p>[46] Aaron van den Oord, Nal Kalchbrenner, Lasse Espeholt, Oriol Vinyals, Alex Graves, et al. Conditional image generation with pixelcnn decoders. In NIPS, pages 4790–4798, 2016.</p>
<p>[47] Jiwei Li, Minh-Thang Luong, and Dan Jurafsky. A hierarchical neural autoencoder for paragraphs and documents. In ACL, 2015.</p>
<p>[48] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In NIPS, 2013.</p>
<p>[49] Kam-Fai Wong, Mingli Wu, and Wenjie Li. Extractive summarization using supervised and semi-supervised learning. In ICCL. Association for Computational Linguistics, 2008.</p>
<p>[50] Chin-Yew Lin. Rouge: A package for automatic evaluation of summaries. In ACL workshop, 2004.</p>
<p>[51] Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In ACL. Association for Computational Linguistics, 2002.</p>
<p>[52] Xiang Zhang, Junbo Zhao, and Yann LeCun. Character-level convolutional networks for text classiﬁcation. In NIPS, pages 649–657, 2015.</p>
<p>[53] Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu, Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron Courville, and Yoshua Bengio. An actor-critic algorithm for sequence prediction. arXiv, 2016.</p>
<p>[54] JP Woodard and JT Nelson. An information theoretic measure of speech recognition performance. In Workshop on standardisation for speech I/O, 1982.</p>
<p>[55] Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.</p>
<p>[56] Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks. In AISTATS, 2010.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/04/18/ssh-%E4%B8%8D%E7%94%A8%E6%89%8B%E5%8A%A8%E8%BE%93%E5%AF%86%E7%A0%81%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lsvih">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/18/ssh-%E4%B8%8D%E7%94%A8%E6%89%8B%E5%8A%A8%E8%BE%93%E5%AF%86%E7%A0%81%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">ssh 不用手动输密码远程执行命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-18 12:15:00" itemprop="dateCreated datePublished" datetime="2018-04-18T12:15:00+08:00">2018-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>小组使用了 GitLab，在某项目中需要利用 CI 进行远程部署，但生产服务器是另一台远程服务器，而 CI Runner 的运行环境是 Docker。</p>
<p>由于 ssh 的安全措施，在建立 ssh 连接时不允许自动化输入密码，必须在出现密码框后手动输入，因此在 CI 流程中无法实现；经过了解，一款名为 sshpass 的工具可以满足此需求；</p>
<p>在本机测试时，使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install sshpass</span><br></pre></td></tr></table></figure><br>提示<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We won&#x27;t add sshpass because <span class="keyword">it</span> makes <span class="keyword">it</span> too easy <span class="keyword">for</span> novice SSH users <span class="keyword">to</span> ruin SSH&#x27;s security.</span><br></pre></td></tr></table></figure><br>可知此工具的确是破坏了 ssh 的安全性。</p>
<p>但在内部机器的 CI Runner Docker 中，不考虑这个问题。Gitlab CI Runner 默认使用的是 <code>alpine:latest</code>，需要事先安装依赖及 sshpass，因此在 before_script 中加上 <code>apk add --update --no-cache openssh sshpass</code> 安装此工具。</p>
<p>在后续的 job/stage 中，加入远程执行命令脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshpass -p <span class="string">&#x27;password&#x27;</span> ssh -T -o StrictHostKeyChecking=no username@192.168.xxx.xxx <span class="string">&#x27;sh /home/remote/script.sh&#x27;</span></span><br></pre></td></tr></table></figure>
<p>即可绕过手动输入密码步骤，在 CI 中运行远程 sh 脚本。</p>
<blockquote>
<p>在联网环境慎用，防止泄密</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18029472号-1 </a>
  </div>

<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lsvih</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    menuSettings: {
      zoom: "None"
    },
    showMathMenu: false,
    jax: ["input/TeX","output/CommonHTML"],
    extensions: ["tex2jax.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js"],
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [["$", "$"],["\\(", "\\)"]],
      displayMath: [["\\[", "\\]"]]
    }
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.3/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.9.2/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  




  


</body>
</html>
