<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My note</title>
  
  <subtitle>lsvih</subtitle>
  <link href="https://lsvih.com/atom.xml" rel="self"/>
  
  <link href="https://lsvih.com/"/>
  <updated>2021-02-01T04:59:04.586Z</updated>
  <id>https://lsvih.com/</id>
  
  <author>
    <name>lsvih</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>构建设计系统和组件库</title>
    <link href="https://lsvih.com/2021/02/01/building-a-design-system-and-a-component-library/"/>
    <id>https://lsvih.com/2021/02/01/building-a-design-system-and-a-component-library/</id>
    <published>2021-02-01T05:03:00.000Z</published>
    <updated>2021-02-01T04:59:04.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/16121554838666.jpg" alt=""></p><p>当我们开始在 React 中重构前端项目时，可复用 UI 组件还不在我们设计和开发工作流程之内。我们的 jQuery 前端项目主要是基于 Twitter 的 bootstrap 组件构建的，这些组件针为特定的用例进行了调整，或通过附加功能进行了扩展。我们通过从旧设计中汲取精华并加以改进，让每个特性都有了新的设计。随着团队和应用的不断发展，我们的各个组件朝着不同的方向改进，导致了文本大小、配色、按钮和链接出现了各种各样的变化，最终使得整个应用的用户体验脱节。</p><p>在 React 中重构前端项目，给了我们重新思考设计和开发工作流的机会，也让我们有机会将重点放在为用户提供更统一的体验上。这一点非常重要，因为我们所需要做的，就是让应用程序更容易访问和能更快速地响应。这也促使了新的组件库的诞生，并继而驱动了设计系统的需求。这个迭代过程一开始非常困难且缓慢，但随着时间的推移，新的组件库和设计系统变得越来越实用，让开发人员和设计师兴奋不已。</p><a id="more"></a><h2 id="什么是设计系统？"><a href="#什么是设计系统？" class="headerlink" title="什么是设计系统？"></a>什么是设计系统？</h2><p>设计系统是关于如何创建、组织存档和使用 UI 组件的综合指南。它定义了一组适用于所有设计的规则、约束、原则和最佳实践。设计系统的核心元素是一组 UI 组件，如按钮、链接和列表。对每个组件，你都可以为其附上说明，描述在设计期间为这个组件所做选择；以及为每个组件撰写文档，用以定义组件的规则、行为和约束，提供用例和其它可以通过文本描述的细节。</p><h2 id="什么是组件库？"><a href="#什么是组件库？" class="headerlink" title="什么是组件库？"></a>什么是组件库？</h2><p>组件库是用编程语言实现的可复用 UI 组件的集合。当得到设计系统的支持时，它也可以被视为设计及其指导方针的交互式实现。</p><h2 id="为什么要关心这个？"><a href="#为什么要关心这个？" class="headerlink" title="为什么要关心这个？"></a>为什么要关心这个？</h2><p>如 <a href="https://medium.com/airbnb-design/224748775e4e">Airbnb 的 Karri Saarinen</a> 所言，统一的设计系统对于实现更好更快的构建来说，非常重要；更好的原因是用户更容易理解统一的体验，更快的原因是它为我们提供了一种共同的语言来进行协作。</p><p>在 Karify 看来，设计系统可以帮助我们创建并遵循自己的设计准则，也可以帮助我们在多种平台和设备上创建出一个统一的用户体验。最后，它还可以帮助我们的团队更高效、更敏捷、更紧密地合作。以下是我们发现的一些更详细的优势：</p><ul><li><strong>沟通</strong>：让设计师理解开发人员，也让开发人员理解设计师。以前对双方都很难理解的概念现在清晰多了。讨论组件和使用我们在沟通中约定的规则，会使得设计和开发过程更加容易。</li><li><strong>一致性</strong>：应用程序页面的外观和体验变得统一。我们会知道一个标题或正常的文本应该使用的大小、应该为主要操作配置什么类型的按钮、什么颜色用来传达特定操作的类型或信息，以及每种类型的元素之间应该有多少间距。如果我们决定更改其中任何一个规范，就可以很容易地在整个设计系统、组件库和应用程序中对它们进行更改。</li><li><strong>协作</strong>：设计师和开发人员工作得更紧密，能够更容易地分享想法和见解。由于沟通变得更容易，因此讨论功能限制以及在早期阶段将它们合并到设计中也变得更容易了。使用 <a href="https://zeplin.io/">Zeplin</a> 之类的工具会使这个过程更加高效，因为它可以让设计师和开发人员针对设计的任何一处细节进行讨论。</li><li><strong>文档</strong>：组件指南提供了关于组件的外观、使用、行为以及为什么这样做的详细信息。如果将来某个组件的设计或实现出现了问题，就更容易找到背后的原因，并避免了再次考虑之前已经考虑过的问题（除非它不再有意义）。</li><li><strong>模块化</strong>：所有的组件都使用有限的规则和关注点来表示设计和代码的一小部分。这样就可以在设计和代码中实现关注点分离。</li><li><strong>可维护性</strong>：这使设计和代码的更新变得更加容易，因为当一个组件被修改时，使用它的所有其它组件都会更新。虽然在旧组件上需要做一些额外的处理，但可以立竿见影地让你看到自己的修改造成的影响。</li></ul><p>与任何其它方法一样，我们在设计系统的开发中也发现了一些缺点：</p><ul><li><strong>耗费时间</strong>：开始的时候尤其如此。定义所有规则、约束和基本组件（如文本、颜色和间距）需要进行大量讨论。随着时间的推移，这个过程会加快。这取决于在设计新特性之前需要创建多少新组件。但是一旦你有了一些组件，在现有的或新的设计中重用它们就会变得非常快。这同样适用于应用程序的开发。</li><li><strong>缺乏创造力</strong>：由于受限于所有的规则和约束，创作空间减少了。不过，这也可以被视为一种优势，因为它带来了一致性。</li><li><strong>陡峭的学习曲线</strong>：这主要是团队里新人面临的问题，因为他们将需要熟悉许多规则，才能熟练地应用它们。从另一个角度来说，这也使他们的学习更容易，因为设计系统本身已经传达了规则。</li><li><strong>复杂性</strong>：如果有太多依赖于其他组件的组件，那么维护和重用它们也会变得很复杂。</li></ul><p>不过，不要让这些缺点吓到你。学习如何让这些缺点最小化，也是我们设计过程的一部分。随着时间的推移，优势变得比劣势更明显。</p><h2 id="如何开始呢？"><a href="#如何开始呢？" class="headerlink" title="如何开始呢？"></a>如何开始呢？</h2><p>首先，我们建议你了解<a href="https://bradfrost.com/blog/post/atomic-web-design/">原子设计</a>的概念以及<a href="https://airbnb.design/systems-thinking-unlocked/">设计系统的最佳实践</a>和诸如 <a href="https://airbnb.design/building-a-visual-language">Airbnb</a> 这样的设计系统的例子。此外，你还应该选择用于构建设计系统的工具。我们选择了 <a href="https://www.sketch.com/">Sketch</a>，但也有其它选择，比如 <a href="https://www.figma.com/">Figma</a>。</p><p>接着，你就可以开始定义属于你的一套色彩、排版样式和间距尺寸，这将是你的第一个“原子”。它将允许你开始定义你的第一个“分子”，如按钮、链接和页面等。在第一次迭代中，你很可能会遗漏一些用例，因此需要多轮迭代来逐步完善，直到一切都没问题并能经得起时间的考验。</p><p>如果你已经有了一个应用程序，但不能一次全部更改，那么我们建议你基于现有的设计系统去对它进行改进。对于每个部分，分析你所拥有的，选择你喜欢的部分，改进你不喜欢的部分。即使这个工作很繁琐，也应该将未来的组件从遗留组件中分离出来。这样，你就可以避免在新组件中使用遗留组件。慢慢地，这会让你达到你的目标。</p><h2 id="我们是怎么做到的？"><a href="#我们是怎么做到的？" class="headerlink" title="我们是怎么做到的？"></a>我们是怎么做到的？</h2><p>我们的团队最初由两名设计师和一名前端开发人员组成，后来又有一名开发人员加入了这个团队。这个团队的规模无论是过去还是现在，都足够完成工作，并且也有充足的时间来处理细节问题。不过，我们认为团队的大小应取决于项目的规模和公司的节奏。</p><p>从头开始重构前端项目的机会也让我们可以从过去的错误中吸取教训。因此，我们根据用户的反馈来设计新组件。他们经常提到可访问性和响应性问题，为了解决这些问题，我们认为首先需要重新设计导航系统，然后再重新设计应用程序中的每个页面。</p><p>我们先将新的导航作为一个整体设计，在它的设计稳定下来之后，我们开始将其分解为更小的组件，这就产生为原子设计所分割好的的原子、分子和有机体。虽然在理想情况下，我们应该从原子开始设计，但如果没有明确的方向，这将是非常困难的事；而现在，我们已经通过拆分整体设计定义好了几个原子和分子，再将它们组合成新的有机体或页面就比较容易了。</p><p>在创建组件时，我们将它们定义为<code>符号</code>（<code>symbols</code>），并在 Sketch 库文件中把它们分割为<code>原子</code>、<code>分子</code>和<code>有机体</code>。Sketch 有助于将我们的<code>原子</code>组件作为符号在其它<code>分子</code>或<code>有机体</code>组件中使用。在 Sketch 中，它们被称为<code>嵌套符号</code>（<code>nested symbols</code>）。我们确保按级联顺序使用组件，以保证更新只能是单向进行的。</p><p><img src="/images/16121555015376.jpg" alt=""></p><p><strong>我们的 Sketch <code>分子</code>库：按钮组件中的图标组件是从 Sketch <code>原子</code>库中复用的。</strong></p><p>为了记录我们的选择，我们在 Material UI 组件指南的启发下，为每个组件（不管它是原子、分子还是有机体）创建了设计指南。紧接着，为不同的组件设定不同指导方针，以及定义一些适用于所有组件的通用方针，其中有些通用指导方针是非常重要的（比如可访问性和风格定位）。这些指导方针是我们唯一的事实来源，它们确保很多细节是一览无余的。为了给人留下印象，它们是一份包含以下部分的简单文档：</p><ul><li>使用</li><li>分解</li><li>不同的视图的布局</li><li>行为</li><li>可访问性</li></ul><p>我们在根据每一个功能或者项目而创建的<code>模板</code>或<code>页面</code>文件中使用组件。当一个组件或页面准备好了，我们通过 <a href="https://zeplin.io/">Zeplin</a> 与开发人员和其他参与者分享设计。这个工具允许他们从设计中提取信息，比如颜色、大小和资源。它还允许对任一组件发起讨论，这可以极大地提高协作效率，因为这些细节通常是需要通过开会来进行讨论的。</p><p><img src="/images/16121555140458.jpg" alt=""></p><p><strong>在 Zeplin 中协作开发的按钮组件。</strong></p><p>现在，开发人员可以使用 Zeplin 中的信息来开始构建相应的 React 组件了。理想情况下，每个设计组件都应该只有一个 React 组件，以保证设计和代码之间的关系尽可能地紧密一些。为了获得灵感，我们经常会看看其他组件库是怎么做的，比如 <a href="https://material-ui.com/">Material-UI</a>。</p><p>为了简化这个过程，我们使用了 <a href="https://storybook.js.org/">Storybook</a>，它促进了组件的独立开发。它还提供了一种与库中所有组件可视化交互的方法，设计师可以使用这些组件来验证最终的实现。</p><p><img src="/images/16121555265534.jpg" alt=""></p><p><strong>Storybook 中相同的按钮：准备审核</strong></p><p>在我们的设计系统和组件库中，我们都按照类别将组件进行分组，例如按钮、颜色、表单元素、布局、链接、排版等。</p><p>从本质上讲，这些工具帮助我们在工作过程中建立起反馈循环机制：设计师可以通过查看 Storybook 轻松地对组件库给出反馈，开发人员可以轻松地在 Zeplin 对设计进行评论或者下载资源。</p><h2 id="还有哪些可以做得更好的地方？"><a href="#还有哪些可以做得更好的地方？" class="headerlink" title="还有哪些可以做得更好的地方？"></a>还有哪些可以做得更好的地方？</h2><p>总的来说，我们觉得现在这个过程已经足够好了，但有些事情还可以做一些变通。下面是我们一路上遇到的痛点：</p><ul><li><strong>可访问性指南</strong>：我们完全低估了可访问性。<a href="https://www.w3.org/TR/WCAG21/">WCAG guidelines</a> 有很多指导方针，但你不可能在这么小的团队中全部实现。我们必须选择哪些是对我们的用户最重要的。然而，我们在这个过程中很晚才做出这个选择，因为它对我们的原子组件（主要是字体和颜色）产生了影响，这迫使我们重新考虑一些分子和有机体。</li><li><strong>复杂组件</strong>：我们经常尝试创建职责过多或对其它组件有太多依赖的组件。最好将它们分解成更小的组件，而不是盲目提高它们的可定制性。拆分也许会导致设计和代码上出现一些冗余，但这种方式是更容易被理解的。</li><li><strong>缺乏计划和无限的范围</strong>：有一段时间，项目的范围只是持续增长。有些事情很重要，但有些就不那么重要了。由于这个项目没有结束日期，很难划定界限。最终，我们开始更频繁地讨论这些问题，以确定哪些是真正重要的。</li></ul><p>最终，在重新设计完导航系统之后，我们对这些问题进行了学习和改进。我们仍然不时地遇到一些复杂的组件，但我认为尽快地发现并指出错误也是其中的一个过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们看来，构建一个设计系统和一个组件库是值得的。它带来了我们从一开始就在寻找的一致性设计。这并不意味着我们会把这套方案推荐给所有人。在开始之前，我们建议你先确认这对于你的项目而言是否是正确的解决方案。我们认为，只有当你知道或期望产品需要大量不同的页面，并且这些页面具有复用同一组件的复杂交互时，才需要这样做。如果是一家初创公司或小公司，并希望在未来几年扩大规模时，这一点尤其重要。然而，如果你的产品是一个简单的网站，在几年之内不会有太大的变化，那么这可能是过分的。</p><hr><blockquote><p>翻译：<a href="https://github.com/Charlo-O">Charlo</a>，<a href="https://github.com/lsvih">lsvih</a><br>校对：<a href="https://github.com/Shirley-He-Maker">贺雪 Amy</a>，<a href="https://github.com/Chorer">Chorer</a><br>原文：<a href="https://medium.com/javascript-in-plain-english/building-a-design-system-and-a-component-library-3f4e01a7b0b4">Building a design system and a component library</a><br>掘金地址：<a href="https://juejin.cn/post/6924152501805678606">https://juejin.cn/post/6924152501805678606</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/16121554838666.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我们开始在 React 中重构前端项目时，可复用 UI 组件还不在我们设计和开发工作流程之内。我们的 jQuery 前端项目主要是基于 Twitter 的 bootstrap 组件构建的，这些组件针为特定的用例进行了调整，或通过附加功能进行了扩展。我们通过从旧设计中汲取精华并加以改进，让每个特性都有了新的设计。随着团队和应用的不断发展，我们的各个组件朝着不同的方向改进，导致了文本大小、配色、按钮和链接出现了各种各样的变化，最终使得整个应用的用户体验脱节。&lt;/p&gt;
&lt;p&gt;在 React 中重构前端项目，给了我们重新思考设计和开发工作流的机会，也让我们有机会将重点放在为用户提供更统一的体验上。这一点非常重要，因为我们所需要做的，就是让应用程序更容易访问和能更快速地响应。这也促使了新的组件库的诞生，并继而驱动了设计系统的需求。这个迭代过程一开始非常困难且缓慢，但随着时间的推移，新的组件库和设计系统变得越来越实用，让开发人员和设计师兴奋不已。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Design" scheme="https://lsvih.com/tags/Design/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="Frontend" scheme="https://lsvih.com/tags/Frontend/"/>
    
    <category term="Design System" scheme="https://lsvih.com/tags/Design-System/"/>
    
  </entry>
  
  <entry>
    <title>自己写一个 Redux</title>
    <link href="https://lsvih.com/2021/01/31/how-to-build-redux/"/>
    <id>https://lsvih.com/2021/01/31/how-to-build-redux/</id>
    <published>2021-01-31T14:03:00.000Z</published>
    <updated>2021-01-31T14:09:58.294Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 是一个简单的库，可以帮助你管理 JavaScript 应用的状态。虽然它很简单，但在学习过程中还是很容易掉坑。我经常需要解释 Redux 的用法和原理，而且我总是会从如何实现 Redux 来开始说明。所以，在此我们做这样一件事：从头开始，写一个能用的 Redux。我们的实现不会考虑所有的情况，但可以揭示大部分 Redux 的原理。</p><p>注意，实际上我们将会实现的是 <a href="https://github.com/reactjs/redux?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">Redux</a> <strong>和</strong> <a href="https://github.com/reactjs/react-redux?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">React Redux</a>。在这里，我们把 Redux 和著名的 UI 库 <a href="https://facebook.github.io/react/">React</a> 相结合，而这正是在实际场景中最为常见的组合。哪怕你把 Redux 和其他东西组合，这里讲解的所有东西几乎也还是一样的。</p><p>我们开始吧！</p><a id="more"></a><h2 id="实现自己的状态对象"><a href="#实现自己的状态对象" class="headerlink" title="实现自己的状态对象"></a>实现自己的状态对象</h2><p>大多数应用都会从服务端获取状态。我们先从在本地创建状态开始实现（即使我们是从服务端获取状态，也要先用一些状态来初始化应用）。我们将构建一个简单的笔记本应用，这样可以不用再去做千篇一律的 TODO 应用，而后文也可以看到，做这个笔记本应用也会驱使我们做一些有趣的东西来控制状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  nextNoteId: <span class="number">1</span>,</span><br><span class="line">  notes: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，注意我们的数据只是一个简单的 JS 对象。Redux 会帮助我们<strong>管理状态的改变</strong>，但它并不太关心状态本身。</p><h2 id="为何使用-Redux？"><a href="#为何使用-Redux？" class="headerlink" title="为何使用 Redux？"></a>为何使用 Redux？</h2><p>在我们继续深入之前，首先来看看不使用 Redux 要怎样开发我们创建的应用。首先，我们需要把 <code>initialState</code> 对象绑定到 <code>window</code> 上，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.state = initialState;</span><br></pre></td></tr></table></figure><p>这就是我们的 store！现在我们不需要什么 Redux，直接来构建一个新的笔记组件吧：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onAddNote = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">window</span>.state.nextNoteId;</span><br><span class="line">  <span class="built_in">window</span>.state.notes[id] = &#123;</span><br><span class="line">    id,</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.state.nextNoteId++;</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteApp = <span class="function">(<span class="params">&#123;notes&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul className=<span class="string">&quot;note-list&quot;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(notes).map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// Obviously we should render something more interesting than the id.</span></span><br><span class="line">        &lt;li className=<span class="string">&quot;note-list-item&quot;</span> key=&#123;id&#125;&gt;&#123;id&#125;&lt;/li&gt;</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;button className=<span class="string">&quot;editor-button&quot;</span> onClick=&#123;onAddNote&#125;&gt;New Note&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderApp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;NoteApp notes=&#123;<span class="built_in">window</span>.state.notes&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure><p>你可以在 <a href="https://jsfiddle.net/justindeal/5j3can1z/102/">JSFiddle</a> 尝试这个例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  nextNoteId: <span class="number">1</span>,</span><br><span class="line">  notes: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.state = initialState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onAddNote = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">window</span>.state.nextNoteId;</span><br><span class="line">  <span class="built_in">window</span>.state.notes[id] = &#123;</span><br><span class="line">    id,</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.state.nextNoteId++;</span><br><span class="line">  renderApp();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteApp = <span class="function">(<span class="params">&#123;notes&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul className=<span class="string">&quot;note-list&quot;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(notes).map(<span class="function"><span class="params">id</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// 显然我们需要显示一些比 id 更有趣的东西。</span></span><br><span class="line">        &lt;li className=<span class="string">&quot;note-list-item&quot;</span> key=&#123;id&#125;&gt;&#123;id&#125;&lt;/li&gt;</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;button className=<span class="string">&quot;editor-button&quot;</span> onClick=&#123;onAddNote&#125;&gt;New Note&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderApp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;NoteApp notes=&#123;<span class="built_in">window</span>.state.notes&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderApp();</span><br></pre></td></tr></table></figure><p>虽然这不是一个很实用的应用，但它能正常工作。看起来我们已经证明了不用 Redux 也能做出记事本，所以这篇文章已经完结了~</p><p>并没有…</p><p>让我们展望一下：我们之后加入了一些新的特性，开发了一个很好的服务端，成立了一个公司来销售它，得到了大量用户，然后又添加了大量的新特性，赚了些钱，扩大公司……（想太多了）</p><p>（在这个简单的记事本应用中很难看出来）在我们通向成功的道路上，这个应用可能不断的增大，包含数百个文件中的数百个组件。我们的应用会执行异步操作，所以我们将会有这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onAddNote = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.state.onLoading = <span class="literal">true</span>;</span><br><span class="line">  renderApp();</span><br><span class="line">  api.createNote()</span><br><span class="line">    .then(<span class="function">(<span class="params">note</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.state.onLoading = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">window</span>.state.notes[id] = note;</span><br><span class="line">      renderApp();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也会有这样的 bug：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ARCHIVE_TAG_ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onAddTag = <span class="function">(<span class="params">noteId, tagId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.state.onLoading = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 哎呀，这里忘记渲染了！</span></span><br><span class="line">  <span class="comment">// 使用速度快的本地服务器时，我们可能不会发现。</span></span><br><span class="line">  api.addTag(noteId, tagId)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.state.onLoading = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">window</span>.state.tagMapping[tagId] = noteId;</span><br><span class="line">      <span class="keyword">if</span> (ARCHIVE_TAG_ID) &#123;</span><br><span class="line">        <span class="comment">// 哎呀，一些命名 bug。可能是由于粗暴的搜索/替换产生的。直到我们测试这个没人真正使用的档案页面时，我们才会发现。</span></span><br><span class="line">        <span class="built_in">window</span>.state.archived = <span class="built_in">window</span>.state.archive || &#123;&#125;;</span><br><span class="line">        <span class="built_in">window</span>.state.archived[noteId] = <span class="built_in">window</span>.state.notes[noteId];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">window</span>.state.notes[noteId];</span><br><span class="line">      &#125;</span><br><span class="line">      renderApp();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及一些奇奇怪怪、临时的状态改变，几乎没人知道它们是做什么的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SomeEvilComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">window</span>.state.pureEvil = <span class="literal">true</span>&#125;&gt;Do Evil&lt;/button&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在很长一段时间内，很多开发者在大型代码库中共同添加代码，我们将会遇到一系列的问题：</p><ol><li>渲染可能在任何地方触发。将会有奇怪的 UI 卡顿或卡死，而且看起来似乎是随机的。</li><li>潜在的竞态条件，甚至在我们看到的少量代码里就存在。</li><li>状态太混乱几乎不能进行测试。你必须让<strong>整个</strong>应用处于特定状态，然后不断调试状态，看看<strong>整个</strong>应用的状态是否如你所料。</li><li>如果你发现一个 bug，你可以有根据地猜测去哪修复，但最终，你的应用中的每一行代码都有嫌疑。</li></ol><p>最后一点是最糟糕的问题，也是我们选择 Redux 的主要原因。如果你想要降低整个应用的复杂性，最好（我个人的观点）通过限制如何、以及在哪里可以改变应用的状态。Redux 不是解决其它问题的灵丹妙药，但是这些限制会让问题出现更少。</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>所以 Redux 是怎样提供这些限制并帮助你管理状态的呢？从一个输入当前状态并返回新状态的简单函数开始说明。对于我们的笔记本应用，如果我们提供一个添加笔记的动作，应当得到一个添加新笔记后的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CREATE_NOTE = <span class="string">&#x27;CREATE_NOTE&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE_NOTE = <span class="string">&#x27;UPDATE_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE:</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">// 有新笔记的状态</span></span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE:</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">// 更新笔记之后的状态</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你不爽 <code>switch</code> 语句，也可以用其他方式写 reducer。我经常使用一个对象，并让 key 指向每种类型的 handler，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handlers = &#123;</span><br><span class="line">  [CREATE_NOTE]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 新笔记的新状态</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [UPDATE_NOTE]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 修改笔记后的新状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (handlers[action.type]) &#123;</span><br><span class="line">    <span class="keyword">return</span> handlers[action.type](state, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写法并不重要。reducer 是你自己写的函数，可以用任何方式来实现它。Redux 完全不关心你怎么做的。</p><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>Redux 关心的是，你的 reducer 必须是<strong>纯函数</strong>。意味着你绝对不能这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="comment">// 不要这样改变状态!!!</span></span><br><span class="line">      state.notes[state.nextNoteId] = &#123;</span><br><span class="line">        id: state.nextNoteId,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      state.nextNoteId++;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="comment">// 不要这样改变状态!!!</span></span><br><span class="line">      state.notes[action.id].content = action.content;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上，如果你像这样改变状态，Redux 将不会正常工作。因为虽然你在改变状态，但是对象的引用不会改变（组件绑定的状态是绑定对象的引用），所以你的应用将不会正确地更新。也会导致不能使用一些 Redux 开发者工具，因为这些工具跟踪的是先前的状态。如果你在持续性地修改状态，将不能进行状态回退。</p><p>原则上，修改状态使得组建自己的 reducer（也可能包括应用的其他部分）更困难。纯函数是可预测的，因为他们在同样的输入下会产生同样的输出。如果你养成了修改状态的习惯，一切就都完了。函数调用变得不确定。你必须在头脑中记住整棵函数调用树。</p><p>这种可预测性的代价很高，尤其是因为 JavaScript 原生不支持不可变对象。在本文的例子中，我们将使用原生 JavaScript，需要多写一些冗余的代码。以下是我们写 reducer 的正确方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> id = state.nextNoteId;</span><br><span class="line">      <span class="keyword">const</span> newNote = &#123;</span><br><span class="line">        id,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nextNoteId: id + <span class="number">1</span>,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: newNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;id, content&#125; = action;</span><br><span class="line">      <span class="keyword">const</span> editedNote = &#123;</span><br><span class="line">        ...state.notes[id],</span><br><span class="line">        content</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: editedNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我在使用<a href="https://github.com/tc39/proposal-object-rest-spread?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">对象扩展语法</a>（<code>...</code>）。如果你想使用较传统的 JavaScript 语法，可以使用 <code>Object.assign</code>。理念都是一样的：不要改变状态，而是为任何状态、嵌套对象、数组创建浅拷贝。对于任何不变的对象，我们只引用存在的部分。我们再仔细看一下这部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...state,</span><br><span class="line">  notes: &#123;</span><br><span class="line">    ...state.notes,</span><br><span class="line">    [id]: editedNote</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们只改变 <code>notes</code> 属性，而 <code>state</code> 属性将保持不变。<code>...state</code> 的含义是，复用已经存在的属性。类似地，在 <code>notes</code> 中，我们只改变我们正在编辑的部分，<code>...state.notes</code> 中的其他部分将不会改变。这样，我们可以借助 <a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a> 或 <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent"><code>PureComponent</code></a>，使得有未改变的 note 作为 props 的组件避免重复渲染。记住，我们还需要避免像这样写 reducer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 好了，我们避免了修改，但是……千万别这样做！</span></span><br><span class="line">  state = _.cloneDeep(state)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="comment">// 现在可以做些改变了</span></span><br><span class="line">      state.notes[action.id].content = action.content;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你又得到了简练的修改对象的代码，而且<strong>实际上</strong> Redux 可以在这种情况下正常工作，但是将无法进行优化。每个对象和数组在每次状态改变时都会是全新的，所以任何依赖于这些对象和数组的组件都将会重新渲染，哪怕你实际上没有对这些组件的状态做任何修改。</p><p>我们不可变的 reducer 肯定需要更多的类型定义，也会有更高的学习成本。但以后，你将会为改变状态的函数是独立的，而且容易测试而感到高兴。对于一个真实的应用，你<strong>可能</strong>想要看一下像 <a href="https://github.com/lodash/lodash/wiki/FP-Guide?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">lodash-fp</a>，或 <a href="http://ramdajs.com/">Ramda</a> 或 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>。在这里，我们使用 <a href="https://github.com/kolodny/immutability-helper?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">immutability-helper</a> 的一个变种，它很简单。提醒一下，这里有很大的坑，我甚至为此写了<a href="https://github.com/jdeal/qim?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">一个新的库</a>。原生的 JS 也很不错，而且有很好且强壮的类型定义解决方案，如 <a href="https://flow.org/">Flow</a> 和 <a href="https://www.typescriptlang.org/">TypeScript</a>。确保使用较小粒度的函数，就像你使用 React 时的情况一样：虽然总体上会比 jQuery 使用更多代码，但是每个组件都更容易预测。</p><h3 id="使用我们的-Reducer"><a href="#使用我们的-Reducer" class="headerlink" title="使用我们的 Reducer"></a>使用我们的 Reducer</h3><p>我们来把一个 action 接入我们的 reducer，并生成一个新的 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state0 = reducer(<span class="literal">undefined</span>, &#123;</span><br><span class="line">  type: CREATE_NOTE</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在 <code>state0</code> 看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  nextNoteId: <span class="number">2</span>,</span><br><span class="line">  notes: &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们把 <code>undefined</code> 作为状态的输入。Redux 总是传入 <code>undefined</code> 作为初始状态，而且你一般需要使用 <code>state = initialState</code> 这样的方式来选择初始状态对象。下一次， Redux 将会输入先前的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state1  = reducer(state0, &#123;</span><br><span class="line">  type: UPDATE_NOTE,</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  content: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在 <code>state1</code> 看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  nextNoteId: <span class="number">2</span>,</span><br><span class="line">  notes: &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      content: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在这里使用我们的 reducer<a href="https://jsfiddle.net/justindeal/kLkjt4y3/37/">（代码链接）</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CREATE_NOTE = <span class="string">&#x27;CREATE_NOTE&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE_NOTE = <span class="string">&#x27;UPDATE_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  nextNoteId: <span class="number">1</span>,</span><br><span class="line">  notes: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> id = state.nextNoteId;</span><br><span class="line">      <span class="keyword">const</span> newNote = &#123;</span><br><span class="line">        id,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nextNoteId: id + <span class="number">1</span>,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: newNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;id, content&#125; = action;</span><br><span class="line">      <span class="keyword">const</span> editedNote = &#123;</span><br><span class="line">        ...state.notes[id],</span><br><span class="line">        content</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: editedNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state0 = reducer(<span class="literal">undefined</span>, &#123;</span><br><span class="line">  type: CREATE_NOTE</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state1  = reducer(state0, &#123;</span><br><span class="line">  type: UPDATE_NOTE,</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  content: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(state1, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然，Redux 并不会像这样创建更多的变量，但我们将会很快讲到真正的实现。重点是，Redux 的核心只是你写的一小块代码，一个简单地接收上一个状态，并返回下一个状态的函数。为什么这个函数被叫做 reducer？因为它可以被接入标准的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>reduce</code></a> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123;<span class="attr">type</span>: CREATE_NOTE&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>: UPDATE_NOTE, <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Hello, world!&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = actions.reduce(reducer, <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>然后，<code>state</code> 将会看起来和之前的 <code>state1</code> 一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  nextNoteId: <span class="number">2</span>,</span><br><span class="line">  notes: &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">      content: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在这里向我们的 <code>actions</code> 数组添加元素，并输入给 reducer<a href="https://jsfiddle.net/justindeal/edogdh33/13/">（代码链接）</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CREATE_NOTE = <span class="string">&#x27;CREATE_NOTE&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE_NOTE = <span class="string">&#x27;UPDATE_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  nextNoteId: <span class="number">1</span>,</span><br><span class="line">  notes: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> id = state.nextNoteId;</span><br><span class="line">      <span class="keyword">const</span> newNote = &#123;</span><br><span class="line">        id,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nextNoteId: id + <span class="number">1</span>,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: newNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;id, content&#125; = action;</span><br><span class="line">      <span class="keyword">const</span> editedNote = &#123;</span><br><span class="line">        ...state.notes[id],</span><br><span class="line">        content</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: editedNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123;<span class="attr">type</span>: CREATE_NOTE&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>: UPDATE_NOTE, <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Hello, world!&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = actions.reduce(reducer, <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(state, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在，你可以理解为什么 Redux 自称为“一个可预测的 JavaScript 应用状态容器”。输入一系列相同的 action，你将得到相同的状态。函数式编程必胜！如果你听说过 Redux 可以复现之前的状态，这就是大致的原理。实际上，Redux 并不会引用一个 action 列表，而是会使用一个变量指向状态对象，然后不断改变这个变量指向下一个状态的对象。这是在你的应用中允许的一个重要的改变（mutation），但是我们需要把这种改变控制在 store 中。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>我们来创建一个 store 吧。它可以保存我们单个的状态变量，并提供一些存取状态的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> validateAction = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!action || <span class="keyword">typeof</span> action !== <span class="string">&#x27;object&#x27;</span> || <span class="built_in">Array</span>.isArray(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Action must be an object!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Action must have a type!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">      validateAction(action)</span><br><span class="line">      state = reducer(state, action);</span><br><span class="line">    &#125;,</span><br><span class="line">    getState: <span class="function">() =&gt;</span> state</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在你可以看到，我们为什么使用常量而不是字符串。我们对于 action 的检测比 Redux 更宽松，但也足以保证我们不拼错 action 类型。如果我们传入字符串，action 将会直接进入 reducer 的默认分支（switch 的 default），什么都不会发生，错误可能会被忽视。但如果我们使用常量，拼写错误将会导致返回 <code>undefined</code> 并抛出错误，让我们立刻发现错误并修复它。</p><p>我们来创建一个 store 并且使用吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass in the reducer we made earlier.</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: CREATE_NOTE</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.getState();</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   nextNoteId: 2,</span></span><br><span class="line"><span class="comment">//   notes: &#123;</span></span><br><span class="line"><span class="comment">//     1: &#123;</span></span><br><span class="line"><span class="comment">//       id: 1,</span></span><br><span class="line"><span class="comment">//       content: &#x27;&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>现在已经可以使用了。我们有了一个 store，它可以使用任何我们提供的 reducer 来管理状态。但是还缺少一个重要的部分：一种订阅状态改变的方法。没有这种方法，我们就需要用一些笨拙的命令式代码。如果将来我们引入了异步 actions，它就完全不能用了。所以我们来实现订阅吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="params">reducer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">const</span> subscribers = [];</span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    dispatch: <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      validateAction(action);</span><br><span class="line">      state = reducer(state, action);</span><br><span class="line">      subscribers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler());</span><br><span class="line">    &#125;,</span><br><span class="line">    getState: <span class="function">() =&gt;</span> state,</span><br><span class="line">    subscribe: <span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      subscribers.push(handler);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> index = subscribers.indexOf(handler);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          subscribers.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;@@redux/INIT&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一点点额外的并不<strong>太</strong>难理解的代码。其中的 <code>subscribe</code> 函数接收一个 <code>handler</code> 函数并把它添加到 <code>subscribers</code> 列表中。它还会返回一个用于取消订阅的函数。任何时候我们调用了 <code>dispatch</code>，我们就通知所有这些 handler。现在每次状态改变时，重新渲染就很简单了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////</span></span><br><span class="line"><span class="comment">// Mini Redux implementation //</span></span><br><span class="line"><span class="comment">///////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validateAction = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!action || <span class="keyword">typeof</span> action !== <span class="string">&#x27;object&#x27;</span> || <span class="built_in">Array</span>.isArray(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Action must be an object!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Action must have a type!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="params">reducer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">const</span> subscribers = [];</span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    dispatch: <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      validateAction(action);</span><br><span class="line">      state = reducer(state, action);</span><br><span class="line">      subscribers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler());</span><br><span class="line">    &#125;,</span><br><span class="line">    getState: <span class="function">() =&gt;</span> state,</span><br><span class="line">    subscribe: <span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      subscribers.push(handler);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> index = subscribers.indexOf(handler);</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          subscribers.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;@@redux/INIT&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="comment">// Our action types //</span></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CREATE_NOTE = <span class="string">&#x27;CREATE_NOTE&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE_NOTE = <span class="string">&#x27;UPDATE_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"><span class="comment">// Our reducer //</span></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  nextNoteId: <span class="number">1</span>,</span><br><span class="line">  notes: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> id = state.nextNoteId;</span><br><span class="line">      <span class="keyword">const</span> newNote = &#123;</span><br><span class="line">        id,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        nextNoteId: id + <span class="number">1</span>,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: newNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;id, content&#125; = action;</span><br><span class="line">      <span class="keyword">const</span> editedNote = &#123;</span><br><span class="line">        ...state.notes[id],</span><br><span class="line">        content</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [id]: editedNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////</span></span><br><span class="line"><span class="comment">// Our store //</span></span><br><span class="line"><span class="comment">///////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Render our app whenever the store changes //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(store.getState(), <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="comment">// Dispatch actions //</span></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: CREATE_NOTE</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: UPDATE_NOTE,</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  content: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以在 <a href="https://jsfiddle.net/justindeal/8cpu4ydj/27/">JSFiddle</a> 中尝试这些代码，并发出更多的 action。渲染的 HTML 将总是反映 store 状态。当然，对于真正的应用，我们将会把 <code>dispatch</code> 函数和用户的 action 联系起来。我们将会很快讲到这部分。</p><h2 id="创建自己的组件"><a href="#创建自己的组件" class="headerlink" title="创建自己的组件"></a>创建自己的组件</h2><p>如何写出可以和 Redux 配合使用的组件呢？只用简单的接收 props 的 React 组件就行了。你实现了你自己的状态，所以写的组件能和这些状态（至少是一部分状态）配合就可以了。有一些特殊情况<strong>可能会</strong>影响你的组件设计（特别是涉及到性能问题的时候），但是在大多数情况，简单的组件都不会有问题。我们从最简单的组件开始开发我们的应用吧：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NoteEditor = <span class="function">(<span class="params">&#123;note, onChangeNote, onCloseNote&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;textarea</span><br><span class="line">        className=<span class="string">&quot;editor-content&quot;</span></span><br><span class="line">        autoFocus</span><br><span class="line">        value=&#123;note.content&#125;</span><br><span class="line">        onChange=&#123;<span class="function"><span class="params">event</span> =&gt;</span> onChangeNote(note.id, event.target.value)&#125;</span><br><span class="line">        rows=&#123;<span class="number">10</span>&#125; cols=&#123;<span class="number">80</span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;button className=<span class="string">&quot;editor-button&quot;</span> onClick=&#123;onCloseNote&#125;&gt;Close&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteTitle = <span class="function">(<span class="params">&#123;note&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> title = note.content.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (title === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span>Untitled<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteLink = <span class="function">(<span class="params">&#123;note, onOpenNote&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li className=<span class="string">&quot;note-list-item&quot;</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;#&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> onOpenNote(note.id)&#125;&gt;</span><br><span class="line">      &lt;NoteTitle note=&#123;note&#125;/&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteList = <span class="function">(<span class="params">&#123;notes, onOpenNote&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;ul className=<span class="string">&quot;note-list&quot;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(notes).map(<span class="function"><span class="params">id</span> =&gt;</span></span><br><span class="line">        &lt;NoteLink</span><br><span class="line">          key=&#123;id&#125;</span><br><span class="line">          note=&#123;notes[id]&#125;</span><br><span class="line">          onOpenNote=&#123;onOpenNote&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteApp = (&#123;</span><br><span class="line">  notes, openNoteId, onAddNote, onChangeNote,</span><br><span class="line">  onOpenNote, onCloseNote</span><br><span class="line">&#125;) =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      openNoteId ?</span><br><span class="line">        &lt;NoteEditor</span><br><span class="line">          note=&#123;notes[openNoteId]&#125; onChangeNote=&#123;onChangeNote&#125;</span><br><span class="line">          onCloseNote=&#123;onCloseNote&#125;</span><br><span class="line">        /&gt; :</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;NoteList notes=&#123;notes&#125; onOpenNote=&#123;onOpenNote&#125;/&gt;</span><br><span class="line">          &lt;button className=<span class="string">&quot;editor-button&quot;</span> onClick=&#123;onAddNote&#125;&gt;New Note&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>没什么特别的。我们可以把 props 输入给这些组件，并且渲染它们。但是需要注意传入的 <code>openNoteId</code> 属性以及 <code>onOpenNote</code> 和 <code>onCloseNote</code> 的回调：我们需要决定状态和回调存放在哪里。我们可以直接使用组件的 state，这当然没问题。但当你开始使用 Redux，也没有规定说<strong>所有</strong>的状态都必须放到 Redux store 中。如果你想知道什么时候使用 store 存放状态，只要问自己：</p><blockquote><p><strong>组件卸载后，这个状态还需要存在吗？</strong></p></blockquote><p>如果不需要，很可能采用组件自身的 state 存储状态更合适。对于需要保存在服务器，或者跨组件（各组件独立加载和卸载）共享的状态而言，Redux 很可能是更好的选择。</p><p>有时候 Redux 很适用于易变的状态。特别是状态需要随着 store 中状态的改变而改变时，把它存放在 store 中可能更容易一些。对于我们的应用而言，当我们创建一个笔记时，我们需要把 <code>openNoteId</code> 设置为新的笔记 id。在组件中做这件事很笨拙，因为我们需要在 <code>componentWillReceiveProps</code> 中监控 store 状态的变化。我并不是说这是错的，只是这样很笨拙。所以对于我们的应用，我们将把 <code>openNoteId</code> 保存在 store 状态中（在真实的应用中，我们可能还需要用到路由。后文也简单介绍了使用路由的情况）。</p><p>另一个需要把易变状态放在 store 中的原因是可能是为了更容易从 Redux 开发者工具中访问它。通过 Redux 开发工具可以更容易的查看 store 中存储的数据，同时还可以使用状态回退之类的有趣的功能。从组件内部状态开始，再切换到 store 状态是很容易的。只要提供一个容器组件来将本地状态进行包装即可，就像用 store 来包装全局状态一样。</p><p>那么，我们来修改我们的 reducer 来处理易变状态吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OPEN_NOTE = <span class="string">&#x27;OPEN_NOTE&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> CLOSE_NOTE = <span class="string">&#x27;CLOSE_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  openNoteId: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">const</span> id = state.nextNoteId;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        openNoteId: id,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> OPEN_NOTE: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        openNoteId: action.id</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CLOSE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        openNoteId: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="手动组装起来"><a href="#手动组装起来" class="headerlink" title="手动组装起来"></a>手动组装起来</h2><p>好了，现在我们可以把整个东西组装起来。我们不会修改现有的组件。我们将会创建新的容器组件，从 store 获取状态并传递给 <code>NoteApp</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteAppContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = props.store.getState();</span><br><span class="line">    <span class="built_in">this</span>.onAddNote = <span class="built_in">this</span>.onAddNote.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.onChangeNote = <span class="built_in">this</span>.onChangeNote.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.onOpenNote = <span class="built_in">this</span>.onOpenNote.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.onCloseNote = <span class="built_in">this</span>.onCloseNote.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.unsubscribe = <span class="built_in">this</span>.props.store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">      <span class="built_in">this</span>.setState(<span class="built_in">this</span>.props.store.getState())</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onAddNote</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.store.dispatch(&#123;</span><br><span class="line">      type: CREATE_NOTE</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onChangeNote</span>(<span class="params">id, content</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.store.dispatch(&#123;</span><br><span class="line">      type: UPDATE_NOTE,</span><br><span class="line">      id,</span><br><span class="line">      content</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onOpenNote</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.store.dispatch(&#123;</span><br><span class="line">      type: OPEN_NOTE,</span><br><span class="line">      id</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onCloseNote</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.store.dispatch(&#123;</span><br><span class="line">      type: CLOSE_NOTE</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;NoteApp</span><br><span class="line">        &#123;...this.state&#125;</span><br><span class="line">        onAddNote=&#123;<span class="built_in">this</span>.onAddNote&#125;</span><br><span class="line">        onChangeNote=&#123;<span class="built_in">this</span>.onChangeNote&#125;</span><br><span class="line">        onOpenNote=&#123;<span class="built_in">this</span>.onOpenNote&#125;</span><br><span class="line">        onCloseNote=&#123;<span class="built_in">this</span>.onCloseNote&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NoteAppContainer store=&#123;store&#125;/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>哈哈，可以了！<a href="https://jsfiddle.net/justindeal/8bL9tL0z/23/">在 JSFiddle 试试这个应用</a></p><p>现在应用通过派发 action 来使得 reducer 更新 store 存储的状态数据，同时使用订阅确保了视图渲染的数据和 store 状态数据保持同步。如果遇到状态数据异常，我们不再需要检查组件本身，只需要检查触发的 actions 和 reducer 即可。</p><h2 id="Provider-和-Connect"><a href="#Provider-和-Connect" class="headerlink" title="Provider 和 Connect"></a>Provider 和 Connect</h2><p>好了，所有东西都能用了。但是…还有些问题。</p><ol><li>绑定操作看起来是命令式的。</li><li>容器组件中有很多重复代码。</li><li>每次把 store 绑定到组件时，需要使用全局 <code>store</code> 对象。否则，我们就需要将 <code>store</code> 传遍整个组件树。或者我们要在顶部节点绑定一次，然后把<strong>所有东西</strong>通过树传递下去。这在大型应用中可不太好。</li></ol><p>所以我们需要 React Redux 中提供的 <code>Provider</code> 和 <code>connect</code>。首先，来创建一个 <code>Provider</code> 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="built_in">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: PropTypes.object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码很简单，<code>Provider</code> 组件使用 React 的 <a href="https://facebook.github.io/react/docs/context.html">context 特性</a> 来把 <code>store</code> 转变成 context 属性。Context 是一种从顶层组件向底层组件传递信息的方式，它不需要中间的组件显式传递信息。总的来说，你应该避免使用 context，因为 <a href="https://facebook.github.io/react/docs/context.html#why-not-to-use-context">React 文档</a> 这样说：</p><blockquote><p><strong>如果你想要你的应用稳定，不要使用 context。这是个试验 API，并可能在未来的 React 版本中被放弃。</strong></p></blockquote><p>这就是我们自己使用代码实现而不直接使用 context 的原因。我们把这个试验 API 封装起来，这样如果它变了，我们可以改变自己的实现，而不需要开发者修改代码。</p><p>所以我们需要一种方式把 context 转化成 props。这就是 <code>connect</code> 的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connect = (</span><br><span class="line">  mapStateToProps = <span class="function">() =&gt;</span> (&#123;&#125;),</span><br><span class="line">  mapDispatchToProps = <span class="function">() =&gt;</span> (&#123;&#125;)</span><br><span class="line">) =&gt; <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connected</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">onStoreOrPropsChange</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context;</span><br><span class="line">      <span class="keyword">const</span> state = store.getState();</span><br><span class="line">      <span class="keyword">const</span> stateProps = mapStateToProps(state, props);</span><br><span class="line">      <span class="keyword">const</span> dispatchProps = mapDispatchToProps(store.dispatch, props);</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        ...stateProps,</span><br><span class="line">        ...dispatchProps</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;store&#125; = <span class="built_in">this</span>.context;</span><br><span class="line">      <span class="built_in">this</span>.onStoreOrPropsChange(<span class="built_in">this</span>.props);</span><br><span class="line">      <span class="built_in">this</span>.unsubscribe = store.subscribe(<span class="function">() =&gt;</span> <span class="built_in">this</span>.onStoreOrPropsChange(<span class="built_in">this</span>.props));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.onStoreOrPropsChange(nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125;/&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Connected.contextTypes = &#123;</span><br><span class="line">    store: PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Connected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有一点点复杂。说实话，和真正的实现相比，我们偷懒了<strong>很多</strong>（我们将在本文结尾的性能一节中讨论），但已经和真正的 Redux 的大概原理很接近了。<code>connect</code> 是一个<a href="https://facebook.github.io/react/docs/higher-order-components.html">高阶组件</a>，实际上它更像是高阶函数，它接收两个函数，并返回一个以组件为输入、新的组件为输出的函数。这个组件订阅 store，并且在发生改变时更新你的组件的 props。开始使用这个 <code>connect</code> 吧，它会变得更实用的。</p><h2 id="自动组装"><a href="#自动组装" class="headerlink" title="自动组装"></a>自动组装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  notes: state.notes,</span><br><span class="line">  openNoteId: state.openNoteId</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  onAddNote: <span class="function">() =&gt;</span> dispatch(&#123;</span><br><span class="line">    type: CREATE_NOTE</span><br><span class="line">  &#125;),</span><br><span class="line">  onChangeNote: <span class="function">(<span class="params">id, content</span>) =&gt;</span> dispatch(&#123;</span><br><span class="line">    type: UPDATE_NOTE,</span><br><span class="line">    id,</span><br><span class="line">    content</span><br><span class="line">  &#125;),</span><br><span class="line">  onOpenNote: <span class="function"><span class="params">id</span> =&gt;</span> dispatch(&#123;</span><br><span class="line">    type: OPEN_NOTE,</span><br><span class="line">    id</span><br><span class="line">  &#125;),</span><br><span class="line">  onCloseNote: <span class="function">() =&gt;</span> dispatch(&#123;</span><br><span class="line">    type: CLOSE_NOTE</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NoteAppContainer = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(NoteApp);</span><br></pre></td></tr></table></figure><p>嘿，看上去好多了！</p><p>传给 <code>connect</code> 的首个函数（<code>mapStateToProps</code>）从我们的 <code>store</code> 中获取当前的 <code>state</code> 并返回一些 props。第二个传给 <code>connect</code> 的函数（<code>mapDispatchToProps</code>）会获取我们 <code>store</code> 的 <code>dispatch</code> 方法，并返回一些 props。<code>connect</code> 给我们返回了一个新的函数，把我们的组件 <code>NoteApp</code> 传给这个函数，会得到一个新的组件，它将会自动获取所有这些 props（和我们额外传入的部分）。</p><p>现在我们需要使用我们的 <code>Provider</code> 组件，以使得 <code>connect</code> 不必把 store 放在 <code>context</code> 中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;NoteAppContainer/&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很好！我们的 <code>store</code> 被在顶部传入一次，然后使用 <code>connect</code> 接收 <code>store</code> 来完成所有的工作（声明式编程万岁！）。<a href="https://jsfiddle.net/justindeal/srnf5n20/10/"><strong>这是我们用 <code>Provider</code> 和 <code>connect</code> 整理好的应用</strong></a></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>现在我们已经写了一些很实用的东西，但还缺了一块：在某些环节中，我们需要和服务器通信。现在我们的 action 是同步的，该如何发出<strong>异步</strong> 的 action 呢？我们可以在组件中获取数据，但是这有一些问题：</p><ol><li>Redux（除了 <code>Provider</code> 和 <code>connect</code>）并不是专用于 React 的。最好有一个 Redux 解决方案。</li><li>在拉取数据时，我们有时候需要访问状态。我们并不想把状态传递得到处都是。所以我们想要写一个类似于 <code>connect</code> 的东西来获取数据。</li><li>我们在测试涉及到数据获取的状态变化时，必须要通过组件来测试。我们应该尽量把数据获取解耦。</li><li>又有一些工具不能用了。</li></ol><p>Redux 是同步的，我们应该怎么做呢？把一些东西放在 dispatch 和改变 store 状态的操作之间。这就是中间件。</p><p>首先，我们需要一种把中间件传给 store 的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, middleware</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">const</span> subscribers = [];</span><br><span class="line">  <span class="keyword">const</span> coreDispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    validateAction(action);</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    subscribers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler());</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function">() =&gt;</span> state;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    dispatch: coreDispatch,</span><br><span class="line">    getState,</span><br><span class="line">    subscribe: <span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">      subscribers.push(handler);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> index = subscribers.indexOf(handler)</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          subscribers.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action);</span><br><span class="line">    store.dispatch = middleware(&#123;</span><br><span class="line">      dispatch,</span><br><span class="line">      getState</span><br><span class="line">    &#125;)(coreDispatch);</span><br><span class="line">  &#125;</span><br><span class="line">  coreDispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;@@redux/INIT&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变得复杂了一些。重要的是最后的 <code>if</code> 语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action);</span><br><span class="line">  store.dispatch = middleware(&#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    getState</span><br><span class="line">  &#125;)(coreDispatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们了创建一个”重新派发 action“的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action);</span><br></pre></td></tr></table></figure><p>如果中间件决定要发出一个新的 action，这个 action 将会通过中间件传递下去。我们需要创建这个函数，因为我们需要修改 store 的 <code>dispatch</code> 方法。（这也另一个用可变对象简化问题的例子，我们开发 Redux 时可以破坏规则，只要它能够帮助开发者遵守规则。<code>^_^</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch = middleware(&#123;</span><br><span class="line">  dispatch,</span><br><span class="line">  getState</span><br><span class="line">&#125;)(coreDispatch);</span><br></pre></td></tr></table></figure><p>上面的代码调用了中间件，传给它一个能进行“re-dispatch”的函数和 <code>getState</code> 的函数。这个中间件需要返回一个新的函数，拥有用来接收调用下一个 dispatch 函数的能力（原始的 dispatch 函数）。如果你读到这里觉得头晕了，不要担心。创建和使用中间件实际上是很容易的。</p><p>Okay，我们来创建一个延迟一秒再 dispatch 的中间件。它没有实际用处，但能够说明异步的原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delayMiddleware = <span class="function">() =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    next(action);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数的签名就看起来很傻，但是能够嵌入我们之前创建的拼图中。它是一个函数，返回一个接受下一个 dispatch 函数的函数，这个函数接受 action。看起来似乎 Redux 在疯狂使用箭头函数，但这是有原因的，我们将很快说明。</p><p>现在，我们开始在 store 中使用这个中间件吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, delayMiddleware);</span><br></pre></td></tr></table></figure><p>哈，我们把我们的 app 变慢了！这可不妙。但是我们有异步操作了！请试一试<a href="https://jsfiddle.net/justindeal/56uf0uy7/7/">这个糟糕的应用</a>，打字延时显得非常可笑。</p><p>调整 <code>setTimeout</code> 时间可以把它变得更糟糕，或更好些。</p><h2 id="组装中间件"><a href="#组装中间件" class="headerlink" title="组装中间件"></a>组装中间件</h2><p>来写一个更有用的中间件，用于记录日志吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loggingMiddleware = <span class="function">(<span class="params">&#123;getState&#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;before&#x27;</span>, getState());</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;action&#x27;</span>, action);</span><br><span class="line">  <span class="keyword">const</span> result = next(action);</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">&#x27;after&#x27;</span>, getState());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就很有用了。我们把它加入我们的 store 中。但是我们的 store 只能接收一个中间件函数，因此需要一种方式来组装我们的中间件。所以，我们需要一种方法，来把很多中间件函数变成一个中间件函数。来写 <code>applyMiddleware</code> 吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (middlewares.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> dispatch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (middlewares.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> middlewares[<span class="number">0</span>](store);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> boundMiddlewares = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span></span><br><span class="line">    middleware(store)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> boundMiddlewares.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span></span><br><span class="line">    next =&gt; a(b(next))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这不是个优雅的函数，但你应该可以跟得上。首先需要注意的是它接收一个中间件的列表，并返回一个中间件函数。这个新的中间件函数和之前的中间件有同样的签名。它接收一个 store（只包含新的派发 action 的 <code>dispatch</code> 和 <code>getState</code> 方法，不是整个 store）并返回另一个函数。对于这个函数：</p><ol><li>如果我们没有中间件，返回和原来一样的函数。基本上只是一个什么都不做的中间件（很蠢，但我们只是防止人们搞破坏）。</li><li>如果我们有一个中间件，直接返回这个中间件函数（也很蠢，只是做了个搬运工而已）。</li><li>我们把所有中间件绑定在我们假的 store 上（终于有趣起来了）。</li><li>我们把这些函数一个个绑定到下一个 dispatch 函数上。这就是我们的中间件有这么多箭头的原因。我们得到了这么一个函数：能够接收 action，并不断调用下一个 dispatch 函数直至抵达最原始的 dispatch 函数。</li></ol><p>好了，现在我们可以按预期使用所有的中间件了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(</span><br><span class="line">  delayMiddleware,</span><br><span class="line">  loggingMiddleware</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>现在我们的 Redux 实现可以做所有的事了！<a href="https://jsfiddle.net/justindeal/3ukd4mL7/52/">试试看</a>！</p><p>在浏览器中打开控制台，可以看到日志中间件发挥作用了。</p><h2 id="Thunk-中间件"><a href="#Thunk-中间件" class="headerlink" title="Thunk 中间件"></a>Thunk 中间件</h2><p>我们来做些真的异步操作吧。在此介绍一种“thunk”中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thunkMiddleware = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch, getState);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>“Thunk”真的只是“函数”的另一个名称，但是它通常意味着“封装了一些未来处理的工作的函数”。如果我们加入 <code>thunkMiddleware</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(</span><br><span class="line">  thunkMiddleware,</span><br><span class="line">  loggingMiddleware</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>现在我们可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="function">(<span class="params">&#123;getState, dispatch&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从 state 中取数据</span></span><br><span class="line">  <span class="keyword">const</span> someId = getState().someId;</span><br><span class="line">  <span class="comment">// 根据获取到的数据从服务端拉取数据</span></span><br><span class="line">  fetchSomething(someId)</span><br><span class="line">    .then(<span class="function">(<span class="params">something</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 任何时候都可以派发 action</span></span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: <span class="string">&#x27;someAction&#x27;</span>,</span><br><span class="line">        something</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunk 中间件是一柄大锤，我们可以把任何东西从 state 中拉出来，并在任何时候把任何 action 派发出去。这十分方便灵活，但随着你的 app 变得越来越大，它<strong>可能</strong>变得危险。但在这里还挺好用的。我们用它来做一些异步操作吧。</p><p>首先，创建一个假的 API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createFakeApi = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> _id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> createNote = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    _id++</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      id: <span class="string">`<span class="subst">$&#123;_id&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    createNote</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = createFakeApi()</span><br></pre></td></tr></table></figure><p>这个 API 只支持一个创建笔记的方法，并返回这个笔记的 id。因为我们从服务端获取 id，我们需要进一步改动我们的 reducer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  notes: &#123;&#125;,</span><br><span class="line">  openNoteId: <span class="literal">null</span>,</span><br><span class="line">  isLoading: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_NOTE: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          isLoading: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newNote = &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">false</span>,</span><br><span class="line">        openNoteId: action.id,</span><br><span class="line">        notes: &#123;</span><br><span class="line">          ...state.notes,</span><br><span class="line">          [action.id]: newNote</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，我们在使用 <code>CREATE_NOTE</code> action 来设置加载状态，以及在 store 中创建笔记。我们只用<code>id</code> 属性的存在与否来标记这种区别。你可能需要使用不同的 action，但 Redux 并不关心你使用什么。如果你想要一些规范，可以看看 <a href="https://github.com/acdlite/flux-standard-action?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">Flux Standard Actions</a>。</p><p>现在，让我们修改 <code>mapDispatchToProps</code> 来发出 thunk 吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  onAddNote: <span class="function">() =&gt;</span> dispatch(</span><br><span class="line">    (dispatch) =&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: CREATE_NOTE</span><br><span class="line">      &#125;);</span><br><span class="line">      api.createNote()</span><br><span class="line">        .then(<span class="function">(<span class="params">&#123;id&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: CREATE_NOTE,</span><br><span class="line">            id</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们的应用在执行异步操作了！<a href="https://jsfiddle.net/justindeal/o27j5zs1/8/">试试看</a>！</p><p>但等等… 除了给我们的组件添加一些丑陋的代码以外，我们还发明了中间件来把这些代码清理出去。但现在又放回去了。如果我们创建了一些定制的 api 中间件而不是使用 thunk，我们就可以避免这种情况。哪怕是使用 thunk 中间件，我们也可以把代码变得更像声明式。</p><h2 id="Action-创建器"><a href="#Action-创建器" class="headerlink" title="Action 创建器"></a>Action 创建器</h2><p>我们可以把在组件中发出 thunk 的操作抽象出来，放进一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createNote = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: CREATE_NOTE</span><br><span class="line">    &#125;);</span><br><span class="line">    api.createNote()</span><br><span class="line">      .then(<span class="function">(<span class="params">&#123;id&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">          type: CREATE_NOTE,</span><br><span class="line">          id</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码发明了一个 action 创建器。这不是什么奇特的东西，只是一个返回 action 的函数。它可以：</p><ol><li>把我们的新 thunk action 等丑陋的 action 抽象出来。</li><li>如果多个组件使用同样的 action，可以帮助你实现 DRY 原则。</li><li>让我们把创建 action 的操作抽象出来，使我们的组件更简洁。</li></ol><p>我们可以早些创建 action 创建器，但是并没有什么理由这样做。我们的应用很简单，所以不需要重复同样的 action。我们的 action 很简单，已经足够简洁和声明式了。</p><p>来使用 action 创建器修改一下我们的 <code>mapDispatchToProps</code>吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  onAddNote: <span class="function">() =&gt;</span> dispatch(createNote()),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就好多了！<a href="https://jsfiddle.net/justindeal/5j3can1z/171/">这是我们最终的应用</a>。</p><h2 id="就这样！"><a href="#就这样！" class="headerlink" title="就这样！"></a>就这样！</h2><p>你自己写了一个 Redux！看起来这篇文章写了很多代码，但是主要是我们的 reducer 和组件。我们实际的 Redux 实现还不到 <a href="https://gist.githubusercontent.com/jdeal/c224026df3bae5803fd9e58cbbd4a60b/raw/623150cb62a7076e78904881b61d4c948639abe8/mini-redux.js">140 行代码</a>，包括了我们的 thunk 和日志中间件、空行和注释！</p><p>真实的 Redux 和真实的应用比这复杂一些。后文中我们将讨论其中一些没讲到的情况，如果你觉得自己掉进 Redux 的坑里了，但愿这能给你带来一些希望。</p><h2 id="遗留事项"><a href="#遗留事项" class="headerlink" title="遗留事项"></a>遗留事项</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>我们的实现所缺少的是，监听特定属性是否真的改变了的能力。对于我们的示例应用而言，这并不要紧，因为每个状态变化都造成了属性的改变。但对于有很多 <code>mapStateToProps</code> 函数的大型应用而言，我们只想要在组件真的接收新属性时更新。要扩展我们的 <code>connect</code> 函数来实现这一点是很容易的。我们只需要在调用 <code>setState</code> 时比较前后的数据即可。我们需要更聪明地使用 <code>mapDispatchToProps</code>。注意，我们每次都在创建新的函数。真正的 React Redux 库会检查函数的参数，看看它是否依赖<code>属性</code>。这样，如果属性没有真的改变，就不需要再做一次映射。</p><p>你也需要注意，当我们在属性或者 store 状态改变时，会调用我们的函数。这些改变可能会瞬间同时发生，从而浪费一些性能。React Redux 优化了这一点，也优化了很多其他东西。</p><p>除此之外，对于更大的应用，我们需要考虑选择器的性能。比如，如果我们过滤一系列的笔记，我们可不想不停重复计算这个列表。为此，我们需要使用例如 <a href="https://github.com/reactjs/reselect?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">reselect</a> 或者其它的技术来缓存结果。</p><h3 id="冻结状态"><a href="#冻结状态" class="headerlink" title="冻结状态"></a>冻结状态</h3><p>如果你使用原始 JS 数据结构（而不是像 Immutable.js 这样的东西），那么我遗漏的一个很重要的细节是在开发时冻结 reducer 状态。因为这是 JavaScript，没有什么阻止你在从 store 中获取状态之后改变它。你可以在 <code>render</code> 方法或者别的任何东西中改变它。这会造成非常糟糕的结果，并且毁坏一些正在通过 Redux 加入的可预见性。我是这样做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> deepFreeze <span class="keyword">from</span> <span class="string">&#x27;deep-freeze&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;your-reducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frozenReducer = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? reducer : (</span><br><span class="line">  (...args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reducer(...args);</span><br><span class="line">    <span class="keyword">return</span> freezeState(state);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这创建了一个冻结了结果的 reducer。这样，如果你想要改变组件中的 store 状态，它将会在开发环境报错。过一段时间，你将能够避免这些错误。但如果你新接触不可变数据，这可能是最容易的练习方式了，对于你和你的团队来说都是如此。</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>除了性能以外，我们还在我们的 <code>connect</code> 实现上偷了懒，忽略了服务端渲染。<code>componentWillMount</code> 可以在服务端被调用，但是我们不想在服务端设置监听。Redux 使用 <code>componentDidMount</code> 和一些其他技巧来使它在浏览器中正常工作。</p><h3 id="Store-增强"><a href="#Store-增强" class="headerlink" title="Store 增强"></a>Store 增强</h3><p>我们并没有写几个高阶函数，这儿就有一个遗漏的：“store 增强器”是一个高阶函数，接收一个 store 创建器并返回一个“增强版”的 store 创建器。这不是一个常见的操作，但它可以被用来创造 Redux 开发者工具之类的东西。<strong>真正的</strong> <a href="https://github.com/reactjs/redux/blob/4d8700c9631b152f0dff384d528a6c7f74024418/src/applyMiddleware.js?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier"><code>applyMidleware</code> 实现</a> 就是一个 store 增强器。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这个 Redux 的实现都没有进行任何测试。因此无论如何，请不要在任何实际的产品中使用这个实现！这只是在本文中用于说明 Redux 原理的！</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>这款笔记应用目前是将数据保存在以数字作为 key 的对象中。这意味着每一个 JS 引擎都会按照创建的顺序来给它们排序。如果我们的服务器返回 GUID 或者其它未排序的主键，我们将很难排序。我们不想把笔记存放在数组中，因为要通过 id 获取特定笔记就不容易了。所以对于真实应用而言，我们可能需要用数组存放排好序的 id。另外，如果用 <code>reselect</code> 来缓存 <code>find</code> 操作结果的话，也可以尝试使用数组。</p><h3 id="Action-创建器的副作用"><a href="#Action-创建器的副作用" class="headerlink" title="Action 创建器的副作用"></a>Action 创建器的副作用</h3><p>有时候，你可能会想要创建一些这样的中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(fetch(<span class="string">&#x27;/something&#x27;</span>));</span><br></pre></td></tr></table></figure><p>别这样做，一个返回了 promise 的函数实际上已经开始运行了（除非它是个不正常的延迟 promise）。这也意味着我们无法用任何中间件来处理这个 action。比如，我们就不能使用节流中间件。另外我们也不能正常使用回放，因为这需要关闭 dispatch 函数。但是任何调用这个 <code>dispatch</code> 的代码都已经完成了工作，所以不能把它停掉。</p><p>确保你的 action 是对副作用的一种描述，而不是副作用本身。Thunk 是不透明的，不是最好的描述，但是它们也是对副作用的描述而不是副作用本身。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由可能会很奇怪，因为浏览器持有当前位置的一些状态，还有一些用于改变位置的方法。你一旦开始使用 Redux，就可能想要把路由状态放在 Redux store 中。我就是这样做的，所以我创建了一个<a href="https://github.com/zapier/redux-router-kit?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">路由库</a>来做这件事。也可以使用新版本的 <a href="https://reacttraining.com/react-router/">React 路由</a> 很酷，而且还有其它非 Redux 的路由解决方案。基本上，只要你想用，就可以找一些路由库来完成尽可能多的工作。</p><h3 id="其它事项"><a href="#其它事项" class="headerlink" title="其它事项"></a>其它事项</h3><p>基于 Redux，有大量中间件和工具组成的生态系统。下面罗列了一部分项目，你可以都看看，但推荐还是先熟悉基础知识！</p><p>你肯定会想看看 <a href="https://github.com/zalmoxisus/redux-devtools-extension?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">Redux 开发者工具扩展</a> 或者 <a href="https://github.com/gaearon/redux-devtools?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">Redux 开发者工具</a> 本身的代码。这些扩展是最简单的使用开发者工具的方式。</p><p><a href="https://github.com/evgenyrodionov/redux-logger?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">Logger for Redux</a> 是一个很方便的把 action 输出到控制台的中间件。</p><p>如果你想要发出多个同步 action，但只触发一次重新渲染，<a href="https://github.com/tshelburne/redux-batched-actions?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-batched-actions</a> 或 <a href="https://github.com/manaflair/redux-batch?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-batch</a> 会有用。</p><p>如果异步 action 或副作用在使用 <a href="https://github.com/gaearon/redux-thunk?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-thunk</a> 后看起来难以控制，而你又不想自己写中间件，你可以看看 <a href="https://github.com/redux-saga/redux-saga?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-saga</a> 或 <a href="https://github.com/jeffbski/redux-logic?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-logic</a>。或者，你想要继续深挖的话，<a href="https://github.com/redux-loop/redux-loop?utm_source=zapier.com&amp;utm_medium=referral&amp;utm_campaign=zapier">redux-loop</a> 也很有趣。</p><p>如果你想用 GraphQL，可以看看 <a href="http://dev.apollodata.com/">Apollo</a>，它可以和 Redux 结合在一起。</p><p>尽情享受吧！</p><hr><blockquote><p>翻译：<a href="https://github.com/tanglie1993">tanglie1993</a>，<a href="https://github.com/lsvih">lsvih</a><br>校对：<a href="https://github.com/nia3y">nia3y</a>，<a href="https://github.com/JohnieXu">JohnieXu</a><br>原文：<a href="https://zapier.com/engineering/how-to-build-redux/">Build Yourself a Redux</a><br>掘金地址：<a href="https://juejin.cn/post/6923922875191656462">https://juejin.cn/post/6923922875191656462</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redux 是一个简单的库，可以帮助你管理 JavaScript 应用的状态。虽然它很简单，但在学习过程中还是很容易掉坑。我经常需要解释 Redux 的用法和原理，而且我总是会从如何实现 Redux 来开始说明。所以，在此我们做这样一件事：从头开始，写一个能用的 Redux。我们的实现不会考虑所有的情况，但可以揭示大部分 Redux 的原理。&lt;/p&gt;
&lt;p&gt;注意，实际上我们将会实现的是 &lt;a href=&quot;https://github.com/reactjs/redux?utm_source=zapier.com&amp;amp;utm_medium=referral&amp;amp;utm_campaign=zapier&quot;&gt;Redux&lt;/a&gt; &lt;strong&gt;和&lt;/strong&gt; &lt;a href=&quot;https://github.com/reactjs/react-redux?utm_source=zapier.com&amp;amp;utm_medium=referral&amp;amp;utm_campaign=zapier&quot;&gt;React Redux&lt;/a&gt;。在这里，我们把 Redux 和著名的 UI 库 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 相结合，而这正是在实际场景中最为常见的组合。哪怕你把 Redux 和其他东西组合，这里讲解的所有东西几乎也还是一样的。&lt;/p&gt;
&lt;p&gt;我们开始吧！&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="Redux" scheme="https://lsvih.com/tags/Redux/"/>
    
    <category term="Frontend" scheme="https://lsvih.com/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>安装并配置 Docker 二进制版</title>
    <link href="https://lsvih.com/2021/01/04/docker-binary-install/"/>
    <id>https://lsvih.com/2021/01/04/docker-binary-install/</id>
    <published>2021-01-04T07:34:00.000Z</published>
    <updated>2021-01-04T08:00:36.816Z</updated>
    
    <content type="html"><![CDATA[<p>在 centos 7 环境下配置与安装 docker 二进制版。</p><ol><li>解压 docker 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf /path/to/&lt;FILE&gt;.tar.gz</span><br></pre></td></tr></table></figure></li><li>复制 docker 文件至 /usr/bin/ 目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp docker/* /usr/bin/</span><br></pre></td></tr></table></figure></li><li>使用 docker service 让 dockerd 自启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp docker_service/* /etc/systemd/system</span><br></pre></td></tr></table></figure></li><li>重启 systemctl，启用 docker 自启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker </span><br></pre></td></tr></table></figure></li><li><p>创建 docker 用户组，并将当前用户加入其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker</span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><blockquote><p>注：如果没有这一步，会导致 docker 只能由 sudo 运行，否则会出现 permission denied 的错误。</p></blockquote></li><li><p>重启 <code>reboot</code>。</p></li><li><p>验证 docker 安装情况： <code>docker images</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 centos 7 环境下配置与安装 docker 二进制版。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解压 docker 文件：&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    <category term="Note" scheme="https://lsvih.com/categories/Note/"/>
    
    
    <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
    <category term="bash" scheme="https://lsvih.com/tags/bash/"/>
    
    <category term="docker" scheme="https://lsvih.com/tags/docker/"/>
    
    <category term="deploy" scheme="https://lsvih.com/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>cytoscape.js 让标签与线错开</title>
    <link href="https://lsvih.com/2020/12/24/cytoscape-js-label-out-of-edge/"/>
    <id>https://lsvih.com/2020/12/24/cytoscape-js-label-out-of-edge/</id>
    <published>2020-12-24T04:05:00.000Z</published>
    <updated>2021-01-04T07:09:55.610Z</updated>
    
    <content type="html"><![CDATA[<p>按照官方说明，在 stylesheet 中直接使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">edge</span>&#123;</span><br><span class="line">     <span class="attribute">label</span>: <span class="built_in">data</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以让连边的 label 正常显示：</p><p><img src="/images/16097437968228.jpg" alt="-w806"></p><p>但是，文字覆盖在连边上效果很不好，因此有时候会使用 <code>outline</code> 等方式，让文本更加突出。而根据需求，现在需要让 label 文本和连边错开（即文本在边的上边而不是重合），使用官方提供的 margin 等接口，都会在连边不是水平的时候导致文本的错位：</p><p><img src="/images/16097440375915.jpg" alt="-w575"></p><p><img src="/images/16097440528539.jpg" alt="-w220"></p><p>上面两个图片是 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">edge</span>&#123;</span><br><span class="line">    <span class="attribute">text-margin-y</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的效果。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graph.cy.style().selector(<span class="string">&#x27;edge&#x27;</span>).style(&#123;<span class="string">&#x27;label&#x27;</span>:  <span class="function"><span class="params">label</span> =&gt;</span> label.data().name + <span class="string">&quot;\n\n\u200b&quot;</span>&#125;).update()</span><br></pre></td></tr></table></figure><p>直接让一行标签变成三行标签，这样就刚好和连边错开了。其中 <code>\u200b</code> 是空白的字符，在图中不会显示，拿来做占位符恰好合适。效果如下：</p><p><img src="/images/16097441916015.jpg" alt="-w310"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按照官方说明，在 stylesheet 中直接使用&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Front End" scheme="https://lsvih.com/categories/Front-End/"/>
    
    
    <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
    <category term="css" scheme="https://lsvih.com/tags/css/"/>
    
    <category term="cytoscpae" scheme="https://lsvih.com/tags/cytoscpae/"/>
    
  </entry>
  
  <entry>
    <title>知识的极限</title>
    <link href="https://lsvih.com/2020/09/20/the-limits-of-knowledge/"/>
    <id>https://lsvih.com/2020/09/20/the-limits-of-knowledge/</id>
    <published>2020-09-20T08:01:00.000Z</published>
    <updated>2020-09-20T08:38:56.084Z</updated>
    
    <content type="html"><![CDATA[<p>在 17 世纪，德国数学家戈特弗里德·莱布尼茨（Gottfried Leibnitz）提出了一种机器，该机器可以读取任意数学陈述，并根据数学公理来判断其是否正确。但是，每个陈述都可以这样判定么？或者我们所能知道的东西是否存在着极限呢？这个问题被称为 <strong>Entscheidungsproblem</strong>（判定性问题）。</p><p>两个世纪后，另一位德国数学家戴维·希尔伯特（David Hilbert）乐观地宣布，判定性问题的答案必须是，是的，我们能并且会知道任何数学问题的答案。他于 1930 年在德国柯尼斯堡（Königsberg）的一次讲话中曾说：</p><blockquote><p>Wir müssen wissen — wir werden wissen.（“我们必须知道 —— 我们会知道。”）</p></blockquote><p>但是我们会知道吗？</p><h4 id="数学的极限"><a href="#数学的极限" class="headerlink" title="数学的极限"></a>数学的极限</h4><p>历史表明希尔伯特的乐观主义是短暂的。同年，奥地利数学家库尔特·哥德尔（Kurt Gödel）通过证明他著名的<strong>不完备定理（incompleteness theorem）</strong>表明我们的数学知识是有极限的。</p><p>下面是理解哥德尔定理的简单方法。请考虑以下陈述。</p><p><strong>命题 S：此命题不可被证明。</strong></p><p>现在，假设在数学中我们可以证明 S 为真。但是这样一来，命题 S 本身将为假，从而不一致。好吧，那么让我们假设相反的情况，即我们无法在数学中证明 S。但这将意味着 S 本身为真，并且数学中包含至少一个无法证明为真的真命题。因此，数学要么不一致，要么不完备。如果我们假设它是一致的（命题不能同时为真和假），这只能得出数学是不完备的结论，即存在不能完全证明是真命题的真命题。</p><p>哥德尔（Gödel）对不完备定理的数学证明比我在此概述的要复杂得多，这从根本上改变了希尔伯特（Hilbert）所宣称的完整知识是可行的观点（“<strong>我们会知道</strong>”）。换句话说，如果我们假设数学是一致的，那么我们必然会发现无法证明的真命题。</p><p>例如，哥德巴赫猜想（The Goldbach conjecture），根据该猜想，每个偶数都是两个素数的和：</p><p>6 = 3 + 3<br>8 = 3 + 5<br>10 = 3 + 7<br>12 = 7 + 5，依此类推。</p><p>至今还没有人发现反例，如果猜想是真的，那也就不存在反例。得益于哥德尔的贡献，我们知道有无法证明的真命题，但不幸的是，我们没有办法找出这些命题。哥德巴赫猜想可能就是其中之一，如果是这样，那么尝试证明它就是浪费时间。</p><p><img src="/images/16005910816708.jpg" alt="Kurt Gödel（左）和 Alan Turing（右）"></p><h4 id="计算的极限"><a href="#计算的极限" class="headerlink" title="计算的极限"></a>计算的极限</h4><p>艾伦·图灵（Alan Turing）第一次了解哥德尔不完备定理时还是剑桥大学的研究生。在那段时间里，图灵忙于做一种机器的数理设计。这种机器可以处理任何输入并计算结果，与莱布尼茨几个世纪前所设想的相似。今天这些概念化的机器被称为<strong>图灵机</strong>，是现代数字计算机的蓝图。简单来说，图灵机可以看作现代计算机程序。</p><p>图灵当时在研究所谓的<strong>停机问题</strong>，可以描述如下：</p><p><strong>是否有一个程序可以确定另一个程序会停止（停机）还是不停（死循环）？</strong></p><p>图灵证明了停机问题的答案是“否”，即不存在这样的程序。与哥德尔的工作类似，他也是用“反证法（proof by contradiction）”证明的。假设存在一个程序 <strong>halts()</strong>，它能确定给定程序是否将停止。但是，我们还可以构建以下程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">    <span class="keyword">if</span> halts(g):</span><br><span class="line">        loop_forever()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>看看这里发生了什么？如果 g 成立，则 g 不成立；如果 g 不成立，则 g 成立。无论哪种方式，我们都将得到一个矛盾。<strong>因此，程序 halts() 不存在。</strong></p><p>哥德尔证明了数学是不完备的，而图灵证明了在某种意义上计算机科学也是“不完备的”。某些程序根本不存在。这不仅是理论上的好奇：停机问题在当今的计算机科学中具有许多实际意义。例如，如果我们希望编译器为给定的程序找到最快的机器码，那么我们实际上是在尝试解决停机问题 —— 而我们已经知道该问题是无法解决的。</p><p><img src="/images/16005911076517.jpg" alt="一个复杂的蛋白质结构 —— 预测蛋白质如何折叠是一个 NP 问题（NP-problem）"></p><h4 id="知识的实际极限：P-与-NP-问题"><a href="#知识的实际极限：P-与-NP-问题" class="headerlink" title="知识的实际极限：P 与 NP 问题"></a>知识的实际极限：P 与 NP 问题</h4><p>哥德尔和图灵通过揭示存在着的一些根本无法解决的问题，证明了我们所能知道的在理论上存在极限。但是此外，还有其他问题是理论上可以解决，但是因为求解的时间太长了，而我们实际上无法解决的。这里我们将会说明 <strong>P 问题和 NP 问题</strong>的区别。</p><p>P 问题是可以在“合理的时间”内解决的问题。在这里，“合理的时间”的含义是“多项式（polynomial）时间”（因此称为 P）。求解这些问题的计算复杂性随问题输入规模的增长而倍数增加（想想乘法或排序问题）。</p><p>另一方面，NP 问题是无法在合理时间内解决的问题。NP 是非确定性多项式（non-deterministic polynomial）的英文缩写，它的含义是可以用多项式级的计算复杂度验证问题的一个解，但不能用多项式级的计算复杂度求解。求 NP 问题的解的复杂度是指数级的，而不是多项式的，这会产生巨大的实际差异。NP 问题的例子包括最佳调度，预测蛋白质的折叠方式，加密消息，解决数独难题，最佳包装（又称背包问题）或最佳路由（又称旅行商问题）。一些问题（例如找到函数的离散傅立叶变换）最开始属于 NP 问题，但由于开发了新的、巧妙的算法来简化求解，最终变成了 P 问题。</p><p>当今计算机科学领域中最大的未解之谜之一就是 P 与 NP 问题：P 是否等于 NP？换句话说，对于所有我们可以在合理时间内<strong>验证</strong>一个解的问题，我们是否能在合理的时间内<strong>求</strong>解？</p><p>P 与 NP 问题非常重要，因此被列入“<a href="https://www.claymath.org/millennium-problems">千禧年大奖难题（Millenium prize problems）</a>”。如果找到答案，你会赢得一百万美元。再怎么夸大这个问题的重要性也不为过：P=NP 的世界与 P≠NP 的世界有着根本的不同。如果 P=NP，那么我们可以肯定地说，有一种更快的方法可以解决数独难题，或者预测蛋白质的折叠方式，我们只是还没有找到这种方法。毫无疑问，了解蛋白质的折叠方式会对现实世界产生全方面的影响，例如理解阿兹海默症的病理或治愈癌症。</p><p>如今，大多数科学家相信 P 不等于 NP，但是我们能确定吗？P 与 NP 问题本身可能类似于希尔伯特的 Entscheidungs 问题或图灵的停机问题：<strong>这个问题可能根本没有答案。</strong></p><a id="more"></a><h4 id="参考资料和进一步阅读"><a href="#参考资料和进一步阅读" class="headerlink" title="参考资料和进一步阅读"></a>参考资料和进一步阅读</h4><ul><li>《复杂》梅拉妮・米歇尔</li><li>P vs NP 和动物园的复杂性（<a href="https://www.youtube.com/watch?v=YX40hbAHx3s">视频</a>）</li><li>哥德尔不完备定理（<a href="https://www.youtube.com/watch?v=O4ndIDcDSGc">视频</a>）</li></ul><p>如果你喜欢本文，也可以查看以下内容：</p><ul><li><a href="https://towardsdatascience.com/how-to-be-less-wrong-5d6632a08f">如何减少错误 —— 用有限数据预测未来的贝叶斯指南</a></li><li><a href="https://medium.com/swlh/trajectories-formed-by-chance-bc96c8e236a5">偶然形成的轨迹 —— 在物理，金融和我们的生活中随机漫步</a></li></ul><blockquote><p>本文发布于掘金：<a href="https://juejin.im/post/6874475968325484552">https://juejin.im/post/6874475968325484552</a> </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 17 世纪，德国数学家戈特弗里德·莱布尼茨（Gottfried Leibnitz）提出了一种机器，该机器可以读取任意数学陈述，并根据数学公理来判断其是否正确。但是，每个陈述都可以这样判定么？或者我们所能知道的东西是否存在着极限呢？这个问题被称为 &lt;strong&gt;Entscheidungsproblem&lt;/strong&gt;（判定性问题）。&lt;/p&gt;
&lt;p&gt;两个世纪后，另一位德国数学家戴维·希尔伯特（David Hilbert）乐观地宣布，判定性问题的答案必须是，是的，我们能并且会知道任何数学问题的答案。他于 1930 年在德国柯尼斯堡（Königsberg）的一次讲话中曾说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wir müssen wissen — wir werden wissen.（“我们必须知道 —— 我们会知道。”）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是我们会知道吗？&lt;/p&gt;
&lt;h4 id=&quot;数学的极限&quot;&gt;&lt;a href=&quot;#数学的极限&quot; class=&quot;headerlink&quot; title=&quot;数学的极限&quot;&gt;&lt;/a&gt;数学的极限&lt;/h4&gt;&lt;p&gt;历史表明希尔伯特的乐观主义是短暂的。同年，奥地利数学家库尔特·哥德尔（Kurt Gödel）通过证明他著名的&lt;strong&gt;不完备定理（incompleteness theorem）&lt;/strong&gt;表明我们的数学知识是有极限的。&lt;/p&gt;
&lt;p&gt;下面是理解哥德尔定理的简单方法。请考虑以下陈述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命题 S：此命题不可被证明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，假设在数学中我们可以证明 S 为真。但是这样一来，命题 S 本身将为假，从而不一致。好吧，那么让我们假设相反的情况，即我们无法在数学中证明 S。但这将意味着 S 本身为真，并且数学中包含至少一个无法证明为真的真命题。因此，数学要么不一致，要么不完备。如果我们假设它是一致的（命题不能同时为真和假），这只能得出数学是不完备的结论，即存在不能完全证明是真命题的真命题。&lt;/p&gt;
&lt;p&gt;哥德尔（Gödel）对不完备定理的数学证明比我在此概述的要复杂得多，这从根本上改变了希尔伯特（Hilbert）所宣称的完整知识是可行的观点（“&lt;strong&gt;我们会知道&lt;/strong&gt;”）。换句话说，如果我们假设数学是一致的，那么我们必然会发现无法证明的真命题。&lt;/p&gt;
&lt;p&gt;例如，哥德巴赫猜想（The Goldbach conjecture），根据该猜想，每个偶数都是两个素数的和：&lt;/p&gt;
&lt;p&gt;6 = 3 + 3&lt;br&gt;8 = 3 + 5&lt;br&gt;10 = 3 + 7&lt;br&gt;12 = 7 + 5，依此类推。&lt;/p&gt;
&lt;p&gt;至今还没有人发现反例，如果猜想是真的，那也就不存在反例。得益于哥德尔的贡献，我们知道有无法证明的真命题，但不幸的是，我们没有办法找出这些命题。哥德巴赫猜想可能就是其中之一，如果是这样，那么尝试证明它就是浪费时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/16005910816708.jpg&quot; alt=&quot;Kurt Gödel（左）和 Alan Turing（右）&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;计算的极限&quot;&gt;&lt;a href=&quot;#计算的极限&quot; class=&quot;headerlink&quot; title=&quot;计算的极限&quot;&gt;&lt;/a&gt;计算的极限&lt;/h4&gt;&lt;p&gt;艾伦·图灵（Alan Turing）第一次了解哥德尔不完备定理时还是剑桥大学的研究生。在那段时间里，图灵忙于做一种机器的数理设计。这种机器可以处理任何输入并计算结果，与莱布尼茨几个世纪前所设想的相似。今天这些概念化的机器被称为&lt;strong&gt;图灵机&lt;/strong&gt;，是现代数字计算机的蓝图。简单来说，图灵机可以看作现代计算机程序。&lt;/p&gt;
&lt;p&gt;图灵当时在研究所谓的&lt;strong&gt;停机问题&lt;/strong&gt;，可以描述如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否有一个程序可以确定另一个程序会停止（停机）还是不停（死循环）？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图灵证明了停机问题的答案是“否”，即不存在这样的程序。与哥德尔的工作类似，他也是用“反证法（proof by contradiction）”证明的。假设存在一个程序 &lt;strong&gt;halts()&lt;/strong&gt;，它能确定给定程序是否将停止。但是，我们还可以构建以下程序：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;g&lt;/span&gt;():&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; halts(g):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        loop_forever()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看看这里发生了什么？如果 g 成立，则 g 不成立；如果 g 不成立，则 g 成立。无论哪种方式，我们都将得到一个矛盾。&lt;strong&gt;因此，程序 halts() 不存在。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哥德尔证明了数学是不完备的，而图灵证明了在某种意义上计算机科学也是“不完备的”。某些程序根本不存在。这不仅是理论上的好奇：停机问题在当今的计算机科学中具有许多实际意义。例如，如果我们希望编译器为给定的程序找到最快的机器码，那么我们实际上是在尝试解决停机问题 —— 而我们已经知道该问题是无法解决的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/16005911076517.jpg&quot; alt=&quot;一个复杂的蛋白质结构 —— 预测蛋白质如何折叠是一个 NP 问题（NP-problem）&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识的实际极限：P-与-NP-问题&quot;&gt;&lt;a href=&quot;#知识的实际极限：P-与-NP-问题&quot; class=&quot;headerlink&quot; title=&quot;知识的实际极限：P 与 NP 问题&quot;&gt;&lt;/a&gt;知识的实际极限：P 与 NP 问题&lt;/h4&gt;&lt;p&gt;哥德尔和图灵通过揭示存在着的一些根本无法解决的问题，证明了我们所能知道的在理论上存在极限。但是此外，还有其他问题是理论上可以解决，但是因为求解的时间太长了，而我们实际上无法解决的。这里我们将会说明 &lt;strong&gt;P 问题和 NP 问题&lt;/strong&gt;的区别。&lt;/p&gt;
&lt;p&gt;P 问题是可以在“合理的时间”内解决的问题。在这里，“合理的时间”的含义是“多项式（polynomial）时间”（因此称为 P）。求解这些问题的计算复杂性随问题输入规模的增长而倍数增加（想想乘法或排序问题）。&lt;/p&gt;
&lt;p&gt;另一方面，NP 问题是无法在合理时间内解决的问题。NP 是非确定性多项式（non-deterministic polynomial）的英文缩写，它的含义是可以用多项式级的计算复杂度验证问题的一个解，但不能用多项式级的计算复杂度求解。求 NP 问题的解的复杂度是指数级的，而不是多项式的，这会产生巨大的实际差异。NP 问题的例子包括最佳调度，预测蛋白质的折叠方式，加密消息，解决数独难题，最佳包装（又称背包问题）或最佳路由（又称旅行商问题）。一些问题（例如找到函数的离散傅立叶变换）最开始属于 NP 问题，但由于开发了新的、巧妙的算法来简化求解，最终变成了 P 问题。&lt;/p&gt;
&lt;p&gt;当今计算机科学领域中最大的未解之谜之一就是 P 与 NP 问题：P 是否等于 NP？换句话说，对于所有我们可以在合理时间内&lt;strong&gt;验证&lt;/strong&gt;一个解的问题，我们是否能在合理的时间内&lt;strong&gt;求&lt;/strong&gt;解？&lt;/p&gt;
&lt;p&gt;P 与 NP 问题非常重要，因此被列入“&lt;a href=&quot;https://www.claymath.org/millennium-problems&quot;&gt;千禧年大奖难题（Millenium prize problems）&lt;/a&gt;”。如果找到答案，你会赢得一百万美元。再怎么夸大这个问题的重要性也不为过：P=NP 的世界与 P≠NP 的世界有着根本的不同。如果 P=NP，那么我们可以肯定地说，有一种更快的方法可以解决数独难题，或者预测蛋白质的折叠方式，我们只是还没有找到这种方法。毫无疑问，了解蛋白质的折叠方式会对现实世界产生全方面的影响，例如理解阿兹海默症的病理或治愈癌症。&lt;/p&gt;
&lt;p&gt;如今，大多数科学家相信 P 不等于 NP，但是我们能确定吗？P 与 NP 问题本身可能类似于希尔伯特的 Entscheidungs 问题或图灵的停机问题：&lt;strong&gt;这个问题可能根本没有答案。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Algorithm" scheme="https://lsvih.com/tags/Algorithm/"/>
    
    <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>树莓派 4 GPIO 简介及使用 Node.js 控制树莓派</title>
    <link href="https://lsvih.com/2020/09/05/an-introduction-to-raspberry-pi-4-gpio-and-controlling-it-with-node-js/"/>
    <id>https://lsvih.com/2020/09/05/an-introduction-to-raspberry-pi-4-gpio-and-controlling-it-with-node-js/</id>
    <published>2020-09-05T10:25:00.000Z</published>
    <updated>2020-10-28T07:21:10.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567.jpeg" alt="68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567"></p><blockquote><p>通过本文，我们将熟悉树莓派 GPIO 及其技术规范。并且，我们将通过了一个简单例子，说明如何使用树莓派的 I/O 控制 LED 和开关。</p></blockquote><p>你可能见过 “<strong>IoT</strong>” 这个术语，它是 <strong>Internet of Things（物联网）</strong> 的缩写。意思是，人们可以通过互联网控制一台设备（即“物” <strong>thing</strong>）。比如，用手机控制你房间内的智能电灯泡就是一种物联网的应用。</p><p>由于物联网设备可通过互联网控制，所以 IoT 设备需要始终与互联网相连。我们主要有两种方式将设备连接至互联网：以太网网线和 WiFi。</p><p>物联网设备可被用于各种目的。例如，你可以使用物联网来控制你家的室内温度、照明或者在回家前打开某些设备，所有这些操作都只需要通过你的手机便能实现。</p><p>那么，物联网设备的技术规范有哪些？简言之，它应该包含连接到互联网的工具，有一些输入和输出接口来读写设备的模拟或数字信号，并且使用最少的硬件来读取和执行程序指令。</p><p>一个物联网设备配有一个硬件组件，为外部设备读取数字数据和取电提供接口。该接口就是 <strong>GPIO</strong> 或称作 <strong>General Purpose Input Output（通用输入输出接口）</strong> 。这种硬件组件基本上都是由一系列可以连接到外部设备的引脚（或管脚，pin）构成。</p><p>这些 GPIO 引脚可以被程序控制。比如，在满足一些条件的情况下，我们可以给一个 GPIO 引脚施以 5V 的电压，任何连接到该引脚的设备都会被开启。程序也能够监听来自互联网的信号，并根据该信号对 GPIO 引脚进行控制。这就是物联网。</p><a id="more"></a><p>从头开始构建这样一个物联网设备可能很困难，因为需要处理的组件有很多。幸运的是，我们可以购买售价低廉的现成的设备。这些设备配有 GPIO 硬件和连接互联网的工具。</p><h4 id="Arduino-微控制器"><a href="#Arduino-微控制器" class="headerlink" title="Arduino 微控制器"></a>Arduino 微控制器</h4><p>目前，如果我们想要实现简单的自动化，那么 <a href="https://en.wikipedia.org/wiki/Arduino"><strong>Arduino</strong></a> 是最好的选择。它是一个 <strong>微控制器（micro-controller）</strong> ，可以用 C 和 C++ 这样的编程语言来编写 Arduino 程序。</p><p><img src="/images/15993016013204.jpg" alt=""></p><p>然而，该控制器不配有内置 WiFi 或以太网插孔，并且必须连接外部外围设备（即<strong>屏蔽</strong>）才能将 Arduino 连接到互联网。</p><p>Arduino 旨在充当外部设备的控制器，而不是成熟的物联网设备。因此，该控制器价格非常便宜，某些最新款的售价可以低至 18 美元。</p><h4 id="树莓派微型电脑"><a href="#树莓派微型电脑" class="headerlink" title="树莓派微型电脑"></a>树莓派微型电脑</h4><p>相较于 Arduino，<a href="https://en.wikipedia.org/wiki/Raspberry_Pi"><strong>树莓派</strong></a> 更像是一只<strong>野兽</strong>。其发明之初的目的就是为了促进基础计算机科学教学在学校和发展中国家的进步。但它现在却被书呆子和业余爱好者们捡起来创造各种各样的小玩意儿。目前，它是世界上最受欢迎的<strong>单板计算机</strong>之一。</p><p>树莓派（<strong>最新版 4B</strong>）配有以太网连接器、WiFi、蓝牙、HDMI 输出、USB 连接器、 40 个 GPIO 引脚和其他基本功能。它由 <strong>ARM</strong> CPU、 <strong>博通</strong> GPU 和 1/2/4 GB 的 <strong>RAM</strong> 驱动。你可以在<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications"><strong>此维基百科</strong></a>的表格中查看这些规范。</p><p><img src="/images/15993016150996.jpg" alt=""></p><p>尽管树莓派的硬件很丰富，但它最新版的售价也仅在 $40 到 $80 间。别忘了，这可是一台拥有原生操作系统的成熟计算机。这意味着我们不需要连接外部计算机就能对其进行编程。</p><p>与我们日常使用的电脑不同，树莓派提供了一个 GPIO 硬件组件来控制外部设备。这使得树莓派成为了一种几乎可以做任何事情的设备。</p><p>让我们了解一下新版树莓派 GPIO 的技术规格。</p><hr><h2 id="树莓派-GPIO-引脚分配"><a href="#树莓派-GPIO-引脚分配" class="headerlink" title="树莓派 - GPIO 引脚分配"></a>树莓派 - GPIO 引脚分配</h2><p>树莓派（<strong>4B 版</strong>）总共 <strong>40 个 GPIO 引脚</strong>，分布在 <code>20 x 2</code> 的阵列当中。如下图所示，每个引脚都有特定的用途。</p><p><img src="/images/15993016268148.jpg" alt=""></p><p>在讨论每个引脚的功能之前，让我们先了解一些协议。每个引脚都有特定的编号，我们就是通过这些编号从软件中控制这些引脚。</p><p>在圆圈中，你可以看到的数字是 GPIO 硬件上的物理引脚编号。例如：<strong>1 号引脚</strong> 提供 3.3V 的恒定电压。该编号系统称为 <strong>Board pin</strong> 或<strong>物理引脚</strong>编号系统。</p><p>由于树莓派 4B 使用 <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/README.md"><strong>BCM2711</strong></a> 处理器芯片，因此，我们还有另一个由<a href="https://en.wikipedia.org/wiki/Broadcom_Inc."><strong>博通</strong></a>创建的引脚编号系统。此系统被称为 <strong>BCM</strong> 或 <strong>博通模式</strong>。上图中，每个引脚附带的标签都显示了 BCM 引脚编号。例如：物理 <strong>7 号引脚</strong>是 <strong>BCM 7 号引脚</strong>并被标记为 <strong>GPIO 4</strong>。</p><p>我们既可以选择遵循 <strong>Board pin</strong> 编码，也可以用 <strong>BCM</strong> 编码系统。然而，由于我们用 GPIO 编程库的原因，同时使用该两种编码系统可能会遇到问题。大多数库都偏好于 BCM 编号系统，因为它引用于博通 CPU 芯片。</p><blockquote><p>从现在开始，如果文中出现 <strong>x 号引脚</strong>，就意味着这是引脚板上的<strong>物理引脚编号</strong>。如果提到了 BCM，则意味着我们在使用 BCM 引脚编号。</p></blockquote><h4 id="💡-电源引脚和引脚分组"><a href="#💡-电源引脚和引脚分组" class="headerlink" title="💡 电源引脚和引脚分组"></a>💡 电源引脚和引脚分组</h4><p><strong>1 号</strong>和 <strong>17 号</strong>引脚提供 <strong>3.3V</strong> 电源，而 <strong>2 号</strong>和 <strong>4 号</strong>引脚提供 <strong>5V</strong> 电源。当你打开树莓派时，这些引脚便会提供<strong>恒定功率</strong>，并且无论在何种条件下，这几个引脚都是<strong>不可编程的</strong>。</p><p><strong>6 号</strong>、 <strong>9 号</strong>、 <strong>14 号</strong>、 <strong>20 号</strong>、 <strong>25 号</strong>、 <strong>30 号</strong>、 <strong>34 号</strong>和 <strong>39 号</strong>引脚支持接地。它们应该与电路的<strong>阴极</strong>相连。电路中所有的接地连接都可以用同一个接地引脚，因为它们都连接到同一根地线。</p><blockquote><p>如果你想知道为什么有这么多接地引脚，可以查看<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=132851"><strong>这个帖子</strong></a>。</p></blockquote><h4 id="🔌-GPIO-引脚"><a href="#🔌-GPIO-引脚" class="headerlink" title="🔌 GPIO 引脚"></a>🔌 GPIO 引脚</h4><p>除了<strong>电源</strong>和<strong>接地</strong>引脚外，其他引脚均为通用输入和输出引脚。当 GPIO 引脚用于<strong>输出模式</strong>时，它在开启时提供 3.3V 恒定功率。</p><p>在<strong>输入模式</strong>下，GPIO 引脚也可用于监听外部电源。从技术上看，当用 <strong>3.3V</strong> 电压供给处于输入模式的 GPIO 引脚时，该引脚将被读取为<strong>逻辑高电平</strong>或 <strong>1</strong>。当引脚接地或提供 <strong>0V</strong> 功率时，它会被读作<strong>逻辑低电平</strong>或 <strong>0</strong>。</p><p>而<strong>输出模式</strong>更加简单。在输出模式下，我们接通一个引脚，设备会通过该引脚提供 3.3V 的电压。而在引脚的输入端，我们需要监听引脚上的电压变化，当引脚处于逻辑高电平或低电平时，我们可以执行其他操作，如打开一个输出 GPIO 引脚。</p><h4 id="🧙‍♀️-SPI、-I²C-和-UART-协议"><a href="#🧙‍♀️-SPI、-I²C-和-UART-协议" class="headerlink" title="🧙‍♀️ SPI、 I²C 和 UART 协议"></a>🧙‍♀️ SPI、 I²C 和 UART 协议</h4><p>SPI（<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface"><strong>Serial Peripheral Interface (串行外设接口)</strong></a>）是一种同步串行通信接口，设备可以使用它来实现相互间的通信。此接口需要 3 条或更多数据线将主设备连接到（<strong>一个或多个</strong>）从设备。</p><p>I²C（<a href="http://C"><strong>Inter-Integrated Circuit (内置集成电路)</strong></a>）类似于 SPI，但它支持多个主设备。此外，与 SPI 不同，它只需要两条数据线来容纳多个从机。不过这会让 I²C 比 SPI 慢。</p><p>UART（<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">Universal asynchronous receiver-transmitter (通用异步收发传输器)</a>）也是一个串行通信接口，但数据是<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication"><strong>异步</strong></a>发送的。</p><p>树莓派提供了一个底层接口用于通过 GPIO 引脚就像我们前文讨论过的输入输出模式一样启用这些接口。然而，并非所有的 GPIO 引脚都可以实现这些通信方式。</p><p>在下图中，你可以看到哪些 GPIO 针脚是可以通过 SPI、I²C 和 UART 协议进行配置的。你可以访问 <strong><a href="https://pinout.xyz/">pinout.xyz</a></strong>，这个网页提供了一个交互界面供用户查看每个 GPIO 引脚的功能。</p><p><img src="/images/15993016462986.jpg" alt=""></p><p>除了简单的输入或输出模式，GPIO 引脚有 <strong>6 种模式</strong>，但每次只能在一种模式下工作。当你在上面那个网页中点击 GPIO 引脚时，你可以在屏幕右侧看到它的工作模式。右表中的 ALT0 至 ALT5 描述了这些模式。</p><blockquote><p>你还可以通过<a href="https://www.youtube.com/watch?v=IyGwvGzrqp8"><strong>这个视频</strong></a>来了解这些通信协议的规范。在本教程中，我们不会涉及这些通信协议，但是，我将在接下来的文章中讨论相关主题。</p></blockquote><h4 id="⚡-现行规范"><a href="#⚡-现行规范" class="headerlink" title="⚡ 现行规范"></a>⚡ 现行规范</h4><p>我们已经讨论过电源和 GPIO 引脚的电压规格。因为树莓派官方文件中未曾提及具体规范，所以现行规范还不太明确。</p><p>不过可以确定的是，我们在处理电流时，必须要遵循安全措施：从任何引脚获取的最大电流应小于或等于 <strong>16mA</strong>。因此，我们必须调整负载以满足这一要求。</p><p>如果我们已经将多个设备连接到树莓派 GPIO 和其他端口（如 USB），那么我们必须确保从电路获取的最大电流小于 <strong>50mA</strong>。</p><p>为了限制电流，我们可以在电路中增加电阻，使得最大电流不会超过这些限制。当一个设备需要的电流比树莓派的最大限制还要大时，应当使用继电器开关。</p><p><strong>输入</strong>模式使用的也是相同的规范。当 GPIO 引脚被用作<strong>漏极</strong>（<strong>而非</strong> 源 <strong>电流</strong>）时，我们不应该供应超过 <strong>16mA</strong> 的电流。此外，当多个 GPIO 引脚用作输入时，总共不应施加超过 <strong>50mA</strong> 的电流。</p><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>我相信你已经走过一遍树莓派的设置流程。这意味着你已经安装了一个 <a href="https://www.raspberrypi.org/downloads/raspbian/"><strong>Raspbian</strong></a> 之类的或是你个人偏好的操作系统，并且可以通过 SSH 或 HDMI 访问它。</p><p>我们需要做的第一件事就是创建项目目录。我已经在 <code>/home/pi/Programs/io-examples</code> 这个路径下创建了项目目录，我们所有的程序都将作为教程示例保存在该路径下。</p><p>由于我们想通过 Node.js 来控制 GPIO 引脚，首先我们必须安装 Node。你可以选择你最喜欢的方法，但我个人会使用 <strong><a href="https://github.com/nvm-sh/nvm">NVM</a></strong>（Node 版本管理器）来安装。你可以遵循<a href="https://github.com/nvm-sh/nvm#install--update-script"><strong>该建议步骤</strong></a>安装 NVM。</p><p>一旦装好了 NVM，我们就可以安装特定版本的 Node。我将使用 Node v12，因为它是最新的稳定版本。要安装 Node v12，请输入以下命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 12</span><br><span class="line">nvm use 12</span><br></pre></td></tr></table></figure><p>一旦树莓派安装了 Node.js，我们就可以继续创建项目了。因为我们想要控制 GPIO 引脚，所以我们需要一个库来为我们提供一个简单的应用编程接口。</p><p><a href="https://www.npmjs.com/package/onoff"><strong>onoff</strong></a> 是一个知名的用树莓派控制 GPIO 的库。首先，在项目目录中创建 package.json，然后安装 <code>onoff</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/pi/Programs/io-examples</span><br><span class="line">npm init -y</span><br><span class="line">npm i -S onoff</span><br></pre></td></tr></table></figure><p>现在一切准备就绪，我们可以开始电路设计并编写第一个程序来测试 GPIO 的能力。</p><hr><h2 id="LED-输出示例"><a href="#LED-输出示例" class="headerlink" title="LED 输出示例"></a>LED 输出示例</h2><p>在本例中，我们将以编程方式打开红色 LED。让我们先看看下面的电路图：</p><p><img src="/images/15993016620920.jpg" alt=""></p><p>从上图可以看出，我们已经将 <strong>6 号引脚</strong>（<strong>接地引脚</strong>）连接到了线路板的负极（<strong>地线</strong>）上，并将 <strong>BCM 4</strong> 连接到了 <strong>1k ohm</strong> 电阻的一端。电阻器的另一端连接到红色 LED 的输入端上，LED 的输出端接地。</p><p>除了有个电阻，这个电路没什么特别的。需要这个额外的电阻是因为红色 LED 在 <strong>2.4V</strong> 电压下工作，而提供 <strong>3.3V</strong> 电压的 GPIO 会损坏 LED。此外，LED 采用的 <strong>20mA</strong> 超过了树莓派的安全阈值，因此，也需要这个电阻来防止电流过大。</p><blockquote><p>我们可以选择 330 ohms 到 1k ohms 的电阻。这个数值范围的电阻会影响电流大小，但都不会损坏 LED。</p></blockquote><p>从上述电路来看，电路中唯一的变量是 BCM 4 引脚输出。如果引脚打开（<strong>3.3V</strong>），电路将闭合，LED 将发光。如果引脚关闭（<strong>0V</strong>），电路断开，LED 不会发光。</p><p>让我们编写一个程序，实现以编程方式打开 BCM 4 引脚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 4 pin as &#x27;output&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ledOut = <span class="keyword">new</span> Gpio( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;out&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// current LED state</span></span><br><span class="line"><span class="keyword">let</span> isLedOn = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run a infinite interval</span></span><br><span class="line"><span class="built_in">setInterval</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ledOut.writeSync( isLedOn ? <span class="number">0</span> : <span class="number">1</span> ); <span class="comment">// provide 1 or 0 </span></span><br><span class="line">  isLedOn = !isLedOn; <span class="comment">// toggle state</span></span><br><span class="line">&#125;, <span class="number">3000</span> ); <span class="comment">// 3s</span></span><br></pre></td></tr></table></figure><p>在上述程序中， 我们导入 <code>onoff</code> 包并引入 <code>Gpio</code> 构造函数。用设定好的配置创建 <code>Gpio</code> 类来配置一个 GPIO。上面的例子中，我们将 <strong>BCM 4</strong> 设置成了<strong>输出模式</strong>。</p><blockquote><p>你可以参考该 <code>onoff</code> 模块的 <a href="https://github.com/fivdi/onoff#api"><strong>API 文档</strong></a>来了解各种配置选项和 API。</p></blockquote><p><code>Gpio</code> 类创建的实例提供了与该引脚交互的高阶 API。<code>writeSync</code> 方法会将 <strong>1</strong> 或 <strong>0</strong> 写入引脚，以实现开启或关闭引脚。当引脚设为 <strong>1</strong> 时，引脚<strong>开启</strong>并输入 <strong>3.3V</strong> 电源。当它设为 <strong>0</strong> 时，引脚会<strong>关闭</strong>且不再提供任何电源电压（<strong>0V</strong>）。</p><p>使用 <code>setInterval</code> 时，我们就是在运行一个无限循环，不断地调用 <code>ledOut.writeSync(val)</code> 方法在 <code>ledOut</code> 引脚中写入 0 或 1。让我们使用 Node.js 来运行这个程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node rpi-led-out.js</span><br></pre></td></tr></table></figure><p>由于这是一个无限循环的程序，一旦启动，它就不会终止，除非我们使用 <code>ctrl + c</code> 强制终止程序。在该程序的生命周期内，它将每隔 <strong>3 秒</strong>切换一次 <strong>BCM 4</strong> 引脚的状态。</p><p>树莓派 GPIO 有意思的一点是，一旦 GPIO 引脚被设为 <strong>1</strong> 或 <strong>0</strong>，它将一直保持不变， 除非我们覆盖该值或关闭树莓派的电源。比如，当你启动程序时，LED 处于熄灭状态，但当你终止程序时，LED 可能会保持亮起状态。</p><h2 id="开关输入示例"><a href="#开关输入示例" class="headerlink" title="开关输入示例"></a>开关输入示例</h2><p>众所周知，当把 GPIO 用作输入时，我们需要提供接近 <strong>3.3V</strong> 的电压。我们可以连接一个开关（<strong>按钮</strong>）直接从 <strong>3.3V</strong> 引脚提供电压，如下图所示：</p><p><img src="/images/15993016750320.jpg" alt=""></p><p>在输入开关之前，我们已经在电路中使用了一个 <strong>1K ohm</strong> 的电阻。它能防止 <strong>3.3V</strong> 电源产生过大的电流，避免开关熔断。</p><p>我们还连接了一个 <strong>10K ohm</strong> 电阻，该电阻也从按钮的输出端汲取电流并接地。这类电阻被称为<strong>下拉</strong>电阻（<strong>因为它们在电路中的位置</strong>），它们会将电流（<strong>或大气中电荷聚集产生的电流</strong>）导向地面。</p><blockquote><p>我们也可以增加一个<strong>上拉电阻</strong>，从 <strong>3.3V</strong> 引脚导出电流，供给给 GPIO 的输入引脚。在这种配置下，输入引脚会始终读取 <strong>高</strong> 或 <strong>1</strong>。按下按钮时，开关在电阻和地面之间产生短路，将所有电流导向地面，并且没有电流通过开关到达输入引脚，读数为 <strong>0</strong>。<a href="https://www.youtube.com/watch?v=5vnW4U5Vj0k"><strong>此处有一段很棒的视频</strong></a>演示了上拉和下拉电阻。</p></blockquote><p>开关的输出连接到 <strong>BCM 17</strong> 引脚。当按下按钮（<strong>开关</strong>）时，电流将通过开关流入 BCM 17 引脚。然而，由于 10K ohm 电阻给电流提供了更大的障碍，大多数电流会流向由<strong>红色虚线</strong>表示的回路。</p><p>未按下按钮时，由红色虚线表示的回路闭合，没有电流流过。然而，由<strong>灰色虚线</strong>表示的环路是闭合的，BCM 17 引脚接地（<strong>0V</strong>）。</p><blockquote><p>增加一个 10k ohm 电阻是为了让 BCM 17 引脚接地，这样它就不会将任何大气干扰读取为高输入。如果不将输入引脚接地，输入引脚会保持在<strong>浮动状态</strong>。在这种状态下，由于大气干扰，输入引脚可能读取为 0 或 1。</p></blockquote><p>既然电路已经准备好了，让我们编写一个程序来读取输入值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 17 pin as &#x27;input&#x27;</span></span><br><span class="line"><span class="keyword">const</span> switchIn = <span class="keyword">new</span> Gpio( <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;both&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen for pin voltage change</span></span><br><span class="line">switchIn.watch( <span class="function">(<span class="params"> err, value </span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( err ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Error&#x27;</span>, err );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// log pin value (0 or 1)</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&#x27;Pin value&#x27;</span>, value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上面的程序中，我们将 <strong>BCM 17</strong> 引脚设置为输入模式。<code>Gpio</code> 构造函数的第三个参数配置了我们何时需要引脚输入电压变化的通知。该参数名为 <strong><code>edge</code></strong>，因为我们读取的是电压上升和下降周期的边缘电压值。</p><p><code>edge</code> 参数可以有以下值：</p><p>当使用 <code>rising</code> 值时，如果 GPIO 引脚的输入电压<strong>从 0V 上升</strong>（<strong>至 3.3V</strong>），我们将收到通知。位于此位置时，引脚将读取<strong>逻辑高位</strong>或 <strong>1</strong>，因为该引脚获得了更高的电压。</p><p>当使用 <code>falling</code> 值时，如果输入电压（<strong>从 3.3V</strong>） <strong>降至 0V</strong>，我们将收到通知。位于此位置时，引脚将读取<strong>逻辑低位</strong>或 <strong>0</strong>，因为它正在失去电压。</p><p>当使用 <code>both</code> 值时，我们将收到上述两个事件的通知。当电压从 0V 上升（<strong>至输入高电平或 1</strong>）或从 3.3V 下降（<strong>至输入低电平或 0</strong>）时，我们都会收到到这些事件的通知。</p><blockquote><p>此处不讨论 <code>none</code> 值，请阅读<a href="https://github.com/fivdi/onoff#gpiogpio-direction--edge--options"><strong>文档</strong></a>了解更多信息。</p></blockquote><p>输入模式下 GPIO 引脚上的 <code>watch</code> 方法监视上述事件。这是一个异步方法，因此我们需要传递一个回调函数，该函数接收输入高（1）或输入低（0）值。</p><p>由于我们使用的是 <code>both</code> 值，所以 <code>watch</code> 方法将在输入电压上升时以及输入电压下降时都执行回调。按下按钮，你应该会在控制台中看到下面的值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Pin</span> value <span class="number">1</span> (按下按钮)</span><br><span class="line"><span class="attribute">Pin</span> value <span class="number">0</span> (释放按钮)</span><br><span class="line"><span class="attribute">Pin</span> value <span class="number">1</span> (按下按钮)</span><br><span class="line"><span class="attribute">Pin</span> value <span class="number">1</span> (重复值)</span><br><span class="line"><span class="attribute">Pin</span> value <span class="number">0</span> (按下按钮)</span><br></pre></td></tr></table></figure><p>如果仔细检查以上输出就能发现，我们有时会在按下或释放按钮时得到重复的值。由于开关机制的两个连接器之间的物理连接并不总那么顺畅，所以，不小心按下开关时，它可以多次连接和断开。</p><p>为了避免这种情况，我们可以在开关电路中增加电容，在实际电流流入 GPIO 引脚之前充电，并在按钮释放时平稳放电。这种方法非常简单，你可以试一试。</p><h2 id="组合-I-O-示例"><a href="#组合-I-O-示例" class="headerlink" title="组合 I/O 示例"></a>组合 I/O 示例</h2><p>现在我们已经充分理解了 GPIO 引脚的工作原理以及配置方法，让我们结合最后两个例子进行讲解。更重要的是，按下按钮时，打开 LED 而释放按钮时关闭 LED。让我们先看看电路图：</p><p><img src="/images/15993016891138.jpg" alt=""></p><p>从以上例子可以看出，我们没有从上面的两个例子中改变任何东西。另外，LED 和开关电路都是独立的。这意味着我们之前的程序在这条线路上应该可以正常工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 4 pin as &#x27;output&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ledOut = <span class="keyword">new</span> Gpio( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;out&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 17 pin as &#x27;input&#x27;</span></span><br><span class="line"><span class="keyword">const</span> switchIn = <span class="keyword">new</span> Gpio( <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;both&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen for pin voltage change</span></span><br><span class="line">switchIn.watch( <span class="function">(<span class="params"> err, value </span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( err ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Error&#x27;</span>, err );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the input value (0 or 1) &#x27;ledOut&#x27; pin</span></span><br><span class="line">  ledOut.writeSync( value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上述程序中，我们将 GPIO 引脚分别配置为输入和输出模式。由于输入引脚上的 <code>watch</code> 方法提供的值是 <strong>0</strong> 或 <strong>1</strong>，因此，我们直接把这些值写入输出引脚。</p><p>因为我们在 <code>both</code> 模式下用 <code>watch</code> 方法监视输入引脚，当按下按钮发送 <strong>1</strong> 或者释放按钮发送 <strong>0</strong> 时，<code>watch</code> 方法的回调将被触发。</p><p>我们可以直接使用该值写入 <code>ledOut</code> 引脚。因此，按下按钮时，<code>value</code> 为 <code>1</code> 并执行 <code>ledOut.writeSync(1)</code>，会打开 LED。松开按钮时则反之。</p><hr><p><img src="/images/1_a35VFbnt_AUM0ch8ftCxMA.gif" alt="1_a35VFbnt_AUM0ch8ftCxMA"></p><p>以上是我们刚才创建的完整输入/输出电路的演示。为了你本人和树莓派的安全，建议买一个好的外壳和 40 针 GPIO 扩展带状电缆。</p><p>希望你今天能学到一点东西。在接下来的教程中，我们将构建一些复杂的电路并学习连接一些有意思的设备，如字符 LCD 显示屏和数字输入板。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/6868946182325043207">https://juejin.im/post/6868946182325043207</a> </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567.jpeg&quot; alt=&quot;68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过本文，我们将熟悉树莓派 GPIO 及其技术规范。并且，我们将通过了一个简单例子，说明如何使用树莓派的 I/O 控制 LED 和开关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可能见过 “&lt;strong&gt;IoT&lt;/strong&gt;” 这个术语，它是 &lt;strong&gt;Internet of Things（物联网）&lt;/strong&gt; 的缩写。意思是，人们可以通过互联网控制一台设备（即“物” &lt;strong&gt;thing&lt;/strong&gt;）。比如，用手机控制你房间内的智能电灯泡就是一种物联网的应用。&lt;/p&gt;
&lt;p&gt;由于物联网设备可通过互联网控制，所以 IoT 设备需要始终与互联网相连。我们主要有两种方式将设备连接至互联网：以太网网线和 WiFi。&lt;/p&gt;
&lt;p&gt;物联网设备可被用于各种目的。例如，你可以使用物联网来控制你家的室内温度、照明或者在回家前打开某些设备，所有这些操作都只需要通过你的手机便能实现。&lt;/p&gt;
&lt;p&gt;那么，物联网设备的技术规范有哪些？简言之，它应该包含连接到互联网的工具，有一些输入和输出接口来读写设备的模拟或数字信号，并且使用最少的硬件来读取和执行程序指令。&lt;/p&gt;
&lt;p&gt;一个物联网设备配有一个硬件组件，为外部设备读取数字数据和取电提供接口。该接口就是 &lt;strong&gt;GPIO&lt;/strong&gt; 或称作 &lt;strong&gt;General Purpose Input Output（通用输入输出接口）&lt;/strong&gt; 。这种硬件组件基本上都是由一系列可以连接到外部设备的引脚（或管脚，pin）构成。&lt;/p&gt;
&lt;p&gt;这些 GPIO 引脚可以被程序控制。比如，在满足一些条件的情况下，我们可以给一个 GPIO 引脚施以 5V 的电压，任何连接到该引脚的设备都会被开启。程序也能够监听来自互联网的信号，并根据该信号对 GPIO 引脚进行控制。这就是物联网。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Node.js" scheme="https://lsvih.com/tags/Node-js/"/>
    
    <category term="IoT" scheme="https://lsvih.com/tags/IoT/"/>
    
    <category term="GPIO" scheme="https://lsvih.com/tags/GPIO/"/>
    
    <category term="Raspberry Pi" scheme="https://lsvih.com/tags/Raspberry-Pi/"/>
    
    <category term="Hardware" scheme="https://lsvih.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 应用中引入 CSS 的几种方式</title>
    <link href="https://lsvih.com/2020/08/31/the-many-ways-to-include-css-in-javascript-applications.md/"/>
    <id>https://lsvih.com/2020/08/31/the-many-ways-to-include-css-in-javascript-applications.md/</id>
    <published>2020-08-31T08:37:00.000Z</published>
    <updated>2020-08-31T08:38:01.981Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/css-vs-js.png" alt="css-vs-js"></p><p>欢迎你踏上了一条在前端世界中饱含争议的道路！相信大部分读者会在关于如何<a href="https://css-tricks.com/tag/css-in-js/">在 JavaScript 应用中处理 CSS</a> 这一话题上产生共鸣。</p><p>文章伊始，先声明一句：<strong>无论是在基于 Vue、Angular 还是 React 构建的应用，针对如何处理 CSS，世界上并没有任何放之四海而皆准的方法。</strong>各个项目皆有不同，每种方式也有可取之处！可能这么说显得含糊其辞，但就我所知，在我们的开发社区内，那些追寻新知识，推动网页开发向前发展的人举目皆是。</p><p>让我们放下对本文话题的感性认知，先领会下 CSS 世界架构的奇妙之处。</p><a id="more"></a><h3 id="让我们盘点一番引入-CSS-的方式"><a href="#让我们盘点一番引入-CSS-的方式" class="headerlink" title="让我们盘点一番引入 CSS 的方式"></a>让我们盘点一番引入 CSS 的方式</h3><p>单单谷歌一下“如何在框架内加入 CSS”，各种言辞凿凿的关于如何在项目中应用样式的观点和看法便映入眼帘。排除一些无关紧要的信息，我们可以先宏观上挑选出更通用的方法和目的检验一番。</p><h4 id="选项-1：-传统样式表"><a href="#选项-1：-传统样式表" class="headerlink" title="选项 1： 传统样式表"></a>选项 1： 传统样式表</h4><p>先从我们最熟悉的方式开始：老掉牙的样式表。我们自然可以在应用中 <code>&lt;link&gt;</code> 一个外部样式表，活儿就完了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以一如往常地写熟悉的 CSS。这样做在一般情况下倒没什么问题，然而，当应用逐渐臃肿、越来越复杂时，维护一个样式表就变成了难题。上千行的 CSS 对应整个应用的样式，开发者要维护这样的样式表将痛苦不堪。样式级联看着很美好，但控制样式也同样困难，比如某个开发改动了一部分样式，会导致其它部分也因此需要跑回归测试。这些问题似曾相识，也因此 <a href="https://sass-lang.com/">Sass</a>（和更新的 <a href="https://github.com/postcss/postcss">PostCSS</a>）悉数登出救场。</p><p>顺着这个思路，我们用 PostCSS 来攥写模块化的 CSS 片段，并通过 <code>@import</code> 将这些模块组合起来。虽然这需要花点精力配置 webpack，但这对你来说不成问题！</p><p>无论你最终选择了哪种编译器，它们最终都会通过一个头部的 <code>&lt;link&gt;</code> 标签，把所有的样式扔在一个 CSS 文件内。随着应用日益复杂，这个文件将更加臃肿，异步加载将变得缓慢，从而阻塞了应用的其余部分的渲染（当然，阻塞渲染不<strong>总是</strong>是件坏事，但总体来说，我们还是会尽量避免使用会阻塞渲染的样式和脚本）。</p><p>我并不是说这种方式毫无可取之处。对于小应用来说，抑或对前端开发并不重视的团队们来讲，一张样式表足以满足需求了。它清晰地分离了业务逻辑和样式，而且它不是生成的，对开发者而言所写即所得，随心所欲。此外，浏览器也可以轻松缓存这张样式表，所以那些回头客们也就不用重新下载了。</p><p>而我们现在所寻找的，是一种能够完全发挥工具优势、稳健的 CSS 架构。这种架构需要能通过一种精细的方式，管理整个应用：CSS 模块化呼之欲出。</p><h4 id="选项-2：CSS-模块化"><a href="#选项-2：CSS-模块化" class="headerlink" title="选项 2：CSS 模块化"></a>选项 2：CSS 模块化</h4><p>单张样式表一个严峻的问题是回归的风险。样式表内写一个模糊选择器样式可能会改动到另一个无关组件的样式。带作用域的样式此刻就发挥了其作用。</p><p>带作用域的样式可以程序化的生成对应组件的明确类名，以确保它们的类名唯一。自动生成的类名例如 <code>header__2lexd</code>，后面那小部分是选择器唯一的哈希值。当一个组件叫 header 时，你可以给它的类名取名为 header，程序将自动生成类似 <code>header__15qy_</code> 的新哈希后缀。</p><p>基于不同的实现方式，CSS 模块生成类名的方式不尽相同，这部分我就不赘述了，请参考 <a href="https://github.com/css-modules/css-modules/tree/master/docs">CSS 模块化文档</a>。</p><p><strong>到头来，在浏览器内我们仍然是用头部的 <code>&lt;link&gt;</code> 标签来加载使用生成的单个 CSS 文件。</strong>伴随而来的有潜在问题（诸如阻塞渲染、文件大小膨胀等），和上文提到的些许好处（缓存是主要优势）。一个需要注意的点是：这种方法移除了全局作用域 —— 起码一开始没有，而这正是其样式作用域所致。</p><p>比如在一个应用内，你想将一个全局的类名 <code>.screen-reader-text</code> 应用在任何一个组件上，当你使用 CSS 模块化时，你得在 <code>:global</code> 伪选择器内定义样式，才能使得这个类样式能被其它组件引用到；接着你需要把这个带有全局选择器的文件导入到各个组件的样式表内，才能生效。这样做虽然不算麻烦，但还是得花点力气习惯这种做法。</p><p>这是一个使用 <code>:global</code> 伪选择器的范例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">typography</span><span class="selector-class">.css</span></span><br><span class="line"><span class="selector-pseudo">:global</span> &#123;</span><br><span class="line">  .aligncenter &#123;</span><br><span class="line">    <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.alignright</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.alignleft</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能得冒险把一大摞的字体、表格和大部分页面都有的通用元素样式扔进这一个 <code>:global</code> 选择器。幸好 <a href="https://github.com/postcss/postcss-nested">PostCSS Nested</a> 或者 Sass 可以帮你导入样式表，让代码看着更加清爽。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.scss</span></span><br><span class="line">:global &#123;</span><br><span class="line">  @import <span class="string">&quot;typography&quot;</span>;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&quot;forms&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样，把部分样式抽离出来，不再需要用 <code>:global</code> 伪选择器包装，只需要在主样式表中导入即可。</p><p>还有一点需要适应的是，在 DOM 节点中引用类名的方式。这点 <a href="https://vue-loader.vuejs.org/guide/css-modules.html#usage">Vue</a>、<a href="https://github.com/css-modules/css-modules/blob/master/docs/css-modules-with-react.md">React</a> 和 <a href="https://github.com/css-modules/css-modules/blob/master/docs/css-modules-with-angular.js.md">Angular</a> 在它们的文档中都有说明。我这里也有一些例子，可以说明在 React 组件内，这些类是如何被引用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./css/Button.css</span></span><br><span class="line"></span><br><span class="line">.btn &#123;</span><br><span class="line">  background-color: blanchedalmond;</span><br><span class="line">  font-size: <span class="number">1.</span>4rem;</span><br><span class="line">  padding: 1rem 2rem;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  transition: background-color ease 300ms, border-color ease 300ms;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./Button.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./css/Button.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;button className=&#123;styles.btn&#125;&gt;</span><br><span class="line">    Click me!</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button;</span><br></pre></td></tr></table></figure><p>CSS 模块化有诸多精彩的用例。如果你在寻找一种带作用域的样式，又希望保留静态样式的优势，那么 CSS 模块化正适合你。</p><p>同样值得注意的是，CSS 模块化可以和你喜爱的 CSS 预处理器相结合。通过 CSS 模块化，诸如 Sass、Less、PostCSS 等 CSS 预处理工具与插件都可以结合进项目构建过程中。</p><p>但是，假如你的应用程序是基于 JavaScript 开发的，那么如果 CSS 样式也可以访问组件的各种状态，并根据状态的变化做出反应，也会是不错的路子。假设你希望轻松地将关键 CSS 加入到应用程序中，有请 CSS-in-JS！</p><h4 id="选项-3：CSS-in-JS"><a href="#选项-3：CSS-in-JS" class="headerlink" title="选项 3：CSS-in-JS"></a>选项 3：CSS-in-JS</h4><p>CSS-in-JS 这个话题颇为宽泛。也有一些库致力于轻松书写 CSS-in-JS。像 <a href="https://cssinjs.org/?v=v10.0.0-alpha.16">JSS</a>、<a href="https://emotion.sh/docs/introduction">Emotion</a> 和 <a href="https://www.styled-components.com/">Styled Components</a> 这类框架扛起了 CSS-in-JS 的大旗。</p><p>总体而言，这些框架大部分的实现方式是相通的。它们都会给单个组件写样式，并在构建过程中<strong>只编译页面上即将渲染的组件</strong>的 CSS。CSS-in-JS 框架通过 <code>&lt;head&gt;</code> 内的 <code>&lt;style&gt;</code> 标签输出 CSS，这种关键 CSS 加载策略开箱即用，并且像 CSS 模块化一样包含作用域，类名也经过了哈希。</p><p>当你在应用内跳转时，卸载的组件会把对应的样式从 <code>&lt;head&gt;</code> 内移除，加载的组件会加上对应的样式，因此性能得到了提升。不再有 HTTP 请求，也不会阻塞渲染，还确保了浏览器只会下载用户需要看到的样式。</p><p>有趣的是，CSS-in-JS 可以获取不同组件的状态和方法，借此渲染不同的 CSS。它可以像基于状态改变而重复加减类名那样简单，也可以像制作一套主题那样复杂。</p><p>因为 CSS-in-JS 着实是热门话题，我知道许多人也有不同的实践。我对 CSS-in-JS 的第一反应是十分负面的，我不喜欢 CSS 和 JS 两者这个理念在一起交叉污染，但我还是想保持开放的心态，因此需要从前端开发者的角度来评估哪些功能是我们<strong>需要</strong>的。现在我将分享一些其他人的感受，这群人非常重视 CSS，尤其是用 JS 写 CSS：</p><ul><li>如果我们采用 CSS-in-JS，我们就得编写<strong>纯正</strong>的 CSS。有些包提供了编写 CSS-in-JS 的模板，但你得使用驼峰式命名 - 即 <code>padding-left</code> 变成 <code>paddingLeft</code>。这不是我个人想放弃的习惯。</li><li>一些 CSS-in-JS 方案要求你在需要样式的元素上编写内联样式。特别是在复杂的组件中，它的语法，开始变得非常冗繁，同样我也不想妥协。</li><li>要想让我使用 CSS-in-JS，它必须得有强大的工具，需要能解决 CSS 模块化或传统的样式表难以解决的痛点。</li><li>我们必须能够利用具有前瞻性思维的 CSS，如嵌套和变量。为了增强开发人员体验，我们还必须能够结合诸如 <a href="https://css-tricks.com/autoprefixer/">Autoprefixer</a> 和其它的附加组件。</li></ul><p>此外针对框架还有很多问题。但对于我们这些人来说，一生中大部分时间都在研究和实施我们喜爱语言的解决方案，我们要确保尽最大的可能把同样的语言写到最好。</p><p>下面是使用 Styled Components 的 React 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./Button.js</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledButton = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blanchedalmond;</span></span><br><span class="line"><span class="string">  font-size: 1.4rem;</span></span><br><span class="line"><span class="string">  padding: 1rem 2rem;</span></span><br><span class="line"><span class="string">  text-transform: uppercase;</span></span><br><span class="line"><span class="string">  transition: background-color ease 300ms, border-color ease 300ms;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: #000;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">StyledButton</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">StyledButton</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button;</span><br></pre></td></tr></table></figure><p>我们还需要探索 CSS-in-JS 解决方案的潜在缺点 —— 绝对不是我加戏。使用 CSS-in-JS，我们很容易落入另一个陷阱，日积月累写出一个组件里有几百行 CSS 的臃肿的 JavaScript 文件，让开发者难以辨别组件的方法和结构。但同时，我们可以非常仔细地检查我们如何以及为什么要如此构建组件。在更深入地思考这个问题时，我们可以利用它并编写更精简的代码和更多可重用的组件。</p><p>此外，此方法完全模糊了业务逻辑和应用程序样式之间的界限。但只要架构的文档完备且经过深思熟虑，项目中的其他开发人员便可以放心遵从这个想法而不会不知所措。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在有各种各样的框架和方法可以在任何项目中解决 CSS 架构问题。我们作为开发者，有<strong>如此之多的选择</strong>，是让人无比兴奋的。然而我们仍会在碎片化社交媒体中产生选择困难症，因为每个解决方案都有其优点和不足的缺点。归根结底，我们是在讨论如何仔细而周密地实现系统在未来可控，让未来的我们和开发人员们感谢自己曾花时间建立这个架构。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/6867054761741549576">https://juejin.im/post/6867054761741549576</a> </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/css-vs-js.png&quot; alt=&quot;css-vs-js&quot;&gt;&lt;/p&gt;
&lt;p&gt;欢迎你踏上了一条在前端世界中饱含争议的道路！相信大部分读者会在关于如何&lt;a href=&quot;https://css-tricks.com/tag/css-in-js/&quot;&gt;在 JavaScript 应用中处理 CSS&lt;/a&gt; 这一话题上产生共鸣。&lt;/p&gt;
&lt;p&gt;文章伊始，先声明一句：&lt;strong&gt;无论是在基于 Vue、Angular 还是 React 构建的应用，针对如何处理 CSS，世界上并没有任何放之四海而皆准的方法。&lt;/strong&gt;各个项目皆有不同，每种方式也有可取之处！可能这么说显得含糊其辞，但就我所知，在我们的开发社区内，那些追寻新知识，推动网页开发向前发展的人举目皆是。&lt;/p&gt;
&lt;p&gt;让我们放下对本文话题的感性认知，先领会下 CSS 世界架构的奇妙之处。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
    <category term="Javascript" scheme="https://lsvih.com/tags/Javascript/"/>
    
    <category term="CSS" scheme="https://lsvih.com/tags/CSS/"/>
    
    <category term="CSS-in-JS" scheme="https://lsvih.com/tags/CSS-in-JS/"/>
    
  </entry>
  
  <entry>
    <title>Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 论文笔记</title>
    <link href="https://lsvih.com/2020/07/15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2020/07/15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-15T12:20:00.000Z</published>
    <updated>2021-03-10T14:13:45.877Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 一文是我和组内同学、师兄的合作工作，作为短文录用于 ACL 2020。</p></blockquote><p>说起来很奇妙，这个工作最开始是为了做 Aspect-extraction 相关工作而开始的，效果很一般。但是在调参的时候发现单纯作为序列标注任务的一个额外的特征输入，居然得到了一丁点提升。也就是这一点点提升，我决定把它应用在预训练语言模型中做一做实验。在经过大量的试错、调整和调参后，最终得到了这么一种新奇的方法，可以让预训练语言模型额外获得一些 word-level 的信息，在各个需要词信息的任务中都有那么一点提升。但这个方法相当的实验化且缺乏理论支撑，并且还有一些别的致命问题（如果没有这些问题谁会去投短文…），会在后面一一说明。下文将结合在会上做远程汇报的 slide，简单描述这个工作。</p><blockquote><p>ppt 已经放在<a href="https://lsvih.com/2020/07/13/Slide-of-MWA/">这里</a>了</p><p>反正就是想写个笔记给自己看，又不是写论文，就不用玩啥避重就轻之类的套路了，<strong>吐槽为主</strong>（反正没人看）。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/15949186123616.jpg" alt="-w591"></p><p>首先是预训练语言模型在最近有了很大的发展，上面那个图是 thunlp 组同学整理的。现在预训练语言模型发展方向就是在不断改进预训练任务和模型结构，让其能适配更大量的数据的数据，方便刷榜，看看 GPT-3 那 1700 亿个参数就心酸。当然也有许多做压缩模型、蒸馏的工作，这些现在应用起来反而更实用一些。还有一些工作在尝试融入额外信息，比如：清华 nlp 提出的 ERNIE 在 BERT 中融入知识图谱；百度的 ERNIE 1.0 融入实体信息，ERNIE 2.0 花式训练；香侬科技魔幻的 Glyce 融合字形；创新工场的 ZEN 用 n-gram 去融合分词信息。</p><p><img src="/images/15949229491682.jpg" alt="-w399"></p><p>但是不管怎样边，主流的预训练语言模型都和上图一样，分预训练和微调两个阶段（GPT-3 那种号称不用微调的除外），现在大家的主要工作也是集中在预训练阶段去做的。近些年这块最经典的工作当然非 BERT 莫属了，所以我后面都是在 BERT 上跑实验。</p><p>不管啥模型，第一件事都是 tokenizer。对于 BERT 来说，英文的 token 是 word-piece，中文的是字（这也对后面的实验造成了很大的麻烦，因为要对齐）。而且已经有相当多的工作证明了，对于中文在 character-level 建模会比较合适（香侬在 ACL2019 的那篇《Is Word Segmentation Necessary for Deep Learning of Chinese Representations》很是经典）。不过在实际应用中，包括很多 Application of NLP 领域的文章，还有我自己的文章，都发现将词信息融入到文本表示中会对应用有效果。</p><p>所以，这篇论文实质上就是在实验看有什么办法去各种拐着弯儿向 character-level 的表示模型融入词信息。</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>至于动机也很简单。玄一些就是把一些眼动追踪的研究挪过来建模：</p><p><img src="/images/15949238058792.jpg" alt=""></p><p>[1] Reading spaced and unspaced chinese text: Evidence from eye movements<br>[2] Parafoveal load of word N+1 modulates preprocessing effectiveness of word N+2 in Chinese reading<br>[3] Cognitive mechanisms in reading ancient Chinese poetry: evidence from eye movements</p><p>上图就是上面几篇论文的部分结论，总结起来就是人阅读中文的时候对每个词付出的“注意度”类似。</p><p>实在一些就是想找一些方法来改变 transformer 的 attention 分布，或者找一种可以折中 soft-attention 与 hard-attention 的方法，在维持原 attention 机制的情况下，用比较 soft 的方法来实现比较 hard 的效果，来方便某些任务（后记中有写）。</p><p>总之，我就是根据这些动机进行了实验。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="单个分词器下的情况"><a href="#单个分词器下的情况" class="headerlink" title="单个分词器下的情况"></a>单个分词器下的情况</h4><p><img src="/images/15949243105852.jpg" alt=""></p><p>（在师兄指导下画的图，还挺好看的）</p><p>模型很简单，就是在预训练语言模型对下游任务进行微调时，中间插上一层 multi-head attention 的变体。</p><p>首先，可以使用分词工具将输入的文本进行分词，具体来说就是讲由字构成的序进行划分（parition），我们把这种划分策略称为 $\pi$。</p><p>得到划分 $\pi$ 后，将其应用于正常得到的 attention 权重矩阵上，可以得到按词划分的（word-based）字级别（character-level）的 attention 权重组合。</p><p>为了同时考虑：1. 句子中所有词的语义表示；2. 句子中最重要的词的语义表示 这两种情况，我们使用 mix-pooling 来对 mean-pooling 和 max-pooling 进行混合：</p><script type="math/tex; mode=display">MixPooling = \lambda MeanPooling + (1 - \lambda MaxPooling)</script><p>其中 $\lambda$ 为参数（后面做实验观察 $\lambda$ 发现，还是 MeanPooling 更重要一些）。</p><p><img src="/images/15949249830517.jpg" alt=""></p><p>比如上图就是这种 attention 权重矩阵的可视化效果图。这个例子是从情感分类任务模型中拿出来试的，可以看到 attention 权重矩阵被转化为了 character-level to word-level 的形式，而实际上还是 character-level 的模型，保留了字建模的优秀表示，同时也做到了前面动机所说的接近 hard-attention 的效果。</p><p>把这样的 attention 权重再拿回 character-level 表示去调整它，就能得到最终的字表示，送往后续的下游任务。</p><h4 id="多个分词器下的情况"><a href="#多个分词器下的情况" class="headerlink" title="多个分词器下的情况"></a>多个分词器下的情况</h4><p>然而，众所周知，分词器经常会出现问题。</p><p><img src="/images/15949252629966.jpg" alt=""></p><p>上图是论文里的图（为了和平特意找了个都没分错的例子），这几个分词器得到的结果都是对的，但是其粒度不同。</p><p>为了减少分词错误，以及用上不同粒度级别的特征，我们找了一种简单的方法，同时用上多个分词工具的分词结果。</p><script type="math/tex; mode=display">\textbf{H'} = \sum_{m=1}^{M} \tanh( {\textbf{H}}^m\textbf{W})</script><p>真的很简单，就是几个分词器的结果，分别得到下游表示之后过个线性层结合在一起而已。</p><p>实验证明这样是有一定效果的。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>都在原文里有，没啥槽点，就是做实验耗的时间太多了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下这个工作的优缺点：</p><p>优点：</p><ul><li>提出了这么一种有意思的结构</li><li>这么一种有意思的结构可以融入一些分词信息，并且对预训练语言模型的下游任务有一些帮助</li><li>单纯融入一种分词信息不够，就多加几种分词信息</li></ul><p>缺点：</p><ul><li>实在缺乏理论支撑</li><li>预处理的真的特别特别慢（尤其是要用几种分词器来分词），并且数据预处理无比复杂（因为各个分词器的处理逻辑都不一样，各种特殊符号、数字、英语、日语、繁体啥的全部都要单独处理，尤其是 BERT 会将英语单词 tokenize 成 word-piece，导致 token 对不上，前期实验有 80% 以上的时间都是在搞这些预处理）</li><li>在 forward 的时候把 transformer 的时间复杂度 $O(n^2)$ 变成了 $O(d n^2)$（这还好是常数级），但是要命的是，在这个方法中，每一条训练数据都会有各自不同的分词方式，都只能各自去分段计算 mix-pooling，这导致完全无法应用 cudnn 原语加速，也完全没可能写成矩阵运算来利用 GPU batch 加速，即使直接用 cuda 编程也没法改善。连 forward 都这么慢，backward 更不用说了……这点是致命的，让我的实验时间变得特别特别长，跑个 CMRC 数据集硬生生把 6 个小时的训练时间搞成了 28 个小时，心态都炸了。</li></ul><p>总结下来，这个工作其实缺点其实挺明显的，主要集中在预处理和速度极慢这两块上。吐槽：<strong>但投稿时 call for short paper 写明白了就是欢迎分享这些不是很完善的 idea 呀，不懂为啥要使劲冲着缺陷打，没这些问题投长文不香吗？</strong></p><p>优点主要还是这个结构足够新颖。由于这种东西的预处理实在太 <strong>dirty</strong> 了，跑起来也慢的<strong>令人抓狂</strong>，我是不打算 follow 这个工作继续做下去了。但是，这种有意思的结构可以用在其它一些 NLP 应用里面，还是可以做一做的。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在郁博文师兄的帮助下第一次写这种实验性质的短文也是挺有意思的。我受到的指导，和我写的文章，一般都是<code>发现问题-&gt;分析问题-&gt;分析方案-&gt;理论支撑方案-&gt;实验支撑理论</code>这么个范式；而这篇文章是<code>发现问题-&gt;分析问题-&gt;哇，有灵感了-&gt;实验结果还不错</code>这么个流程，还是蛮奇妙的。但说到底还是缺乏理论支撑，我去年曾尝试用离散数学去建模分词和这个模型的过程（有图为证），还试图用<code>正则化</code>或者<code>标准化</code>等深度学习术语来解释这种模型，但都成功地浪费了大量的时间，在没有理论支撑的情况下，也只能这样了。</p><p><img src="/images/15949218669058.jpg" alt="-w202"></p><p>这篇文章的录用还是很侥幸的。在审稿 rebuttal 的时候，审稿人给的分和评价都很一般。正如前文所说，文本的确有很多问题，但几位审稿人最主要的关注点居然都主要集中在空间复杂度和训练参数数量上面，没有抓主要矛盾而是重点抓次要矛盾去了。所以简单回答这些关于参数、空间占用之类的问题值后，有位审稿人改了分，这才被录用。</p><blockquote><p>最后这篇论文出来的时候真是命运多舛，赶上了 2020 年的疫情，不让回实验室，资料、代码啥的全在工位台式机上，又赶上组里的大工程和自己的毕设，只能抽空远程一点一点扒代码，扒到开会都没扒完；后来都有好几位老师同学发邮件索取了，都没办法直接发给人家可以直接跑的模型，只给一个老师发了最主要的那个 <code>attention align</code> 模块，也不知道有没有帮上他的忙；好在后来找了点办法能远程直连了，不然更难受。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 一文是我和组内同学、师兄的合作工作，作为短文录用于 ACL 2020。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
    <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
    <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
    <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
    <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
    <category term="NLP" scheme="https://lsvih.com/tags/NLP/"/>
    
    <category term="Natural Language Processing" scheme="https://lsvih.com/tags/Natural-Language-Processing/"/>
    
    <category term="ACL" scheme="https://lsvih.com/tags/ACL/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention&#39; used in ACL conference.</title>
    <link href="https://lsvih.com/2020/07/13/Slide-of-MWA/"/>
    <id>https://lsvih.com/2020/07/13/Slide-of-MWA/</id>
    <published>2020-07-13T03:06:00.000Z</published>
    <updated>2020-07-16T17:17:35.470Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/20-07-15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/20-07-15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-align</summary>
      
    
    
    
    <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
    <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
    <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
    <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
    <category term="conference" scheme="https://lsvih.com/tags/conference/"/>
    
    <category term="language model" scheme="https://lsvih.com/tags/language-model/"/>
    
  </entry>
  
  <entry>
    <title>获取 Git 全部远程分支</title>
    <link href="https://lsvih.com/2020/06/05/fetch-all-git-remote-branch/"/>
    <id>https://lsvih.com/2020/06/05/fetch-all-git-remote-branch/</id>
    <published>2020-06-05T08:13:59.000Z</published>
    <updated>2020-06-05T08:23:51.327Z</updated>
    
    <content type="html"><![CDATA[<p>因为图省硬盘，直接用了 <code>--depth=1</code> 命令 clone，导致在本地追踪不到远程的分支，并且用 <code>git branch -a</code> 看不到远程分支，当然也不能 checkout 到 origin/remote 上去。<code>git fetch all</code>、<code>git fetch origin</code> 也都拿不到内容。</p><p>因为有 slash 的内容和已经准备好的 commit，又不想重新去 clone，想起来 git 使用 fetch 时就是去找 <code>.git/config</code> 文件里的 remote origin 字段，因此直接改了这个文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .git/config</span><br></pre></td></tr></table></figure><p>找到  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx</span><br><span class="line">        fetch = +refs<span class="regexp">/heads/m</span>aster:refs<span class="regexp">/remotes/</span>origin/master</span><br></pre></td></tr></table></figure><p>果然 head 和 remote origin 都指向 master，把 master 改成 *：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx</span><br><span class="line">        fetch = +refs<span class="regexp">/heads/</span>*:refs<span class="regexp">/remotes/</span>origin/*</span><br></pre></td></tr></table></figure><p>接着 <code>git fetch --all</code>，就拿到了全部的分支，现在就可以直接去 checkout 了~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为图省硬盘，直接用了 &lt;code&gt;--depth=1&lt;/code&gt; 命令 clone，导致在本地追踪不到远程的分支，并且用 &lt;code&gt;git branch -a&lt;/code&gt; 看不到远程分支，当然也不能 checkout 到 origin/remote 上去。&lt;code</summary>
      
    
    
    
    <category term="Note" scheme="https://lsvih.com/categories/Note/"/>
    
    
    <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
    <category term="tool" scheme="https://lsvih.com/tags/tool/"/>
    
    <category term="bash" scheme="https://lsvih.com/tags/bash/"/>
    
    <category term="git" scheme="https://lsvih.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 进行边缘检测</title>
    <link href="https://lsvih.com/2020/02/07/edge-detection-in-python/"/>
    <id>https://lsvih.com/2020/02/07/edge-detection-in-python/</id>
    <published>2020-02-07T11:50:00.000Z</published>
    <updated>2020-02-07T11:50:31.380Z</updated>
    
    <content type="html"><![CDATA[<p>上季度，我在学校辅助一门 Python 课程的教学，在此过程中学到了很多图像处理的知识。我希望通过本文分享一些关于边缘检测的知识，包括边缘检测的<strong>理论</strong>以及如何使用 Python <strong>实现</strong>边缘检测。</p><hr><h3 id="为何检测边缘？"><a href="#为何检测边缘？" class="headerlink" title="为何检测边缘？"></a>为何检测边缘？</h3><p>我们首先应该了解的问题是：<strong>“为什么要费尽心思去做边缘检测？”</strong>除了它的效果很酷外，为什么边缘检测还是一种实用的技术？为了更好地解答这个问题，请仔细思考并对比下面的风车图片和它的“仅含边缘的图”：</p><p><img src="/images/1-2.png" alt="Image of pinwheel (left) and its edges (right)"></p><p>可以看到，左边的原始图像有着各种各样的色彩、阴影，而右边的“仅含边缘的图”是黑白的。如果有人问，哪一张图片需要更多的存储空间，你肯定会告诉他原始图像会占用更多空间。这就是边缘检测的意义：通过对图片进行边缘检测，丢弃大多数的细节，从而得到“更轻量化”的图片。</p><p>因此，在无须保存图像的所有复杂细节，而 <strong>“只关心图像的整体形状”</strong> 的情况下，边缘检测会非常有用。</p><hr><h3 id="如何进行边缘检测-——-数学"><a href="#如何进行边缘检测-——-数学" class="headerlink" title="如何进行边缘检测 —— 数学"></a>如何进行边缘检测 —— 数学</h3><p>在讨论代码实现前，让我们先快速浏览一下边缘检测背后的数学原理。作为人类，我们非常擅长识别图像中的“边”，那如何让计算机做到同样的事呢？</p><p>首先，假设有一张很简单的图片，在白色背景上有一个黑色的正方形：</p><p><img src="/images/2-1.png" alt="Our working image"></p><p>在这个例子中，由于处理的是黑白图片，因此我们可以考虑将图中的每个像素的值都用 <strong>0（黑色）</strong> 或 <strong>1（白色）</strong> 来表示。除了黑白图片，同样的理论也完全适用于彩色图像。</p><p>现在，我们需要判断上图中绿色高亮的像素是不是这个图像边缘的一部分。作为人类，我们当然可以认出它<strong>是</strong>图像的边缘；但如何让计算机利用相邻的像素来得到同样的结果呢？</p><p>我们以绿色高亮的像素为中心，设定一个 3 x 3 像素大小的小框，在图中以红色示意。接着，对这个小方框“应用”一个过滤器（filter）：</p><p><img src="/images/3.png" alt="对局部像素框应用纵向过滤器"></p><p>上图展示了我们将要“应用”的过滤器。乍一看上去很神秘，让我们仔细研究它做的事情：当我们说 <strong>“将过滤器应用于一小块局部像素块”</strong> 时，具体是指红色框中的每个像素与过滤器中与之位置对应的像素进行相乘。因此，红色框中左上角像素值为 1，而过滤器中左上角像素值为 -1，它们相乘得到 -1，这也就是结果图中左上角像素显示的值。结果图中的每个像素都是用这种方式得到的。</p><p>下一步是对过滤结果中的所有像素值求和，得到 -4。请注意，-4 其实是我们应用这个过滤器可获得的“最小”值（因为原始图片中的像素值只能在 0 到 1 之间）。因此，当获得 -4 这个最小值的时候，我们就能知道，对应的像素点是图像中正方形<strong>顶部竖直方向边缘</strong>的一部分。</p><p>为了更好地掌握这种变换，我们可以看看将此过滤器应用于图中正方形底边上的一个像素会发生什么：</p><p><img src="/images/4-1.png" alt=""></p><p>可以看到，我们得到了与前文相似的结果，相加之后得到的结果是 4，这是应用此过滤器能得到的<strong>最大值</strong>。因此，由于我们得到了 4 这一最大值，可以知道这个像素是图像中正方形<strong>底部竖直方向边缘</strong>的一部分。</p><p>为了把这些值映射到 0-1 的范围内，我们可以简单地给其加上 4 再除以 8，这样就能把 -4 映射成 0（<strong>黑色</strong>），把 4 映射成 1（<strong>白色</strong>）。因此，我们将这种过滤器称为<strong>纵向 Sobel 过滤器</strong>，可以用它轻松检测图像中垂直方向的边缘。</p><p>那如何检测水平方向的边缘呢？只需简单地将<strong>纵向过滤器</strong>进行转置（按照其数值矩阵的对角线进行翻转）就能得到一个新的过滤器，可以用于检测水平方向的边缘。</p><p>如果需要同时检测水平方向、垂直方向以及介于两者之间的边缘，我们可以把<strong>纵向过滤器得分和横向过滤器得分进行结合</strong>，这个步骤在后面的代码中将有所体现。</p><p>希望上文已经讲清楚了这些理论！下面看一看代码是如何实现的。</p><hr><h3 id="如何进行边缘检测-——-代码"><a href="#如何进行边缘检测-——-代码" class="headerlink" title="如何进行边缘检测 —— 代码"></a>如何进行边缘检测 —— 代码</h3><p>首先进行一些设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义纵向过滤器</span></span><br><span class="line">vertical_filter = [[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义横向过滤器</span></span><br><span class="line">horizontal_filter = [[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], [-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>], [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取纸风车的示例图片“pinwheel.jpg”</span></span><br><span class="line">img = plt.imread(<span class="string">&#x27;pinwheel.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到图片的维数</span></span><br><span class="line">n,m,d = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化边缘图像</span></span><br><span class="line">edges_img = img.copy()</span><br></pre></td></tr></table></figure><ul><li>你可以把代码中的“pinwheel.jpg”替换成其它你想要找出边缘的图片文件！需要确保此文件和代码在同一工作目录中。</li></ul><p>接着编写边缘检测代码本身：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义纵向过滤器</span></span><br><span class="line">vertical_filter = [[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">1</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义横向过滤器</span></span><br><span class="line">horizontal_filter = [[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], [-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>], [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取纸风车的示例图片“pinwheel.jpg”</span></span><br><span class="line">img = plt.imread(<span class="string">&#x27;pinwheel.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到图片的维数</span></span><br><span class="line">n,m,d = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化边缘图像</span></span><br><span class="line">edges_img = img.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历图片的全部像素</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n-<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, m-<span class="number">2</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在当前位置创建一个 3x3 的小方框</span></span><br><span class="line">        local_pixels = img[row-<span class="number">1</span>:row+<span class="number">2</span>, col-<span class="number">1</span>:col+<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用纵向过滤器</span></span><br><span class="line">        vertical_transformed_pixels = vertical_filter*local_pixels</span><br><span class="line">        <span class="comment"># 计算纵向边缘得分</span></span><br><span class="line">        vertical_score = vertical_transformed_pixels.<span class="built_in">sum</span>()/<span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用横向过滤器</span></span><br><span class="line">        horizontal_transformed_pixels = horizontal_filter*local_pixels</span><br><span class="line">        <span class="comment"># 计算横向边缘得分</span></span><br><span class="line">        horizontal_score = horizontal_transformed_pixels.<span class="built_in">sum</span>()/<span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将纵向得分与横向得分结合，得到此像素总的边缘得分</span></span><br><span class="line">        edge_score = (vertical_score**<span class="number">2</span> + horizontal_score**<span class="number">2</span>)**<span class="number">.5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将边缘得分插入边缘图像中</span></span><br><span class="line">        edges_img[row, col] = [edge_score]*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对边缘图像中的得分值归一化，防止得分超出 0-1 的范围</span></span><br><span class="line">edges_img = edges_img/edges_img.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>在图片的边界像素上，我们无法创建完整的 3 x 3 小方框，因此在图片的四周会有一个细边框。</li><li>既然是同时检测水平方向和垂直方向的边缘，我们可以直接将原始的纵向得分与横向得分分别除以 4（而不像前文描述的分别加 4 再除以 8）。这个改动无伤大雅，反而可以更好地突出图像的边缘。</li><li>将纵向得分与横向得分结合起来时，有可能会导致最终的边缘得分超出 0-1 的范围，因此最后还需要重新对最终得分进行标准化。</li></ul><p>在更复杂的图片上运行上述代码：</p><p><img src="/images/5-1.png" alt=""></p><p>得到边缘检测的结果：</p><p><img src="/images/6-1.png" alt=""></p><hr><p>以上就是本文的全部内容了！希望你了解到了一点新知识，并继续关注更多数据科学方面的文章〜</p><blockquote><p>掘金链接：<a href="https://juejin.im/post/5e3d4b53e51d4526c26fadd4">https://juejin.im/post/5e3d4b53e51d4526c26fadd4</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上季度，我在学校辅助一门 Python 课程的教学，在此过程中学到了很多图像处理的知识。我希望通过本文分享一些关于边缘检测的知识，包括边缘检测的&lt;strong&gt;理论&lt;/strong&gt;以及如何使用 Python &lt;strong&gt;实现&lt;/strong&gt;边缘检测。&lt;/p&gt;
&lt;hr</summary>
      
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
    <category term="Computer Vision" scheme="https://lsvih.com/tags/Computer-Vision/"/>
    
    <category term="Tutorial" scheme="https://lsvih.com/tags/Tutorial/"/>
    
    <category term="Edge Detection" scheme="https://lsvih.com/tags/Edge-Detection/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost 算法万岁！</title>
    <link href="https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/"/>
    <id>https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/</id>
    <published>2019-08-05T14:50:00.000Z</published>
    <updated>2019-08-05T14:54:58.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15650167189931.jpg" alt="Photo By Jared Subia"></p><a id="more"></a><blockquote><p>机器学习算法的新女王将接管整个世界……</p></blockquote><p>（本文与 <a href="https://towardsdatascience.com/u/e15e82916c90">Venkat Anurag Setty</a> 共同完成）</p><p>我还记得 15 年前我的第一份工作。那时，我刚完成研究生课程，作为一名分析师加入了一家国际投行。在入职的第一天，我小心翼翼地工作，不断回想学过的知识，心里想着自己是否能胜任这个企业的工作。老板感受到了我的焦虑，笑着对我说：</p><p><strong>“别担心！你只要了解回归模型就行了！”</strong></p><p>我仔细想了想，“明白了！” —— 无论是线性回归还是逻辑回归我都了解。老板是对的，在我的任期内，专门构建基于回归的统计学模型。我并不是孤身一人，因为在那时，回归模型是无可争议的预测分析女王。15 年后，回归模型的时代结束了，这位老女王已经退位。新上任的女王有着时髦的名字：XGBoost 或 Extreme Gradient Boosting。</p><hr><h2 id="什么是-XGBoost？"><a href="#什么是-XGBoost？" class="headerlink" title="什么是 XGBoost？"></a>什么是 XGBoost？</h2><p><a href="https://xgboost.ai/">XGBoost</a> 是一种基于决策树的集成（ensemble）机器学习算法，使用了<a href="https://en.wikipedia.org/wiki/Gradient_boosting">梯度提升（gradient boosting）</a>框架。在非结构化数据（如图像、文本等）的预测问题中，人工神经网络效果好于其它所有算法和框架；然而，在解决中小型的结构化、扁平化数据时，基于决策树的算法才是最好的。下面的图表展示了近年来基于树的算法的演变过程：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QJZ6W-Pck_W7RlIDwUIN9Q.jpeg" alt="Evolution of XGBoost Algorithm from Decision Trees"></p><p>XGBoost 算法是华盛顿大学在科研工程中开发的。<a href="https://arxiv.org/pdf/1603.02754.pdf">陈天奇与 Carlos Guestrin</a> 在 SIGKDD 2016 上发表了他们的论文，迅速吸引了机器学习界的注意。自从 XGBoost 推出以来，它不仅在许多 Kaggle 竞赛中获得了胜利，还为一些顶尖的业界应用提供了动力。因此，形成了一个强大的数据科学家社区为 XGBoost 做贡献，目前 <a href="https://github.com/dmlc/xgboost/">GitHub</a> 上的 XGBoost 项目有 350 余名贡献者，3600 余条 commit 记录。XGBoost 算法还在下面几个方面极为出众：</p><ol><li>应用广泛：可以用于解决回归、分类、排序和其它用户自定义的预测问题；</li><li>可移植性：在 Windows、Linux 和 OS X 系统中都能顺畅运行；</li><li>语言：支持包括 C++、Python、R、Java、Scala 和 Julia 等全部主流编程语言；</li><li>云端集成：支持 AWS、Azure、Yarn 集群，并与 Flink、Spark 等生态系统配合无间。</li></ol><hr><h2 id="如何直观地理解-XGBoost？"><a href="#如何直观地理解-XGBoost？" class="headerlink" title="如何直观地理解 XGBoost？"></a>如何直观地理解 XGBoost？</h2><p>决策树在最简单的形式下，是最易于可视化以及最具可解释性的算法，但想要直观的理解新一代的基于树的算法可能会有些困难。可以用下面的类比来更好地了解基于树的算法的演变。</p><p><img src="https://cdn-images-1.medium.com/max/11030/1*Uwbv9Nzv7uoZV_hJwrsPGQ.jpeg" alt="[rawpixel](https://unsplash.com/photos/cnseVhmbA7k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) 供图[Unsplash](https://unsplash.com/search/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"></p><p>设想你是一名 HR，要对几名优秀的候选人进行面试。而基于树的算法的演变过程的每一步，都可以视为是面试过程的一个版本。</p><ol><li><p><strong>决策树（Decision Tree）</strong>：每个 HR 都有一系列标准，比如学历、工作年份、面试表现等。一个决策树就类似于一个 HR 基于他的这些标准来筛选候选人。</p></li><li><p><strong>Bagging</strong>：假设现在不只有一个面试官，而是有一个面试小组，组中每个面试官都有投票权。Bagging 和 Bootstrap 就是通过一个民主投票的过程，将所有面试官的输入聚合起来，得到一个最终的决定。</p></li><li><p><strong>随机森林（Random Forest）</strong>：它是一种基于 Bagging 的算法，关键点在于随机森林会随机使用特征的子集。换句话说，就是每个面试官都只会用一些随机选择的标准来考验候选人的任职资格（比如，技术面值考察编程技能，行为面只考察非技术相关的技能）。</p></li><li><p><strong>Boosting</strong>：这是一种替代方法，每个面试官都会根据上一个面试官的面试结果来改变自己的评价标准。通过利用更加动态的评估过程，可以提升（boost）面试过程的效率。</p></li><li><p><strong>梯度提升（Gradient Boosting）</strong>：Boosting 的特例，用梯度下降算法来将误差最小化。比如，咨询公司用案例面试来剔除不太合格的候选人。</p></li><li><p><strong>XGBoost</strong>：可以认为 XGBoost 就是“打了兴奋剂”的梯度提升（因此它全称是“Extreme Gradient Boosting” —— 极端梯度提升）。它是软件和硬件优化技术的完美结合，可以在最短的时间内用较少的计算资源得到出色的结果。</p></li></ol><hr><h2 id="为什么-XGBoost-效果这么好？"><a href="#为什么-XGBoost-效果这么好？" class="headerlink" title="为什么 XGBoost 效果这么好？"></a>为什么 XGBoost 效果这么好？</h2><p>XGBoost 和梯度提升机（Gradient Boosting Machines，GBM）都是集成（ensemble）树方法，原理都是用梯度下降架构来对多个弱分类器（通常是 <a href="https://www.datasciencecentral.com/profiles/blogs/introduction-to-classification-regression-trees-cart">CARTs</a>）进行提升（boosting）。不过，XGBoost 通过系统优化与算法强化在 GBM 框架上进行了改进。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*FLshv-wVDfu-i54OqvZdHg.png" alt="XGBoost 是如何优化标准 GBM 算法的"></p><p><strong>系统优化：</strong></p><ol><li><p><strong>并行化</strong>：XGBoost 通过<a href="http://zhanpengfang.github.io/418home.html">并行化</a>方法来实现顺序的建树过程。由于基础学习器循环内部（包括用于枚举树的叶子节点的外部循环，以及用于计算特征的内部循环）的可互换性，因此才能这么做；循环的嵌套会限制并行化，因为如果没有完成两个开销更大的内部循环，就不能开始新的外部循环。XGBoost 算法通过使用并行线程对所有实例进行全局扫描和排序来进行初始化，使得循环的顺序变得可交换，从而减少了运行的时间。这样做，可以抵消并行化开销而提升算法性能。</p></li><li><p><strong>树剪枝</strong>：在 GBM 框架中，树停止分裂的标准本质上是贪婪的，取决于分裂点的 loss 值。而 XGBoost 用 <code>max_depth</code> 这一参数而非某个指标来停止分裂，然后开始反过来对树进行剪枝。这种“深度优先”的方法显著提高了计算性能。</p></li><li><p><strong>硬件优化</strong>：XGBoost 算法就是为了高效利用硬件资源而设计的。它为每个线程都分配了内部缓存区，用于存储梯度统计信息。另外，利用“核外计算”方法，在处理不适合放在内存中的大数据切片时，进一步优化磁盘可用空间。</p></li></ol><p><strong>算法强化：</strong></p><ol><li><p><strong>正则化（Regularization）</strong>：XGBoost 同时通过 LASSO（L1）与 Ridge（L2）<a href="https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c">正则化</a>惩罚过于复杂的模型，从而避免过拟合。</p></li><li><p><strong>稀疏意识（Sparsity Awareness）</strong>：XGBoost 会根据训练 loss 自动“学习”输入中的缺失值，从而自然地接收稀疏特征，并更高效地处理各种<a href="https://www.kdnuggets.com/2017/10/xgboost-concise-technical-overview.html">稀疏模式（sparsity patterns）</a>的数据。</p></li><li><p><strong>Weighted Quantile Sketch</strong>：XGBoost 使用分布式 <a href="https://arxiv.org/pdf/1603.02754.pdf">weighted Quantile Sketch 算法</a>，可以有效地找到大多数带权数据集的最佳分割点。 </p></li><li><p><strong>交叉验证（Cross-validation）</strong>：算法内置了在每次迭代时进行<a href="https://towardsdatascience.com/cross-validation-in-machine-learning-72924a69872f">交叉验证</a>的方法，不再需要显式地去搜索与指定一轮训练中所需的 boosting 迭代次数。</p></li></ol><hr><h2 id="Where-is-the-proof"><a href="#Where-is-the-proof" class="headerlink" title="Where is the proof?"></a>Where is the proof?</h2><p>我们使用 Scikit-learn 的 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html"><code>Make_Classification</code></a> 数据包，创建了一个包含 100 万个数据点、20 个特征（其中包括 2 个信息性特征与 2 个冗余特征）的随机样本集，并用它测试几种算法：逻辑回归、随机森林、标准梯度提升和 XGBoost。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*U72CpSTnJ-XTjCisJqCqLg.jpeg" alt="XGBoost vs. Other ML Algorithms using SKLearn’s Make_Classification Dataset"></p><p>如上图所示，与其它算法相比，XGBoost 模型得到了最好的预测性能与最短的处理时间。研究发现，在其它严格的<a href="https://github.com/szilard/benchm-ml">基准测试</a>中，也能得到类似的结果。因此，XGBoost 在最近的数据科学比赛中被广泛采用，也是意料之中的事。</p><blockquote><p>“当你举棋不定的时候，用 XGBoost 就对了” —— <a href="http://blog.kaggle.com/2015/08/26/avito-winners-interview-1st-place-owen-zhang/">Avito</a> Kaggle 上下文广告点击预测大赛冠军 Owen Zhang 如是说。</p></blockquote><hr><h2 id="我们是否可以在任何情况都用-XGBoost？"><a href="#我们是否可以在任何情况都用-XGBoost？" class="headerlink" title="我们是否可以在任何情况都用 XGBoost？"></a>我们是否可以在任何情况都用 XGBoost？</h2><p>在机器学习中（或者说在生命中），没有免费的午餐。作为数据科学家，必须为手头数据测试所有算法，以找到效果最好的算法。但是，选出正确算法还不够，还必须要为数据集正确地配置算法的<a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/">超参数</a>。此外，在选择最优算法时，除了效果还要考虑其它的因素，比如计算复杂度、可解释性、易用性等等。这正是机器学习从科学转向艺术的部分，同时，也是魔法发生的地方！</p><hr><h2 id="未来会如何？"><a href="#未来会如何？" class="headerlink" title="未来会如何？"></a>未来会如何？</h2><p>机器学习是一个非常活跃的研究领域，目前已经出现了各种各样的 XGBoost 的变体。微软研究院最近提出了 <a href="https://www.microsoft.com/en-us/research/project/lightgbm/">LightGBM</a> 梯度提升框架，体现出了巨大的潜力。Yandex 科技开发了 <a href="https://catboost.ai/">CatBoost</a>，得到了令人印象深刻的基准测试结果。出现一个在预测性能、灵活性、可解释性和实用型都优于 XGBoost 的框架只是时间上的问题。然而，在这个更强的挑战者到来之前，XGBoost 将继续统治机器学习的世界！</p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5d484040e51d4561f95ee9de">https://juejin.im/post/5d484040e51d4561f95ee9de</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/15650167189931.jpg&quot; alt=&quot;Photo By Jared Subia&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Algorithm" scheme="https://lsvih.com/tags/Algorithm/"/>
    
    <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
    <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
    <category term="XGBoost" scheme="https://lsvih.com/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>在机器学习中为什么要进行 One-Hot 编码？</title>
    <link href="https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/"/>
    <id>https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/</id>
    <published>2019-06-28T03:10:00.000Z</published>
    <updated>2019-06-28T03:12:13.010Z</updated>
    
    <content type="html"><![CDATA[<p>入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。</p><p>一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。</p><p>其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。</p><ul><li>为什么 One-Hot 编码是必要的？</li><li>为什么你不能直接使用数据来拟合模型？</li></ul><p>在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。</p><a id="more"></a><p>让我们开始吧！</p><p><img src="/images/Why-One-Hot-Encode-Data-in-Machine-Learning.jpg" alt=""></p><p><a href="https://www.flickr.com/photos/jiangkeren/8263176332/">题图 by Karan Jain，保留部分权利</a></p><h2 id="什么是类别数据？"><a href="#什么是类别数据？" class="headerlink" title="什么是类别数据？"></a>什么是类别数据？</h2><p>类别数据是一种只有标签值而没有数值的变量。</p><p>它的值通常属于一个大小固定且有限的集合。</p><p>类别变量也常被称为<a href="https://en.wikipedia.org/wiki/Nominal_category">标称值（nominal）</a>。</p><p>下面举例说明：</p><ul><li>宠物（pet）变量包含以下几种值：狗（dog）、猫（cat）。</li><li>颜色（color）变量包含以下几种值：红（red）、绿（green）、蓝（blue）。</li><li>位次（place）变量包含以下几种值：第一（first）、第二（second）和第三（third）。</li></ul><p>以上例子中的每个值都代表着一个不同的类别。</p><p>有些类别彼此间存在一定的自然关系，比如自然的排序关系。</p><p>上述例子中，位次（place）变量的值就有这种自然的排序关系。这种变量被称为序数变量（ordinal variable）。</p><h2 id="类别数据有什么问题？"><a href="#类别数据有什么问题？" class="headerlink" title="类别数据有什么问题？"></a>类别数据有什么问题？</h2><p>有些算法可以直接应用于类别数据。</p><p>比如，你可以不进行任何数据转换，将决策树算法直接应用于类别数据上（取决于具体实现方式）。</p><p>但还有许多机器学习算法并不能直接操作标签数据。这些算法要求所有的输入输出变量都是数值（numeric）。</p><p>通常来说，这种限制主要是因为这些机器学习算法的高效实现造成的，而不是算法本身的限制。</p><p>但这也意味着我们需要把类别数据转换成数值形式。如果输出变量是类别变量，那你可能还得将模型的预测值转换回类别形式，以便在一些应用中展示或使用它们。</p><h2 id="如何将类别数据转换成数值数据？"><a href="#如何将类别数据转换成数值数据？" class="headerlink" title="如何将类别数据转换成数值数据？"></a>如何将类别数据转换成数值数据？</h2><p>这包含两个步骤：</p><ol><li>整数编码</li><li>One-Hot 编码</li></ol><h3 id="1-整数编码"><a href="#1-整数编码" class="headerlink" title="1. 整数编码"></a>1. 整数编码</h3><p>第一步，先要给每个类别值都分配一个整数值。</p><p>比如，用 1 表示红色（red），2 表示绿色（green），3 表示蓝色（blue）。</p><p>这种方式被称为标签编码或者整数编码，可以很轻松地将它还原回类别值。</p><p>对于某些变量来说，这种编码就足够了。</p><p>整数之间存在自然的排序关系，机器学习算法也许可以理解并利用这种关系。</p><p>比如，前面的位次（place）例子中的序数变量就是一个很好的例子。对于它我们只需要进行标签编码就够了。</p><h3 id="2-One-Hot-编码"><a href="#2-One-Hot-编码" class="headerlink" title="2. One-Hot 编码"></a>2. One-Hot 编码</h3><p>但对于不存在次序关系的类别变量，仅使用上述的整数编码是不够的。</p><p>实际上，使用整数编码会让模型假设类别间存在自然的次序关系，从而导致结果不佳或得到意外的结果（预测值落在两个类别的中间）。</p><p>这种情况下，就要对整数表示使用 One-Hot 编码了。One-Hot 编码会去除整数编码，并为每个整数值都创建一个二值变量。</p><p>在颜色（color）的示例中，有 3 种类别，因此需要 3 个二值变量进行编码。对应的颜色位置上将被标为“1”，其它颜色位置上会被标为“0”。</p><p>比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">red</span>, green, blue</span><br><span class="line"><span class="attribute">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="attribute">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="attribute">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在统计学等领域中，这种二值变量通常被称为“虚拟变量”或“哑变量”（dummy variable）。</p><h2 id="One-Hot-编码教程"><a href="#One-Hot-编码教程" class="headerlink" title="One-Hot 编码教程"></a>One-Hot 编码教程</h2><p>如果你想了解如何在 Python 对你的数据进行 One-Hot 编码，请参阅：</p><ul><li><a href="https://machinelearningmastery.com/data-preparation-gradient-boosting-xgboost-python/">Data Preparation for Gradient Boosting with XGBoost in Python</a> — 在 Python 中使用 XGBoost 梯度提升法前的数据准备</li><li><a href="https://machinelearningmastery.com/how-to-one-hot-encode-sequence-data-in-python/">How to One Hot Encode Sequence Data in Python</a> — 如何使用 Python 对序列数据进行 One-Hot 编码</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Categorical_variable">类别变量（Categorical variable）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Nominal_category">标称分类（Nominal category）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Dummy_variable_(statistics">虚拟变量，哑变量（Dummy variable）</a>)，Wikipedia</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，你应该了解了为什么在使用机器学习算法时通常要对类别数据进行编码。</p><p>特别要注意：</p><ul><li>类别数据的定义是由一组有限集合中的值构成的变量。</li><li>大多数机器学习算法都需要输入数值变量，并会输出数值变量。</li><li>通过整数编码与 One-Hot 编码可以将类别数据转换为整型数据。</li></ul><p>文章首发于掘金：<a href="https://juejin.im/post/5d15840e5188255c23553204">https://juejin.im/post/5d15840e5188255c23553204</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。&lt;/p&gt;
&lt;p&gt;一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。&lt;/p&gt;
&lt;p&gt;其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 One-Hot 编码是必要的？&lt;/li&gt;
&lt;li&gt;为什么你不能直接使用数据来拟合模型？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
    <category term="Tutorial" scheme="https://lsvih.com/tags/Tutorial/"/>
    
    <category term="One Hot" scheme="https://lsvih.com/tags/One-Hot/"/>
    
    <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Graph Convolutional Networks for Text Classification 论文笔记</title>
    <link href="https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/"/>
    <id>https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/</id>
    <published>2019-06-27T04:04:00.000Z</published>
    <updated>2019-06-27T04:06:42.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：<a href="https://github.com/yao8839836/text_gcn">https://github.com/yao8839836/text_gcn</a> </p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文解决的是自然语言处理中最基础的任务 - 文本分类任务。利用近年大火的图神经网络，作者通过词与文章的共现信息和 TF-IDF 权重和互信息权重将无结构数据文本进行了构图，并利用 Graph Convolutional Network（GCN）捕获图中的文档-词、词-词、文档-文档关系，从而进行文本分类。</p><p>具体来说，本文主要有以下两个贡献点：</p><ol><li>提出了使用图神经网络来解决文本分类问题，有效利用了文档、词等的异构信息</li><li>在 benchmark 上达到了 state-of-the-art 的效果</li></ol><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><p>传统的文本分类方法主要依靠特征工程，在深度学习兴起后，各种深度学习框架代替了这个步骤。人们利用文本的分布式表示（embedding），使用各种 CNN、RNN、LSTM 等神经网络来捕获 embedding 中的语义信息，进行分类。本文就是在此基础之上，用 GCN 来捕获 Graph 中的 语义信息从而实现准确分类。</p><h3 id="图网络"><a href="#图网络" class="headerlink" title="图网络"></a>图网络</h3><p>近些年为了突破传统神经网络只能应用于对齐的 grid 数据的限制，出现了可以应用于 Graph 的图神经网络。其中，GCN 方法简单有效，在图的各个节点上计算其邻居的聚合信息表示。因此，作者 employ 了 GCN 方法，将其用于图结构的学习。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>作者在 5 个常用的公开数据集上进行了实验。这 5 个数据集的基本信息如下：</p><p><img src="/images/15616083187154.jpg" alt="-w692"></p><p>在实验前，作者利用 NLTK 去除了前 4 个数据集的停用词，并去除了频次小于 5 的低频次。MR 数据集因为句子太短了，没有必要再删。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h3><p>作者最终构成的图结构如下图所示：</p><p><img src="/images/15616083306904.jpg" alt="-w922"></p><p>在图中，左边是文本构成的图，右边是经过 GCN 得到的图表示。在左图中，以“O”开头的节点是文档节点，白色圈里有单词的节点是单词节点，黑色的线是文档-单词关系，灰色的线是单词-单词关系。右图中的$R(x)$表示文档或单词$x$的表示。</p><p>具体来说，在这个情景中，构图主要在于如何对文档-单词和单词-单词的边赋权。作者使用了下面公式所示的构图方式：</p><script type="math/tex; mode=display">A _ { i j } = \left\{ \begin{array} { c } { \operatorname { PMI } ( i , j ) } \space \text{i,j 是单词，且 PMI(i,j)>0} \\ { \mathrm { TF } - \mathrm { IDF } _ { i j } } \space \text{i是单词，j是文档} \\ { 1 } \space i =j \\ { 0 } \space otherwise \end{array} \right.</script><p>$A_{ij}$表示从节点 i 连到节点 j 的边的权重。简单来说，就是对文档-单词的边算 TF-IDF 作为权重，对单词-单词的边使用 PMI 做权重。PMI 是单词与单词的互信息，具体计算方式是：</p><script type="math/tex; mode=display">\begin{aligned} \operatorname { PMI } ( i , j ) = & \log \frac { p ( i , j ) } { p ( i ) p ( j ) } \\ p ( i , j ) = & \frac { \# W ( i , j ) } { \# W } \\ p ( i ) = & \frac { \# W ( i ) } { \# W } \end{aligned}</script><p>其中，#W 是滑动窗口，具体来说，PMI 就是算单词 i 和单词 j 同时出现的概率比上单词 i 和单词 j 单独出现的概率。</p><h3 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h3><p>在 GCN 框架内，使用 BP 算法来优化节点表示，并在 GCN 后加一层 Dense 层和激活层，利用 softmax 来进行分类。作者将其表示如下：</p><script type="math/tex; mode=display">Z = \operatorname { softmax } \left( \tilde { A } \operatorname { ReL } \mathbf { U } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 } \right)</script><p>其中，$ \tilde { A } X W _ { 0 } $ 和前面的公式 $L ^ { ( 1 ) } = \rho \left( \tilde { A } X W _ { 0 } \right)$ 一致，都是通过对 W 的优化来进行节点的表示。对上面的公式进一步拆解，可以记为：</p><script type="math/tex; mode=display">E _ { 1 } = \tilde { A } X W _ { 0 }</script><p>$E_1$ 就是对单词和文档节点的表示。</p><script type="math/tex; mode=display">E _ { 2 } = \tilde { A } \operatorname { ReLU } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 }</script><p>$E_2$ 就是对节点的第二层级表示。因此，本文相当于用了 2 层 GCN 进行图表示，然后用 softmax 进行分类。在分类优化时，采用了交叉熵损失函数：</p><script type="math/tex; mode=display">\mathcal { L } = - \sum _ { d \in \mathcal { Y } _ { D } } \sum _ { f = 1 } ^ { F } Y _ { d f } \ln Z _ { d f }</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="baseline-设置"><a href="#baseline-设置" class="headerlink" title="baseline 设置"></a>baseline 设置</h3><p>作者设置了多种 baseline，包括：</p><ul><li>TF-IDF + 线性分类器</li><li>CNN 文本分类（Convolutional neural networks for sentence classification，EMNLP）</li><li>LSTM 文本分类（Recurrent neural network for text classiﬁcation with multi-task learning，IJCAI）</li><li>Bi-LSTM</li><li>PV-DBOW（Distributed representations of sentences and documents，ICML）</li><li>PV-DM（同上）</li><li>PTE（Automatic lymphoma classiﬁcation with sentence subgraph mining from pathology reports）</li><li>FastText（Bag of tricks for efﬁcient text classiﬁcation，EACL）</li><li>SWEM（Baseline needs more love: On simple wordembedding-based models and associated pooling mechanisms，ACL）</li><li>LEAM（Joint embedding of words and labels for text classiﬁcation，ACL）</li><li>Graph-CNN-C（Convolutional neural networks on graphs with fast localized spectral ﬁltering，NIPS）</li><li>Graph-CNN-S（Spectral networks and locally connected networks on graphs，ICLR）</li><li>Graph-CNN-F（Deep convolutional networks on graphstructured data）</li></ul><p>可以看到，作者的实验非常完善且置信，应用了当时几乎全部的文本分类方法来进行对比。</p><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>作者用了 200 维作为 embedding 维数，20 作为滑动窗口大小，学习率设为 0.02，Dorpout 设为 0.5，分别随机采样 10 % 数据作为验证集和测试集。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>最终，得到了如下表所示的实验结果：</p><p><img src="/images/15616083449147.jpg" alt="-w1067"></p><p>该表有两个维度，数据集和模型。从此也可以看出，作者实验做的非常充分。</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>从上表可以看到，除了 MR 数据集外，作者提出的 Text GCN 方法在其余全部数据集上都得到了最好的结果。猜测可能是由于 MR 数据集中数据过于短，构图效果不佳造成的。</p><p>此外，作者利用 t-SNE 方法（Visualizing data using t-sne，JMLR）对结果进行了可视化，用于分析训练得到的 embedding 的效果。结果如下：</p><p><img src="/images/15616083604339.jpg" alt="-w513"></p><p>可以看到，作者提出的 Text GCN 方法得到的文档表示在 t-SNE 表现是可分的，类间距离较大，优于用来对比的其余两种方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者提出的 Text GCN 方法在文本分类任务中，在多个数据集上得到了最好的结果。我认为其最大创新点在于：1、引入了 GCN 来做文本分类 2、提出了这种构建带权边图的方式。整个工作非常完备，应该要做的实验基本都做了，令人信服，我们做文本分类应当也要学习本文的实验方式。此外，文章最后的节点表示可视化也很有说服力。</p><p>对于后续工作，我觉得一个是可以 follow 一些新的构图方式和 GNN 框架，再有就是在 loss 方面进行改进，优化表示的空间分布。此外，可以考虑结合一些最新的语言模型方法（BERT、XLNET 等）改善结果。以及，可以对分类器那块进行一些改进，比如引入 Attention 等方法可能可以提升效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：&lt;a href=&quot;https://github.com/yao8839836/t</summary>
      
    
    
    
    <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
    <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
    <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
    <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
    <category term="NLP" scheme="https://lsvih.com/tags/NLP/"/>
    
    <category term="GNN" scheme="https://lsvih.com/tags/GNN/"/>
    
    <category term="GCN" scheme="https://lsvih.com/tags/GCN/"/>
    
    <category term="Text classification" scheme="https://lsvih.com/tags/Text-classification/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 线性代数系列</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra/</id>
    <published>2019-06-26T02:00:00.000Z</published>
    <updated>2019-06-26T02:08:51.880Z</updated>
    
    <content type="html"><![CDATA[<p>本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 <a href="https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0">Linear Algebra with Javascript</a>，旨在帮助复习线性代数的基本概念与运算，并了解如何使用 React、SVG、ThreeJS 等技术栈对线性代数的二维、三维向量、矩阵、线性变换进行可视化。</p><p>本系列共包含 5 篇文章：</p><ol><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/">用 React 制作线性代数教程示例：网格与箭头</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/">JavaScript 线性代数：向量</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/">JavaScript 线性代数：线性变换与矩阵</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/">JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/">线性代数：矩阵基本运算</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 &lt;a href=&quot;https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0&quot;&gt;Linear Algebr</summary>
      
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线性代数：矩阵基本运算</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/</id>
    <published>2019-06-26T01:05:00.000Z</published>
    <updated>2019-06-26T02:07:56.440Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。</p><h2 id="矩阵的加减法"><a href="#矩阵的加减法" class="headerlink" title="矩阵的加减法"></a>矩阵的加减法</h2><p>矩阵的<strong>加法</strong>与<strong>减法</strong>运算将接收两个矩阵作为输入，并输出一个新的矩阵。矩阵的加法和减法都是在分量级别上进行的，因此要进行加减的矩阵必须有着相同的维数。</p><p>为了避免重复编写加减法的代码，我们先创建一个可以接收运算函数的方法，这个方法将对两个矩阵的分量分别执行传入的某种运算。然后在加法、减法或者其它运算中直接调用它就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">componentWiseOperation</span>(<span class="params">func, &#123; rows &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = rows.map(<span class="function">(<span class="params">row, i</span>) =&gt;</span></span><br><span class="line">      row.map(<span class="function">(<span class="params">element, j</span>) =&gt;</span> func(<span class="built_in">this</span>.rows[i][j], element))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, other)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subtract</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b, other)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 6, 8 ], [ 10, 12 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.subtract(one))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 4 ], [ 4, 4 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的标量乘法"><a href="#矩阵的标量乘法" class="headerlink" title="矩阵的标量乘法"></a>矩阵的标量乘法</h2><p>矩阵的标量乘法与向量的缩放类似，就是将矩阵中的每个元素都乘上标量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">scaleBy</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span></span><br><span class="line">      row.map(<span class="function"><span class="params">element</span> =&gt;</span> element * number)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 6 ], [ 8, 10 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>当 <strong>A</strong>、<strong>B</strong> 两个矩阵的维数是<strong>兼容</strong>的时候，就能对这两个矩阵进行矩阵乘法。所谓维数兼容，指的是 <strong>A</strong> 的列数与 <strong>B</strong> 的行数相同。矩阵乘法 <strong>AB</strong> 就是对举证 <strong>A</strong> 的每一行行与矩阵 <strong>B</strong> 的每一列分别进行点积运算：</p><p><img src="/images/15615137842832.jpg" alt="matrix-matrix multiplication"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">multiply</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows[<span class="number">0</span>].length !== other.rows.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;The number of columns of this matrix is not equal to the number of rows of the given matrix.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> columns = other.columns()</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span> </span><br><span class="line">      columns.map(<span class="function"><span class="params">column</span> =&gt;</span> sum(row.map(<span class="function">(<span class="params">element, i</span>) =&gt;</span> element * column[i])))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, -<span class="number">4</span>],</span><br><span class="line">  [<span class="number">0</span>, -<span class="number">3</span>],</span><br><span class="line">  [<span class="number">6</span>, -<span class="number">2</span>],</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">2</span>, -<span class="number">4</span>],</span><br><span class="line">  [<span class="number">4</span>, -<span class="number">3</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(one.multiply(other))</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows:</span></span><br><span class="line"><span class="comment">//    [ [ -7, 18, -32 ],</span></span><br><span class="line"><span class="comment">//      [ -12, 9, -15 ],</span></span><br><span class="line"><span class="comment">//      [ 10, 18, -34 ],</span></span><br><span class="line"><span class="comment">//      [ 1, -5, 9 ] ]&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以把矩阵乘法 <strong>AB</strong> 视为先后应用 <strong>A</strong> 和 <strong>B</strong> 两个线性变换矩阵。为了更好地理解这种概念，可以看一看我们的 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a>。</p><p>下图中黄色的部分就是对红色方块应用线性变换 <strong>C</strong> 的结果。而线性变换 <strong>C</strong> 就是矩阵乘法 <strong>AB</strong> 的结果，其中 <strong>A</strong> 是做相对于 y 轴进行反射的变换矩阵，<strong>B</strong> 是做剪切变换的矩阵。</p><p><img src="/images/15615138080956.jpg" alt="先旋转再剪切变换"></p><p>如果在矩阵乘法中调换 <strong>A</strong> 和 <strong>B</strong> 的顺序，我们会得到一个不同的结果，因为相当于先应用了 <strong>B</strong> 的剪切变换，再应用 <strong>A</strong> 的反射变换：</p><p><img src="/images/15615138231502.jpg" alt="shear than rotate"></p><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><p><strong>转置</strong>矩阵 $A^T$ 由公式 $a^T_{ij}=a_{ji}$ 定义。换句话说，我们通过关于矩阵的对角线对其进行翻转来得到转置矩阵。需要注意的是，矩阵对角线上的元素不受转置运算影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">transpose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...this.columns())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.transpose())</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows: [</span></span><br><span class="line"><span class="comment">//     [ 0, 3, 6, 9 ],</span></span><br><span class="line"><span class="comment">//     [ 1, 4, 7, 10 ],</span></span><br><span class="line"><span class="comment">//     [ 2, 5, 8, 11 ]</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="行列式运算"><a href="#行列式运算" class="headerlink" title="行列式运算"></a>行列式运算</h2><p>矩阵的<strong>行列式</strong>运算将计算矩阵中的所有系数，最后输出一个数字。准确地说，行列式可以描述一个由矩阵行构成的向量的相对几何指标（比如在欧式空间中的有向面积、体积等空间概念）。更准确地说，矩阵 <strong>A</strong> 的行列式相当于告诉你由 <strong>A</strong> 的行定义的方块的体积。$2\times 2$ 矩阵的行列式运算如下所示：</p><p><img src="/images/15615138461810.jpg" alt="det(2×2 matrix)"></p><p>$3\times 3$ 矩阵的行列式运算如下所示：</p><p><img src="/images/15615138625927.jpg" alt="det(3×3 matrix)"></p><p>我们的方法可以计算任意大小矩阵（只要其行列的数量相同）的行列式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">determinant</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows.length !== <span class="built_in">this</span>.rows[<span class="number">0</span>].length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Only matrices with the same number of rows and columns are supported.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows.length === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.rows[<span class="number">0</span>][<span class="number">0</span>] * <span class="built_in">this</span>.rows[<span class="number">1</span>][<span class="number">1</span>] - <span class="built_in">this</span>.rows[<span class="number">0</span>][<span class="number">1</span>] * <span class="built_in">this</span>.rows[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parts = <span class="built_in">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">coef, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matrixRows = <span class="built_in">this</span>.rows.slice(<span class="number">1</span>).map(<span class="function"><span class="params">row</span> =&gt;</span> [ ...row.slice(<span class="number">0</span>, index), ...row.slice(index + <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(...matrixRows)</span><br><span class="line">      <span class="keyword">const</span> result = coef * matrix.determinant()</span><br><span class="line">      <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span> ? result : -result</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(parts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix2 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  [-<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix2.determinant())</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">const</span> matrix3 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, -<span class="number">3</span>,  <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,  <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,  <span class="number">4</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix3.determinant())</span><br><span class="line"><span class="comment">// 49</span></span><br><span class="line"><span class="keyword">const</span> matrix4 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">2</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, -<span class="number">3</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>,  <span class="number">0</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix4.determinant())</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>行列式可以告诉我们变换时对象被拉伸的程度。因此我们可以将其视为一个线性变换对区域改变的一个因素。为了更好地理解这个概念，请参考 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a>：</p><p>在下图中，我们可以看到对红色的 <strong>1×1</strong> 方形进行线性变换后得到了一个 <strong>3×2</strong> 的长方形，面积从 <strong>1</strong> 变为了 <strong>6</strong>，这个数字与线性变换矩阵的行列式值相同。</p><p><img src="/images/15615138875261.jpg" alt="det(scale transformation)"></p><p>如果我们应用一个剪切变换，可以看到方形会变成一个面积不变的平行四边形。因此，剪切变换矩阵的行列式值等于 1：</p><p><img src="/images/15615139063445.jpg" alt="det(shear transformation)"></p><p>如果行列式的值是<strong>负数</strong>，则说明应用线性变换后，空间被反转了。比如在下图中，我们可以看到变换前 $\hat{\jmath}$ 在 $\hat{\imath}$ 的左边，而变换后 $\hat{\jmath}$ 在 $\hat{\imath}$ 的右边。</p><p><img src="/images/15615139284033.jpg" alt="negative determinant"></p><p>如果变换的行列式为 <strong>0</strong>，则表示它会将所有空间都压缩到一条线或一个点上。也就是说，计算一个给定矩阵的行列式是否为 0，可以判断这个矩阵对应的线性变换是否会将对象压缩到更小的维度去。</p><p><img src="/images/15615139536351.jpg" alt="2D 中的 0 行列式"></p><p>在三维空间里，行列式可以告诉你体积缩放了多少：</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a7937595f61716c476f2d4a31356877776c374e6766512e676966.gif" alt="det(scale transformation) in 3D"></p><p>变换行列式等于 0，意味着原来的空间会被完全压缩成体积为 0 的空间。如前文所说，如果在 2 维空间中变换的行列式为 0，则意味着变换的结果将空间压缩成了一条线或一个点；而在 3 维空间中变换的行列式为 0 意味着一个物体会被压扁成一个平面，如下图所示：</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a4b396f324f7268746671574f324e4e6f34684b354e412e676966.gif" alt="3D 中的 0 行列式"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
    <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
    <category term="Matrix" scheme="https://lsvih.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/</id>
    <published>2019-06-26T01:04:00.000Z</published>
    <updated>2019-06-26T02:07:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我完成了一篇关于使用 JavaScript 进行线性变换的文章，并用 <strong>SVG</strong> 网格实现了 2D 的示例。你可以在<a href="https://juejin.im/post/5cefbc37f265da1bd260d129">此处</a>查看之前的文章。但是，那篇文章没有三维空间的示例，因此本文将补全那篇文章的缺失。你可以在<a href="https://github.com/RodionChachura/linear-algebra">此处</a>查看本系列文章的 GitHub 仓库，与本文相关的 commit 可以在<a href="https://github.com/RodionChachura/linear-algebra/tree/6e9b5fe7f037ec12b115c915f33b58ce5e2e9c1f">此处</a>查看。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本文中，我们将制作一个组件，用于对三维空间的对象的线性变换进行可视化。最终效果如下面的动图所示，或者你也可以在<a href="https://rodionchachura.github.io/linear-algebra/">此网页</a>体验。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323533322f312a42415a757839676e656956795a2d456a676b714565672e676966.gif" alt="applying different linear transformations on cube"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当我们要在浏览器中制作 3D 动画时，第一个想到的当然就是 <a href="https://threejs.org/">three.js</a> 库啦。所以让我们来安装它以及另一个可以让用户移动摄像机的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save three three-orbitcontrols</span><br></pre></td></tr></table></figure><p>下面构建一个组件，它可以由父组件的属性中接收矩阵，并且渲染一个立方体的转换动画。下面代码展示了这个组件的结构。我们用 <strong>styled-components</strong> 和 <strong>react-sizeme</strong> 库中的函数对这个组件进行了包装，以访问颜色主题和检测组件尺寸的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">&#x27;react-sizeme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  animate = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">&#123; size: &#123; width, height &#125; &#125;</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedScene = withTheme(withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(ThreeScene))</span><br></pre></td></tr></table></figure><p>在<strong>构造函数</strong>中，我们对状态进行了初始化，其中包括了视图的大小。因此，我们当接收新的状态值时，可以在 <strong>componentWillReceiveProps</strong> 方法中与初始状态进行对比。由于需要访问实际的 <strong>DOM</strong> 元素以注入 <strong>ThreeJS</strong> 的 <strong>renderer</strong>，因此需要在 <strong>render</strong> 方法中用到 <strong>ref</strong> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      width: <span class="number">0</span>,</span><br><span class="line">      height: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">ref</span>=<span class="string">&#123;el</span> =&gt;</span> (this.view = el)&#125; /&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>componentDidMount</strong> 方法中，我们对方块变换动画所需要的所有东西都进行了初始化。首先，我们创建了 ThreeJS 的场景（scene）并确定好摄像机（camera）的位置，然后我们创建了 ThreeJS 的 <strong>renderer</strong>，为它设置好了颜色及大小，最后将 <strong>renderer</strong> 加入到 <strong>View</strong> 组件中。</p><p>接下来创建需要进行渲染的对象：坐标轴、方块以及方块的边。由于我们需要手动改变矩阵，因此将方块和边的 <strong>matrixAutoUpdate</strong> 属性设为 false。创建好这些对象后，将它们加入场景（scene）中。为了让用户可以通过鼠标来移动摄像机位置，我们还用到了 <strong>OrbitControls</strong>。</p><p>最后要做的，就是将我们的库输出的矩阵转换成 <strong>ThreeJS</strong> 的格式，然后获取根据时间返回颜色和转换矩阵的函数。在 <strong>componentWillUnmount</strong>，取消动画（即停止 anime frame）并从 <strong>DOM</strong> 移除 <strong>renderer</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      size: &#123; width, height &#125;,</span><br><span class="line">      matrix,</span><br><span class="line">      theme</span><br><span class="line">    &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">    <span class="built_in">this</span>.scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line">    <span class="built_in">this</span>.camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">100</span>, width / height)</span><br><span class="line">    <span class="built_in">this</span>.camera.position.set(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="built_in">this</span>.renderer.setClearColor(theme.color.background)</span><br><span class="line">    <span class="built_in">this</span>.renderer.setSize(width, height)</span><br><span class="line">    <span class="built_in">this</span>.view.appendChild(<span class="built_in">this</span>.renderer.domElement)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> initialColor = theme.color.red</span><br><span class="line">    <span class="keyword">const</span> axes = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">this</span>.segments = <span class="keyword">new</span> THREE.LineSegments(</span><br><span class="line">      <span class="keyword">new</span> THREE.EdgesGeometry(geometry),</span><br><span class="line">      <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: theme.color.mainText &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.cube = <span class="keyword">new</span> THREE.Mesh(</span><br><span class="line">      geometry,</span><br><span class="line">      <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: initialColor &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.objects = [<span class="built_in">this</span>.cube, <span class="built_in">this</span>.segments]</span><br><span class="line">    <span class="built_in">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.matrixAutoUpdate = <span class="literal">false</span>))</span><br><span class="line">    <span class="built_in">this</span>.scene.add(<span class="built_in">this</span>.cube, axes, <span class="built_in">this</span>.segments)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.controls = <span class="keyword">new</span> OrbitControls(<span class="built_in">this</span>.camera)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getAnimatedColor = getGetAnimatedColor(</span><br><span class="line">      initialColor,</span><br><span class="line">      theme.color.blue,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> fromMatrix = fromMatrix4(<span class="built_in">this</span>.cube.matrix)</span><br><span class="line">    <span class="keyword">const</span> toMatrix = matrix.toDimension(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">this</span>.getAnimatedTransformation = getGetAnimatedTransformation(</span><br><span class="line">      fromMatrix,</span><br><span class="line">      toMatrix,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.frameId = requestAnimationFrame(<span class="built_in">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cancelAnimationFrame(<span class="built_in">this</span>.frameId)</span><br><span class="line">    <span class="built_in">this</span>.view.removeChild(<span class="built_in">this</span>.renderer.domElement)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过此时我们还没有定义 <strong>animate</strong> 函数，因此什么也不会渲染。首先，我们更新立方体及其边缘的转换矩阵，并且更新立方体的颜色，然后进行渲染并且调用 <code>window.requestAnimationFrame</code>。</p><p><strong>componentWillReceiveProps</strong> 方法将接收当前组件的大小，当它检测到组件尺寸发生了变化时，会更新状态，改变 renderer 的尺寸，并调整 camera 的方位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  animate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transformation = <span class="built_in">this</span>.getAnimatedTransformation()</span><br><span class="line">    <span class="keyword">const</span> matrix4 = toMatrix4(transformation)</span><br><span class="line">    <span class="built_in">this</span>.cube.material.color.set(<span class="built_in">this</span>.getAnimatedColor())</span><br><span class="line">    <span class="built_in">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> obj.matrix.set(...matrix4.toArray()))</span><br><span class="line">    <span class="built_in">this</span>.renderer.render(<span class="built_in">this</span>.scene, <span class="built_in">this</span>.camera)</span><br><span class="line">    <span class="built_in">this</span>.frameId = <span class="built_in">window</span>.requestAnimationFrame(<span class="built_in">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">&#123; size: &#123; width, height &#125; &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.width !== width || <span class="built_in">this</span>.state.height !== height) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">      <span class="built_in">this</span>.renderer.setSize(width, height)</span><br><span class="line">      <span class="built_in">this</span>.camera.aspect = width / height</span><br><span class="line">      <span class="built_in">this</span>.camera.updateProjectionMatrix()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>为了将颜色变化以及矩阵变换做成动画，需要写个函数来返回动画函数。在写这块函数前，我们先要完成以下两种转换器：将我们库的矩阵转换为 <strong>ThreeJS</strong> 格式矩阵的函数，以及参考 StackOverflow 上代码的将 RGB 转换为 hex 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/matrix&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/matrix&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>首先，需要计算每种原色（RGB）变化的幅度。第一次调用 <strong>getGetAnimatedColor</strong> 时会返回新的色彩与时间戳的集合；并在后续被调用时，通过颜色变化的距离以及时间的耗费，可以计算出当前时刻新的 <strong>RGB</strong> 颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hexToRgb, rgbToHex &#125; <span class="keyword">from</span> <span class="string">&#x27;./generic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedColor = <span class="function">(<span class="params">fromColor, toColor, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fromRgb = hexToRgb(fromColor)</span><br><span class="line">  <span class="keyword">const</span> toRgb = hexToRgb(toColor)</span><br><span class="line">  <span class="keyword">const</span> distances = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toPart = toRgb[index]</span><br><span class="line">    <span class="keyword">return</span> fromPart &lt;= toPart ? toPart - fromPart : <span class="number">255</span> - fromPart + toPart</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toColor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> rgb = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances[index]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round((fromPart + step) % <span class="number">255</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> rgbToHex(...rgb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>为了给线性变换做出动画效果，同样要进行上节的操作。我们首先找到矩阵变换前后的区别，然后在动画函数中，根据第一次调用 <strong>getGetAnimatedTransformation</strong> 时的状态，根据时间来更新各个组件的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedTransformation = <span class="function">(<span class="params">fromMatrix, toMatrix, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> distances = toMatrix.subtract(fromMatrix)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toMatrix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> newMatrix = fromMatrix.map(<span class="function">(<span class="params">fromComponent, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances.rows[i][j]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> fromComponent + step</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newMatrix</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
    <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：线性变换与矩阵</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/</id>
    <published>2019-06-26T01:03:00.000Z</published>
    <updated>2019-06-26T02:08:06.140Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>矩阵</strong>是一种由 <strong>m</strong> 行 <strong>n</strong> 列实数组成的“矩形”数组。比如，一个 <strong>3x2</strong> 的矩阵如下所示：</p><p><img src="/images/15615130636391.jpg" alt="**3×2** 矩阵"></p><p><strong>Matrix</strong> 类的构造器（constructor）接收若干行元素作为参数。我们可以通过指定行号取出矩阵中的一行，然后再通过指定列号取出一个特定的元素。下面直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...rows</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix)</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// [ 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="矩阵与向量的乘积"><a href="#矩阵与向量的乘积" class="headerlink" title="矩阵与向量的乘积"></a>矩阵与向量的乘积</h2><p><strong>矩阵与向量的乘法</strong> —— $A\vec{x}$ 会将矩阵 $A$ 的列进行系数为 $\vec{x}$ 的线性组合。比如，一个 $3\times 2$ 的矩阵 A 与一个 <strong>2D</strong> 向量 <strong>x⃗</strong> 的乘积将得到一个 <strong>3D</strong> 向量，这个计算记为：$\vec{y} : \vec{y} = A\vec{x}$。</p><p><img src="/images/15615131095284.jpg" alt=""></p><p>假设有一组向量 $\{\vec{e}_1,\vec{e}_2\}$，另一个向量 $\vec{y}$ 是 $\vec{e}_1$ 和 $\vec{e}_2$ 的<strong>线性组合</strong>：$\vec{y} = \alpha\vec{e}_1 + \beta \vec{e}_2$。其中，$\alpha, \beta \in \mathbb{R}$ 就是这个线性组合的系数。</p><p>为了更好地学习线性组合，我们特地为此定义了矩阵向量乘法。我们可以将前面所说的线性组合记为以下矩阵向量乘法的形式：$\vec{y} = E \vec{x}$。矩阵 $E$ 有 $\vec{e}_1$、$\vec{e}_2$ 两列。矩阵的维数是 $n \times 2$，其中 $n$ 是向量 $\vec{e}_1$、$\vec{e}_2$ 与 $\vec{y}$ 的维数。</p><p>下图展示了将向量 $\vec{v}$ 表示为向量 $\vec{\imath}$ 和向量 $\vec{\jmath}$ 的线性组合：</p><p><img src="/images/15615131638823.jpg" alt="线性组合"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> j = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> firstCoeff = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> secondCoeff = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> linearCombination = i.scaleBy(firstCoeff).add(j.scaleBy(secondCoeff))</span><br><span class="line"><span class="built_in">console</span>.log(linearCombination)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 5 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>矩阵与向量的乘法是<strong>线性变换</strong>的抽象概念，这是学习线性代数中的关键概念之一。向量与矩阵的乘法可以视为对向量进行线性变换：将 n 维向量作为输入，并输出 m 维向量。也可以说，矩阵是定义好的某种空间变换。</p><p>我们可以通过一个示例来更清楚地理解线性变换。首先需要给 Matrix 类加上一个方法，用于返回矩阵的列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...rows</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">columns</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">r</span> =&gt;</span> r[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.columns())</span><br><span class="line"><span class="comment">// [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]</span></span><br></pre></td></tr></table></figure><p>乘法得到的向量的维数将与矩阵的行数相同。如果我们将一个 <strong>2D</strong> 向量和一个 <strong>3x2</strong> 矩阵相乘，将得到一个 <strong>3D</strong> 的向量；如果将一个 <strong>3D</strong> 向量和一个 <strong>2x3</strong> 矩阵相乘，将得到一个 <strong>2D</strong> 的向量；如果在做乘法时，矩阵的列数和向量的维数不相同，将报错。在下面的代码中，你可以看到几种不同的向量与矩阵相乘的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, value</span>) =&gt;</span> acc + value, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">transform</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> columns = matrix.columns()</span><br><span class="line">    <span class="keyword">if</span>(columns.length !== <span class="built_in">this</span>.components.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Matrix columns length should be equal to vector components length.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> multiplied = columns</span><br><span class="line">      .map(<span class="function">(<span class="params">column, i</span>) =&gt;</span> column.map(<span class="function"><span class="params">c</span> =&gt;</span> c * <span class="built_in">this</span>.components[i]))</span><br><span class="line">    <span class="keyword">const</span> newComponents = multiplied[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> sum(multiplied.map(<span class="function"><span class="params">column</span> =&gt;</span> column[i])))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(...newComponents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector2D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> vector3D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> matrix2x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix2x3D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix3x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector3D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 19, 49 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 3D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix3x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29, 45 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Error: Matrix columns length should be equal to vector components length.</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在，我们将尝试对二维的对象应用线性变换。首先，需要创建一个新的 <strong>Contour</strong>（轮廓）类，它在 constructor 中接收一系列的向量（在 2D 平面中形成一个轮廓），然后用唯一的方法 —— <strong>transform</strong> 对轮廓中的所有向量坐标进行变换，最后返回一个新的轮廓。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contour</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vectors</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.vectors = vectors</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">transform</span>(<span class="params">matrix</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newVectors = <span class="built_in">this</span>.vectors.map(<span class="function"><span class="params">v</span> =&gt;</span> v.transform(matrix))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contour(newVectors)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contour = <span class="keyword">new</span> Contour([</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在，请在 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a> 项目中试试各种转换矩阵。红色方块是初始化的轮廓，蓝色形状是应用变换矩阵后的轮廓。</p><p><img src="/images/15615132290264.jpg" alt="镜像"></p><p><img src="/images/15615132414178.jpg" alt="缩放"></p><p>通过下面的方式，我们可以构建一个矩阵，用于将给定的向量旋转指定的角度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> angle = toRadians(<span class="number">45</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="built_in">Math</span>.cos(angle), -<span class="built_in">Math</span>.sin(angle)],</span><br><span class="line">  [<span class="built_in">Math</span>.sin(angle), <span class="built_in">Math</span>.cos(angle)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/15615132769006.jpg" alt="旋转"></p><p><img src="/images/15615133004176.jpg" alt="剪切变换"></p><p>对 3D 空间内的对象进行变换也与此类似。你可以在下图中看到一个红色方块变换成一个蓝色的平行六边形的动画。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323433322f312a7a6f5472705f6c6d3170324851436c6b614f644d4f512e676966.gif" alt="3D 剪切变换"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：向量</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/</id>
    <published>2019-06-26T01:01:00.000Z</published>
    <updated>2019-06-26T02:08:28.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>向量</strong>是用于精确表示空间中方向的方法。向量由一系列数值构成，每维数值都是向量的一个<strong>分量</strong>。在下图中，你可以看到一个由两个分量组成的、在 2 维空间内的向量。在 3 维空间内，向量会由 3 个分量组成。</p><p><img src="/images/15615124754701.jpg" alt="the vector in 2D space"></p><p>我们可以为 2 维空间的向量创建一个 <strong>Vector2D</strong> 类，然后为 3 维空间的向量创建一个 <strong>Vector3D</strong> 类。但是这么做有一个问题：向量并不仅用于表示物理空间中的方向。比如，我们可能需要将颜色（RGBA）表示为向量，那么它会有 4 个分量：红色、绿色、蓝色和 alpha 通道。或者，我们要用向量来表示有不同占比的 <strong>n</strong> 种选择（比如表示 5 匹马赛马，每匹马赢得比赛的概率的向量）。因此，我们会创建一个不指定维度的类，并像这样使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> direction2d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> direction3d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> Vector(<span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="keyword">const</span> probabilities = <span class="keyword">new</span> Vector(<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>考虑有两个向量的情况，可以对它们定义以下运算：</p><p><img src="/images/15615124998598.jpg" alt="basic vector operations"></p><p>其中，<strong>α ∈ R</strong> 为任意常数。</p><p>我们对除了叉积之外的运算进行了可视化，你可以在<a href="https://rodionchachura.github.io/linear-algebra/">此处</a>找到相关示例。<a href="https://github.com/RodionChachura/linear-algebra">此 GitHub 仓库</a>里有用来创建这些可视化示例的 React 项目和相关的库。如果你想知道如何使用 React 和 SVG 来制作这些二维可视化示例，请参考<a href="https://juejin.im/post/5cefbc37f265da1bd260d129">本文</a>。</p><h3 id="加法与减法"><a href="#加法与减法" class="headerlink" title="加法与减法"></a>加法与减法</h3><p>与数值运算类似，你可以对向量进行加法与减法运算。对向量进行算术运算时，可以直接对向量各自的分量进行数值运算得到结果：</p><p><img src="/images/15615125322484.jpg" alt="vectors addition"></p><p><img src="/images/15615125380537.jpg" alt="vectors subtraction"></p><p>加法函数接收另一个向量作为参数，并将对应的向量分量相加，返回得出的新向量。减法函数与之类似，不过会将加法换成减法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">&#123; components &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="built_in">this</span>.components[index] + component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subtract</span>(<span class="params">&#123; components &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="built_in">this</span>.components[index] - component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 4, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(one.subtract(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们可以对一个向量进行缩放，缩放比例可为任意数值 <strong>α ∈ R</strong>。缩放时，对所有向量分量都乘以缩放因子 <strong>α</strong>。当 <strong>α &gt; 1</strong> 时，向量会变得更长；当 <strong>0 ≤ α \&lt; 1</strong> 时，向量会变得更短。如果 <strong>α</strong> 是负数，缩放后的向量将会指向原向量的反方向。</p><p><img src="/images/15615125690651.jpg" alt="scaling vector"></p><p>在 <strong>scaleBy</strong> 方法中，我们对所有的向量分量都乘上传入参数的数值，得到新的向量并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">scaleBy</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...this.components.map(<span class="function"><span class="params">component</span> =&gt;</span> component * number)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.5, 1 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(-<span class="number">1</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -1, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>向量长度可由勾股定理导出：</p><p><img src="/images/15615125935367.jpg" alt="vectors length"></p><p>由于在 JavaScript 内置的 Math 对象中有现成的函数，因此计算长度的方法非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">length</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(...this.components)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br></pre></td></tr></table></figure><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。两个向量的点积等于它们各自对应分量的乘积之和。</p><p><img src="/images/15615126207640.jpg" alt="dot product"></p><p>在 <strong>dotProduct</strong> 方法中，接收另一个向量作为参数，通过 reduce 方法来计算对应分量的乘积之和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">dotProduct</span>(<span class="params">&#123; components &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> components.reduce(<span class="function">(<span class="params">acc, component, index</span>) =&gt;</span> acc + component * <span class="built_in">this</span>.components[index], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.dotProduct(other))</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法。这种归一化后的向量在许多情景中都会用到。比如说当我们需要在空间中指定一个方向时，就需要用一个归一化后的向量来表示这个方向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scaleBy(<span class="number">1</span> / <span class="built_in">this</span>.length())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> normalized = vector.normalize()</span><br><span class="line"><span class="built_in">console</span>.log(normalized)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.4472135954999579, 0.8944271909999159 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(normalized.length())</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><img src="/images/15615126527250.jpg" alt="using dot product"></p><p>如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。我们创建了 <strong>areEqual</strong> 函数用来比较两个浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EPSILON = <span class="number">0.00000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> areEqual = <span class="function">(<span class="params">one, other, epsilon = EPSILON</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Math</span>.abs(one - other) &lt; epsilon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">haveSameDirectionWith</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveSameDirectionWith(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量点积结果等于 -1，则表示它们的方向完全相反：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">haveOppositeDirectionTo</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, -<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(-<span class="number">4</span>, -<span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveOppositeDirectionTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量的点积结果为 0，则表示这两个向量是相互垂直的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">isPerpendicularTo</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.isPerpendicularTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量：</p><p><img src="/images/15615126731739.jpg" alt=""></p><p>我们实现叉积时，假定它只用于计算三维空间内的向量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只适用于 3 维向量</span></span><br><span class="line">  <span class="function"><span class="title">crossProduct</span>(<span class="params">&#123; components &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">1</span>] * components[<span class="number">2</span>] - <span class="built_in">this</span>.components[<span class="number">2</span>] * components[<span class="number">1</span>],</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">2</span>] * components[<span class="number">0</span>] - <span class="built_in">this</span>.components[<span class="number">0</span>] * components[<span class="number">2</span>],</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">0</span>] * components[<span class="number">1</span>] - <span class="built_in">this</span>.components[<span class="number">1</span>] * components[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.crossProduct(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, -3, 3 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.crossProduct(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 3, -3 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h2><p>在现实生活的应用中，上述方法是远远不够的。比如说，我们有时需要找到两个向量的夹角、将一个向量反向，或者计算一个向量在另一个向量上的投影等。</p><p>在开始编写上面说的方法前，需要先写下面两个函数，用于在角度与弧度间相互转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toDegrees = <span class="function"><span class="params">radians</span> =&gt;</span> (radians * <span class="number">180</span>) / <span class="built_in">Math</span>.PI</span><br><span class="line"><span class="keyword">const</span> toRadians = <span class="function"><span class="params">degrees</span> =&gt;</span> (degrees * <span class="built_in">Math</span>.PI) / <span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">angleBetween</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> toDegrees(</span><br><span class="line">      <span class="built_in">Math</span>.acos(</span><br><span class="line">        <span class="built_in">this</span>.dotProduct(other) /</span><br><span class="line">        (<span class="built_in">this</span>.length() * other.length())</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.angleBetween(other))</span><br><span class="line"><span class="comment">// 45.00000000000001</span></span><br></pre></td></tr></table></figure><h3 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h3><p>当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">negate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scaleBy(-<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.negate())</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -2, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p><img src="/images/15615126897492.jpg" alt="project v on d"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">projectOn</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> normalized = other.normalize()</span><br><span class="line">    <span class="keyword">return</span> normalized.scaleBy(<span class="built_in">this</span>.dotProduct(normalized))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(other.projectOn(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 6, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="设定长度"><a href="#设定长度" class="headerlink" title="设定长度"></a>设定长度</h3><p>当需要给向量指定一个长度时，可以使用如下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">withLength</span>(<span class="params">newLength</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.normalize().scaleBy(newLength)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br><span class="line"><span class="keyword">const</span> modified = one.withLength(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(modified.length())</span><br></pre></td></tr></table></figure><h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p>为了判断两个向量是否相等，可以对它们对应的分量使用  <strong>areEqual</strong> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...components</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">equalTo</span>(<span class="params">&#123; components &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> components.every(<span class="function">(<span class="params">component, index</span>) =&gt;</span> areEqual(component, <span class="built_in">this</span>.components[index]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(another))</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="单位向量与基底"><a href="#单位向量与基底" class="headerlink" title="单位向量与基底"></a>单位向量与基底</h2><p>我们可以将一个向量看做是“在 x 轴上走 $v_x$ 的距离、在 y 轴上走 $v_y$ 的距离、在 z 轴上走 $v_z$ 的距离”。我们可以使用 $\hat { \imath }$ 、$\hat { \jmath }$ 和 $\hat { k }$ 分别乘上一个值更清晰地表示上述内容。下图分别是 $x$、$y$、$z$ 轴上的<strong>单位向量</strong>：</p><script type="math/tex; mode=display">\hat { \imath } = ( 1,0,0 ) \quad \hat { \jmath } = ( 0,1,0 ) \quad \hat { k } = ( 0,0,1 )</script><p>任何数值乘以 $\hat { \imath }$ 向量，都可以得到一个第一维分量等于该数值的向量。例如：</p><script type="math/tex; mode=display">2 \hat { \imath } = ( 2,0,0 ) \quad 3 \hat { \jmath } = ( 0,3,0 ) \quad 5 \hat { K } = ( 0,0,5 )</script><p>向量中最重要的一个概念是<strong>基底</strong>。设有一个 3 维向量 $\mathbb{R}^3$，它的基底是一组向量：$\{\hat{e}_1,\hat{e}_2,\hat{e}_3\}$，这组向量也可以作为 $\mathbb{R}^3$ 的坐标系统。如果 $\{\hat{e}_1,\hat{e}_2,\hat{e}_3\}$ 是一组基底，则可以将任何向量 $\vec{v} \in \mathbb{R}^3$ 表示为该基底的系数 $(v_1,v_2,v_3)$：</p><script type="math/tex; mode=display">\vec{v} = v_1 \hat{e}_1 + v_2 \hat{e}_2 + v_3 \hat{e}_3</script><p>向量 $\vec{v}$ 是通过在 $\hat{e}_1$ 方向上测量 $v_2$ 的距离、在 $\hat{e}_2$ 方向上测量 $v_1$ 的距离、在 $\hat{e}_3$ 方向上测量 $v_3$ 的距离得出的。</p><p>在不知道一个向量的基底前，向量的系数三元组并没有什么意义。只有知道向量的基底，才能将类似于 $(a,b,c)$ 三元组的数学对象转化为现实世界中的概念（比如颜色、概率、位置等）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>用 React 制作线性代数教程示例：网格与箭头</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/</id>
    <published>2019-06-26T01:00:00.000Z</published>
    <updated>2019-06-26T02:08:16.940Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我撰写了这个线性代数系列的<a href="https://medium.com/@geekrodion/linear-algebra-vectors-f7610e9a0f23">开篇之作</a>。在新篇开始动笔前，我有了一个想法：使用 React 开发一个项目，来为这个系列的所有示例提供可视化功能一定很好玩！本系列的所有代码都存放于<a href="https://github.com/RodionChachura/linear-algebra">此 GitHub 仓库</a>，本文相关代码的提交记录位于<a href="https://github.com/RodionChachura/linear-algebra/tree/813cfecfda70cb3a9415c21ead97e09242e08f49">此处</a>。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本系列刚开始写作时，只有一个章节涉及了向量的基本运算。所以，目前实现一个能渲染二维坐标网格以及能将向量可视化为箭头的组件就够用了。本文最后做出的效果如下图所示，你也可以在<a href="https://rodionchachura.github.io/linear-algebra/">此处</a>进行体验。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f333833302f312a3338743653416c5363676d42476a58516e39635475412e676966.gif" alt="二维空间中的基本向量运算"></p><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>其实已经有关于创建 React 项目的最佳实践指南文章可供参考，不过在本文中，我们将尽可能减少依赖的库，并简化对项目的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-react-app linear-algebra-demo</span><br><span class="line"><span class="built_in">cd</span> linear-algebra-demo</span><br><span class="line">npm install --save react-sizeme styled-components</span><br></pre></td></tr></table></figure><p>上面的脚本安装了两个库。第一个库 <code>react-sizeme</code> 可以实现当窗体大小发生变化时，重新渲染网格组件。第二个库 <code>styled-components</code> 则能让我们更轻松地编写组件的样式。此外，要用到我们正在开发的 <strong>linear-algebra</strong> 库，需要在 <strong>package.json</strong> 中进行如下引用：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;linear-algebra&quot;</span>: <span class="string">&quot;file:../library&quot;</span>,</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/images/15615123069092.jpg" alt="项目结构"></p><p>本系列为每个示例都在 <code>views</code> 目录中创建了各自的组件。我们在 <strong>index.js</strong> 中导出一个以示例名称为键、以对应组件为值的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorLength &#125; <span class="keyword">from</span> <span class="string">&#x27;./vector-length&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorScale &#125; <span class="keyword">from</span> <span class="string">&#x27;./vector-scale&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsAddition &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-addition&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsSubtraction &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-subtraction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsDotProduct &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-dot-product&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">&#x27;vectors: addition&#x27;</span>: VectorsAddition,</span><br><span class="line">  <span class="string">&#x27;vectors: subtraction&#x27;</span>: VectorsSubtraction,</span><br><span class="line">  <span class="string">&#x27;vectors: length&#x27;</span>: VectorLength,</span><br><span class="line">  <span class="string">&#x27;vectors: scale&#x27;</span>: VectorScale,</span><br><span class="line">  <span class="string">&#x27;vectors: dot product&#x27;</span>: VectorsDotProduct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>Main</code> 组件中导入该对象，并在菜单中展示出所有的键。当用户通过菜单选择示例后，更新组件状态，并渲染新的 <code>view</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> views <span class="keyword">from</span> <span class="string">&#x27;./views&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MenuItem <span class="keyword">from</span> <span class="string">&#x27;./menu-item&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Menu = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      view: <span class="built_in">Object</span>.keys(views)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; view &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> View = views[view]</span><br><span class="line">    <span class="keyword">const</span> viewsNames = <span class="built_in">Object</span>.keys(views)</span><br><span class="line">    <span class="keyword">const</span> MenuItems = <span class="function">() =&gt;</span></span><br><span class="line">      viewsNames.map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MenuItem</span><br><span class="line">          key=&#123;name&#125;</span><br><span class="line">          selected=&#123;name === view&#125;</span><br><span class="line">          text=&#123;name&#125;</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">view</span>: name &#125;)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;View /&gt;</span><br><span class="line">        &lt;Menu&gt;</span><br><span class="line">          &lt;MenuItems /&gt;</span><br><span class="line">        &lt;/Menu&gt;</span><br><span class="line">      &lt;/Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><h2 id="网格组件"><a href="#网格组件" class="headerlink" title="网格组件"></a>网格组件</h2><p>为了在之后的示例中渲染向量和其它内容，我们设计了一个功能强大的组件，这个组件需要有这么一种投影功能：将我们熟知的直角坐标系（原点在中间，y 轴正向朝上）投影到 <strong>SVG</strong> 坐标系（原点在左上角，y 轴正向朝下）中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.updateProject(<span class="function"><span class="params">vector</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 vector 类中没有任何用于缩放的方法，因此在这里进行计算：</span></span><br><span class="line">  <span class="keyword">const</span> scaled = vector.scaleBy(step)</span><br><span class="line">  <span class="keyword">const</span> withNegatedY = <span class="keyword">new</span> Vector(</span><br><span class="line">    scaled.components[<span class="number">0</span>],</span><br><span class="line">    -scaled.components[<span class="number">1</span>]</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> middle = getSide(size) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> withNegatedY.add(<span class="keyword">new</span> Vector(middle, middle))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了捕获到网格组件容器的大小变动，我们使用 <strong>react-size</strong> 库提供的函数将这个组件包装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">&#x27;react-sizeme&#x27;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  updateProject = <span class="function">(<span class="params">size, cells</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> step = getStepLen(size, cells)</span><br><span class="line">    <span class="built_in">this</span>.props.updateProject(<span class="function">() =&gt;</span> /...)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">&#123; size, cells &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="keyword">const</span> newStepLen = getStepLen(size, cells)</span><br><span class="line">      <span class="keyword">const</span> oldStepLen = getStepLen(<span class="built_in">this</span>.props.size, cells)</span><br><span class="line">      <span class="keyword">if</span> (newStepLen !== oldStepLen) &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateProject(size, cells)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="built_in">this</span>.updateProject(<span class="built_in">this</span>.props.size, <span class="built_in">this</span>.props.cells)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(Grid)</span><br></pre></td></tr></table></figure><p>为了便于在不同的示例中使用这个网格组件，我们编写了一个 <strong>GridExample</strong> 组件，它可以接收两个参数：一个用于渲染信息（例如向量的名称）的函数 <code>renderInformation</code>，以及一个用于在网格上呈现内容（如后面的箭头组件）的函数 <code>renderGridContent</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> Grid <span class="keyword">from</span> <span class="string">&#x27;./grid&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      project: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; project &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123; renderInformation, renderGridContent &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> Content = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (project &amp;&amp; renderGridContent) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderGridContent(&#123; project &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Information = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (renderInformation) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderInformation()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Grid cells=&#123;<span class="number">10</span>&#125; updateProject=&#123;<span class="function"><span class="params">project</span> =&gt;</span> <span class="built_in">this</span>.setState(&#123; project &#125;)&#125;&gt;</span><br><span class="line">          &lt;Content /&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">        &lt;InfoContainer&gt;</span><br><span class="line">          &lt;Information /&gt;</span><br><span class="line">        &lt;/InfoContainer&gt;</span><br><span class="line">      &lt;/Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><p>这样就能在 view 中使用这个组件了。下面以向量的加法为例测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GridExample <span class="keyword">from</span> <span class="string">&#x27;../grid-example&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Arrow <span class="keyword">from</span> <span class="string">&#x27;../arrow&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VectorView <span class="keyword">from</span> <span class="string">&#x27;../vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VectorsAddition = <span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> oneName = <span class="string">&#x27;v⃗&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> otherName = <span class="string">&#x27;w⃗&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> oneColor = theme.color.green</span><br><span class="line">  <span class="keyword">const</span> otherColor = theme.color.red</span><br><span class="line">  <span class="keyword">const</span> sum = one.add(other)</span><br><span class="line">  <span class="keyword">const</span> sumColor = theme.color.blue</span><br><span class="line">  <span class="keyword">const</span> sumText = <span class="string">`<span class="subst">$&#123;oneName&#125;</span> + <span class="subst">$&#123;otherName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> renderInformation = <span class="function">() =&gt;</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;VectorView components=&#123;one.components&#125; name=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span><br><span class="line">      &lt;VectorView</span><br><span class="line">        components=&#123;other.components&#125;</span><br><span class="line">        name=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;VectorView components=&#123;sum.components&#125; name=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> renderGridContent = <span class="function">(<span class="params">&#123; project &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;one&#125; text=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span><br><span class="line">      &lt;Arrow</span><br><span class="line">        project=&#123;project&#125;</span><br><span class="line">        vector=&#123;other&#125;</span><br><span class="line">        text=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;sum&#125; text=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> props = &#123; renderInformation, renderGridContent &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GridExample</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTheme(VectorsAddition)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头组件"><a href="#箭头组件" class="headerlink" title="箭头组件"></a>箭头组件</h2><p>箭头组件由 3 个 <strong>SVG</strong> 元素组成：<strong>line</strong> 用于显示箭头的线、<strong>polygon</strong> 用于显示箭头的头、<strong>text</strong> 用于显示向量名称。此外，我们需要接收 <strong>project</strong> 函数，用于将箭头放在网格中正确的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Arrow = styled.line<span class="string">`</span></span><br><span class="line"><span class="string">  stroke-width: 2px;</span></span><br><span class="line"><span class="string">  stroke: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Head = styled.polygon<span class="string">`</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Text = styled.text<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 24px;</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; vector, text, color, project &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> direction = vector.normalize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> headStart = direction.scaleBy(vector.length() - <span class="number">0.6</span>)</span><br><span class="line">  <span class="keyword">const</span> headSide = <span class="keyword">new</span> Vector(</span><br><span class="line">    direction.components[<span class="number">1</span>],</span><br><span class="line">    -direction.components[<span class="number">0</span>]</span><br><span class="line">  ).scaleBy(<span class="number">0.2</span>)</span><br><span class="line">  <span class="keyword">const</span> headPoints = [</span><br><span class="line">    headStart.add(headSide),</span><br><span class="line">    headStart.subtract(headSide),</span><br><span class="line">    vector</span><br><span class="line">  ]</span><br><span class="line">    .map(project)</span><br><span class="line">    .map(<span class="function"><span class="params">v</span> =&gt;</span> v.components)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> projectedStart = project(<span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">const</span> projectedEnd = project(vector)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PositionedText = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!text) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> &#123; components &#125; = project(vector.withLength(vector.length() + <span class="number">0.2</span>))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text color=&#123;color&#125; x=&#123;components[<span class="number">0</span>]&#125; y=&#123;components[<span class="number">1</span>]&#125;&gt;</span><br><span class="line">        &#123;text&#125;</span><br><span class="line">      &lt;/Text&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;g&gt;</span><br><span class="line">      &lt;Arrow</span><br><span class="line">        color=&#123;color&#125;</span><br><span class="line">        x1=&#123;projectedStart.components[<span class="number">0</span>]&#125;</span><br><span class="line">        y1=&#123;projectedStart.components[<span class="number">1</span>]&#125;</span><br><span class="line">        x2=&#123;projectedEnd.components[<span class="number">0</span>]&#125;</span><br><span class="line">        y2=&#123;projectedEnd.components[<span class="number">1</span>]&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Head color=&#123;color&#125; points=&#123;headPoints&#125; /&gt;</span><br><span class="line">      &lt;PositionedText /&gt;</span><br><span class="line">    &lt;/g&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>通过结合 <strong>React</strong> 与 <strong>SVG</strong> 可以做更多有意思的事。在本系列的后面章节中，我们会给这个可视化示例添加更多的功能。最后推荐另一篇类似的文章：<a href="https://medium.com/@geekrodion/bar-chart-with-react-3b20b7907633">使用 <strong>React</strong> 与 <strong>SVG</strong> 制作复杂的条形图</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
    <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
    <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
    <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
    <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
    <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
</feed>
