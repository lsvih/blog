<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My note</title>
  
  <subtitle>lsvih</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lsvih.com/"/>
  <updated>2019-06-26T02:08:51.889Z</updated>
  <id>https://lsvih.com/</id>
  
  <author>
    <name>lsvih</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript 线性代数系列</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra/</id>
    <published>2019-06-26T02:00:00.000Z</published>
    <updated>2019-06-26T02:08:51.889Z</updated>
    
    <content type="html"><![CDATA[<p>本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 <a href="https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0" target="_blank" rel="noopener">Linear Algebra with Javascript</a>，旨在帮助复习线性代数的基本概念与运算，并了解如何使用 React、SVG、ThreeJS 等技术栈对线性代数的二维、三维向量、矩阵、线性变换进行可视化。</p><p>本系列共包含 5 篇文章：</p><ol><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/">用 React 制作线性代数教程示例：网格与箭头</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/">JavaScript 线性代数：向量</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/">JavaScript 线性代数：线性变换与矩阵</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/">JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/">线性代数：矩阵基本运算</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 &lt;a href=&quot;https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线性代数：矩阵基本运算</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/</id>
    <published>2019-06-26T01:05:00.000Z</published>
    <updated>2019-06-26T02:07:56.442Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。</p><h2 id="矩阵的加减法"><a href="#矩阵的加减法" class="headerlink" title="矩阵的加减法"></a>矩阵的加减法</h2><p>矩阵的<strong>加法</strong>与<strong>减法</strong>运算将接收两个矩阵作为输入，并输出一个新的矩阵。矩阵的加法和减法都是在分量级别上进行的，因此要进行加减的矩阵必须有着相同的维数。</p><p>为了避免重复编写加减法的代码，我们先创建一个可以接收运算函数的方法，这个方法将对两个矩阵的分量分别执行传入的某种运算。然后在加法、减法或者其它运算中直接调用它就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  componentWiseOperation(func, &#123; rows &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = rows.map(<span class="function">(<span class="params">row, i</span>) =&gt;</span></span><br><span class="line">      row.map(<span class="function">(<span class="params">element, j</span>) =&gt;</span> func(<span class="keyword">this</span>.rows[i][j], element))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">  add(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, other)</span><br><span class="line">  &#125;</span><br><span class="line">  subtract(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b, other)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 6, 8 ], [ 10, 12 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.subtract(one))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 4 ], [ 4, 4 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的标量乘法"><a href="#矩阵的标量乘法" class="headerlink" title="矩阵的标量乘法"></a>矩阵的标量乘法</h2><p>矩阵的标量乘法与向量的缩放类似，就是将矩阵中的每个元素都乘上标量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scaleBy(number) &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span></span><br><span class="line">      row.map(<span class="function"><span class="params">element</span> =&gt;</span> element * number)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 6 ], [ 8, 10 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>当 <strong>A</strong>、<strong>B</strong> 两个矩阵的维数是<strong>兼容</strong>的时候，就能对这两个矩阵进行矩阵乘法。所谓维数兼容，指的是 <strong>A</strong> 的列数与 <strong>B</strong> 的行数相同。矩阵乘法 <strong>AB</strong> 就是对举证 <strong>A</strong> 的每一行行与矩阵 <strong>B</strong> 的每一列分别进行点积运算：</p><p><img src="https://lsvih.com/images/15615137842832.jpg" alt="matrix-matrix multiplication"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  multiply(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows[<span class="number">0</span>].length !== other.rows.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The number of columns of this matrix is not equal to the number of rows of the given matrix.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> columns = other.columns()</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span> </span><br><span class="line">      columns.map(<span class="function"><span class="params">column</span> =&gt;</span> sum(row.map(<span class="function">(<span class="params">element, i</span>) =&gt;</span> element * column[i])))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, <span class="number">-4</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">-3</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">-2</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">2</span>, <span class="number">-4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">-3</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(one.multiply(other))</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows:</span></span><br><span class="line"><span class="comment">//    [ [ -7, 18, -32 ],</span></span><br><span class="line"><span class="comment">//      [ -12, 9, -15 ],</span></span><br><span class="line"><span class="comment">//      [ 10, 18, -34 ],</span></span><br><span class="line"><span class="comment">//      [ 1, -5, 9 ] ]&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以把矩阵乘法 <strong>AB</strong> 视为先后应用 <strong>A</strong> 和 <strong>B</strong> 两个线性变换矩阵。为了更好地理解这种概念，可以看一看我们的 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a>。</p><p>下图中黄色的部分就是对红色方块应用线性变换 <strong>C</strong> 的结果。而线性变换 <strong>C</strong> 就是矩阵乘法 <strong>AB</strong> 的结果，其中 <strong>A</strong> 是做相对于 y 轴进行反射的变换矩阵，<strong>B</strong> 是做剪切变换的矩阵。</p><p><img src="https://lsvih.com/images/15615138080956.jpg" alt="先旋转再剪切变换"></p><p>如果在矩阵乘法中调换 <strong>A</strong> 和 <strong>B</strong> 的顺序，我们会得到一个不同的结果，因为相当于先应用了 <strong>B</strong> 的剪切变换，再应用 <strong>A</strong> 的反射变换：</p><p><img src="https://lsvih.com/images/15615138231502.jpg" alt="shear than rotate"></p><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><p><strong>转置</strong>矩阵 $A^T$ 由公式 $a^T_{ij}=a_{ji}$ 定义。换句话说，我们通过关于矩阵的对角线对其进行翻转来得到转置矩阵。需要注意的是，矩阵对角线上的元素不受转置运算影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  transpose() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...this.columns())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.transpose())</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows: [</span></span><br><span class="line"><span class="comment">//     [ 0, 3, 6, 9 ],</span></span><br><span class="line"><span class="comment">//     [ 1, 4, 7, 10 ],</span></span><br><span class="line"><span class="comment">//     [ 2, 5, 8, 11 ]</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="行列式运算"><a href="#行列式运算" class="headerlink" title="行列式运算"></a>行列式运算</h2><p>矩阵的<strong>行列式</strong>运算将计算矩阵中的所有系数，最后输出一个数字。准确地说，行列式可以描述一个由矩阵行构成的向量的相对几何指标（比如在欧式空间中的有向面积、体积等空间概念）。更准确地说，矩阵 <strong>A</strong> 的行列式相当于告诉你由 <strong>A</strong> 的行定义的方块的体积。$2\times 2$ 矩阵的行列式运算如下所示：</p><p><img src="https://lsvih.com/images/15615138461810.jpg" alt="det(2×2 matrix)"></p><p>$3\times 3$ 矩阵的行列式运算如下所示：</p><p><img src="https://lsvih.com/images/15615138625927.jpg" alt="det(3×3 matrix)"></p><p>我们的方法可以计算任意大小矩阵（只要其行列的数量相同）的行列式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  determinant() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows.length !== <span class="keyword">this</span>.rows[<span class="number">0</span>].length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Only matrices with the same number of rows and columns are supported.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows.length === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.rows[<span class="number">0</span>][<span class="number">0</span>] * <span class="keyword">this</span>.rows[<span class="number">1</span>][<span class="number">1</span>] - <span class="keyword">this</span>.rows[<span class="number">0</span>][<span class="number">1</span>] * <span class="keyword">this</span>.rows[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parts = <span class="keyword">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">coef, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matrixRows = <span class="keyword">this</span>.rows.slice(<span class="number">1</span>).map(<span class="function"><span class="params">row</span> =&gt;</span> [ ...row.slice(<span class="number">0</span>, index), ...row.slice(index + <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(...matrixRows)</span><br><span class="line">      <span class="keyword">const</span> result = coef * matrix.determinant()</span><br><span class="line">      <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span> ? result : -result</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(parts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix2 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix2.determinant())</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">const</span> matrix3 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, <span class="number">-3</span>,  <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,  <span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">  [<span class="number">1</span>,  <span class="number">4</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix3.determinant())</span><br><span class="line"><span class="comment">// 49</span></span><br><span class="line"><span class="keyword">const</span> matrix4 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-3</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>,  <span class="number">0</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix4.determinant())</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>行列式可以告诉我们变换时对象被拉伸的程度。因此我们可以将其视为一个线性变换对区域改变的一个因素。为了更好地理解这个概念，请参考 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a>：</p><p>在下图中，我们可以看到对红色的 <strong>1×1</strong> 方形进行线性变换后得到了一个 <strong>3×2</strong> 的长方形，面积从 <strong>1</strong> 变为了 <strong>6</strong>，这个数字与线性变换矩阵的行列式值相同。</p><p><img src="https://lsvih.com/images/15615138875261.jpg" alt="det(scale transformation)"></p><p>如果我们应用一个剪切变换，可以看到方形会变成一个面积不变的平行四边形。因此，剪切变换矩阵的行列式值等于 1：</p><p><img src="https://lsvih.com/images/15615139063445.jpg" alt="det(shear transformation)"></p><p>如果行列式的值是<strong>负数</strong>，则说明应用线性变换后，空间被反转了。比如在下图中，我们可以看到变换前 $\hat{\jmath}$ 在 $\hat{\imath}$ 的左边，而变换后 $\hat{\jmath}$ 在 $\hat{\imath}$ 的右边。</p><p><img src="https://lsvih.com/images/15615139284033.jpg" alt="negative determinant"></p><p>如果变换的行列式为 <strong>0</strong>，则表示它会将所有空间都压缩到一条线或一个点上。也就是说，计算一个给定矩阵的行列式是否为 0，可以判断这个矩阵对应的线性变换是否会将对象压缩到更小的维度去。</p><p><img src="https://lsvih.com/images/15615139536351.jpg" alt="2D 中的 0 行列式"></p><p>在三维空间里，行列式可以告诉你体积缩放了多少：</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a7937595f61716c476f2d4a31356877776c374e6766512e676966.gif" alt="det(scale transformation) in 3D"></p><p>变换行列式等于 0，意味着原来的空间会被完全压缩成体积为 0 的空间。如前文所说，如果在 2 维空间中变换的行列式为 0，则意味着变换的结果将空间压缩成了一条线或一个点；而在 3 维空间中变换的行列式为 0 意味着一个物体会被压扁成一个平面，如下图所示：</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a4b396f324f7268746671574f324e4e6f34684b354e412e676966.gif" alt="3D 中的 0 行列式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
      <category term="Matrix" scheme="https://lsvih.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/</id>
    <published>2019-06-26T01:04:00.000Z</published>
    <updated>2019-06-26T02:07:41.326Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我完成了一篇关于使用 JavaScript 进行线性变换的文章，并用 <strong>SVG</strong> 网格实现了 2D 的示例。你可以在<a href="https://juejin.im/post/5cefbc37f265da1bd260d129" target="_blank" rel="noopener">此处</a>查看之前的文章。但是，那篇文章没有三维空间的示例，因此本文将补全那篇文章的缺失。你可以在<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此处</a>查看本系列文章的 GitHub 仓库，与本文相关的 commit 可以在<a href="https://github.com/RodionChachura/linear-algebra/tree/6e9b5fe7f037ec12b115c915f33b58ce5e2e9c1f" target="_blank" rel="noopener">此处</a>查看。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本文中，我们将制作一个组件，用于对三维空间的对象的线性变换进行可视化。最终效果如下面的动图所示，或者你也可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此网页</a>体验。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323533322f312a42415a757839676e656956795a2d456a676b714565672e676966.gif" alt="applying different linear transformations on cube"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当我们要在浏览器中制作 3D 动画时，第一个想到的当然就是 <a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a> 库啦。所以让我们来安装它以及另一个可以让用户移动摄像机的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save three three-orbitcontrols</span><br></pre></td></tr></table></figure><p>下面构建一个组件，它可以由父组件的属性中接收矩阵，并且渲染一个立方体的转换动画。下面代码展示了这个组件的结构。我们用 <strong>styled-components</strong> 和 <strong>react-sizeme</strong> 库中的函数对这个组件进行了包装，以访问颜色主题和检测组件尺寸的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">'react-sizeme'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;&#125;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedScene = withTheme(withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(ThreeScene))</span><br></pre></td></tr></table></figure><p>在<strong>构造函数</strong>中，我们对状态进行了初始化，其中包括了视图的大小。因此，我们当接收新的状态值时，可以在 <strong>componentWillReceiveProps</strong> 方法中与初始状态进行对比。由于需要访问实际的 <strong>DOM</strong> 元素以注入 <strong>ThreeJS</strong> 的 <strong>renderer</strong>，因此需要在 <strong>render</strong> 方法中用到 <strong>ref</strong> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      width: <span class="number">0</span>,</span><br><span class="line">      height: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">ref</span>=<span class="string">&#123;el</span> =&gt;</span> (this.view = el)&#125; /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // ...</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <strong>componentDidMount</strong> 方法中，我们对方块变换动画所需要的所有东西都进行了初始化。首先，我们创建了 ThreeJS 的场景（scene）并确定好摄像机（camera）的位置，然后我们创建了 ThreeJS 的 <strong>renderer</strong>，为它设置好了颜色及大小，最后将 <strong>renderer</strong> 加入到 <strong>View</strong> 组件中。</p><p>接下来创建需要进行渲染的对象：坐标轴、方块以及方块的边。由于我们需要手动改变矩阵，因此将方块和边的 <strong>matrixAutoUpdate</strong> 属性设为 false。创建好这些对象后，将它们加入场景（scene）中。为了让用户可以通过鼠标来移动摄像机位置，我们还用到了 <strong>OrbitControls</strong>。</p><p>最后要做的，就是将我们的库输出的矩阵转换成 <strong>ThreeJS</strong> 的格式，然后获取根据时间返回颜色和转换矩阵的函数。在 <strong>componentWillUnmount</strong>，取消动画（即停止 anime frame）并从 <strong>DOM</strong> 移除 <strong>renderer</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      size: &#123; width, height &#125;,</span><br><span class="line">      matrix,</span><br><span class="line">      theme</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">    <span class="keyword">this</span>.scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line">    <span class="keyword">this</span>.camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">100</span>, width / height)</span><br><span class="line">    <span class="keyword">this</span>.camera.position.set(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.renderer.setClearColor(theme.color.background)</span><br><span class="line">    <span class="keyword">this</span>.renderer.setSize(width, height)</span><br><span class="line">    <span class="keyword">this</span>.view.appendChild(<span class="keyword">this</span>.renderer.domElement)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> initialColor = theme.color.red</span><br><span class="line">    <span class="keyword">const</span> axes = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">this</span>.segments = <span class="keyword">new</span> THREE.LineSegments(</span><br><span class="line">      <span class="keyword">new</span> THREE.EdgesGeometry(geometry),</span><br><span class="line">      <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: theme.color.mainText &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.cube = <span class="keyword">new</span> THREE.Mesh(</span><br><span class="line">      geometry,</span><br><span class="line">      <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: initialColor &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.objects = [<span class="keyword">this</span>.cube, <span class="keyword">this</span>.segments]</span><br><span class="line">    <span class="keyword">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.matrixAutoUpdate = <span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">this</span>.scene.add(<span class="keyword">this</span>.cube, axes, <span class="keyword">this</span>.segments)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.controls = <span class="keyword">new</span> OrbitControls(<span class="keyword">this</span>.camera)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getAnimatedColor = getGetAnimatedColor(</span><br><span class="line">      initialColor,</span><br><span class="line">      theme.color.blue,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> fromMatrix = fromMatrix4(<span class="keyword">this</span>.cube.matrix)</span><br><span class="line">    <span class="keyword">const</span> toMatrix = matrix.toDimension(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">this</span>.getAnimatedTransformation = getGetAnimatedTransformation(</span><br><span class="line">      fromMatrix,</span><br><span class="line">      toMatrix,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.frameId = requestAnimationFrame(<span class="keyword">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    cancelAnimationFrame(<span class="keyword">this</span>.frameId)</span><br><span class="line">    <span class="keyword">this</span>.view.removeChild(<span class="keyword">this</span>.renderer.domElement)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过此时我们还没有定义 <strong>animate</strong> 函数，因此什么也不会渲染。首先，我们更新立方体及其边缘的转换矩阵，并且更新立方体的颜色，然后进行渲染并且调用 <code>window.requestAnimationFrame</code>。</p><p><strong>componentWillReceiveProps</strong> 方法将接收当前组件的大小，当它检测到组件尺寸发生了变化时，会更新状态，改变 renderer 的尺寸，并调整 camera 的方位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transformation = <span class="keyword">this</span>.getAnimatedTransformation()</span><br><span class="line">    <span class="keyword">const</span> matrix4 = toMatrix4(transformation)</span><br><span class="line">    <span class="keyword">this</span>.cube.material.color.set(<span class="keyword">this</span>.getAnimatedColor())</span><br><span class="line">    <span class="keyword">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> obj.matrix.set(...matrix4.toArray()))</span><br><span class="line">    <span class="keyword">this</span>.renderer.render(<span class="keyword">this</span>.scene, <span class="keyword">this</span>.camera)</span><br><span class="line">    <span class="keyword">this</span>.frameId = <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.width !== width || <span class="keyword">this</span>.state.height !== height) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">      <span class="keyword">this</span>.renderer.setSize(width, height)</span><br><span class="line">      <span class="keyword">this</span>.camera.aspect = width / height</span><br><span class="line">      <span class="keyword">this</span>.camera.updateProjectionMatrix()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>为了将颜色变化以及矩阵变换做成动画，需要写个函数来返回动画函数。在写这块函数前，我们先要完成以下两种转换器：将我们库的矩阵转换为 <strong>ThreeJS</strong> 格式矩阵的函数，以及参考 StackOverflow 上代码的将 RGB 转换为 hex 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/matrix'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/matrix'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>首先，需要计算每种原色（RGB）变化的幅度。第一次调用 <strong>getGetAnimatedColor</strong> 时会返回新的色彩与时间戳的集合；并在后续被调用时，通过颜色变化的距离以及时间的耗费，可以计算出当前时刻新的 <strong>RGB</strong> 颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hexToRgb, rgbToHex &#125; <span class="keyword">from</span> <span class="string">'./generic'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedColor = <span class="function">(<span class="params">fromColor, toColor, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fromRgb = hexToRgb(fromColor)</span><br><span class="line">  <span class="keyword">const</span> toRgb = hexToRgb(toColor)</span><br><span class="line">  <span class="keyword">const</span> distances = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toPart = toRgb[index]</span><br><span class="line">    <span class="keyword">return</span> fromPart &lt;= toPart ? toPart - fromPart : <span class="number">255</span> - fromPart + toPart</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toColor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> rgb = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances[index]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round((fromPart + step) % <span class="number">255</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> rgbToHex(...rgb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>为了给线性变换做出动画效果，同样要进行上节的操作。我们首先找到矩阵变换前后的区别，然后在动画函数中，根据第一次调用 <strong>getGetAnimatedTransformation</strong> 时的状态，根据时间来更新各个组件的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedTransformation = <span class="function">(<span class="params">fromMatrix, toMatrix, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> distances = toMatrix.subtract(fromMatrix)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toMatrix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> newMatrix = fromMatrix.map(<span class="function">(<span class="params">fromComponent, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances.rows[i][j]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> fromComponent + step</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newMatrix</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：线性变换与矩阵</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/</id>
    <published>2019-06-26T01:03:00.000Z</published>
    <updated>2019-06-26T02:08:06.143Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>矩阵</strong>是一种由 <strong>m</strong> 行 <strong>n</strong> 列实数组成的“矩形”数组。比如，一个 <strong>3x2</strong> 的矩阵如下所示：</p><p><img src="https://lsvih.com/images/15615130636391.jpg" alt="**3×2** 矩阵"></p><p><strong>Matrix</strong> 类的构造器（constructor）接收若干行元素作为参数。我们可以通过指定行号取出矩阵中的一行，然后再通过指定列号取出一个特定的元素。下面直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix)</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// [ 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="矩阵与向量的乘积"><a href="#矩阵与向量的乘积" class="headerlink" title="矩阵与向量的乘积"></a>矩阵与向量的乘积</h2><p><strong>矩阵与向量的乘法</strong> —— $A\vec{x}$ 会将矩阵 $A$ 的列进行系数为 $\vec{x}$ 的线性组合。比如，一个 $3\times 2$ 的矩阵 A 与一个 <strong>2D</strong> 向量 <strong>x⃗</strong> 的乘积将得到一个 <strong>3D</strong> 向量，这个计算记为：$\vec{y} : \vec{y} = A\vec{x}$。</p><p><img src="https://lsvih.com/images/15615131095284.jpg" alt=""></p><p>假设有一组向量 ${\vec{e}_1,\vec{e}_2}$，另一个向量 $\vec{y}$ 是 $\vec{e}_1$ 和 $\vec{e}_2$ 的<strong>线性组合</strong>：$\vec{y} = \alpha\vec{e}_1 + \beta \vec{e}_2$。其中，$\alpha, \beta \in \mathbb{R}$ 就是这个线性组合的系数。</p><p>为了更好地学习线性组合，我们特地为此定义了矩阵向量乘法。我们可以将前面所说的线性组合记为以下矩阵向量乘法的形式：$\vec{y} = E \vec{x}$。矩阵 $E$ 有 $\vec{e}_1$、$\vec{e}_2$ 两列。矩阵的维数是 $n \times 2$，其中 $n$ 是向量 $\vec{e}_1$、$\vec{e}_2$ 与 $\vec{y}$ 的维数。</p><p>下图展示了将向量 $\vec{v}$ 表示为向量 $\vec{\imath}$ 和向量 $\vec{\jmath}$ 的线性组合：</p><p><img src="https://lsvih.com/images/15615131638823.jpg" alt="线性组合"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> j = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> firstCoeff = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> secondCoeff = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> linearCombination = i.scaleBy(firstCoeff).add(j.scaleBy(secondCoeff))</span><br><span class="line"><span class="built_in">console</span>.log(linearCombination)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 5 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>矩阵与向量的乘法是<strong>线性变换</strong>的抽象概念，这是学习线性代数中的关键概念之一。向量与矩阵的乘法可以视为对向量进行线性变换：将 n 维向量作为输入，并输出 m 维向量。也可以说，矩阵是定义好的某种空间变换。</p><p>我们可以通过一个示例来更清楚地理解线性变换。首先需要给 Matrix 类加上一个方法，用于返回矩阵的列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">  columns() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">r</span> =&gt;</span> r[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.columns())</span><br><span class="line"><span class="comment">// [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]</span></span><br></pre></td></tr></table></figure><p>乘法得到的向量的维数将与矩阵的行数相同。如果我们将一个 <strong>2D</strong> 向量和一个 <strong>3x2</strong> 矩阵相乘，将得到一个 <strong>3D</strong> 的向量；如果将一个 <strong>3D</strong> 向量和一个 <strong>2x3</strong> 矩阵相乘，将得到一个 <strong>2D</strong> 的向量；如果在做乘法时，矩阵的列数和向量的维数不相同，将报错。在下面的代码中，你可以看到几种不同的向量与矩阵相乘的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, value</span>) =&gt;</span> acc + value, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  transform(matrix) &#123;</span><br><span class="line">    <span class="keyword">const</span> columns = matrix.columns()</span><br><span class="line">    <span class="keyword">if</span>(columns.length !== <span class="keyword">this</span>.components.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Matrix columns length should be equal to vector components length.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> multiplied = columns</span><br><span class="line">      .map(<span class="function">(<span class="params">column, i</span>) =&gt;</span> column.map(<span class="function"><span class="params">c</span> =&gt;</span> c * <span class="keyword">this</span>.components[i]))</span><br><span class="line">    <span class="keyword">const</span> newComponents = multiplied[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> sum(multiplied.map(<span class="function"><span class="params">column</span> =&gt;</span> column[i])))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(...newComponents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector2D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> vector3D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> matrix2x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix2x3D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix3x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector3D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 19, 49 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 3D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix3x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29, 45 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Error: Matrix columns length should be equal to vector components length.</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在，我们将尝试对二维的对象应用线性变换。首先，需要创建一个新的 <strong>Contour</strong>（轮廓）类，它在 constructor 中接收一系列的向量（在 2D 平面中形成一个轮廓），然后用唯一的方法 —— <strong>transform</strong> 对轮廓中的所有向量坐标进行变换，最后返回一个新的轮廓。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contour</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vectors) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vectors = vectors</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transform(matrix) &#123;</span><br><span class="line">    <span class="keyword">const</span> newVectors = <span class="keyword">this</span>.vectors.map(<span class="function"><span class="params">v</span> =&gt;</span> v.transform(matrix))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contour(newVectors)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contour = <span class="keyword">new</span> Contour([</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在，请在 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a> 项目中试试各种转换矩阵。红色方块是初始化的轮廓，蓝色形状是应用变换矩阵后的轮廓。</p><p><img src="https://lsvih.com/images/15615132290264.jpg" alt="镜像"></p><p><img src="https://lsvih.com/images/15615132414178.jpg" alt="缩放"></p><p>通过下面的方式，我们可以构建一个矩阵，用于将给定的向量旋转指定的角度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> angle = toRadians(<span class="number">45</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="built_in">Math</span>.cos(angle), -<span class="built_in">Math</span>.sin(angle)],</span><br><span class="line">  [<span class="built_in">Math</span>.sin(angle), <span class="built_in">Math</span>.cos(angle)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/15615132769006.jpg" alt="旋转"></p><p><img src="https://lsvih.com/images/15615133004176.jpg" alt="剪切变换"></p><p>对 3D 空间内的对象进行变换也与此类似。你可以在下图中看到一个红色方块变换成一个蓝色的平行六边形的动画。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323433322f312a7a6f5472705f6c6d3170324851436c6b614f644d4f512e676966.gif" alt="3D 剪切变换"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：向量</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/</id>
    <published>2019-06-26T01:01:00.000Z</published>
    <updated>2019-06-26T02:08:28.243Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>向量</strong>是用于精确表示空间中方向的方法。向量由一系列数值构成，每维数值都是向量的一个<strong>分量</strong>。在下图中，你可以看到一个由两个分量组成的、在 2 维空间内的向量。在 3 维空间内，向量会由 3 个分量组成。</p><p><img src="https://lsvih.com/images/15615124754701.jpg" alt="the vector in 2D space"></p><p>我们可以为 2 维空间的向量创建一个 <strong>Vector2D</strong> 类，然后为 3 维空间的向量创建一个 <strong>Vector3D</strong> 类。但是这么做有一个问题：向量并不仅用于表示物理空间中的方向。比如，我们可能需要将颜色（RGBA）表示为向量，那么它会有 4 个分量：红色、绿色、蓝色和 alpha 通道。或者，我们要用向量来表示有不同占比的 <strong>n</strong> 种选择（比如表示 5 匹马赛马，每匹马赢得比赛的概率的向量）。因此，我们会创建一个不指定维度的类，并像这样使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> direction2d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> direction3d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> Vector(<span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="keyword">const</span> probabilities = <span class="keyword">new</span> Vector(<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>考虑有两个向量的情况，可以对它们定义以下运算：</p><p><img src="https://lsvih.com/images/15615124998598.jpg" alt="basic vector operations"></p><p>其中，<strong>α ∈ R</strong> 为任意常数。</p><p>我们对除了叉积之外的运算进行了可视化，你可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此处</a>找到相关示例。<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此 GitHub 仓库</a>里有用来创建这些可视化示例的 React 项目和相关的库。如果你想知道如何使用 React 和 SVG 来制作这些二维可视化示例，请参考<a href="https://juejin.im/post/5cefbc37f265da1bd260d129" target="_blank" rel="noopener">本文</a>。</p><h3 id="加法与减法"><a href="#加法与减法" class="headerlink" title="加法与减法"></a>加法与减法</h3><p>与数值运算类似，你可以对向量进行加法与减法运算。对向量进行算术运算时，可以直接对向量各自的分量进行数值运算得到结果：</p><p><img src="https://lsvih.com/images/15615125322484.jpg" alt="vectors addition"></p><p><img src="https://lsvih.com/images/15615125380537.jpg" alt="vectors subtraction"></p><p>加法函数接收另一个向量作为参数，并将对应的向量分量相加，返回得出的新向量。减法函数与之类似，不过会将加法换成减法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="keyword">this</span>.components[index] + component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  subtract(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="keyword">this</span>.components[index] - component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 4, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(one.subtract(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们可以对一个向量进行缩放，缩放比例可为任意数值 <strong>α ∈ R</strong>。缩放时，对所有向量分量都乘以缩放因子 <strong>α</strong>。当 <strong>α &gt; 1</strong> 时，向量会变得更长；当 <strong>0 ≤ α \&lt; 1</strong> 时，向量会变得更短。如果 <strong>α</strong> 是负数，缩放后的向量将会指向原向量的反方向。</p><p><img src="https://lsvih.com/images/15615125690651.jpg" alt="scaling vector"></p><p>在 <strong>scaleBy</strong> 方法中，我们对所有的向量分量都乘上传入参数的数值，得到新的向量并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  scaleBy(number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...this.components.map(<span class="function"><span class="params">component</span> =&gt;</span> component * number)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.5, 1 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">-1</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -1, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>向量长度可由勾股定理导出：</p><p><img src="https://lsvih.com/images/15615125935367.jpg" alt="vectors length"></p><p>由于在 JavaScript 内置的 Math 对象中有现成的函数，因此计算长度的方法非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  length() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(...this.components)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br></pre></td></tr></table></figure><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。两个向量的点积等于它们各自对应分量的乘积之和。</p><p><img src="https://lsvih.com/images/15615126207640.jpg" alt="dot product"></p><p>在 <strong>dotProduct</strong> 方法中，接收另一个向量作为参数，通过 reduce 方法来计算对应分量的乘积之和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  dotProduct(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.reduce(<span class="function">(<span class="params">acc, component, index</span>) =&gt;</span> acc + component * <span class="keyword">this</span>.components[index], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.dotProduct(other))</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法。这种归一化后的向量在许多情景中都会用到。比如说当我们需要在空间中指定一个方向时，就需要用一个归一化后的向量来表示这个方向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  normalize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scaleBy(<span class="number">1</span> / <span class="keyword">this</span>.length())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> normalized = vector.normalize()</span><br><span class="line"><span class="built_in">console</span>.log(normalized)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.4472135954999579, 0.8944271909999159 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(normalized.length())</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/15615126527250.jpg" alt="using dot product"></p><p>如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。我们创建了 <strong>areEqual</strong> 函数用来比较两个浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EPSILON = <span class="number">0.00000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> areEqual = <span class="function">(<span class="params">one, other, epsilon = EPSILON</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Math</span>.abs(one - other) &lt; epsilon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  haveSameDirectionWith(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveSameDirectionWith(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量点积结果等于 -1，则表示它们的方向完全相反：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  haveOppositeDirectionTo(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">-4</span>, <span class="number">-8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveOppositeDirectionTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量的点积结果为 0，则表示这两个向量是相互垂直的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  isPerpendicularTo(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">-2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.isPerpendicularTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量：</p><p><img src="https://lsvih.com/images/15615126731739.jpg" alt=""></p><p>我们实现叉积时，假定它只用于计算三维空间内的向量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只适用于 3 维向量</span></span><br><span class="line">  crossProduct(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      <span class="keyword">this</span>.components[<span class="number">1</span>] * components[<span class="number">2</span>] - <span class="keyword">this</span>.components[<span class="number">2</span>] * components[<span class="number">1</span>],</span><br><span class="line">      <span class="keyword">this</span>.components[<span class="number">2</span>] * components[<span class="number">0</span>] - <span class="keyword">this</span>.components[<span class="number">0</span>] * components[<span class="number">2</span>],</span><br><span class="line">      <span class="keyword">this</span>.components[<span class="number">0</span>] * components[<span class="number">1</span>] - <span class="keyword">this</span>.components[<span class="number">1</span>] * components[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.crossProduct(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, -3, 3 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.crossProduct(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 3, -3 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h2><p>在现实生活的应用中，上述方法是远远不够的。比如说，我们有时需要找到两个向量的夹角、将一个向量反向，或者计算一个向量在另一个向量上的投影等。</p><p>在开始编写上面说的方法前，需要先写下面两个函数，用于在角度与弧度间相互转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toDegrees = <span class="function"><span class="params">radians</span> =&gt;</span> (radians * <span class="number">180</span>) / <span class="built_in">Math</span>.PI</span><br><span class="line"><span class="keyword">const</span> toRadians = <span class="function"><span class="params">degrees</span> =&gt;</span> (degrees * <span class="built_in">Math</span>.PI) / <span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  angleBetween(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> toDegrees(</span><br><span class="line">      <span class="built_in">Math</span>.acos(</span><br><span class="line">        <span class="keyword">this</span>.dotProduct(other) /</span><br><span class="line">        (<span class="keyword">this</span>.length() * other.length())</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.angleBetween(other))</span><br><span class="line"><span class="comment">// 45.00000000000001</span></span><br></pre></td></tr></table></figure><h3 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h3><p>当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  negate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scaleBy(<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.negate())</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -2, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p><img src="https://lsvih.com/images/15615126897492.jpg" alt="project v on d"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  projectOn(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> normalized = other.normalize()</span><br><span class="line">    <span class="keyword">return</span> normalized.scaleBy(<span class="keyword">this</span>.dotProduct(normalized))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(other.projectOn(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 6, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="设定长度"><a href="#设定长度" class="headerlink" title="设定长度"></a>设定长度</h3><p>当需要给向量指定一个长度时，可以使用如下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  withLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.normalize().scaleBy(newLength)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br><span class="line"><span class="keyword">const</span> modified = one.withLength(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(modified.length())</span><br></pre></td></tr></table></figure><h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p>为了判断两个向量是否相等，可以对它们对应的分量使用  <strong>areEqual</strong> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="keyword">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  equalTo(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.every(<span class="function">(<span class="params">component, index</span>) =&gt;</span> areEqual(component, <span class="keyword">this</span>.components[index]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(another))</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="单位向量与基底"><a href="#单位向量与基底" class="headerlink" title="单位向量与基底"></a>单位向量与基底</h2><p>我们可以将一个向量看做是“在 x 轴上走 $v_x$ 的距离、在 y 轴上走 $v_y$ 的距离、在 z 轴上走 $v_z$ 的距离”。我们可以使用 $\hat { \imath }$ 、$\hat { \jmath }$ 和 $\hat { k }$ 分别乘上一个值更清晰地表示上述内容。下图分别是 $x$、$y$、$z$ 轴上的<strong>单位向量</strong>：</p><script type="math/tex; mode=display">\hat { \imath } = ( 1,0,0 ) \quad \hat { \jmath } = ( 0,1,0 ) \quad \hat { k } = ( 0,0,1 )</script><p>任何数值乘以 $\hat { \imath }$ 向量，都可以得到一个第一维分量等于该数值的向量。例如：</p><script type="math/tex; mode=display">2 \hat { \imath } = ( 2,0,0 ) \quad 3 \hat { \jmath } = ( 0,3,0 ) \quad 5 \hat { K } = ( 0,0,5 )</script><p>向量中最重要的一个概念是<strong>基底</strong>。设有一个 3 维向量 $\mathbb{R}^3$，它的基底是一组向量：${\hat{e}_1,\hat{e}_2,\hat{e}_3}$，这组向量也可以作为 $\mathbb{R}^3$ 的坐标系统。如果 ${\hat{e}_1,\hat{e}_2,\hat{e}_3}$ 是一组基底，则可以将任何向量 $\vec{v} \in \mathbb{R}^3$ 表示为该基底的系数 $(v_1,v_2,v_3)$：</p><script type="math/tex; mode=display">\vec{v} = v_1 \hat{e}_1 + v_2 \hat{e}_2 + v_3 \hat{e}_3</script><p>向量 $\vec{v}$ 是通过在 $\hat{e}_1$ 方向上测量 $v_2$ 的距离、在 $\hat{e}_2$ 方向上测量 $v_1$ 的距离、在 $\hat{e}_3$ 方向上测量 $v_3$ 的距离得出的。</p><p>在不知道一个向量的基底前，向量的系数三元组并没有什么意义。只有知道向量的基底，才能将类似于 $(a,b,c)$ 三元组的数学对象转化为现实世界中的概念（比如颜色、概率、位置等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>用 React 制作线性代数教程示例：网格与箭头</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/</id>
    <published>2019-06-26T01:00:00.000Z</published>
    <updated>2019-06-26T02:08:16.948Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我撰写了这个线性代数系列的<a href="https://medium.com/@geekrodion/linear-algebra-vectors-f7610e9a0f23" target="_blank" rel="noopener">开篇之作</a>。在新篇开始动笔前，我有了一个想法：使用 React 开发一个项目，来为这个系列的所有示例提供可视化功能一定很好玩！本系列的所有代码都存放于<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此 GitHub 仓库</a>，本文相关代码的提交记录位于<a href="https://github.com/RodionChachura/linear-algebra/tree/813cfecfda70cb3a9415c21ead97e09242e08f49" target="_blank" rel="noopener">此处</a>。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本系列刚开始写作时，只有一个章节涉及了向量的基本运算。所以，目前实现一个能渲染二维坐标网格以及能将向量可视化为箭头的组件就够用了。本文最后做出的效果如下图所示，你也可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此处</a>进行体验。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f333833302f312a3338743653416c5363676d42476a58516e39635475412e676966.gif" alt="二维空间中的基本向量运算"></p><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>其实已经有关于创建 React 项目的最佳实践指南文章可供参考，不过在本文中，我们将尽可能减少依赖的库，并简化对项目的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-react-app linear-algebra-demo</span><br><span class="line"><span class="built_in">cd</span> linear-algebra-demo</span><br><span class="line">npm install --save react-sizeme styled-components</span><br></pre></td></tr></table></figure><p>上面的脚本安装了两个库。第一个库 <code>react-sizeme</code> 可以实现当窗体大小发生变化时，重新渲染网格组件。第二个库 <code>styled-components</code> 则能让我们更轻松地编写组件的样式。此外，要用到我们正在开发的 <strong>linear-algebra</strong> 库，需要在 <strong>package.json</strong> 中进行如下引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;linear-algebra&quot;: &quot;file:../library&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://lsvih.com/images/15615123069092.jpg" alt="项目结构"></p><p>本系列为每个示例都在 <code>views</code> 目录中创建了各自的组件。我们在 <strong>index.js</strong> 中导出一个以示例名称为键、以对应组件为值的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorLength &#125; <span class="keyword">from</span> <span class="string">'./vector-length'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorScale &#125; <span class="keyword">from</span> <span class="string">'./vector-scale'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsAddition &#125; <span class="keyword">from</span> <span class="string">'./vectors-addition'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsSubtraction &#125; <span class="keyword">from</span> <span class="string">'./vectors-subtraction'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsDotProduct &#125; <span class="keyword">from</span> <span class="string">'./vectors-dot-product'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">'vectors: addition'</span>: VectorsAddition,</span><br><span class="line">  <span class="string">'vectors: subtraction'</span>: VectorsSubtraction,</span><br><span class="line">  <span class="string">'vectors: length'</span>: VectorLength,</span><br><span class="line">  <span class="string">'vectors: scale'</span>: VectorScale,</span><br><span class="line">  <span class="string">'vectors: dot product'</span>: VectorsDotProduct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>Main</code> 组件中导入该对象，并在菜单中展示出所有的键。当用户通过菜单选择示例后，更新组件状态，并渲染新的 <code>view</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> views <span class="keyword">from</span> <span class="string">'./views'</span></span><br><span class="line"><span class="keyword">import</span> MenuItem <span class="keyword">from</span> <span class="string">'./menu-item'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Menu = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      view: <span class="built_in">Object</span>.keys(views)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; view &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> View = views[view]</span><br><span class="line">    <span class="keyword">const</span> viewsNames = <span class="built_in">Object</span>.keys(views)</span><br><span class="line">    <span class="keyword">const</span> MenuItems = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      viewsNames.map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MenuItem</span><br><span class="line">          key=&#123;name&#125;</span><br><span class="line">          selected=&#123;name === view&#125;</span><br><span class="line">          text=&#123;name&#125;</span><br><span class="line">          onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">view</span>: name &#125;)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;View /&gt;</span><br><span class="line">        &lt;Menu&gt;</span><br><span class="line">          &lt;MenuItems /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Menu&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><h2 id="网格组件"><a href="#网格组件" class="headerlink" title="网格组件"></a>网格组件</h2><p>为了在之后的示例中渲染向量和其它内容，我们设计了一个功能强大的组件，这个组件需要有这么一种投影功能：将我们熟知的直角坐标系（原点在中间，y 轴正向朝上）投影到 <strong>SVG</strong> 坐标系（原点在左上角，y 轴正向朝下）中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.updateProject(<span class="function"><span class="params">vector</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 vector 类中没有任何用于缩放的方法，因此在这里进行计算：</span></span><br><span class="line">  <span class="keyword">const</span> scaled = vector.scaleBy(step)</span><br><span class="line">  <span class="keyword">const</span> withNegatedY = <span class="keyword">new</span> Vector(</span><br><span class="line">    scaled.components[<span class="number">0</span>],</span><br><span class="line">    -scaled.components[<span class="number">1</span>]</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> middle = getSide(size) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> withNegatedY.add(<span class="keyword">new</span> Vector(middle, middle))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了捕获到网格组件容器的大小变动，我们使用 <strong>react-size</strong> 库提供的函数将这个组件包装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">'react-sizeme'</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  updateProject = <span class="function">(<span class="params">size, cells</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> step = getStepLen(size, cells)</span><br><span class="line">    <span class="keyword">this</span>.props.updateProject(<span class="function"><span class="params">()</span> =&gt;</span> /...)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; size, cells &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="keyword">const</span> newStepLen = getStepLen(size, cells)</span><br><span class="line">      <span class="keyword">const</span> oldStepLen = getStepLen(<span class="keyword">this</span>.props.size, cells)</span><br><span class="line">      <span class="keyword">if</span> (newStepLen !== oldStepLen) &#123;</span><br><span class="line">        <span class="keyword">this</span>.updateProject(size, cells)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateProject(<span class="keyword">this</span>.props.size, <span class="keyword">this</span>.props.cells)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(Grid)</span><br></pre></td></tr></table></figure><p>为了便于在不同的示例中使用这个网格组件，我们编写了一个 <strong>GridExample</strong> 组件，它可以接收两个参数：一个用于渲染信息（例如向量的名称）的函数 <code>renderInformation</code>，以及一个用于在网格上呈现内容（如后面的箭头组件）的函数 <code>renderGridContent</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> Grid <span class="keyword">from</span> <span class="string">'./grid'</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      project: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; project &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123; renderInformation, renderGridContent &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> Content = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (project &amp;&amp; renderGridContent) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderGridContent(&#123; project &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Information = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (renderInformation) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderInformation()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Grid cells=&#123;<span class="number">10</span>&#125; updateProject=&#123;project =&gt; <span class="keyword">this</span>.setState(&#123; project &#125;)&#125;&gt;</span><br><span class="line">          &lt;Content /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Grid&gt;</span></span><br><span class="line"><span class="regexp">        &lt;InfoContainer&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Information /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/InfoContainer&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><p>这样就能在 view 中使用这个组件了。下面以向量的加法为例测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/vector'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GridExample <span class="keyword">from</span> <span class="string">'../grid-example'</span></span><br><span class="line"><span class="keyword">import</span> Arrow <span class="keyword">from</span> <span class="string">'../arrow'</span></span><br><span class="line"><span class="keyword">import</span> VectorView <span class="keyword">from</span> <span class="string">'../vector'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VectorsAddition = <span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> oneName = <span class="string">'v⃗'</span></span><br><span class="line">  <span class="keyword">const</span> otherName = <span class="string">'w⃗'</span></span><br><span class="line">  <span class="keyword">const</span> oneColor = theme.color.green</span><br><span class="line">  <span class="keyword">const</span> otherColor = theme.color.red</span><br><span class="line">  <span class="keyword">const</span> sum = one.add(other)</span><br><span class="line">  <span class="keyword">const</span> sumColor = theme.color.blue</span><br><span class="line">  <span class="keyword">const</span> sumText = <span class="string">`<span class="subst">$&#123;oneName&#125;</span> + <span class="subst">$&#123;otherName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> renderInformation = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;VectorView components=&#123;one.components&#125; name=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span><br><span class="line">      &lt;VectorView</span><br><span class="line">        components=&#123;other.components&#125;</span><br><span class="line">        name=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;VectorView components=&#123;sum.components&#125; name=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  const renderGridContent = (&#123; project &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Arrow project=&#123;project&#125; vector=&#123;one&#125; text=&#123;oneName&#125; color=&#123;oneColor&#125; /</span>&gt;</span><br><span class="line">      &lt;Arrow</span><br><span class="line">        project=&#123;project&#125;</span><br><span class="line">        vector=&#123;other&#125;</span><br><span class="line">        text=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;sum&#125; text=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  const props = &#123; renderInformation, renderGridContent &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return &lt;GridExample &#123;...props&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTheme(VectorsAddition)</span><br></pre></td></tr></table></figure><h2 id="箭头组件"><a href="#箭头组件" class="headerlink" title="箭头组件"></a>箭头组件</h2><p>箭头组件由 3 个 <strong>SVG</strong> 元素组成：<strong>line</strong> 用于显示箭头的线、<strong>polygon</strong> 用于显示箭头的头、<strong>text</strong> 用于显示向量名称。此外，我们需要接收 <strong>project</strong> 函数，用于将箭头放在网格中正确的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/vector'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Arrow = styled.line<span class="string">`</span></span><br><span class="line"><span class="string">  stroke-width: 2px;</span></span><br><span class="line"><span class="string">  stroke: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Head = styled.polygon<span class="string">`</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Text = styled.text<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 24px;</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; vector, text, color, project &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> direction = vector.normalize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> headStart = direction.scaleBy(vector.length() - <span class="number">0.6</span>)</span><br><span class="line">  <span class="keyword">const</span> headSide = <span class="keyword">new</span> Vector(</span><br><span class="line">    direction.components[<span class="number">1</span>],</span><br><span class="line">    -direction.components[<span class="number">0</span>]</span><br><span class="line">  ).scaleBy(<span class="number">0.2</span>)</span><br><span class="line">  <span class="keyword">const</span> headPoints = [</span><br><span class="line">    headStart.add(headSide),</span><br><span class="line">    headStart.subtract(headSide),</span><br><span class="line">    vector</span><br><span class="line">  ]</span><br><span class="line">    .map(project)</span><br><span class="line">    .map(<span class="function"><span class="params">v</span> =&gt;</span> v.components)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> projectedStart = project(<span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">const</span> projectedEnd = project(vector)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PositionedText = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!text) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> &#123; components &#125; = project(vector.withLength(vector.length() + <span class="number">0.2</span>))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text color=&#123;color&#125; x=&#123;components[<span class="number">0</span>]&#125; y=&#123;components[<span class="number">1</span>]&#125;&gt;</span><br><span class="line">        &#123;text&#125;</span><br><span class="line">      &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;g&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Arrow</span></span><br><span class="line"><span class="regexp">        color=&#123;color&#125;</span></span><br><span class="line"><span class="regexp">        x1=&#123;projectedStart.components[0]&#125;</span></span><br><span class="line"><span class="regexp">        y1=&#123;projectedStart.components[1]&#125;</span></span><br><span class="line"><span class="regexp">        x2=&#123;projectedEnd.components[0]&#125;</span></span><br><span class="line"><span class="regexp">        y2=&#123;projectedEnd.components[1]&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;Head color=&#123;color&#125; points=&#123;headPoints&#125; /&gt;</span><br><span class="line">      &lt;PositionedText /&gt;</span><br><span class="line">    &lt;<span class="regexp">/g&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>通过结合 <strong>React</strong> 与 <strong>SVG</strong> 可以做更多有意思的事。在本系列的后面章节中，我们会给这个可视化示例添加更多的功能。最后推荐另一篇类似的文章：<a href="https://medium.com/@geekrodion/bar-chart-with-react-3b20b7907633" target="_blank" rel="noopener">使用 <strong>React</strong> 与 <strong>SVG</strong> 制作复杂的条形图</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>An Online Social Network-based Recommendation System 论文笔记</title>
    <link href="https://lsvih.com/2019/05/23/An%20Online%20Social%20Network-based%20Recommendation%20System/"/>
    <id>https://lsvih.com/2019/05/23/An Online Social Network-based Recommendation System/</id>
    <published>2019-05-23T14:48:00.000Z</published>
    <updated>2019-05-23T14:48:31.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作者提出了一种基于社会网络的推荐系统，这种推荐系统利用用户资料以及用户与用户之间的连接进行推荐（具体来说是通过用户的打分矩阵和对应的朋友关系来推荐）。</p><blockquote><p>本文的数据来源于一个名为 BoardGameGeek（BGG）的网站，在数据一节详细描述</p></blockquote><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p>所谓推荐系统，是一种基于用户以往数据、通过某些算法计算，向用户推送新内容的一种机制，在 20 世纪互联网经济发展中被广泛使用。最早利用推荐系统扩大利润的是电商 Amazon，他们利用用户曾经购买或评分的商品来预测用户之后可能会购买的商品并进行推送，从而促使用户购买更多的商品。</p><p>推荐系统最常用的方式就是基于内容的<strong>协同过滤</strong>方法（这种方式在今天也被广泛使用，好处是推荐较为准确，坏处是计算量极大），具体来说就是通过计算多个用户喜好的相似，来推荐对应的对象。</p><p>推荐系统研究的一个难点就是数据的获取，使用用户数据容易触及隐私问题，因此各个公司都是在利用用户的公开数据来进行推荐系统的研究。这又有另一个问题：很多用户的公开数据并不完全（比如获取不到用户间的联系），导致困难重重。此外，传统的算法的前提假设为用户是独立的存在，因此无法利用用户的结构信息来进行推荐。</p><p>作者通过对社会学和机器学习的研究，为 boardgaming 开发了一种 Online Social Network-based（OSN）推荐系统，实现了较好的推荐效果。</p><p>最后作者还对数据的隐私问题和算法的应用进行了讨论。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>BoardGameGeek（BGG）是一个知名的游戏站点，人们在其中讨论各种游戏机和卡带，并且会对各个游戏、主机等产品进行评价、打分。比较特殊的是，这个网站包含了大量的公开社交信息（玩家会公开加好友，并进行讨论），因此适合用来使用社会网络来构建推荐系统。</p><p>最终，作者使用的数据包括：</p><ul><li>大约 3 万条被用户评价过的游戏数据</li><li>大约 4 万条曾经评价过游戏的用户数据</li><li>所有的任意用户对任意游戏的评价数据</li><li>各个用户“愿望清单”的游戏列表</li><li>用户与用户之间的好友关系</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>作者使用了概率矩阵分解算法（probabilistic matrix factorization，简称 PMF 算法）。在此简单描述一下这个算法：</p><p>给定一个维数为 $M \times N$ 的评价矩阵 $R$，其中 $R_{ij}$ 可以表示用户 $i$ 对游戏 $j$ 的评价分数。而 PMF 算法的目的就是对评价矩阵 $R$ 进行矩阵分解，找到评价矩阵的因子：</p><script type="math/tex; mode=display">R \approx U G</script><p>其中 $U \in \mathcal { R } ^ { M \times D } $, $G \in \mathcal { R } ^ { D \times N }$。作者假设有一些“原型用户”（prototype user），这种用户具有评分和喜好的代表性。上式中的$D$就是这种“原型用户”的数量。因此上面的矩阵分解就能得出原型用户的评分矩阵。作者直接利用 FA、PCA 之类的矩阵分解算法，使用方差 $\left( \sum _ { i , j } R _ { i j } - U _ { i } ^ { T } G _ { j } \right) ^ { 2 }$ 作为损失函数，对矩阵分解算法进行优化。（注，这应该是非常稀疏的矩阵分析）</p><p>为了把社会网络的信息加入模型中，作者将社交信息定义为矩阵 $F$，其维数是 $M \times M$。在 $F$ 中，如果用户 $i$ 和 $j$ 是好友关系，则 $F_{ij} = 1$，否则为 0。由此，作者将前面的矩阵分析式子改写为：</p><script type="math/tex; mode=display">R \approx F U G</script><p>转换问题，写作：</p><script type="math/tex; mode=display">F^{-1} R \approx U G</script><p>这样就可以继续用前文的方法求出原型用户的评分了。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者使用 SE（方差）loss 对矩阵分解进行优化，在训练迭代过程中 loss 下降情况如下图所示：</p><p><img src="https://lsvih.com/images/15586229007735.jpg" alt="-w445"></p><p>可以看到算法确实收敛了。（个人觉得可能过拟合了）</p><p>这个实验因为没有标注数据，所以也不好进行评价。因此作者用少数的数据作为测试集来验证效果，发现结果不错，最后直接将这个 baseline 做成了一款 Web 应用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种同时利用社会网络信息和用户评分信息的推荐算法，改善了推荐系统的效果。其意义是找了一种方法来把简单的社会网络信息给整合进传统的评分矩阵分解法中。总体来说整个文章的方法非常简单，而且实验不够置信，但可以用来参考了解“基于社会网络的推荐系统”这一课题。</p><p>此外，这篇文献的年代其实比较久远，目前已经有各种各样利用 Network Embedding 的方法，利用各种异构网络信息去做推荐系统，但其实主要的方法还是这篇文章中的方法：将评分矩阵与网络表示矩阵进行合并，然后再做矩阵分析。区别是本文的 Social Network 的表示实质上就是最简单的 one-hot Network Embedding，如果换成现代先进的 node2vec、deep walk 之类的方法应该会有所提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="recommendation system" scheme="https://lsvih.com/tags/recommendation-system/"/>
    
      <category term="social network" scheme="https://lsvih.com/tags/social-network/"/>
    
  </entry>
  
  <entry>
    <title>使用 PyTorch 在 MNIST 数据集上进行逻辑回归</title>
    <link href="https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/"/>
    <id>https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/</id>
    <published>2019-04-29T04:02:00.000Z</published>
    <updated>2019-04-29T04:03:39.628Z</updated>
    
    <content type="html"><![CDATA[<p><strong>逻辑回归（Logistic Regression）</strong>既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了<strong>逻辑回归</strong>与<strong>线性回归</strong>的区别。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*xFhICZgdr2VEZQ-C4FLUEA.jpeg" alt="Taken from [https://www.sciencedirect.com/topics/nursing-and-health-professions/logistic-regression-analysis](https://www.sciencedirect.com/topics/nursing-and-health-professions/logistic-regression-analysis)"></p><p>本文将展示如何使用 PyTorch 编写逻辑回归模型。<br><a id="more"></a><br>我们将尝试在 MNIST 数据集上解决分类问题。首先，导入我们所需要的所有库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dsets</span><br></pre></td></tr></table></figure><p>在创建模型前，我喜欢列一个如下的步骤表。PyTorch 官网[2]上也有这个步骤列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：加载数据集</span></span><br><span class="line"><span class="comment"># 第二步：使数据集可迭代</span></span><br><span class="line"><span class="comment"># 第三步：创建模型类</span></span><br><span class="line"><span class="comment"># 第四步：将模型类实例化</span></span><br><span class="line"><span class="comment"># 第五步：实例化 Loss 类</span></span><br><span class="line"><span class="comment"># 第六步：实例化优化器类</span></span><br><span class="line"><span class="comment"># 第七步：训练模型</span></span><br></pre></td></tr></table></figure><p>下面我们将一步步完成上述的步骤。</p><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>我们使用 <strong>torchvision.datasets</strong> 来加载数据集。这个库中包含了几乎全部的用于机器学习的流行数据集。在[3]中可以看到完整的数据集列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = dsets.MNIST(root=<span class="string">'./data'</span>, train=<span class="keyword">True</span>, transform=transforms.ToTensor(), download=<span class="keyword">False</span>)</span><br><span class="line">test_dataset = dsets.MNIST(root=<span class="string">'./data'</span>, train=<span class="keyword">False</span>, transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><h3 id="使数据集可迭代"><a href="#使数据集可迭代" class="headerlink" title="使数据集可迭代"></a>使数据集可迭代</h3><p>我们利用 DataLoader 类，使用以下代码来让我们的数据集可被迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="keyword">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h3 id="创建模型类"><a href="#创建模型类" class="headerlink" title="创建模型类"></a>创建模型类</h3><p>现在，我们将创建一个用来定义逻辑回归模型结构的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim, output_dim)</span>:</span></span><br><span class="line">        super(LogisticRegression, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(input_dim, output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        outputs = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h3 id="将模型类实例化"><a href="#将模型类实例化" class="headerlink" title="将模型类实例化"></a>将模型类实例化</h3><p>在将模型类实例化之前，我们先初始化如下所示的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">n_iters = <span class="number">3000</span></span><br><span class="line">epochs = n_iters / (len(train_dataset) / batch_size)</span><br><span class="line">input_dim = <span class="number">784</span></span><br><span class="line">output_dim = <span class="number">10</span></span><br><span class="line">lr_rate = <span class="number">0.001</span></span><br></pre></td></tr></table></figure><p>然后，就能初始化我们的逻辑回归模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = LogisticRegression(input_dim, output_dim)</span><br></pre></td></tr></table></figure><h3 id="实例化-Loss-类"><a href="#实例化-Loss-类" class="headerlink" title="实例化 Loss 类"></a>实例化 Loss 类</h3><p>我们使用交叉熵损失来计算 loss：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.CrossEntropyLoss() <span class="comment"># 计算 softmax 分布之上的交叉熵损失</span></span><br></pre></td></tr></table></figure><h3 id="实例化优化器类"><a href="#实例化优化器类" class="headerlink" title="实例化优化器类"></a>实例化优化器类</h3><p>优化器（optimizer）就是我们即将使用的学习算法。在本例中，我们将使用随机梯度下降（SGD）作为优化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=lr_rate)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>这就是最后一步了。我们将用以下的代码来训练模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">iter = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(int(epochs)):</span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line">        labels = Variable(labels)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        iter+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> iter%<span class="number">500</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 计算准确率</span></span><br><span class="line">            correct = <span class="number">0</span></span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">                images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line">                outputs = model(images)</span><br><span class="line">                _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">                total+= labels.size(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 如果用的是 GPU，则要把预测值和标签都取回 CPU，才能用 Python 来计算</span></span><br><span class="line">                correct+= (predicted == labels).sum()</span><br><span class="line">            accuracy = <span class="number">100</span> * correct/total</span><br><span class="line">            print(<span class="string">"Iteration: &#123;&#125;. Loss: &#123;&#125;. Accuracy: &#123;&#125;."</span>.format(iter, loss.item(), accuracy))</span><br></pre></td></tr></table></figure><p>在训练时，这个模型只需要进行 3000 次迭代就能达到 <strong>82%</strong> 的准确率。你可以试着继续调整一下参数，看看还能不能把准确率再调高一点。</p><p>如果你想加深对在 PyTorch 中实现逻辑回归的理解，可以把上面的模型应用于任何分类问题。比如，你可以训练一个逻辑回归模型来对你最喜爱的<strong>漫威英雄</strong>的图像做个分类（有一半已经化灰了，所以做分类应该不是很难）:)</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] <a href="https://www.statisticssolutions.com/what-is-logistic-regression/" target="_blank" rel="noopener">https://www.statisticssolutions.com/what-is-logistic-regression/</a></p><p>[2] <a href="https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py" target="_blank" rel="noopener">https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py</a></p><p>[3] <a href="https://pytorch.org/docs/stable/torchvision/datasets.html" target="_blank" rel="noopener">https://pytorch.org/docs/stable/torchvision/datasets.html</a></p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5cc66d946fb9a032286173a7" target="_blank" rel="noopener">https://juejin.im/post/5cc66d946fb9a032286173a7</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;逻辑回归（Logistic Regression）&lt;/strong&gt;既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了&lt;strong&gt;逻辑回归&lt;/strong&gt;与&lt;strong&gt;线性回归&lt;/strong&gt;的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*xFhICZgdr2VEZQ-C4FLUEA.jpeg&quot; alt=&quot;Taken from [https://www.sciencedirect.com/topics/nursing-and-health-professions/logistic-regression-analysis](https://www.sciencedirect.com/topics/nursing-and-health-professions/logistic-regression-analysis)&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将展示如何使用 PyTorch 编写逻辑回归模型。&lt;br&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="pytorch" scheme="https://lsvih.com/tags/pytorch/"/>
    
      <category term="MNIST" scheme="https://lsvih.com/tags/MNIST/"/>
    
  </entry>
  
  <entry>
    <title>Robust Classification with Convolutional Prototype Learning 论文笔记</title>
    <link href="https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-论文笔记/</id>
    <published>2019-04-07T10:48:00.000Z</published>
    <updated>2019-04-08T01:36:59.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。<br>论文地址：<a href="https://arxiv.org/abs/1805.03438v1" target="_blank" rel="noopener">https://arxiv.org/abs/1805.03438v1</a><br>论文代码：<a href="https://github.com/YangHM/Convolutional-Prototype-Learning" target="_blank" rel="noopener">https://github.com/YangHM/Convolutional-Prototype-Learning</a></p></blockquote><p>这篇文章在原型学习（prototype learning）与 CNN 的基础之上，提出了一种有效的学习方式，并设计了几种不同的 loss 函数，这些损失函数均能从直观上理解其效果并在实验中证明它们的有效性。通过学习这篇文章，可以更好地了解原型学习以及 loss 的设计，同时可以直接将文中的方法用于一些下游应用。</p><p><strong>此外需要注意的是</strong>，这篇文章的“Robust classification”和 Goodfellow 提出的对抗样本型“Robust model”是两码事。这篇文章没有对模型对于对抗样本的 Robust 进行分析，但本文提出的方法学习到的分类器对于任务来说是 Robust 的。从文章的实验结果来看，将这篇文章提出的方法称为“Robust”一点也不为过，毕竟“Robust”又不是 Goodfellow 发明的，各人可以有自己的理解。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章主要按以下的框架描述了作者提出的方法：</p><ul><li>背景与相关工作</li><li>卷积原型学习（Convolutional prototype learning）</li><li>设计的各种 loss 函数</li><li>实验结果与分析</li></ul><p>因此，这篇笔记也按照论文作者的写作顺序记录。</p><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p><img src="https://lsvih.com/images/15546341569411.jpg" alt=""></p><p>文章开头就给了这张图，描述了传统的 CNN 模型 + cross entropy loss 在 MNIST 上训练出来的特征的二维表示。作者用此图片说明了传统 CNN 模型的问题：学习出来的分类特征在特征空间内非常集中，甚至有很多类内距离（intra-class）小于类间距离（inter-class）的情况。这种情况也就会导致最终的分类效果变差，并且分类模型不易拓展等不够“Robust”的问题。</p><blockquote><p>这个图片的具体作图方法，是把模型输出层前的最后隐层（bottleneck layer）设定为两个神经元，训练完成后，将样本送入神经网络，取出这两个神经元的输出，将输出分别设为 X 与 Y 轴，即得到了这张图。（这个方法可以用在别的需要可视化特征的场景中，可以免去 PCA 等降维步骤。不过在一些比较复杂的任务里貌似这么训练会很难收敛）</p></blockquote><p>尽管后来还有人为此做了各种改进，比如 triple loss、centre loss 等，来改善这种情况，但这些方法都没有离开 softmax + cross entropy 的范畴，也没有根本解决问题。因此作者基于原型学习的思想，利用 CNN 作为特征提取的工具，提出了一种原型学习框架 Convolutional prototype learning（后文直接记为 CPL），同时为它设计了几种模式的 loss 函数，在实验上取得了良好的效果。</p><blockquote><p>关于什么是原型学习，可以了解一下 LVQ 算法。</p></blockquote><h2 id="卷积原型学习"><a href="#卷积原型学习" class="headerlink" title="卷积原型学习"></a>卷积原型学习</h2><p><img src="https://lsvih.com/images/15546341698125.jpg" alt=""></p><p>如图所示。这个框架其实思路很简单：</p><ol><li>利用 CNN 进行特征提取：直接将 CNN 看做是一个 $f(x,\theta)$ 的函数，输入的 x 是数据，$\theta$ 是 CNN 的参数；输出的是特征。</li><li>用一个或多个原型来对应每一个分类（文章后来用实验证明了一个分类对应一个原型就可以有足够好的效果）。</li><li>在训练时，让原型与原型间的欧式距离尽量远，让特征与对应类别原型的欧式距离尽量近：</li></ol><script type="math/tex; mode=display">\begin{array} { l } { x \in \text { class arg } \max _ { i = 1 } ^ { C } g _ { i } ( x ) } \\ { g _ { i } ( x ) = - \min _ { j = 1 } \left\| f ( x ; \theta ) - m _ { i j } \right\| _ { 2 } ^ { 2 } } \end{array}</script><p>（上式中各符号代表的含义请参考原论文 3.1 与 3.2）</p><h2 id="loss-函数"><a href="#loss-函数" class="headerlink" title="loss 函数"></a>loss 函数</h2><p>这部分是文章的核心。为了实现上面一节说的 CPL，必须要有合适的 loss 函数，这种 loss 函数需要满足以下几个条件：</p><ol><li>符合 CPL 的思路，及让原型与原型间距离尽量远，让特征与对应原型的距离尽量近。</li><li>需要对 CNN 可导（这样才能通过 BP 算法去优化 CNN 的参数 $\theta$，也就才能让 CNN 提取出正确的特征）</li><li>需要对原型可导（这样才符合原型学习的思想，才能去不断调整原型在特征空间中的位置）</li></ol><p>因此，这篇文章设计的几个 loss 函数都会去证明 $\frac { \partial l } { \partial f }$ 与 $\frac { \partial l } { \partial M }$ 的可导性。（l 是 loss 函数，f 是 CNN 特征提取器，M 是原型集），笔记中就不再赘述。</p><p>下文将逐个说明论文提出的 loss 函数。</p><h3 id="Minimum-classification-error-loss-MCE"><a href="#Minimum-classification-error-loss-MCE" class="headerlink" title="Minimum classification error loss(MCE)"></a>Minimum classification error loss(MCE)</h3><p>MCE 即“最小分类误差”，是《Discriminative learning for minimum error classification》提出的一种经典的测量指标，主要公式如下：</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + \left[ \frac { 1 } { C - 1 } \sum _ { j \neq y } g _ { j } ( x ) ^ { \eta } \right] ^ { 1 / \eta }</script><p>作者在列这个公式的时候貌似忘了解释 $\eta$ 的作用了。查阅原文发现，这个指标可以用来控制考虑误分类的程度多少。当 $\eta$ 为正无穷的时候，上式等于</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + g _ { r } ( x )</script><p>其中 $g _ { r } ( x ) = \max _ { k \neq y } g _ { k } ( x )$，是“错的最离谱”的错分距离。因此可以将 MCE 记为</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = \left\| f ( x ) - m _ { y i } \right\| _ { 2 } ^ { 2 } - \left\| f ( x ) - m _ { r j } \right\| _ { 2 } ^ { 2 }</script><p>作者按照《Discriminative learning for minimum error classification》中的 Translated sigmoid 公式定义了这个方法最终的 loss 函数计算公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \frac { 1 } { 1 + e ^ { - \xi \mu _ { y } } }</script><p>综上，这个 loss 方法其实优化的是 MCE 指标，重点是作者将 $\mu_y$ 转换为了原型的形式，换句话就是说这个 loss 在优化时，除了会让 CNN 提取出正确的特征外，还会尽量让原型靠近正确的类的特征分布密集区域，远离错误的类的特征分布区域。通过这种方式，可以实现笔记最开头提到的目标。</p><h3 id="Margin-based-classification-loss-MCL"><a href="#Margin-based-classification-loss-MCL" class="headerlink" title="Margin based classification loss(MCL)"></a>Margin based classification loss(MCL)</h3><p>顾名思义，这个 loss 是“基于边距的分类 loss”。这个“margin”在 triple loss 等方法中其实都有用到。作者提出这个方法的思想就是“让一个样本的特征和对应分类的原型在特征空间中的距离，要小于和其它原型在特征空间内的距离”，通过这种思路，就能使得样本尽量不被误分类。按照这个思路，作者提出了公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) \right] _ { + }</script><p>这个公式中的 d 函数就是求样本和原型在特征空间中的欧式距离。整个 loss 用 $\left[ \right] _+$ 包含着，表示只取正值。因为如果样本距离正确分类的原型的距离已经满足要求时，loss 值应该为 0。</p><p>根据上式，作者进一步对这个 loss 进行完善，为它添加了 margin（作用和 triple loss、centre loss 的 margin 是一致的），让“样本离本类原型”的距离要比“样本离其它类原型”距离+margin要更小：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) + m \right] _ { + }</script><p>这样就能达成前文所说的目的。</p><p>作者在此基础上，又为 margin 的值做了进一步的改进。因为在上述 loss 中，margin 的值必须和“样本与原型的距离”值在同一个数量级上才能顺利进行优化。为此，作者稍作转换：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ \frac { d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) } { d \left( f ( x ) , m _ { y i } \right) + d \left( f ( x ) , m _ { r j } \right) } + m \right] _ { + }</script><p>这样，m 在 (0,1) 的范围内取值即可保证数量级的一致性。</p><h3 id="Distance-based-cross-entropy-loss-DCE"><a href="#Distance-based-cross-entropy-loss-DCE" class="headerlink" title="Distance based cross entropy loss(DCE)"></a>Distance based cross entropy loss(DCE)</h3><p> 这个 loss 函数是基于一个约等式：</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) \propto - \left\| f ( x ) - m _ { i j } \right\| _ { 2 } ^ { 2 }</script><p> 这个式子的意义是，可以用“样本距离原型的距离”来测度“样本属于一个原型类别的概率”。这样就能用 cross entropy 之类的方法对概率进行优化了。因此，需要用一个确切的值来把上式给写出来，同时满足：</p><ol><li>概率值是正数</li><li><p>所有概率（即一个样本属于各个原型的概率）的和需要为 1</p><p>为此，作者定义</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) = \frac { e ^ { - \gamma d \left( f ( x ) , m _ { i j } \right) } } { \sum _ { k = 1 } ^ { C } \sum _ { l = 1 } ^ { K } e ^ { - \gamma d \left( f ( x ) , m _ { k l } \right) } }</script><p>此时，样本属于一个分类的概率即为样本属于这个分类的各个原型的概率之和，即为：</p><script type="math/tex; mode=display">p ( y | x ) = \sum _ { j = 1 } ^ { K } p \left( x \in m _ { y j } | x \right)</script><p>应用 cross entropy，可以将最终的 loss 函数写出来：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = - \log p ( y | x )</script><p>这个 loss 相当于换了一个角度考虑，把距离换成了概率然后代入 cross entropy。</p></li></ol><h3 id="Generalized-CPL-with-prototype-loss-GCPL"><a href="#Generalized-CPL-with-prototype-loss-GCPL" class="headerlink" title="Generalized CPL with prototype loss(GCPL)"></a>Generalized CPL with prototype loss(GCPL)</h3><p>除了上述的 loss 之外，作者还提出了一种可以加入上述 loss 中的约束方法。作者给的理由是，由于 CPL 中的参数比较少（因为 CNN 的参数本来就不多），很容易过拟合，因此需要这么一个约束来防止 overfit 情况的发生：</p><script type="math/tex; mode=display">p l ( ( x , y ) ; \theta , M ) = \left\| f ( x ) - m _ { y j } \right\| _ { 2 } ^ { 2 }</script><p>这个式子的意义是，计算在特征空间内样本的位置与对应分类的原型（且为距离最近的一个原型）位置的距离。利用这个约束，可以将前文提到的几种 loss 记为：</p><script type="math/tex; mode=display">\operatorname { loss } ( ( x , y ) ; \theta , M ) = l ( ( x , y ) ; \theta , M ) + \lambda p l ( ( x , y ) ; \theta , M )</script><p>上式中的 $\lambda$ 作用是控制此约束的强硬程度。通过这个约束，可以让同类的原型间的距离更近，不同类的原型间的距离更远。与此同时，就能保证样本在特征空间中的类内距离更近，类间距离更远。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>基于以上方法，作者在 MNIST、CIFAR-10、OLHWDB 数据集上进行了实验。其中，OLHWDB 数据集是一个大规模的中文手写文字数据集，甚至比 ImageNet 还要大。（不过我觉得作者还是应该在 ImageNet 上进行实验，不然整个实验还是不够完整。另外，作者的实验虽然都很置信且完善，但是对比实验选择的 baseline 不够 solid，只用了最基本的 softmax 作为对比，没有考虑最近几年涌现出的各种 softmax 的进阶版。）</p><h3 id="基本分类实验结果"><a href="#基本分类实验结果" class="headerlink" title="基本分类实验结果"></a>基本分类实验结果</h3><ul><li><p>MNIST:<br><img src="https://lsvih.com/images/15546341823585.jpg" alt=""></p></li><li><p>CIFAR-10:<br><img src="https://lsvih.com/images/15546341912068.jpg" alt=""></p></li><li><p>OLHWDB<br><img src="https://lsvih.com/images/15546342050566.jpg" alt=""></p></li></ul><p>可以看到，结果还是不错的，至少证明这篇文章提出的方法在最基本的分类效果上不会比 softmax 差。</p><h3 id="拒识实验"><a href="#拒识实验" class="headerlink" title="拒识实验"></a>拒识实验</h3><p><img src="https://lsvih.com/images/15546342149853.jpg" alt=""></p><p>这个实验结果比较亮眼。最近对模型的“拒识能力”的要求越来越高，所谓拒识，就是在输入 invalid 的测试样本时，模型可以判断出这个是 out-of-domain 的东西，返回拒绝的结果。</p><p>作者的实验方法是，在 MNIST 上进行训练，然后混入 CIFAR 数据集的数据来测试模型的拒识能力。在这种 open-domain 的实验中，我们经常会用某种类似于 min-confidence 的指标来判断送入的数据是不是 out-of-domain，但是像传统的 softmax + cross-entropy 方法中，min-confidence 越大，拒识率虽然会增加，但是准确率却也会明显下降。</p><p>作者提出的方法由于让不同类别的特征分布非常紧密，留出了大量的类间空间，因此在拒识率这块效果很好。</p><p>不过这个实验结果表格还是很微妙，因为每一横行参数啥的都不一样，虽然是为了做 AR 和 RR 的 trade-off 研究，但这样放着还是很奇怪。</p><h3 id="类增量实验"><a href="#类增量实验" class="headerlink" title="类增量实验"></a>类增量实验</h3><p><img src="https://lsvih.com/images/15546342235530.jpg" alt=""></p><p>这个实验其实还不是很常见，一般在 life-long learning 相关的工作里会有这个实验。目的是，测试一个模型在训练完成后新增一个类别的能力。对于标准的 softmax + cross-entropy 来说，自然不存在这一种能力，原因可以参考这篇笔记的第一个图，本来各个类就离的近了，再加一个类直接就乱套了。</p><p>而本文的方法，可以在“基本分类实验”一章的图中看出，样本按照类原型聚集的非常紧密。这样新增一个类并不是什么很困难的事。</p><p>作者的实验方法是，在 MNIST 训练出的模型中，增加 CIFAR-10 的类。可以看上图，做出来的结果依然很不错。</p><h3 id="小样本训练"><a href="#小样本训练" class="headerlink" title="小样本训练"></a>小样本训练</h3><p><img src="https://lsvih.com/images/15546342332247.jpg" alt=""></p><p>这个实验其实槽点也是 baseline 太 weak 了。现在做小样本的模型其实不占少数，但作者还是只选了 softmax 做比较。尽管如此，可以看到 GCPL 的效果还是很不错的。</p><h3 id="多原型实验"><a href="#多原型实验" class="headerlink" title="多原型实验"></a>多原型实验</h3><p>前面的所有实验都是在“一个类别对应一个原型”的设定之下完成的，都有不错的效果。作者在文章最后用“一个类别对应多个原型”的假设进行了实验，结果如下表所示：</p><p><img src="https://lsvih.com/images/15546342428370.jpg" alt=""></p><p>可以观察到，一个类别对应的原型数量其实对结果没有太大的影响。作者给出的解释是，CNN 提取特征的能力已经足够强大，即使初始数据的分布非常复杂，经过 CNN 变换之后，依然可以得到符合单高斯分布的特征分布，也就是一个类别一个原型的分布。</p><p>不过，在更复杂的情景下，一些更复杂的分类状况，多原型可能会发挥它应有的作用。</p><blockquote><p>这块其实也是 trade-off。因为增加一个原型相当于在隐层输出时增加了 Dense Node，会极大地增加空间占用和计算量。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章提出的方法足够新颖，并且取得的结果也非常好。虽然实验部分有些小遗憾（没有和各个任务顶尖的方法对比），但是仍然体现了这篇文章方法的综合性能的优越性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。&lt;br&gt;论文地址：&lt;a h
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="CNN" scheme="https://lsvih.com/tags/CNN/"/>
    
      <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="https://lsvih.com/tags/cnn/"/>
    
      <category term="prototype learning" scheme="https://lsvih.com/tags/prototype-learning/"/>
    
  </entry>
  
  <entry>
    <title>Web 开发者需要了解的基础色彩理论</title>
    <link href="https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/"/>
    <id>https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/</id>
    <published>2019-02-20T01:42:00.000Z</published>
    <updated>2019-02-20T01:55:55.996Z</updated>
    
    <content type="html"><![CDATA[<p>如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。</p><a id="more"></a><p><img src="https://lsvih.com/images/1-1.png" alt="1"></p><p>在小学美术课上应该讲过<strong>一次色</strong>（primary color，即三原色）与<strong>二次色</strong>（seondary color，间色），如果你在小学之后还上过美术课，应该还了解过<strong>三次色</strong>（tertiary color，副色）。</p><p><img src="https://lsvih.com/images/2-1.jpeg" alt="2"></p><p>不过如果你在高中或者更高层次的学校中学习过艺术，那你就会发现，色轮是展示<a href="https://en.wikipedia.org/wiki/Color_theory" target="_blank" rel="noopener">色彩理论</a>、练习混色以及研究色彩组合的最简单的方法。</p><h2 id="何谓色彩理论？"><a href="#何谓色彩理论？" class="headerlink" title="何谓色彩理论？"></a>何谓色彩理论？</h2><p><strong>色彩理论简史</strong>：爱德华·马奈（Édouard Manet）、埃德加·德加（Edgar Degas）、克洛德·莫奈（Claude Monet）等印象派的画家在抛弃写实，而开始尝试捕捉<strong>光色</strong>时，色彩理论就诞生了。</p><p><img src="https://lsvih.com/images/3-2.jpeg" alt="3"></p><p>上图为莫奈的 Haystacks 系列画作</p><p><strong>简单来说</strong>：色彩理论研究的是人的眼睛如何将光波转化为颜色。匹配或相似的色彩往往有着相似或互补的波。</p><p>因此可以将色彩理论归结为光波科学，来解释为什么可以看到各种颜色。不过在本文中，我们只专注于两个问题：</p><ul><li>为什么有些颜色可以完美搭配？</li><li>我们该如何选择“正确”的颜色？</li></ul><p>颜色的搭配问题有点像“与生俱来”的东西。不管怎样，在网页或者 App 里用纯绿色的背景是绝对让人无法忍受的！</p><p>下面我列了一个简表，当你遇到与色彩有关的问题时可以参考：</p><h2 id="Level-1：单色"><a href="#Level-1：单色" class="headerlink" title="Level 1：单色"></a>Level 1：单色</h2><p><strong>单色</strong>就是单一的颜色，或者同种颜色的多个色调的组合。</p><blockquote><p><strong>在 Web 开发时</strong>，你可以在<a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">这个网页中</a>选择并查询某种颜色的 Hex 代码，并且可以在不影响色调的情况下让颜色更亮或更暗。</p></blockquote><p><img src="https://lsvih.com/images/4-1.jpeg" alt="4"></p><p>这就是最简单的网页配色方法。诸如 <a href="http://facebook.com" target="_blank" rel="noopener">Facebook</a>、<a href="http://twitter.com" target="_blank" rel="noopener">Twitter</a> 之类的网站大都是用的这种单色配色方案。黑色、白色、天蓝色组合而成的简单配色，让这些社交 App 更加简洁。</p><p>只有用户的头像、链接、照片有着不同的颜色，这些不同的颜色可以被用户识别，更好地找到他们感兴趣的帖子和账号。</p><p>如果 Twitter 的网页上还有其它的颜色，就会让区分帖子、发帖人变得困难。</p><p>一般来说，即使你需要多种颜色，也得有个主色，所谓背景或者标题的颜色。</p><blockquote><p><strong>专业建议</strong>：如果你的网页要使用单色配色，请确保阴影可以清晰地将各个元素区分开了。否则用户在阅读文本或分离网页元素时将很不方便。</p></blockquote><h2 id="Level-2：互补色"><a href="#Level-2：互补色" class="headerlink" title="Level 2：互补色"></a>Level 2：互补色</h2><p>如果不想在配色中只用各种各样的“橙色”怎么办？如果你想让链接突出，但又不和导航栏或者背景色冲突怎么办？</p><p>如果我们遵循基本色彩理论，解决上述问题的方案就是去寻找<strong>互补色</strong>。</p><p>可以在色轮中一种颜色相对的位置找到它的<strong>互补</strong>色。</p><p><img src="https://lsvih.com/images/5-1.jpeg" alt="5"></p><p>每种<strong>主色</strong>都与一种<strong>副色</strong>作为互补色相对应。有种方法可以轻松记住颜色如何匹配：如果一种<strong>副色</strong>和一种<strong>主色</strong>匹配，那么<strong>副色</strong>的构成色一定不含<strong>主色</strong>。比如，红色的互补色是绿色，而绿色由蓝色和黄色组成。</p><blockquote><p><strong>专业建议</strong>：一次只增加一种颜色，并保持页面简单。不要为了呈现一个完整的彩虹配色牺牲了你干净、好用的布局。不然，你可能会做出上世纪 90 年代流行的经典网站（比如<a href="https://spacejam.com/" target="_blank" rel="noopener">这个</a>）。</p></blockquote><h2 id="继续升级…"><a href="#继续升级…" class="headerlink" title="继续升级…"></a>继续升级…</h2><p>随着你的设计水平的提高，就能自如地挑战自己的极限了。配色并不是什么可怕的工作。你可以多多关注一些配色水平高的开发者（比如<a href="https://www.alispit.tel/#/" target="_blank" rel="noopener">他</a> ）和设计师。多问问自己喜欢什么配色、不喜欢什么配色、为什么，这样就能建立自己的品味与品牌。</p><h2 id="Web-开发者的色彩-Hack"><a href="#Web-开发者的色彩-Hack" class="headerlink" title="Web 开发者的色彩 Hack"></a>Web 开发者的色彩 Hack</h2><p>试试自己手写一些 hex 代码、RBG 数字来尝试各种色彩的组合与混合。如果你是 SASS 的粉丝，可以把配好的颜色存储在文件中，日后在项目中导入。如果你的工作是构建页面结构而不是视觉设计（由客户或者产品经理决定），可以把这些颜色当做是占位符，让页面看起来更加明了。</p><p>请确保：</p><ul><li>所有东西都是可读的。</li><li>链接、标题等你想要强调的东西应该与纯文本有所区别。</li><li>用户可以轻松地区分网页的不同部分（比如导航栏、主要内容、文章等）。</li></ul><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><a href="http://paletton.com/" target="_blank" rel="noopener">Palleton.com</a></li><li><a href="https://coolors.co/" target="_blank" rel="noopener">Coolors.co</a></li></ul><p><a href="https://dev.to/ferkungamaboobo" target="_blank" rel="noopener">Doug R. Thomas, Esq.</a> 强烈推荐以下网站：</p><ul><li><a href="https://color.adobe.com/" target="_blank" rel="noopener">Color.Adobe.com</a></li><li><a href="https://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM — 颜色对比度检查器</a> — 确保文本在背景上的可读性。</li><li><a href="https://www.color-blindness.com/coblis-color-blindness-simulator/" target="_blank" rel="noopener">Coblis — 色盲模拟器</a> — 用色盲滤镜来测试你的布局截图，以确保内容对所有受众都是可读的。</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>希望在读完这篇文章后，你不再为给网站、网页、app 配色感到犯愁。如果你对这个主题感兴趣，强烈建议去了解<a href="https://www.colormatters.com/color-and-design/basic-color-theory" target="_blank" rel="noopener">更多相关知识</a>。本文只是浅显地进行了讲解，你可以读<a href="https://99designs.com/blog/tips/the-7-step-guide-to-understanding-color-theory/" target="_blank" rel="noopener">这篇文章</a>了解更多关于色调和阴影的知识。</p><p>最后我想说，在你给自己的项目进行配色时，并不存在”错误答案“。许多人认为品味是天生就有的，正是它帮助你寻找美妙的设计、带来灵感、尝试各种组合，最终为你和你的品牌找到最适合方案。祝你好运！</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c6caee26fb9a049df24a4df" target="_blank" rel="noopener">https://juejin.im/post/5c6caee26fb9a049df24a4df</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="Color" scheme="https://lsvih.com/tags/Color/"/>
    
      <category term="Design" scheme="https://lsvih.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>十件你不知道的关于 WebPageTest.org 的事(译)</title>
    <link href="https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/"/>
    <id>https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/</id>
    <published>2019-02-16T04:52:00.000Z</published>
    <updated>2019-02-16T05:17:51.304Z</updated>
    
    <content type="html"><![CDATA[<p>够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。</p><p>如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！</p><p>最近我在 Santa Clara 参加了 <a href="http://conferences.oreilly.com/velocity" target="_blank" rel="noopener">Velocity Conference</a>，偶遇了 <a href="https://github.com/pmeenan" target="_blank" rel="noopener">Pat Meenan</a>（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），<del>希望你还没有用过它们</del>。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。</p><a id="more"></a><h2 id="10-模拟单点失效"><a href="#10-模拟单点失效" class="headerlink" title="10. 模拟单点失效"></a>10. 模拟单点失效</h2><p>你的网站很可能依赖了一些第三方库来提供额外的功能（包括且不仅限于监控脚本、A/B 测试和广告）。问题就有可能出在这些你使用的部署在别人服务器上的库，这就是<a href="https://en.wikipedia.org/wiki/Single_point_of_failure" target="_blank" rel="noopener">单点失效</a>（SPOF）风险。如果出于某些原因，导致托管这些库的服务器出现故障或响应缓慢，你的网站也会不幸地收到影响。这种事情可能发生在任何人身上！</p><p>使用 WebPageTest 模拟单点失效与正常测试网站的设置一模一样，不过你需要将第三方库的域名屏蔽。例如，如果你想对 ccn.com 测试单点失效，可以将以下域名复制并粘贴到 SPOF 选项卡中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cdn3.optimizely.com</span><br><span class="line">a.visualrevenue.com</span><br><span class="line">www.google-analytics.com</span><br><span class="line">pixel.quantserve.com</span><br><span class="line">budgetedbauer.com</span><br></pre></td></tr></table></figure><p>粘贴好后界面应该如下所示：</p><p><img src="https://lsvih.com/images/1-1.jpeg" alt="1"></p><p>当查看此网站的加载视频时，你会发现 WebPagetest 已经对 SPOF 进行了模拟，导致该网站的加载时间长了不少。在<a href="http://www.webpagetest.org/video/compare.php?tests=160705_CE_HJQ,160705_JS_HJR" target="_blank" rel="noopener">上述测试</a>中，网站最终加载完毕共花了 20 多秒！这个功能是测试你的网站在 SPOF 情况下响应情况的好工具。</p><h2 id="9-创建个人-WebPagetest-实例"><a href="#9-创建个人-WebPagetest-实例" class="headerlink" title="9. 创建个人 WebPagetest 实例"></a>9. 创建个人 WebPagetest 实例</h2><p>WebPageTest 公共实例非常方便，你可以免费用它来快速获取需要的信息。不过公共实例有一些限制，比如在某个忙碌的日子里，你可能会需要在排队等待测试结果。如果你将 WebPageTest 用于商业用途，也许需要创建属于自己的私有 WebPageTest 实例。</p><p>Pat Meenan 写了一篇名为 <a href="http://calendar.perfplanet.com/2014/webpagetest-private-instances-in-five-minutes/" target="_blank" rel="noopener">5 分钟上手 WebPagetest 私有实例</a>的指南，介绍了在 Amazon EC2 上如何设置自己的实例。代理在所有 EC2 域中以 AMI 的形式提供，如果你需要在公司防火墙内部进行测试，也可以自行配置。</p><p>私有实例用起来很方便，因为你可以控制测试的基础架构，并且 API 请求数量没有限制。</p><h2 id="8-编写登录脚本"><a href="#8-编写登录脚本" class="headerlink" title="8. 编写登录脚本"></a>8. 编写登录脚本</h2><p>WebPageTest 不仅可以用于测试公开的网站，如果有需要，它也可以通过编写登录网站的脚本测试需要登录的网站。WebPageTest 具有脚本功能，可以自动执行多步测试（比如登录网站和发送电子邮件）。</p><p>例如，如果你想为 AOL 网站编写登录步骤的脚本，可以执行类似于以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logData0</span><br><span class="line"></span><br><span class="line">// bring up the login screen</span><br><span class="line">navigatehttp://webmail.aol.com</span><br><span class="line"></span><br><span class="line">logData1</span><br><span class="line"></span><br><span class="line">// log in</span><br><span class="line">setValuename=loginIdsomeuser@aol.com</span><br><span class="line">setValuename=passwordsomepassword</span><br><span class="line">submitFormname=AOLLoginForm</span><br></pre></td></tr></table></figure><p>请记住不要将重要的登录凭证放在里面！除非你将它们明确设为私有，否则 webpagetest.org 网站上的测试都是公开的。如果你想了解更多有关编写脚本的信息，请查阅此<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/scripting" target="_blank" rel="noopener">链接</a>。</p><h2 id="7-WebPagetest-发明的-Speed-Index-指标"><a href="#7-WebPagetest-发明的-Speed-Index-指标" class="headerlink" title="7.WebPagetest 发明的 Speed Index 指标"></a>7.WebPagetest 发明的 Speed Index 指标</h2><p>WebPagetest 于 2012 年添加了 Speed Index 指标（速度指数），它可以用于标化页面可视内容的填充速度。你可以尝试将不同的页面相互比较（优化之前与之后、自己的网站与竞品等），并与其他指标（加载时间，开始渲染时刻等）结合，来更好地理解这个对于描述网站性能非常有用的指标。如果你想了解更多有关 Speed Index 的信息，请参阅<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="noopener">此链接</a>。</p><h2 id="6-收集自定义指标"><a href="#6-收集自定义指标" class="headerlink" title="6. 收集自定义指标"></a>6. 收集自定义指标</h2><p>WebPageTest 提供了大量有用的统计指标。但你知道吗？你还可以用它来收集你自定义的指标。WebPageTest 可以在测试的最后执行任意的 JavaScript 脚本并收集<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/custom-metrics" target="_blank" rel="noopener">自定义指标</a>。你可以在服务器配置中静态地配置或在每个基础测试进行时配置它。</p><p>其实，自定义指标可以覆写内置指标。当你需要通过 JavaScript 验证强制让测试失败时，可以通过自定义指标得到“测试结果”。<a href="http://httparchive.org/" target="_blank" rel="noopener">HTTP Archive</a> 还通过 <a href="https://github.com/HTTPArchive/httparchive/tree/master/custom_metrics" target="_blank" rel="noopener">自定义指标</a> 采集了一些统计数据。</p><h2 id="5-将-WebPageTest-整合进你的-CI-测试中"><a href="#5-将-WebPageTest-整合进你的-CI-测试中" class="headerlink" title="5. 将 WebPageTest 整合进你的 CI 测试中"></a>5. 将 WebPageTest 整合进你的 CI 测试中</h2><p>如果你想在每次部署新代码时，都确保新代码不会让你在 Web 性能上的努力前功尽弃，那么 WebPageTest 可以帮上忙！你可以在页面上设置“budget”（预算），如果测试结果超过预算值则会导致测试失败。<a href="https://timkadlec.com/2013/01/setting-a-performance-budget/" target="_blank" rel="noopener">Tim Kadlec</a> 创建了一个有用的 <a href="https://github.com/tkadlec/grunt-perfbudget" target="_blank" rel="noopener">Grunt任务</a>，可以用 WebPagetest 的公开或私有实例对指定的 URL 执行测试。Marcel Duran 还为 NodeJS 创建了一个 <a href="https://github.com/marcelduran/webpagetest-api" target="_blank" rel="noopener">WebPageTest API 包装器</a>，可以让你自定义测试的运行方式。</p><p>通过这些方法，每当更新代码时，都能检查网站性能。网页的性能并不是儿戏，而是维系网站生命的重要事项！</p><h2 id="4-你可以自定义瀑布图的显示方式"><a href="#4-你可以自定义瀑布图的显示方式" class="headerlink" title="4. 你可以自定义瀑布图的显示方式"></a>4. 你可以自定义瀑布图的显示方式</h2><p>你知道吗？WebPageTest 可以自定义瀑布图的显示方式。运行测试后，单击瀑布图像并向下滚动，可以看到一个“customize waterfall”（自定义瀑布）的链接。</p><p><img src="https://lsvih.com/images/2.jpeg" alt="2"></p><p>点击这个链接，可以自定义瀑布图的显示方式。很好用！</p><p><img src="https://lsvih.com/images/3-1.jpeg" alt="3"></p><p>如果你要在幻灯片里使用瀑布图，这个功能可让你精准地展示需要展示的部分。</p><h2 id="3-在测试历史记录中对比多个测试结果"><a href="#3-在测试历史记录中对比多个测试结果" class="headerlink" title="3. 在测试历史记录中对比多个测试结果"></a>3. 在测试历史记录中对比多个测试结果</h2><p>在测试历史记录页面中，你可以查看针对特定实例运行过的测试列表。这个页面可以让你以幻灯片的形式直观地比较多个测试。</p><p><img src="https://lsvih.com/images/4.jpeg" alt="4"></p><p>选择要进行比较的测试，就能看到一个幻灯片视图，比较所有过去运行过的测试。</p><p><img src="https://lsvih.com/images/5.jpeg" alt="5"></p><p>需要注意，在运行测试时最好对测试设置标签。这样有助于帮你在历史记录中找到对应的测试，并且在幻灯片、视频视图中显示时也会显示标签。</p><h2 id="2-你也可以为-WebPageTest-代码库做贡献"><a href="#2-你也可以为-WebPageTest-代码库做贡献" class="headerlink" title="2. 你也可以为 WebPageTest 代码库做贡献"></a>2. 你也可以为 WebPageTest 代码库做贡献</h2><p>整个 WebPageTest 的代码库都是开源的！代码库位于 <a href="https://github.com/WPO-Foundation/webpagetest" target="_blank" rel="noopener">Github</a>，包括了 Web UI 和可用于在各种浏览器上运行测试的代码。Pat 提到，这个代码库使用的是非常宽松的 BSD 协议，也就是说你可以出于任何的目的（包括商业等用途）使用项目的任何部分。</p><p>如果你觉得有些东西可以让社区受益，请务必为这个非常棒的工具做出贡献！</p><h2 id="1-检查你的-JavaScript-执行是否导致性能瓶颈"><a href="#1-检查你的-JavaScript-执行是否导致性能瓶颈" class="headerlink" title="1. 检查你的 JavaScript 执行是否导致性能瓶颈"></a>1. 检查你的 JavaScript 执行是否导致性能瓶颈</h2><p>现在 JavaScript 在全世界都非常流行，这也意味着 JavaScript 的执行已经成为了妨碍浏览器性能的一个严重瓶颈。你知道吗？使用 WebPageTest，可以模拟在设备上运行网站，并得到主线程运作的详细情况。</p><p>在运行测试前，打开 Chrome 标签，然后勾选“Capture Dev Tools Timeline”（捕获开开发者工具时间轴）。</p><p><img src="https://lsvih.com/images/6.jpeg" alt="6"></p><p>在测试完成后，点击“Processing Breakdown”（处理详情）按钮，将得到主线程处理过程中的详细视图。通过展示主线程的处理过程的详细情况，可以让你更好地了解网站在真实设备上的确切运行情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：如果你经常使用 WebPageTest，希望这篇文章能帮你了解更多关于它的内容。感谢 <a href="http://blog.patrickmeenan.com/" target="_blank" rel="noopener">Pat Meenan</a> 提供信息并帮忙检查文章！</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c679531f265da2dc45367ab" target="_blank" rel="noopener">https://juejin.im/post/5c679531f265da2dc45367ab</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。&lt;/p&gt;
&lt;p&gt;如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！&lt;/p&gt;
&lt;p&gt;最近我在 Santa Clara 参加了 &lt;a href=&quot;http://conferences.oreilly.com/velocity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Velocity Conference&lt;/a&gt;，偶遇了 &lt;a href=&quot;https://github.com/pmeenan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pat Meenan&lt;/a&gt;（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），&lt;del&gt;希望你还没有用过它们&lt;/del&gt;。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="FrontEnd" scheme="https://lsvih.com/tags/FrontEnd/"/>
    
      <category term="Test" scheme="https://lsvih.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>5 个可以立刻在你的 Ionic App 中用上的动画包</title>
    <link href="https://lsvih.com/2019/01/30/5-%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AB%8B%E5%88%BB%E5%9C%A8%E4%BD%A0%E7%9A%84-Ionic-App-%E4%B8%AD%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%8C%85/"/>
    <id>https://lsvih.com/2019/01/30/5-个可以立刻在你的-Ionic-App-中用上的动画包/</id>
    <published>2019-01-30T10:20:00.000Z</published>
    <updated>2019-02-16T05:31:10.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.png" alt="1"></p><p>使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。</p><p>在本文中我们将介绍 <strong>5 个不同的动画包</strong>，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。</p><a id="more"></a><p><img src="https://lsvih.com/images/2.gif" alt="2"></p><p>你可以使用以下代码初始化一个空白的 Ionic 4 App：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionic start animationPackages blank --type=angular</span><br></pre></td></tr></table></figure><p>我们不会完整地摘录这些包的文档，只会展示如何将它们整合进你的 App 这一重要部分。</p><h2 id="1-Anime-js"><a href="#1-Anime-js" class="headerlink" title="1. Anime.js"></a>1. <a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">Anime.js</a></h2><p>只要安装好这个包，不需要任何别的操作就能将它引入你的 App 中了。你只需要简单地按照下列代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animejs</span><br></pre></td></tr></table></figure><p>通过它你可以让你<strong>在你的 Javascript 代码中</strong>创建动画。这也是它与绝大多数包不同的地方：别的包大多是通过添加 CSS class，或者在你的 class 中用特定的语法来创建动画的。</p><p>通过 Anime.js，你能轻松地为屏幕中的元素设定动画并移动它们。下面是创建一个小方块，并用一个函数来创建动画效果的代码（我们给小方块加了一些 CSS 样式，这样它才能在屏幕上有一定的大小）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div class=&quot;animate-me&quot; #box&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">// SCSS</span><br><span class="line"> </span><br><span class="line">.animate-me &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: #0000ff;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import * as anime from &apos;animejs&apos;;</span><br><span class="line"> </span><br><span class="line">callAnime() &#123;</span><br><span class="line">    anime(&#123;</span><br><span class="line">      targets: &apos;.animate-me&apos;,</span><br><span class="line">      translateX: [</span><br><span class="line">        &#123; value: 100, duration: 1200 &#125;,</span><br><span class="line">        &#123; value: 0, duration: 800 &#125;</span><br><span class="line">      ],</span><br><span class="line">      rotate: &apos;1turn&apos;,</span><br><span class="line">      backgroundColor: &apos;#ff00ff&apos;,</span><br><span class="line">      duration: 2000</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用元素的 CSS class 来轻松指定应用动画效果的目标（即 target 参数），其它的参数都不言自明。这也是这个包的强大之处：</p><p>你可以轻松理解这个包的一些基本命令，<strong>快速上手并创建强大的动画效果</strong>。如果选择用这个包来创建动画，你不需要学习又臭又长的 API。</p><h2 id="2-Magic-CSS"><a href="#2-Magic-CSS" class="headerlink" title="2. Magic CSS"></a>2. <a href="https://github.com/miniMAC/magic" target="_blank" rel="noopener">Magic CSS</a></h2><p>这个包依赖于预设好的 CSS 动画，你可以将这些动画加入到元素中。安装方式与前文相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install magic.css</span><br></pre></td></tr></table></figure><p>不过此时你需要从 node module 将实际的 CSS 文件导入进来，因此你得用类似下面的方法来修改你的 <strong>src/global.scss</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~magic.css/magic.min.css&apos;;</span><br></pre></td></tr></table></figure><p>现在可以在你的 app 中用 Magic CSS 了。你可以直接在元素上添加动画的 class，或者用下面这种方式通过 <code>@ViewChild()</code> 标注将动画 class 加入到元素的 <code>classList</code> 中去，这样就能在特定的时间来创建动画了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div class=&quot;animate-me&quot; #box&gt;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">@ViewChild(&apos;box&apos;) box: ElementRef;</span><br><span class="line"> </span><br><span class="line">doMagic() &#123;</span><br><span class="line">    this.box.nativeElement.classList.add(&apos;magictime&apos;);</span><br><span class="line">    this.box.nativeElement.classList.add(&apos;foolishIn&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次你都要先加入 <strong>magictime</strong> class，然后加入你要用的动画的 class 名。</p><p>这个包没有提供那么多的自定义选项，不过如果你只需要<strong>简单且快速的 CSS 动画</strong>，试试它准没错！</p><h2 id="3-Number-Flip"><a href="#3-Number-Flip" class="headerlink" title="3. Number Flip"></a>3. <a href="https://github.com/gaoryrt/number-flip" target="_blank" rel="noopener">Number Flip</a></h2><p>这是一个小巧的包。我最近才发现它，非常喜欢它的动画。不过只有在一种特定的情景下，你才会需要将它加入你的 app（你可以看看它的 Github page，那里面的效果就是它唯一的效果）。安装方式很简单，依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install number-flip</span><br></pre></td></tr></table></figure><p>假设你的 Ionic app 的顶栏上有一些计数器，现在你希望通过动画效果来修改它的数字。</p><p>这个情景中，number flip 包就非常好用，你可以用帅帅的动画效果让一个元素翻转，并在翻转时修改元素里面的数字。我用一些代码创建了对该元素的引用，当触发 <code>flip()</code> 函数的时候会直接调用动画包里面的 <code>flipTo()</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;ion-header&gt;</span><br><span class="line">  &lt;ion-toolbar&gt;</span><br><span class="line">    &lt;ion-title&gt;</span><br><span class="line">      Ionic Animations</span><br><span class="line">    &lt;/ion-title&gt;</span><br><span class="line">    &lt;ion-buttons slot=&quot;end&quot;&gt;</span><br><span class="line">      &lt;div #numberbtn&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/ion-buttons&gt;</span><br><span class="line">  &lt;/ion-toolbar&gt;</span><br><span class="line">&lt;/ion-header&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import &#123; Flip &#125; from &apos;number-flip&apos;;</span><br><span class="line"> </span><br><span class="line">@ViewChild(&apos;numberbtn&apos;, &#123; read: ElementRef &#125;) private btn: ElementRef;</span><br><span class="line"> </span><br><span class="line">flip() &#123;</span><br><span class="line">  if (!this.flipAnim) &#123;</span><br><span class="line">    this.flipAnim = new Flip(&#123;</span><br><span class="line">      node: this.btn.nativeElement,</span><br><span class="line">      from: &apos;9999&apos;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  this.flipAnim.flipTo(&#123;</span><br><span class="line">    to: Math.floor((Math.random() * 1000) + 1)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个包没有任何别的高级动画效果，它<strong>仅仅在这种特殊情景下特别好用</strong>。如果你要使用计时器或者创建数字动画，考虑考虑它吧！</p><h2 id="4-Animate-CSS"><a href="#4-Animate-CSS" class="headerlink" title="4. Animate CSS"></a>4. <a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">Animate CSS</a></h2><p>它可是一位重磅玩家，在这几个包中就属它的 Github star 最多。它的口号是“像倒水一样添加 CSS 动画”，事实上它的用法确特别简单。安装方法和前文一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animate.css</span><br></pre></td></tr></table></figure><p>由于这个包依赖于 CSS，因此使用它前我们也要通过下面的方式将 CSS 文件导入 <strong>src/global.scss</strong> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~animate.css/animate.min.css&apos;;</span><br></pre></td></tr></table></figure><p>现在，我们就可以享受这个包各种预设好的超帅的 CSS 动画了（每个用例都对应着一种动画）。我们还可以添加一些其它的 class，比如说 <code>infinite</code> 让动画循环播放，或者让动画延迟一段时间播放。</p><p>在下面的例子中，我们 ngFor 和它的 index 来定义不同的动画延迟（当然在真实的 app 中不会有这么慢的动画），然后用 <code>ViewChildren</code> 列表来为需要飞出来的元素增加相应的动画 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;h1 text-center class=&quot;animated infinite rubberBand delay-1s&quot;&gt;Example&lt;/h1&gt;</span><br><span class="line"> </span><br><span class="line">&lt;ion-list&gt;</span><br><span class="line">    &lt;ion-item *ngFor=&quot;let val of [&apos;First&apos;, &apos;Second&apos;, &apos;Third&apos;]; let i = index;&quot; </span><br><span class="line">    class=&quot;animated fadeInLeft delay-&#123;&#123; i &#125;&#125;s&quot; #itemlist&gt;</span><br><span class="line">      &#123;&#123; val &#125;&#125; Item</span><br><span class="line">    &lt;/ion-item&gt;</span><br><span class="line">&lt;/ion-list&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">@ViewChildren(&apos;itemlist&apos;, &#123; read: ElementRef &#125;) items: QueryList&lt;ElementRef&gt;;</span><br><span class="line"> </span><br><span class="line">animateItems() &#123;</span><br><span class="line">  let elements = this.items.toArray();</span><br><span class="line">  elements.map(elem =&gt; &#123;</span><br><span class="line">    return elem.nativeElement.classList.add(&apos;zoomOutRight&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要个<strong>预设好大量 CSS 动画的武器库</strong>，你一定要试试它。虽然它已经预设好了很多东西，但你也可以根据你的需要来进行组合！</p><h2 id="5-Bounce-js"><a href="#5-Bounce-js" class="headerlink" title="5. Bounce.js"></a>5. <a href="https://github.com/tictail/bounce.js" target="_blank" rel="noopener">Bounce.js</a></h2><p>最后，我想测试这个特别灵活的包。它也可以用 Javascript 来编写动画。这个包的安装方法和其它几个包一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bounce.js</span><br></pre></td></tr></table></figure><p>这个包的文档非常完整，你可能要多花一点时间来探索所有的配置，比如下面是他们页面广告中的一个片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;ion-button expand=&quot;block&quot; (click)=&quot;bounce()&quot; #bouncebtn&gt;Bounce&lt;/ion-button&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import * as Bounce from &apos;bounce.js&apos;;</span><br><span class="line"> </span><br><span class="line">@ViewChild(&apos;bouncebtn&apos;, &#123; read: ElementRef &#125;)bouncebtn: ElementRef;</span><br><span class="line"> </span><br><span class="line">bounce() &#123;</span><br><span class="line">  var bounce = new Bounce();</span><br><span class="line">  bounce</span><br><span class="line">    .translate(&#123;</span><br><span class="line">      from: &#123; x: -300, y: 0 &#125;,</span><br><span class="line">      to: &#123; x: 0, y: 0 &#125;,</span><br><span class="line">      duration: 600,</span><br><span class="line">      stiffness: 4</span><br><span class="line">    &#125;)</span><br><span class="line">    .scale(&#123;</span><br><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span><br><span class="line">      to: &#123; x: 0.1, y: 2.3 &#125;,</span><br><span class="line">      easing: &quot;sway&quot;,</span><br><span class="line">      duration: 800,</span><br><span class="line">      delay: 65,</span><br><span class="line">      stiffness: 2</span><br><span class="line">    &#125;)</span><br><span class="line">    .scale(&#123;</span><br><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span><br><span class="line">      to: &#123; x: 5, y: 1 &#125;,</span><br><span class="line">      easing: &quot;sway&quot;,</span><br><span class="line">      duration: 300,</span><br><span class="line">      delay: 30,</span><br><span class="line">    &#125;)</span><br><span class="line">    .applyTo(this.bouncebtn.nativeElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，所有步骤都在你的 Javascript 代码中。你可以用这个包在任何粒度上<strong>创建复杂的关键帧动画</strong>。</p><p>不过这种灵活性是要付出代价的，你需要深入地研究它的文档，因此比起其它的包你需要更多的时间才能入门。不过，如果你付出了时间，它也会回报你的付出：你可以用它在 app 中创建任何你想要的动画！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在推荐的这几个包中，有一些包可以让你快速做出产品，有些包则需要你学习它们的语法；有些包已经预设好了一切动画，而有些包则可以让你创建更灵活的动画；有些包是纯 CSS，还有一些是纯 JS。</p><p>没有哪个是真正“最好的”，因为它们在不同的场景下有着各自的优势。另外，注意这些包的大小也是一件重要的事，你也不希望加太多的东西影响 app 的下载时间吧。</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c517544f265da613b702848" target="_blank" rel="noopener">https://juejin.im/post/5c517544f265da613b702848</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。&lt;/p&gt;
&lt;p&gt;在本文中我们将介绍 &lt;strong&gt;5 个不同的动画包&lt;/strong&gt;，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Ionic" scheme="https://lsvih.com/tags/Ionic/"/>
    
      <category term="Angular" scheme="https://lsvih.com/tags/Angular/"/>
    
      <category term="Animation" scheme="https://lsvih.com/tags/Animation/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>DNS over TLS：端到端加密的 DNS</title>
    <link href="https://lsvih.com/2019/01/23/DNS-over-TLS-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%9A%84%20DNS/"/>
    <id>https://lsvih.com/2019/01/23/DNS-over-TLS-端到端加密的 DNS/</id>
    <published>2019-01-23T11:13:00.000Z</published>
    <updated>2019-01-23T11:15:54.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.jpeg" alt="1"></p><p>为了加密互联网流量中未被加密的最后一部分，我们与 <a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener">Cloudflare DNS</a> 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 <a href="https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/" target="_blank" rel="noopener">TLS</a>，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。</p><a id="more"></a><h2 id="DNS-的历史"><a href="#DNS-的历史" class="headerlink" title="DNS 的历史"></a>DNS 的历史</h2><p>二十世纪八十年代末，域名系统（DNS）被提出，可以让人们用简短易记的名称来连接实体（比如 facebook.com），这使得网络安全发生了极大的变化。人们为网络安全做了许多的改进，比如现在大部分的网络流量都是通过 HTTPS 连接，但在线上传输明文时仍然存在一些问题。</p><p>2010 年，<a href="https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" target="_blank" rel="noopener">DNS 安全拓展</a>（DNSSEC）部署实施，DNS 协议由此支持身份验证功能。虽然 DNSSEC 支持对消息进行身份验证，但仍然会使用明文来传输 DNS 请求与应答。这也使得传输的内容可以被请求方与响应方中间路径上任意节点轻松获取。2014 年 10 月，国际互联网工程任务组（IETF）建立了 <a href="https://datatracker.ietf.org/wg/dprive/about/" target="_blank" rel="noopener">DPRIVE 工作组</a>，其章程包括为 DNS 提供保密性与身份验证功能。</p><p>此工作组在于 2016 年提出 <a href="https://tools.ietf.org/html/rfc7858" target="_blank" rel="noopener">RFC 7858</a> 指定了 DoT 标准。为此，Cloudflare 的 1.1.1.1 与 Quad9 的 9.9.9.9 等开放的解析器在 DoT 的支持下更加关注使用者的隐私。这也保护了终端用户设备到 DNS 解析器这一部分 DNS 通信。但连接的其它部分仍然是明文传输。在 2018 年 5 月，DPRIVE 重新开发了一个方法，用于加密从解析器到域名服务器间的通信。</p><p><img src="https://lsvih.com/images/2.png" alt="2"></p><p><strong>DoT 以前的 DNS</strong></p><h2 id="DoT-试验"><a href="#DoT-试验" class="headerlink" title="DoT 试验"></a>DoT 试验</h2><p>我们在过去的几个月中一直在进行一项试验，在 Cloudflare 1.1.1.1 递归解析器与我们的主域名服务器间开启 DoT。这个试验的目的是了解大规模使用 DoT 的可行性，收集信息以更好地了解 DoT 在接受应答时的延迟产生的开销，并确定计算开销。这个试验让我们更好地了解了 DoT 协议在真实环境下的表现。另外在生产环境负载中试验把 DNS 从 UDP 等即发即弃方法换成 TLS 之类的加密连接协议，可以将一些设计协议时发现不了的问题给暴露出来。</p><p><img src="https://lsvih.com/images/3.jpeg" alt="3"></p><p><strong>DoT 下的 DNS</strong></p><p>截至目前，通过观察 Cloudflare DNS 与 Facebook 域名服务器间的生产环境流量，已经可以证明该试验是可行的解决方案。在初始化一个新连接的时候由于需要初始化请求，因此增加了延时；但我们可以重用 TLS 连接来处理其它更多的请求。因此，初始化增加的负载在均摊之后，降低到了 Cloudflare DNS 与 Facebook 主域名服务器 UDP 基线的 p99 相同的程度。</p><p>下图展示了我们从 TLS 切换回 UDP 时（在 17:30 时刻）延时的变化。它可以让我们比较两个协议请求的延时。第一个图显示了在没有 TCP/TLS 会话建立开销情况下的延时百分比。它展示了当连接建立后，TLS 与 UDP 在查询和响应间的延时是相同的。</p><p><img src="https://lsvih.com/images/4.png" alt="4"></p><p>第二张图加上了建立连接的时间来考虑请求的总体延迟。从图中可以看到，使用 TLS 还是 UDP 对连接的总体延时也没有影响。这是因为我们使用 TLS 的会话恢复技术，通过相同的 TLS 连接来执行多个请求，实质上分摊了初始化连接的开销。</p><p><img src="https://lsvih.com/images/5.png" alt="5"></p><p>作为参考，下图展示了在不使用 TLS 会话恢复技术，并在建立连接后仅处理少量请求时总延时的差异。在比 22:35 稍早的时刻完成了 TLS 到 UDP 的切换，可以看到总体而言 TLS 对大多数的请求的影响与 UDP 类似，但在 p95 或更高的统计指标下，请求的延时收到了影响。后面一张图显示，当链接已经建立时，延时不受影响。这两张图表明，第一张图中的差异是由于建立新连接时产生的，并且实际上，建立新连接的频率很高。</p><p><img src="https://lsvih.com/images/6.png" alt="6"></p><p><img src="https://lsvih.com/images/7.png" alt="7"></p><p>基本来说，浏览 Facebook 和使用带 DoT 的 Cloudflare DNS 的用户，无论是在用 HTTPS 连接时还是在 DNS 层面上，都可以享受完全加密的体验。虽然我们已经实现了 TLS 会话恢复技术，但还没有充分利用现代协议栈提供的全部优化方法。在将来，我们可以利用 TLS 的最新版本（<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">TLS 1.3</a>）和 <a href="https://en.wikipedia.org/wiki/TCP_Fast_Open" target="_blank" rel="noopener">TCP Fast Open</a> 等技术带来的改进，进一步降低延时。</p><h2 id="DoT-的下一步"><a href="#DoT-的下一步" class="headerlink" title="DoT 的下一步"></a>DoT 的下一步</h2><p>这个试验已经证明了，我们可以使用 DoT 大规模处理生产环境的负荷，并且不会对用户体验产生任何负面影响。我们将这个试验所得到的经验和知识，作为一种可行的经验回馈给 DNS 社区。</p><p><a href="https://www.ietf.org/" target="_blank" rel="noopener">IETF</a> 等标准社区开发协议时，有时候会缺乏与最终实施与运行协议的组织的意见，这导致了协议设计者、实施者、运营者间的脱节。通过这个试验，我们可以根据在生产环境中运行协议得到的经验，及时向工作组报告具体结果，同时也为有意于部署 DoT 的运营商和软件供应商提供了最佳实践。</p><p>我们希望这些初步的试验结果可以激励其它的行业合作伙伴加入我们的试验，扩大 DoT 运营商的数量，并得到更多制定此协议时得到的经验，从而提高反馈水准、得到更多的运营知识和最佳实践。</p><p><strong>感谢 Cloudflare 的 Marek Vavruša 在这个试验中做出的贡献。</strong></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c4849d06fb9a049c30b967b" target="_blank" rel="noopener">https://juejin.im/post/5c4849d06fb9a049c30b967b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.jpeg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了加密互联网流量中未被加密的最后一部分，我们与 &lt;a href=&quot;https://www.cloudflare.com/dns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloudflare DNS&lt;/a&gt; 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 &lt;a href=&quot;https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TLS&lt;/a&gt;，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Back End" scheme="https://lsvih.com/tags/Back-End/"/>
    
      <category term="DNS" scheme="https://lsvih.com/tags/DNS/"/>
    
      <category term="TLS" scheme="https://lsvih.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>Translation of &#39;Deep Variational Bayes Filters Unsupervised Learning of State Space Models from Raw Data&#39;.</title>
    <link href="https://lsvih.com/2018/12/15/Translation-of-DVBF/"/>
    <id>https://lsvih.com/2018/12/15/Translation-of-DVBF/</id>
    <published>2018-12-15T14:06:00.000Z</published>
    <updated>2019-01-21T13:28:03.985Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/files/DVBF.pdf" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/files/DVBF.pdf&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; align=&quot;&quot; height=&quot;600px&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Char-BiLSTM-CRF Incorporating POS and Dictionaries for Chinese OTE&#39; used in ACML conference.</title>
    <link href="https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/"/>
    <id>https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/</id>
    <published>2018-11-26T04:29:00.000Z</published>
    <updated>2018-11-26T04:30:09.709Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.h
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="conference" scheme="https://lsvih.com/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Algorithms for Non-negative Matrix Factorization&#39; used in assignment.</title>
    <link href="https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/</id>
    <published>2018-10-30T08:00:00.000Z</published>
    <updated>2018-10-30T08:00:49.004Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html&quot; scrolling=&quot;no&quot; fram
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="assignment" scheme="https://lsvih.com/tags/assignment/"/>
    
      <category term="optimization" scheme="https://lsvih.com/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms for Non-negative Matrix Factorization，非负矩阵分解 论文翻译</title>
    <link href="https://lsvih.com/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Algorithms for Non-negative Matrix Factorization/</id>
    <published>2018-10-29T19:08:00.000Z</published>
    <updated>2019-04-07T07:47:51.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NIPS 2000 经典论文 非负矩阵分解算法 翻译</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>非负矩阵分解（NMF）是一种可以有效处理多变量数据的方法。本文介绍、分析了两种不同的 NMF 算法，这两种算法仅在更新规则（update rule）中使用的乘性因子（multiplicative factor）有所区别。其中一种可以对传统的最小二乘误差进行最小化（minimize），而另一种可以对广义 Kullback-Leibler 散度（KL 散度）进行最小化。可以使用与证明最大化期望算法收敛性类似的辅助函数来证明这两种算法的单调收敛性。这两种算法均可理解为用斜向最陡下降法（diagonally rescaled gradient descent）对因子进行最优化，以保证算法收敛。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PCA、矢量量化（Vector Quantization）等无监督学习算法可以理解为在不同约束条件下对数据矩阵进行分解。根据其约束的不同，分解所得的因子的会表现出大相径庭的性质。比如，PCA 仅使用了弱正交约束，从而得到非常分散的表示，对这些表示使用消去法来产生多样性；矢量量化使用一种严格的全局最优型约束，最终会得到互斥的数据聚类原型。</p><p>我们之前已经证明过，在矩阵分解用于学习数据的部分表示中，非负性（non-negative）是一种非常有用的约束。学习得到的非负基向量是分散的，但仍可通过稀疏的组合，在重建时得到效果良好的表达向量。在本文中，我们详细分析了这两种用于在数据中学习最优的非负因子的数值算法。</p><h2 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h2><p>下面我们正式开始分析如何用算法解决以下问题：</p><p><strong>在非负矩阵分解（NMF）中</strong>，给定非负矩阵V，找到非负矩阵因子W和H，使得：</p><script type="math/tex; mode=display">(1):  V\approx WH</script><p>NMF 可以应用下面的方法用于对多变量数据进行统计分析。给定一组多变量的 n 维数据向量，其向量位于一个 $n\times x$ 矩阵 V 的列中（m 表示数据集中的示例数）。然后将此矩阵近似分解为 $n\times r$ 的 W 矩阵与 $r\times m$的 H 矩阵。通常 r 要小于 n 或 m，以使 W 和 H 小于原始矩阵 V。最终得到的是原始数据矩阵的压缩形态。</p><p>公式(1)中约等于的意义在于它可以将公式逐列用 $v\approx Wh$ 来表示，其中 v 和 h 是矩阵 V 和矩阵 H 的对应的列。也就是说，每个数据向量 v 近似地由矩阵 W 的各列线性组合而成，同时用 h 的分量进行加权。因此可以被认为 W 包含了对 V 中的数据的线性近似优化的基向量。由于要使用少量的基向量来表示大量的数据向量，因此只有在基向量发现数据中的潜在结构时才能实现较好的近似。</p><p>本文不会涉及关于 NMF 的应用，而会侧重于在技术方面探讨非负矩阵分解的技术。当然，已经有许多其它的矩阵分解方式在数值线性代数中得到了广泛的研究，但是以前的大多数工作都不适用于非负性约束情况。</p><p>在此，我们讨论了基于迭代更新 W 和 H 的两种 NMF 算法。由于这两种算法易于实现，同时能保证其收敛性，因此它们在现实情况中非常实用。其他算法可能在总计算时间方面更有效率，但是更难实现，并且很难推广到不同的代价函数（cost function）。因子与我们类似的算法，已经被用于对发射断层扫描和天文图像进行反卷积（deconvolution）。</p><p>在我们算法的每次迭代中，会用当前值乘某些取决于公式(1)中的“近似程度”的因数，来找到 W 或 H 的新值。我们可以证明“近似程度”会随着不断应用这些乘法更新规则而单调减小。这正意味着更新规则的重复迭代可以保证矩阵分解算法收敛到局部最优。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>为了找到$ V\approx WH  $的近似解，我们首先需要定义一个代价函数，用以量化近似的程度。可以使用两个非负矩阵 A 和 B 的距离来构造此代价函数。一种使用的距离度量方法为：计算 A  和 B 之间的欧几里得距离（Euclidean distance）的平方值。</p><script type="math/tex; mode=display">(2): ||A-B||^2 = \sum_{ij}(A_{ij} - B_{ij})^2</script><p>此公式下界为 0，仅当 A=B 时距离消失。</p><p>另一种实用的度量方式为：</p><script type="math/tex; mode=display">(3): D(A||B) = \sum_{ij}(A_{ij} \log{\frac{A_{ij}}{B_{ij}}} - A_{ij}+B_{ij})</script><p>与欧几里得距离相同，它的下界也为 0，且在 A=B 时距离消失。但它不能被称为“距离”，因为这个式子在 A 与 B 中并不对称，因此我们将其称为 A 对于 B 的“散度”（divergence）。它可以归纳为 KL 散度或者相对熵，当 $\sum_{ij}A_{ij}=\sum_{ij}B_{ij}=1$ 时，A 与 B 可以看做是标准化的概率分布。</p><p>现在，我们可以按照以下两种公式来将 NMF 化为最优化问题：</p><p><strong>最优化问题1</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $||V - WH||^2$。</p><p><strong>最优化问题2</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $D(V||WH)$。</p><p>虽然方程 $||V - WH||^2$ 和 $D(V||WH)$ 在只考虑 W 或 H 之一时为凸，但在同时考虑 WH 两个变量时不为凸。因此，寻找一种可以找到全局最小值的算法去解决以上两个最优化问题是不切实际的。但是，还有许多数值优化方法可以用于寻找局部最小值。</p><p>虽然梯度下降法（Gradient descent）的收敛速度很慢，但它的实现最为简单。其它方法（比如共轭梯度法）可以更快地收敛（至少在局部最小值附近会更快），但是它们比梯度下降更复杂。此外，梯度下降方法的收敛对步长的选择非常敏感，这对于大规模应用十分不利。</p><h2 id="乘法更新规则"><a href="#乘法更新规则" class="headerlink" title="乘法更新规则"></a>乘法更新规则</h2><p>我们发现在解决上述两个最优化问题时，在速度与实现难度中权衡，“乘法更新规则”是一种综合性能很好方法。</p><p><strong>定理1</strong>：欧几里得距离 $||V-WH||$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(4): H_{a\mu} \leftarrow H_{a\mu}\frac{(W^T V)_{a\mu}}{(W^T W H)_{a\mu}}</script><script type="math/tex; mode=display">(4): W_{ia} \leftarrow W_{ia}\frac{(V H^T)_{ia}}{(W H H^T)_{ia}}</script><p>在上述更新规则中，W 与 H 在距离公式的驻点上时，欧几里得距离将固定不动。</p><p><strong>定理2</strong>：散度 $D(V|WH)$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(5): H_{a\mu} \leftarrow H_{a\mu}\frac{\frac{\sum_{i}W_{ia}V_{i\mu}}{WH_{i\mu}}}{\sum_k W_{ka}}</script><script type="math/tex; mode=display">(5): W_{ia} \leftarrow W_{ia}\frac{\frac{\sum_{\mu}H_{a\mu}V_{i\mu}}{WH_{i\mu}}}{\sum_v H_{av}}</script><p>在上述更新规则中，W 和 H 在散度公式的驻点上时，散度将不再更新。</p><p>上述定理的证明将在后面给出。我们可以发现，每次更新都是乘以一个因子。特别地，当V = WH时，可以直观地看出这个乘数因子是一样的，当更新规则固定时，才会得到完美的分解。</p><h2 id="乘法与加法更新规则"><a href="#乘法与加法更新规则" class="headerlink" title="乘法与加法更新规则"></a>乘法与加法更新规则</h2><p>可以将乘法更新与梯度下降更新进行对比。特别的，对 H 进行更新以减小平方距离可以记为：</p><script type="math/tex; mode=display">(6):H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[(W^TV)_{a\mu} - (W^T WH)_{a\mu}]</script><p>如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $||V-WH||$。</p><p>如果我们按照斜向最陡调整变量，并设置：</p><script type="math/tex; mode=display">(7): \eta_{a\mu}=\frac{H_{a\mu}}{(W^TWH)_{a\mu}}</script><p>就能得到定理 1 中给出的 H 更新规则。注意，该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>对于散度公式，我们按照下述公式调整斜向最陡梯度下降：</p><script type="math/tex; mode=display">(8): H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[\sum_{i}W_{ia}\frac{V_{i\mu}}{(WH)_{i\mu}}-\sum_{i}W_{ia}]</script><p>同样的，如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $D(V||WH)$。如果设置：</p><script type="math/tex; mode=display">(9): \eta_{a\mu} = \frac{H_{a\mu}}{\sum_i W_{ia}}</script><p>那么就能得到定理 2 中给出的 H 更新规则。该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>由于我们对 $\eta_{a\mu}$ 的取值并不够小，看起来不能保证这种调整过后的梯度下降的代价函数减小。不过让人惊讶的是，如下节所示，上述假设是事实。</p><h2 id="收敛证明"><a href="#收敛证明" class="headerlink" title="收敛证明"></a>收敛证明</h2><p>我们将使用一个类似于 EM 算法的辅助函数来证明定理 1 与定理 2。</p><p><strong>定义 1</strong>：$G(h,h’)$ 是 $F(h)$ 的辅助函数，满足以下条件成立：</p><script type="math/tex; mode=display">(10): G(h,h')\geq F(h), G(h,h)=F(h)</script><p>根据下面的引理，此辅助函数是一个有用的概念。（在图1中的插图也显示了这一点）</p><p><strong>引理 1</strong>：如果 G 为辅助函数，则 F 在下述更新时为非增：</p><script type="math/tex; mode=display">(11): h^{t+1} = \arg\min_{h}G(h,h^t)</script><p><strong>证明</strong>：$F(h^{t+1}) \leq G(h^{t+1}, h^t) \leq G(h^t,h^t) = F(h^t)$</p><p>请注意，只有在$h^t$为$G(h,h^t)$的全局最小值时满足$F(h^{t+1})=F(h^t)$。如果 F 的导数存在，且在$h^{t}$的邻域连续，也就是说$\nabla F(h^t) = 0 $。因此通过公式11反复更新，我们就能得到目标函数收敛的局部最小值 $h_{min} = \arg\min_h F(h)$</p><script type="math/tex; mode=display">(12): F(h_{min}) \leq ... F(h^{t+1})\leq F(h^t) ... \leq F(h_2) \leq F(h_1) \leq F(h_0)</script><p><img src="https://lsvih.com/images/15408401601646.jpg" alt="-w663"></p><p>下面，我们证明如何为$||V-WH||$与$D(V,WH)$定义适当的辅助函数$G(h,h^t)$。定理 1 与定理 2 可以直接遵循公式 11 的更新规则。</p><p><strong>引理 2</strong>：如果$K(h^t)$为对角矩阵，</p><script type="math/tex; mode=display">(13): K_{ab}(h^t) = \delta_{ab}\frac{W^T Wh^t}{h^t_a}</script><p>则</p><script type="math/tex; mode=display">(14): G(h,h^t)=F(h^t)+(h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T K(h^t)(h-h^t)</script><p>为</p><script type="math/tex; mode=display">(15): F(h)=\frac{1}{2} \sum_i(v_i- \sum_a W_{ia} h_a)^2</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。为了证明此不等式，需要将</p><script type="math/tex; mode=display">(16): F(h) = F(h^t) + (h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T(W^TW)(h-h^t)</script><p>与公式 14 进行对比，发现 $G(h,h’) \geq F(h)$ 等价于</p><script type="math/tex; mode=display">(17): 0 \leq (h-h^t)^T[K(h^t) - W^TW](h-h^t)</script><p>为证明半正定情况，考虑矩阵：</p><script type="math/tex; mode=display">(18): M_{ab}(h^t)=h_a^t(K(h^t)-W^TW)_{ab}h_b^t</script><p>仅是$K-W^TW$的调整形式。因此，仅当 M 符合下列公式时，$K-W^TW$具有半正定性：</p><script type="math/tex; mode=display">(19):v^T Mv = \sum_{ab}v_a M_{ab} v_b \\(20):=\sum_{ab}h^t_a(W^TW)_{ab}h^t_bv_a^2-v_ah^t_a(W^TW)_{ab}h_b^tv_b \\(21):=\sum_{ab}(W^TW)_{ab}h_a^th_b^t[\frac{1}{2}v_a^2 + \frac{1}{2}v_b^2 - v_av_b] \\(22):=\frac{1}{2}\sum_{ab}(W^TW)_{ab}h_a^th_b^t(v_a-v_b)^2 \\(23):\geq 0</script><p>现在，我们可以证明定理 1 的收敛性。</p><p><strong>定理 1 证明</strong>：使用公式14的结果替换公式11中的$G(h,h^t)$，得到更新规则：</p><script type="math/tex; mode=display">(24): h^{t+1}=h^t - K(h^t)^{-1} \nabla F(h^t)</script><p>因为公式14为辅助函数，根据引理1，F 在更新规则中为非增。将上式完整的写下来，可以得到：</p><script type="math/tex; mode=display">(25): h^{t+1}_a= h^{t}_a \frac{(W^Tv)_a}{(W^TWh^t)_a}</script><p>反转引理 1 与引理 2 中 W 和 H 的角色，F 可以以类似的方法证明在 W 的更新规则下为非增。</p><p>接下来，我们为散度代价方程寻找辅助函数。</p><p><strong>引理 3</strong>：定义</p><script type="math/tex; mode=display">(26): G(h,h^t)=\sum_i(v_i \log{v_i} - v_i) + \sum_{ia} W_{ia}h_a \\(27):-\sum_{ia}v_i\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b} (\log{W_{ia} h_a - \log{\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b}}})</script><p>为</p><script type="math/tex; mode=display">(28): F(h)=\sum_i v_i \log(\frac{v_i}{\sum_a W_{ia} h_a})- v_i + \sum_a W_{ia} h_a</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。我们通过对数函数的凸性来推导此不等式：</p><script type="math/tex; mode=display">(29): -\log \sum_a W_{ia} h_a \leq -\sum_a a_a \log \frac{ W_{ia} h_a}{a_a}</script><p>上式对所有的联合求合数 $a_a$ 均成立。设</p><script type="math/tex; mode=display">(30): a_a =\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b}</script><p>可以得到：</p><script type="math/tex; mode=display">(31): -\log \sum_a W_{ia} h_a \leq - \sum_a \frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} (\log W_{ia} h_a - \log\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} )</script><p>上面的不等式遵循 $G(h,h’) \geq F(h)$。</p><p>定理 2 的证明遵循引理 1 及其应用：</p><p><strong>定理 2 证明</strong>：要令 $G(h,h^t)$ 最小化，则需要将梯度设为 0 来求出 h：</p><script type="math/tex; mode=display">(32): \frac{dG(h,h^t)}{dh_a} = - \sum_i v_i \frac{ W_{ia} h_a^t}{\sum_b W_{ib} h_b^t} \frac{1}{h_a} + \sum_i W_{ia} = 0</script><p>因此，公式 11 采取的更新规则应当如下所示：</p><script type="math/tex; mode=display">(33): h_a^{t+1} = \frac{h_a^t}{\sum_b W_{kb}} \sum_i \frac{v_i}{\sum_b W_{ib}h_b^t} W_{ia}</script><p>因为 G 为辅助函数，公式 28 中的 F 在更新规则中为非增。用矩阵形式重写上述公式，发现与 公式 5 的更新规则等价。反转 W 和 H 的角色，可以以类似的方法证明 F 在 W 的更新规则下为非增。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们已经证明了在公式 4 与公式 5 中应用更新规则，可以找到问题 1 与问题 2 的局部最优解。借助定义合适的辅助函数证明了函数的收敛性。我们将把这些证明推广到更复杂的约束条件下去。更新规则在计算上非常容易实现，有望进行广泛的应用。</p><p>感谢贝尔实验室的支持，以及 Carlos Brody, Ken Clarkson, Corinna Cortes, Roland Freund, Linda Kaufman, Yann Le Cun, Sam Roweis, Larry Saul, Margaret Wright 的帮助与讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NIPS 2000 经典论文 非负矩阵分解算法 翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;非负矩阵分解（NM
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="algorithm" scheme="https://lsvih.com/tags/algorithm/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="gradient descent" scheme="https://lsvih.com/tags/gradient-descent/"/>
    
  </entry>
  
  <entry>
    <title>关键词规则生成</title>
    <link href="https://lsvih.com/2018/10/29/%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90/"/>
    <id>https://lsvih.com/2018/10/29/关键词规则生成/</id>
    <published>2018-10-29T03:25:00.000Z</published>
    <updated>2018-10-29T03:29:33.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>提取关键词将得到一系列的词库，要将这些词应用于文本筛查、分类则必须要对这些词进行拆分、组合，形成特定的规则，再应用这些规则对文本进行匹配，得到某文本所对应的模式。</p><p>要生成规则，即需要从系列关键词通过某些算法找出在不同样本文本下关键词的共有特征（或规律），再对多种特征（或规律）进行组合得到某种策略，最终通过策略对目标文本进行判定。因此关键词规则生成可以总结为以下几个主要步骤：</p><ol><li>关键词特征或规律查找</li><li>策略生成</li><li>策略优化与化简</li></ol><p>对于关键词特征与规律的查找，可以视为机器学习中的分类问题的反向过程。分类问题简要来说即给定标注样本，通过特征训练，得到一个可适用于同类样本的分类策略。常用的分类方法包括决策树、SVM、神经网络等方法。</p><p>决策树算法是常用的数据分类算法。决策树算法具有以下优点：</p><ol><li>决策树算法中学习简单的决策规则建立决策树模型的过程非常容易理解</li><li>决策树模型可以可视化，非常直观</li><li>应用范围广，可用于分类和回归，而且非常容易做多类别的分类</li><li>能够处理数值型和连续的样本特征</li></ol><p>由于它生成分类策略的可解释性，以及树状结构的可编辑性，在本步骤中可选用决策树算法作为样本分类策略。</p><p>下图为对某样本文本进行决策树（CART）生成的分类器策略可视化图像：</p><p><img src="https://lsvih.com/images/15407837052758.jpg" alt="-w889"></p><p>可以从图片中看出，决策树算法根据样本标注训练而成了对应的基于关键词的文本分类器。此分类器策略为清晰的树状结构，每个节点代表一个判断条件，每个树杈代表一个条件分支。为了得到在特定计算性能高、可解释性更好的策略，需要对其进行进一步的策略挖掘及精简。</p><p>由于决策树得到的策略为树状结构，因此在这种结构上的进一步策略挖掘可选用盲目搜索算法；又由于此模型为树状结构，最终分类落于叶子节点中，故采用深度优先搜索（DFS）对此树的路径进行检索，进一步优化策略。</p><p>在决策树得到的规则通过深度优先搜索之后，会得到一系列的组别，每个组别中包含各个关键词的“与”和“或”两种逻辑关系。在目标文本中使用时，即可通过这些逻辑关系的匹配找出对应的模式。</p><p>但由于决策树得到的策略叶子节点通常较多（如上图所示），通过深度优先搜索得到的策略也非常繁杂，最终生成得到的规则也会非常复杂，因此还可以进行进一步的策略化简。</p><p>在此步骤中，实质上是对多个逻辑代数运算及逻辑代数复合运算组合而成的逻辑函数进行化简。逻辑函数的化简方法一般有如下三种：</p><ol><li>公式化简法</li><li>卡诺图法</li><li>Q-M 法</li></ol><p>由于在此步骤实际应用时逻辑规则较为繁杂，且“与”—“或”逻辑对较多，比起公式化简法或卡诺图法，Q-M 算法在选取出可以覆盖逻辑规则真值的最小质蕴涵项时更能发挥优势。</p><p>最终，通过决策树算法生成树、对决策树进行深度优先搜索得到包含“与”、“或”的分类逻辑、对分类逻辑应用 Q-M 算法，最终得到了包含“与”、“或”、“非”三种逻辑关系的可解释性强、精简的规则。</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一个树结构，其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。运用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树算法是通过一系列规则对数据进行分类的过程。</p><p>决策树算法构造决策树来发现数据中蕴涵的分类规则．如何构造精度高、规模小的决策树是决策树算法的核心内容。决策树构造可以分两步进行：</p><p>第一步，决策树的生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集。</p><p>第二步，决策树的剪枝：决策树的剪枝是对上一阶段生成的决策树进行检验、校正和修下的过程，主要是用新的样本数据集（称为测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除。</p><p>在第一步决策树的生成中，需要确定树杈的分裂属性（即在多个自变量中，优先选择哪个自变量进行分叉）。而采用何种计算方式选择树杈决定了决策树算法的类型，典型的分裂属性的选择的方法有 ID3 算法、C4.5 算法、CART 算法三种，三种决策树算法选择树杈的方式是不一样的。</p><h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><p>ID3 算法是目前决策树算法中较有影响力的算法，于 1986 年由 Quinlan 提出。该算法只是一个启发式算法。ID3 算法的核心是判断测试哪个属性为最佳的分类属性。ID3 算法选择分裂后信息增益最大的属性进行分裂，以信息增益度量属性选择。ID3 算法中常用到的两个概念是熵和信息增益。</p><p>熵是刻画任意样本例集的纯度，如果目标属性具有 m 个不同的值，那么 D 相对于 m 这个状态的分类的熵定义为：</p><script type="math/tex; mode=display">\text{inf}\ o(D) = -\sum^m_{i=1}p_i \log_2 (P_i)</script><p>其中 Pi 表示 Pi 是 m 类别的比例。</p><p>一个属性的信息增益就是由于使用这个属性分割样例而导致的期望熵降低，更精确来讲，一个属性A相对样本例集合S的信息增益 Gain(S，A) 被定义为：</p><script type="math/tex; mode=display">gain(A) = info(D) - infoA(D)</script><p>A 对 D 划分的期望信息为：</p><script type="math/tex; mode=display">\text{inf}\ o_A(D) = \sum^v_{j=1} \frac{|D_j|}{|D|} \text{inf}\ o(D_j)</script><p>ID3 算法不足之处是只能处理离散型数据，信息增益的选择分裂属性的方式会偏向选择具有大量值得属性。</p><h3 id="C4-5-算法"><a href="#C4-5-算法" class="headerlink" title="C4.5 算法"></a>C4.5 算法</h3><p>ID3 算法在实际应用中存在一些问题，于是 Quilan 在保留 ID3 算法优点基础上提出了 C4.5 算法，C4.5 算法只是 ID3 算法的改进算法。C4.5 算法采用最大信息增益率的属性被选为分裂属性。C4.5 算法中用到了“分裂信息”这一概念，该概念可以表示为：</p><script type="math/tex; mode=display">split\_ \text{inf}\ o_A(D) = -\sum^v_{j=1} \frac{|D_j|}{|D|} \log_2\frac{|D_j|}{|D|}</script><p>信息增益率的定义是：</p><script type="math/tex; mode=display">gain\_ratio(A) = \frac{gainA}{split\_\text{inf}\ o(A)}</script><p>C4.5 算法是对 ID3 算法的一种改进，改进后可以计算连续型属性的值。对于连续型属性的值，只需将连续型变量由小到大递增排序，取相邻连个值的中点作为分裂点，然后按照离散型变量计算信息增益的方法计算信息增益，取其中最大的信息增益作为最终的分裂点。</p><p>C4.5 算法继承了 ID3 算法的优点，并在以下几方面对 ID3 算法进行了改进：</p><ul><li><p>用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；</p></li><li><p>在树构造过程中进行剪枝；</p></li><li><p>能够完成对连续属性的离散化处理；能够对不完整的数据进行处理。</p></li></ul><h3 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h3><p>CART 算法选择分裂属性的方式首先要计算不纯度，然后利用不纯度计算 Gini 指标，然后计算有效子集的不纯度和 Gini 指标，选择最小的 Gini 指标作为分裂属性。</p><script type="math/tex; mode=display">Gini(D) = 1 - \sum^n_{i=0}(\frac{Di}{D})^2</script><script type="math/tex; mode=display">Gini(D|A) = \sum^n_{i=0} \frac{Di}{D} Gini(D i)</script><p>由于 CART 算法在处理离散数据上具有优势，因此对于关键词规则的生成可选用此方法生成决策树。</p><h2 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h2><p>搜索算法可分为盲目搜索算法和启发式搜索算法两种，二者的区别在于：启发式搜索算法的每一步都试图向着目标状态方向进行搜索，而盲目搜索算法则是每一步按照固定的规则进行搜索，然后判断是否达到目标状态。相比之下，启发式搜索算法克服了盲目搜索算法的盲目性问题。</p><p>虽然启发式搜索算法可以解决盲目搜索算法的盲搜索问题，但是在实际问题求解中，缺少一些必要的信息来构建启发式搜索算法，此时采用盲目搜索算法仍然是解决问题的有效手段。盲目搜索算法有两种：一种按照广度优先展开搜索树的搜索算法，叫广度优先搜索法；另一种则是按照深度优先展开搜索的搜索算法，叫深度优先搜索法算法。</p><p>深度优先搜索算法是优先扩展尚未扩展的且具有最大深度的节点；广度优先搜索法是在扩展完第 K 层的节点后才扩展 K+1 层的节点。在此应用深度优先搜索算法。</p><p>假设初始状态是图中所有顶点未曾被访问，从图中某个顶点 i 出发，访问此顶点，然后依次从 i 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 i 有路径的顶点都被访问为止。若此时图中尚有顶点未被访问，则另选图中未曾访问的顶点为起始点，重复上述过程，直至图中所有顶点都被访问为止。在节点遍历过程中，应该注意节点的回溯搜索以及避免节点被重复搜索。</p><p>在搜索过程中，如何避免被搜过的节点不被重复搜索以及节点的回溯是主要难点。根据关联矩阵以及深度优先搜索算法，从节点 i 搜索出节点 j，如果节点 j 已经被搜索过，那么修改关联矩阵中对应节点 i 和节点 j 的元素为 0，并返回节点 i 重新搜索与之相联的另一节点。当节点 j 是该条树枝的最后一个节点时，修改关联矩阵中相应的元素，并且返回节点 i 重新搜索与之相连的另一树枝。依此类推，直至遍历所有节点，也就是关联矩阵的所有元素都变为 0 时，停止搜索。在遍历各节点的同时，根据节点的先后顺序以及树枝集合，合理地安排各节点坐标。其搜索过程逻辑如下图所示：</p><p><img src="https://lsvih.com/images/15407837517781.jpg" alt="-w241"></p><h2 id="Q-M-算法"><a href="#Q-M-算法" class="headerlink" title="Q-M 算法"></a>Q-M 算法</h2><p>在得到只包含“与”、“或”的逻辑函数之后，可对逻辑进行更进一步的简化与合并，并加上“非”逻辑来使得逻辑函数更具解释性。</p><p>下图为一个简单逻辑函数的卡诺图，101 项被覆盖了 3 次，明显可对函数进行化简。</p><p><img src="https://lsvih.com/images/15407837648773.jpg" alt="-w386"></p><p>Q-M 算法是由 Quine 和 Mccluskey 提出的一种系统列表化简法。这种化简方法和卡诺图化简法的基本思想大致相同, 是通过找出函数 F 的全部质蕴涵项、必要质蕴涵项以及最简质蕴涵项集来求得最简表达式。</p><p>下面为蕴含项与质蕴涵项的定义：</p><p>蕴涵项：在函数的“与”—“或”表达式中，每个“与”项被称为该函数的蕴涵项。显然在函数卡诺图中，任何一个  1 方格所对应的最小项或者卡诺圈中的 $2^n$ 个 1 方格所对应的“与”项都是函数的蕴涵项。</p><p>质蕴涵项：若函数的一个蕴涵项不是该函数中其它蕴涵项的子集，则此蕴涵项称为质蕴涵项，简称为质项。显然在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈不可能被其它更大的卡诺圈包含，那么该卡诺圈所对应的“与”项为质蕴涵项。</p><p>必要质蕴涵项：若函数的一个质蕴涵项所包含的某一个最小项不被函数的其它任何质蕴涵项包含，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项。在函数卡诺图中，若某个卡诺圈包含了不可能被任何其它卡诺圈包含的 1 方格，那么该卡诺圈所对应的“与”项为必要质蕴涵项。</p><p>一般的化简步骤是：  </p><p>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每—个最小项。</p><p>第二步：找出函数的全部质蕴涵项。先将 n 个变量函数中的相邻最小项合并，消去相异的—个变量，得到 (n-1) 个变量的“与”项，再将相邻的 (n-1) 个变量的“与”项合并，消去相异的变量，得到 (n-2) 个变量的“与”项。依此类推，直到不能再合并为止。所得到的全部不能再合并的“与”项（包括不能合并的最小项），即所要求的全部质蕴涵项。</p><p>第三步：找出函数的必要质蕴涵项。 </p><p>第四步：找出函数的最小覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;提取关键词将得到一系列的词库，要将这些词应用于文本筛查、分类则必须要对这些词进行拆分、组合，形成特定的规则，再应用这些规则对文本进行匹配，得
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://lsvih.com/categories/Algorithm/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Python 的多线程与多进程</title>
    <link href="https://lsvih.com/2018/08/28/Python-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://lsvih.com/2018/08/28/Python-的多线程与多进程/</id>
    <published>2018-08-28T07:04:00.000Z</published>
    <updated>2018-10-28T16:12:59.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初学者的并行编程指南"><a href="#初学者的并行编程指南" class="headerlink" title="初学者的并行编程指南"></a>初学者的并行编程指南</h2><p><img src="https://lsvih.com/images/pasted-322.png" alt="upload successful"></p><p>在参加 Kaggle 的 <a href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space" target="_blank" rel="noopener">Understanding the Amazon from Space</a> 比赛时，我试图对自己代码的各个部分进行加速。速度在 Kaggle 比赛中至关重要。高排名常常需要尝试数百种模型结构与超参组合，能在一个持续一分钟的 epoch 中省出 10 秒都是一个巨大的胜利。</p><p>让我吃惊的是，数据处理是最大的瓶颈。我用了 Numpy 的矩阵旋转、矩阵翻转、缩放及裁切等操作，在 CPU 上进行运算。Numpy 和 Pytorch 的 DataLoader 在某些情况中使用了并行处理。我同时会运行 3 到 5 个实验，每个实验都各自进行数据处理。但这种处理方式看起来效率不高，我希望知道我是否能用并行处理来加快所有实验的运行速度。</p><a id="more"></a><h3 id="什么是并行处理？"><a href="#什么是并行处理？" class="headerlink" title="什么是并行处理？"></a>什么是并行处理？</h3><p>简单来说就是在同一时刻做两件事情，也可以是在不同的 CPU 上分别运行代码，或者说当程序等待外部资源（文件加载、API 调用等）时把“浪费”的 CPU 周期充分利用起来提高效率。</p><p>下面的例子是一个“正常”的程序。它会使用单线程，依次进行下载一个 URL 列表的内容。</p><p><img src="https://lsvih.com/images/pasted-323.png" alt="upload successful"></p><p>下面是一个同样的程序，不过使用了 2 个线程。它把 URL 列表分给不同的线程，处理速度几乎翻倍。</p><p><img src="https://lsvih.com/images/pasted-324.png" alt="upload successful"></p><p>如果你对如何绘制以上图表感到好奇，可以参考<a href="https://github.com/bfortuner/ml-study/blob/master/multitasking_python.ipynb" target="_blank" rel="noopener">源码</a>，下面也简单介绍一下：</p><ol><li>在你函数内部加上一个计时器，并返回函数执行的起始与结束时间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URLS = [url1, url2, url3, ...]</span><br><span class="line">def download(url, base):</span><br><span class="line">    start = time.time() - base</span><br><span class="line">    resp = urlopen(url)</span><br><span class="line">    stop = time.time() - base</span><br><span class="line">    return start,stop</span><br></pre></td></tr></table></figure><ol><li>单线程程序的可视化如下：多次执行你的函数，并将多个开始结束的时间存储下来</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = [download(url, 1) for url in URLS]</span><br></pre></td></tr></table></figure><ol><li>将 [start, stop] 的结果数组进行转置，绘制柱状图</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def visualize_runtimes(results):</span><br><span class="line">    start,stop = np.array(results).T</span><br><span class="line">    plt.barh(range(len(start)), stop-start, left=start)</span><br><span class="line">    plt.grid(axis=’x’)</span><br><span class="line">    plt.ylabel(&quot;Tasks&quot;)</span><br><span class="line">    plt.xlabel(&quot;Seconds&quot;)</span><br></pre></td></tr></table></figure><p>多线程的图表生成方式与此类似。Python 的并发库一样可以返回结果数组。</p><h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a><strong>进程 vs 线程</strong></h3><p>一个<strong>进程</strong>就是一个程序的实例（比如 Jupyter notebook 或 Python 解释器）。进程启动<strong>线程</strong>（子进程）来处理一些子任务（比如按键、加载 HTML 页面、保存文件等）。线程存活于进程内部，线程间共享相同的内存空间。</p><p><strong>举例：Microsoft Word</strong><br>当你打开 Word 时，你其实就是创建了一个进程。当你开始打字时，进程启动了一些线程：一个线程专门用于获取键盘输入，一个线程用于显示文本，一个线程用于自动保存文件，还有一个线程用于拼写检查。在启动这些线程之后，Word 就能更好的利用空闲的 CPU 时间（等待键盘输入或文件加载的时间）让你有更高的工作效率。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h4><ul><li>由操作系统创建，以运行程序</li><li>一个进程可以包括多个线程</li><li>两个进程可以在 Python 程序中同时执行代码</li><li>启动与终止进程需要花费更多的时间，因此用进程比用线程的开销更大</li><li>由于进程不共享内存空间，因此进程间交换信息比线程间交换信息要慢很多。在 Python 中，用序列化数据结构（如数组）的方法进行信息交换会花费 IO 处理级别的时间。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h4><ul><li>线程是在进程内部的类似迷你进程的东西</li><li>不同的线程共享同样的内存空间，可以高效地读写相同的变量</li><li>两个线程不能在同一个 Python 程序中执行代码（有解决这个问题的方法<code>*</code>）</li></ul><h4 id="CPU-vs-核"><a href="#CPU-vs-核" class="headerlink" title="CPU vs 核"></a>CPU vs 核</h4><p><strong>CPU</strong>，或者说处理器，管理着计算机最基本的运算工作。CPU 有一个或着多个<strong>核</strong>，可以让 CPU 同时执行代码。</p><p>如果只有一个核，那么对 CPU 密集型任务（比如循环、运算等）不会有速度的提升。操作系统需要在很小的时间片在不同的任务间来回切换调度。因此，做一些很琐碎的操作（比如下载一些图片）时，多任务处理反而会降低处理性能。这个现象的原因是在启动与维护多个任务时也有性能的开销。</p><h4 id="Python-的-GIL-锁问题"><a href="#Python-的-GIL-锁问题" class="headerlink" title="Python 的 GIL 锁问题"></a><strong>Python 的 GIL 锁问题</strong></h4><p>CPython（python 的标准实现）有一个叫做 <a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">GIL</a>（全局解释锁）的东西，会阻止在程序中同时执行两个线程。一些人非常不喜欢它，但也有一些人喜欢它。目前有一些解决它的方法，不过 Numpy 之类的库大都是通过执行外部 C 语言代码来绕过这种限制。</p><h4 id="何时使用线程，何时使用进程？"><a href="#何时使用线程，何时使用进程？" class="headerlink" title="何时使用线程，何时使用进程？"></a><strong>何时使用线程，何时使用进程？</strong></h4><ul><li>得益于多核与不存在 GIL，<strong>多进程</strong>可以加速 CPU 密集型的 Python 程序。</li><li><strong>多线程</strong>可以很好的处理 IO 任务或涉及外部系统的任务，因为线程可以将不同的工作高效地结合起来。而进程需要对结果进行序列化才能汇聚多个结果，这需要消耗额外的时间。</li><li>由于 GIL 的存在，<strong>多线程</strong>对 CPU 密集的 Python 程序没有什么帮助。</li></ul><p><code>*</code>对于点积等某些运算，Numpy 绕过了 Python 的 GIL 锁，能够并行执行代码。</p><h3 id="并行处理示例"><a href="#并行处理示例" class="headerlink" title="并行处理示例"></a>并行处理示例</h3><p>Python 的 <a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener">concurrent.futures 库</a>用起来轻松愉快。你只需要简单的将函数、待处理的对象列表和并发的数量传给它即可。在下面几节中，我会以几种实验来演示何时使用线程何时使用进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def multithreading(func, args, </span><br><span class="line">                   workers):</span><br><span class="line">    with ThreadPoolExecutor(workers) as ex:</span><br><span class="line">        res = ex.map(func, args)</span><br><span class="line">    return list(res)</span><br><span class="line"></span><br><span class="line">def multiprocessing(func, args, </span><br><span class="line">                    workers):</span><br><span class="line">    with ProcessPoolExecutor(work) as ex:</span><br><span class="line">        res = ex.map(func, args)</span><br><span class="line">    return list(res)</span><br></pre></td></tr></table></figure><h4 id="API-调用"><a href="#API-调用" class="headerlink" title="API 调用"></a><strong>API 调用</strong></h4><p>对于 API 调用，多线程明显比串行处理与多进程速度要快很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def download(url):</span><br><span class="line">    try:</span><br><span class="line">        resp = urlopen(url)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (&apos;ERROR: %s&apos; % e)</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/pasted-325.png" alt="upload successful"></p><p><strong>2 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-326.png" alt="upload successful"></p><p><strong>4 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-327.png" alt="upload successful"></p><p><strong>2 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-328.png" alt="upload successful"></p><p><strong>4 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-329.png" alt="upload successful"></p><h4 id="IO-密集型任务"><a href="#IO-密集型任务" class="headerlink" title="IO 密集型任务"></a><strong>IO 密集型任务</strong></h4><p>我传入了一个巨大的文本，以观测线程与进程的写入性能。线程效果较好，但多进程也让速度有所提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def io_heavy(text):</span><br><span class="line">    f = open(&apos;output.txt&apos;, &apos;wt&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    f.write(text)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p><strong>串行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%timeit -n 1 [io_heavy(TEXT,1) for i in range(N)]</span><br><span class="line">&gt;&gt; 1 loop, best of 3: 1.37 s per loop</span><br></pre></td></tr></table></figure><p><strong>4 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-330.png" alt="upload successful"></p><p><strong>4 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-331.png" alt="upload successful"></p><h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p>由于没有 GIL，可以在多核上同时执行代码，多进程理所当然的胜出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def cpu_heavy(n):</span><br><span class="line">    count = 0</span><br><span class="line">    for i in range(n):</span><br><span class="line">        count += i</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/pasted-332.png" alt="upload successful"></p><p><strong>串行：</strong> 4.2 秒<br><strong>4 个线程：</strong> 6.5 秒<br><strong>4 个进程：</strong> 1.9 秒</p><h4 id="Numpy-中的点积"><a href="#Numpy-中的点积" class="headerlink" title="Numpy 中的点积"></a>Numpy 中的点积</h4><p>不出所料，无论是用多线程还是多进程都不会对此代码有什么帮助。Numpy 在幕后执行外部的 C 语言代码，绕开了 GIL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def dot_product(i, base):</span><br><span class="line">    start = time.time() - base</span><br><span class="line">    res = np.dot(a,b)</span><br><span class="line">    stop = time.time() - base</span><br><span class="line">    return start,stop</span><br></pre></td></tr></table></figure><p><strong>串行：</strong> 2.8 秒<br><strong>2 个线程：</strong> 3.4 秒<br><strong>2 个进程：</strong> 3.3 秒</p><p>以上实验的 Notebook 请<a href="https://github.com/bfortuner/ml-study/blob/master/multitasking_python.ipynb" target="_blank" rel="noopener">参考此处</a>，你可以自己来复现这些实验。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><p>以下是我在探索这个主题时的一些参考文章。特别推荐 Nathan Grigg 的<a href="https://nathangrigg.com/2015/04/python-threading-vs-processes" target="_blank" rel="noopener">这篇博客</a>，给了我可视化方法的灵感。</p><ul><li><p><a href="http://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python" target="_blank" rel="noopener"><strong>Multiprocessing vs Threading Python</strong>: I am trying to understand the advantages of multiprocessing over threading. I know that multiprocessing gets around the…</a></p></li><li><p><a href="http://stackoverflow.com/questions/5260068/multithreaded-blas-in-python-numpy" target="_blank" rel="noopener"><strong>multithreaded blas in python/numpy</strong>: I re-run the the benchmark on our new HPC. Both the hardware as well as the software stack changed from the setup in…</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank" rel="noopener"><strong>Amdahl’s law - Wikipedia</strong>: In computer architecture, Amdahl’s law (or Amdahl’s argument) is a formula which gives the theoretical speedup in…</a></p></li><li><p><a href="http://stackoverflow.com/questions/8463741/how-linux-handles-threads-and-process-scheduling" target="_blank" rel="noopener"><strong>How Linux handles threads and process scheduling</strong>: The Linux kernel scheduler is actually scheduling tasks, and these are either threads or (single-threaded) processes…</a></p></li><li><p><a href="http://stackoverflow.com/questions/1718465/optimal-number-of-threads-per-core/10670440#10670440" target="_blank" rel="noopener"><strong>Optimal number of threads per core</strong>: Let’s say I have a 4-core CPU, and I want to run some process in the minimum amount of time. The process is ideally…</a></p></li><li><p><a href="http://stackoverflow.com/questions/481970/how-many-threads-is-too-many" target="_blank" rel="noopener"><strong>How many threads is too many?</strong>: I am writing a server, and I branch each action of into a thread when the request is incoming. I do this because almost…</a></p></li></ul><blockquote><p>juejin:<a href="https://juejin.im/post/5b84f3086fb9a01a1a27cedb#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b84f3086fb9a01a1a27cedb#heading-14</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初学者的并行编程指南&quot;&gt;&lt;a href=&quot;#初学者的并行编程指南&quot; class=&quot;headerlink&quot; title=&quot;初学者的并行编程指南&quot;&gt;&lt;/a&gt;初学者的并行编程指南&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/pasted-322.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;在参加 Kaggle 的 &lt;a href=&quot;https://www.kaggle.com/c/planet-understanding-the-amazon-from-space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding the Amazon from Space&lt;/a&gt; 比赛时，我试图对自己代码的各个部分进行加速。速度在 Kaggle 比赛中至关重要。高排名常常需要尝试数百种模型结构与超参组合，能在一个持续一分钟的 epoch 中省出 10 秒都是一个巨大的胜利。&lt;/p&gt;
&lt;p&gt;让我吃惊的是，数据处理是最大的瓶颈。我用了 Numpy 的矩阵旋转、矩阵翻转、缩放及裁切等操作，在 CPU 上进行运算。Numpy 和 Pytorch 的 DataLoader 在某些情况中使用了并行处理。我同时会运行 3 到 5 个实验，每个实验都各自进行数据处理。但这种处理方式看起来效率不高，我希望知道我是否能用并行处理来加快所有实验的运行速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Back End" scheme="https://lsvih.com/tags/Back-End/"/>
    
      <category term="python" scheme="https://lsvih.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 PhpFastCache 提升网站性能</title>
    <link href="https://lsvih.com/2018/07/23/%E4%BD%BF%E7%94%A8-PhpFastCache-%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/"/>
    <id>https://lsvih.com/2018/07/23/使用-PhpFastCache-提升网站性能/</id>
    <published>2018-07-22T18:48:00.000Z</published>
    <updated>2018-10-28T16:13:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>本文将与你一同探索 PhpFastCache 库，来为你的 PHP 应用实现缓存功能。通过缓存功能，能够提升网站的整体性能与页面加载速度。</p><h2 id="什么是-PhpFastCache？"><a href="#什么是-PhpFastCache？" class="headerlink" title="什么是 PhpFastCache？"></a>什么是 PhpFastCache？</h2><p>PhpFastCache 是一个能让你轻松在 PHP 应用中实现缓存功能的库。它的功能强大，且简单易用，提供了一些 API 以无痛实现缓存策略。</p><p>PhpFastCache 不是一个纯粹的传统文件系统式缓存。它支持各种各样的文件适配器（Files Adapter），可以让你选择 Memcache、Redis、MongoDB、CouchDB 等高性能的后端服务。</p><p>让我们先总览一遍最流行的适配器：</p><ul><li>文件系统</li><li>Memcache、Redis 和 APC</li><li>CouchDB 和 MongoDB</li><li>Zend Disk Cache 和 Zend Memory Cache</li></ul><p>如果你用的文件适配器不在上面的列表中，也可以简单地开发一个自定义驱动，插入到系统中，同样也能高效地运行。</p><p>除了基本功能外，PhpFastCache 还提供了事件机制，可以让你对预定义好的事件进行响应。例如，当某个事物从缓存中被删除时，你可以接收到这个事件，并去刷新或删除相关的数据。</p><p>在下面的章节中，我们将通过一些示例来了解如何安装及配置 PhpFastCache。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在本节中，我们将了解如何安装及配置 PhpFastCache。下面是几种将它集成进项目的方法。</p><p>如果你嫌麻烦，仅准备下载这个库的 <strong>.zip</strong> 或者 <strong>.tar.gz</strong> 文件，可以去<a href="https://www.phpfastcache.com/" target="_blank" rel="noopener">官方网站</a>直接下载。</p><p>或者你也可以用 Composer 包的方式来安装它。这种方式更好，因为在之后的维护和升级时会更方便。如果你还没有安装 Composer，需要先去安装它。</p><p>当你安装好 Composer 之后，可以用以下命令下载 PhpFastCache：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$composer</span> require phpfastcache/phpfastcache</span><br></pre></td></tr></table></figure><p>命令完成后，你会得到一个 vendor 目录，在此目录中包括了全部 PhpFastCache 所需的文件。另外，如果你缺失了 PhpFastCache 依赖的库或插件，Composer 会提醒你先去安装依赖。</p><p>你需要找到 <code>composer.json</code> 文件，它类似于下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"phpfastcache/phpfastcache"</span>: <span class="string">"^6.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你通过什么方式来安装的 PhpFastCache，都要在应用中 include <strong>autoload.php</strong> 文件。</p><p>如果你用的是基于 Composer 的工作流，<strong>autoload.php</strong> 文件会在 <strong>vendor</strong> 目录中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'&#123;YOUR_APP_PATH&#125;/vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure><p>另外，如果你是直接下载的 <strong>.zip</strong> 和 <strong>.tar.gz</strong>，<strong>autoload.php</strong> 的路径会在 <strong>src/autoload.php</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'&#123;YOUR_APP_PATH&#125;/src/autoload.php'</span>;</span><br></pre></td></tr></table></figure><p>只要完成上面的操作，就能开始进行缓存，享受 PhpFastCache 带来的好处了。在下一章节中，我们将以一个简单的示例来介绍如何在你的应用中使用 PhpFastCache。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>前面我提到过，PhpFastCache 支持多种文件适配器进行缓存。在本节中，我会以文件系统和 Redis 这两种文件适配器为例进行介绍。</p><h3 id="使用文件适配器进行缓存"><a href="#使用文件适配器进行缓存" class="headerlink" title="使用文件适配器进行缓存"></a>使用文件适配器进行缓存</h3><p>创建 <strong>file_cache_example.php</strong> 文件并写入下面的代码。在此我假设你使用的是 Composer workflow，因此 <strong>vendor</strong> 目录会与 <strong>file_cache_example.php</strong> 文件同级。如果你是手动安装的 PhpFastCache，需要根据实际情况修改文件结构。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with "file system" adapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for "files" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"path"</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">"/cache"</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objFilesCache = CacheManager::getInstance(<span class="string">'files'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objFilesCache-&gt;getItem($key);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objFilesCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们一块一块地来理解代码。首先看到的是将 <strong>autoload.php</strong> 文件引入，然后导入要用到的 namespace：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br></pre></td></tr></table></figure><p>当你使用文件缓存的时候，最好提供一个目录路径来存放缓存系统生成的文件。下面的代码就是做的这件事：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for "files" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"path"</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">"/cache"</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>当然，你需要确保 <strong>cache</strong> 目录存在且 web server 有写入权限。</p><p>接下来，我们将缓存对象实例化，用 <strong>welcome_message</strong> 加载对应的缓存对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objFilesCache = CacheManager::getInstance(<span class="string">'files'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objFilesCache-&gt;getItem($key);</span><br></pre></td></tr></table></figure><p>如果缓存中不存在此对象，就将它以 60s 过期时间加入缓存，并从缓存中读取与展示它。如果它存在于缓存中，则直接获取：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objFilesCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常容易上手对吧！你可以试着自己去运行一下这个程序来查看结果。</p><p>当你第一次运行这个程序时，应该会看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not in cache yet, we set it in cache and try to get it from cache!</span><br><span class="line">The value of welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure><p>之后再运行的时候，输出会是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Already in cache!</span><br><span class="line">The value of welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure><p>现在就能随手实现文件系统缓存了。在下一章节中，我们将模仿这个例子来使用 Redis Adapter 实现缓存。</p><h3 id="使用-Redis-Adapter-进行缓存"><a href="#使用-Redis-Adapter-进行缓存" class="headerlink" title="使用 Redis Adapter 进行缓存"></a>使用 Redis Adapter 进行缓存</h3><p>假定你在阅读本节前已经安装好了 Redis 服务，并让它运行在 6379 默认端口上。</p><p>下面进行配置。创建 <strong>redis_cache_example.php</strong> 文件并写入以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with "redis" adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Make sure php-redis extension is installed along with Redis server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for "redis" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"host"</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  <span class="string">"port"</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objRedisCache = CacheManager::getInstance(<span class="string">'redis'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objRedisCache-&gt;getItem($key);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objRedisCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，除了初始化 Redis 适配器的配置一段之外，这个文件与之前基本一样。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for "redis" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"host"</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  <span class="string">"port"</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>当然如果你要在非本机运行 Redis 服务，需要根据需求修改 host 与 port 的设置。</p><p>运行 <strong>redis_cache_example.php</strong> 文件来查看它的工作原理。你也可以在 Redis CLI 中查看输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;welcome_message&quot;</span><br></pre></td></tr></table></figure><p>以上就是使用 Redis 适配器的全部内容。你可以去多试试其它不同的适配器和配置！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了 PhpFastCache 这个 PHP 中非常热门的库。在文章前半部分，我们讨论了它的基本知识以及安装和配置。在文章后半部分，我们通过几个例子来详细演示了前面提到的概念。</p><p>希望你喜欢这篇文章，并将 PhpFastCache 集成到你即将开发的项目中。随时欢迎提问和讨论！</p><blockquote><p>掘金：<a href="https://juejin.im/post/5b54d01be51d4517c5649965" target="_blank" rel="noopener">https://juejin.im/post/5b54d01be51d4517c5649965</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将与你一同探索 PhpFastCache 库，来为你的 PHP 应用实现缓存功能。通过缓存功能，能够提升网站的整体性能与页面加载速度。&lt;/p&gt;
&lt;h2 id=&quot;什么是-PhpFastCache？&quot;&gt;&lt;a href=&quot;#什么是-PhpFastCache？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="PHP" scheme="https://lsvih.com/tags/PHP/"/>
    
      <category term="Cache" scheme="https://lsvih.com/tags/Cache/"/>
    
      <category term="Backend" scheme="https://lsvih.com/tags/Backend/"/>
    
  </entry>
  
</feed>
