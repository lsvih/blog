<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My note</title>
  
  <subtitle>lsvih</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lsvih.com/"/>
  <updated>2019-08-05T14:54:58.090Z</updated>
  <id>https://lsvih.com/</id>
  
  <author>
    <name>lsvih</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XGBoost 算法万岁！</title>
    <link href="https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/"/>
    <id>https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/</id>
    <published>2019-08-05T14:50:00.000Z</published>
    <updated>2019-08-05T14:54:58.090Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/15650167189931.jpg" alt="Photo By Jared Subia"></p><a id="more"></a><blockquote><p>机器学习算法的新女王将接管整个世界……</p></blockquote><p>（本文与 <a href="https://towardsdatascience.com/u/e15e82916c90" target="_blank" rel="noopener">Venkat Anurag Setty</a> 共同完成）</p><p>我还记得 15 年前我的第一份工作。那时，我刚完成研究生课程，作为一名分析师加入了一家国际投行。在入职的第一天，我小心翼翼地工作，不断回想学过的知识，心里想着自己是否能胜任这个企业的工作。老板感受到了我的焦虑，笑着对我说：</p><p><strong>“别担心！你只要了解回归模型就行了！”</strong></p><p>我仔细想了想，“明白了！” —— 无论是线性回归还是逻辑回归我都了解。老板是对的，在我的任期内，专门构建基于回归的统计学模型。我并不是孤身一人，因为在那时，回归模型是无可争议的预测分析女王。15 年后，回归模型的时代结束了，这位老女王已经退位。新上任的女王有着时髦的名字：XGBoost 或 Extreme Gradient Boosting。</p><hr><h2 id="什么是-XGBoost？"><a href="#什么是-XGBoost？" class="headerlink" title="什么是 XGBoost？"></a>什么是 XGBoost？</h2><p><a href="https://xgboost.ai/" target="_blank" rel="noopener">XGBoost</a> 是一种基于决策树的集成（ensemble）机器学习算法，使用了<a href="https://en.wikipedia.org/wiki/Gradient_boosting" target="_blank" rel="noopener">梯度提升（gradient boosting）</a>框架。在非结构化数据（如图像、文本等）的预测问题中，人工神经网络效果好于其它所有算法和框架；然而，在解决中小型的结构化、扁平化数据时，基于决策树的算法才是最好的。下面的图表展示了近年来基于树的算法的演变过程：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QJZ6W-Pck_W7RlIDwUIN9Q.jpeg" alt="Evolution of XGBoost Algorithm from Decision Trees"></p><p>XGBoost 算法是华盛顿大学在科研工程中开发的。<a href="https://arxiv.org/pdf/1603.02754.pdf" target="_blank" rel="noopener">陈天奇与 Carlos Guestrin</a> 在 SIGKDD 2016 上发表了他们的论文，迅速吸引了机器学习界的注意。自从 XGBoost 推出以来，它不仅在许多 Kaggle 竞赛中获得了胜利，还为一些顶尖的业界应用提供了动力。因此，形成了一个强大的数据科学家社区为 XGBoost 做贡献，目前 <a href="https://github.com/dmlc/xgboost/" target="_blank" rel="noopener">GitHub</a> 上的 XGBoost 项目有 350 余名贡献者，3600 余条 commit 记录。XGBoost 算法还在下面几个方面极为出众：</p><ol><li>应用广泛：可以用于解决回归、分类、排序和其它用户自定义的预测问题；</li><li>可移植性：在 Windows、Linux 和 OS X 系统中都能顺畅运行；</li><li>语言：支持包括 C++、Python、R、Java、Scala 和 Julia 等全部主流编程语言；</li><li>云端集成：支持 AWS、Azure、Yarn 集群，并与 Flink、Spark 等生态系统配合无间。</li></ol><hr><h2 id="如何直观地理解-XGBoost？"><a href="#如何直观地理解-XGBoost？" class="headerlink" title="如何直观地理解 XGBoost？"></a>如何直观地理解 XGBoost？</h2><p>决策树在最简单的形式下，是最易于可视化以及最具可解释性的算法，但想要直观的理解新一代的基于树的算法可能会有些困难。可以用下面的类比来更好地了解基于树的算法的演变。</p><p><img src="https://cdn-images-1.medium.com/max/11030/1*Uwbv9Nzv7uoZV_hJwrsPGQ.jpeg" alt="[rawpixel](https://unsplash.com/photos/cnseVhmbA7k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) 供图[Unsplash](https://unsplash.com/search/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"></p><p>设想你是一名 HR，要对几名优秀的候选人进行面试。而基于树的算法的演变过程的每一步，都可以视为是面试过程的一个版本。</p><ol><li><p><strong>决策树（Decision Tree）</strong>：每个 HR 都有一系列标准，比如学历、工作年份、面试表现等。一个决策树就类似于一个 HR 基于他的这些标准来筛选候选人。</p></li><li><p><strong>Bagging</strong>：假设现在不只有一个面试官，而是有一个面试小组，组中每个面试官都有投票权。Bagging 和 Bootstrap 就是通过一个民主投票的过程，将所有面试官的输入聚合起来，得到一个最终的决定。</p></li><li><p><strong>随机森林（Random Forest）</strong>：它是一种基于 Bagging 的算法，关键点在于随机森林会随机使用特征的子集。换句话说，就是每个面试官都只会用一些随机选择的标准来考验候选人的任职资格（比如，技术面值考察编程技能，行为面只考察非技术相关的技能）。</p></li><li><p><strong>Boosting</strong>：这是一种替代方法，每个面试官都会根据上一个面试官的面试结果来改变自己的评价标准。通过利用更加动态的评估过程，可以提升（boost）面试过程的效率。</p></li><li><p><strong>梯度提升（Gradient Boosting）</strong>：Boosting 的特例，用梯度下降算法来将误差最小化。比如，咨询公司用案例面试来剔除不太合格的候选人。</p></li><li><p><strong>XGBoost</strong>：可以认为 XGBoost 就是“打了兴奋剂”的梯度提升（因此它全称是“Extreme Gradient Boosting” —— 极端梯度提升）。它是软件和硬件优化技术的完美结合，可以在最短的时间内用较少的计算资源得到出色的结果。</p></li></ol><hr><h2 id="为什么-XGBoost-效果这么好？"><a href="#为什么-XGBoost-效果这么好？" class="headerlink" title="为什么 XGBoost 效果这么好？"></a>为什么 XGBoost 效果这么好？</h2><p>XGBoost 和梯度提升机（Gradient Boosting Machines，GBM）都是集成（ensemble）树方法，原理都是用梯度下降架构来对多个弱分类器（通常是 <a href="https://www.datasciencecentral.com/profiles/blogs/introduction-to-classification-regression-trees-cart" target="_blank" rel="noopener">CARTs</a>）进行提升（boosting）。不过，XGBoost 通过系统优化与算法强化在 GBM 框架上进行了改进。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*FLshv-wVDfu-i54OqvZdHg.png" alt="XGBoost 是如何优化标准 GBM 算法的"></p><p><strong>系统优化：</strong></p><ol><li><p><strong>并行化</strong>：XGBoost 通过<a href="http://zhanpengfang.github.io/418home.html" target="_blank" rel="noopener">并行化</a>方法来实现顺序的建树过程。由于基础学习器循环内部（包括用于枚举树的叶子节点的外部循环，以及用于计算特征的内部循环）的可互换性，因此才能这么做；循环的嵌套会限制并行化，因为如果没有完成两个开销更大的内部循环，就不能开始新的外部循环。XGBoost 算法通过使用并行线程对所有实例进行全局扫描和排序来进行初始化，使得循环的顺序变得可交换，从而减少了运行的时间。这样做，可以抵消并行化开销而提升算法性能。</p></li><li><p><strong>树剪枝</strong>：在 GBM 框架中，树停止分裂的标准本质上是贪婪的，取决于分裂点的 loss 值。而 XGBoost 用 <code>max_depth</code> 这一参数而非某个指标来停止分裂，然后开始反过来对树进行剪枝。这种“深度优先”的方法显著提高了计算性能。</p></li><li><p><strong>硬件优化</strong>：XGBoost 算法就是为了高效利用硬件资源而设计的。它为每个线程都分配了内部缓存区，用于存储梯度统计信息。另外，利用“核外计算”方法，在处理不适合放在内存中的大数据切片时，进一步优化磁盘可用空间。</p></li></ol><p><strong>算法强化：</strong></p><ol><li><p><strong>正则化（Regularization）</strong>：XGBoost 同时通过 LASSO（L1）与 Ridge（L2）<a href="https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c" target="_blank" rel="noopener">正则化</a>惩罚过于复杂的模型，从而避免过拟合。</p></li><li><p><strong>稀疏意识（Sparsity Awareness）</strong>：XGBoost 会根据训练 loss 自动“学习”输入中的缺失值，从而自然地接收稀疏特征，并更高效地处理各种<a href="https://www.kdnuggets.com/2017/10/xgboost-concise-technical-overview.html" target="_blank" rel="noopener">稀疏模式（sparsity patterns）</a>的数据。</p></li><li><p><strong>Weighted Quantile Sketch</strong>：XGBoost 使用分布式 <a href="https://arxiv.org/pdf/1603.02754.pdf" target="_blank" rel="noopener">weighted Quantile Sketch 算法</a>，可以有效地找到大多数带权数据集的最佳分割点。 </p></li><li><p><strong>交叉验证（Cross-validation）</strong>：算法内置了在每次迭代时进行<a href="https://towardsdatascience.com/cross-validation-in-machine-learning-72924a69872f" target="_blank" rel="noopener">交叉验证</a>的方法，不再需要显式地去搜索与指定一轮训练中所需的 boosting 迭代次数。</p></li></ol><hr><h2 id="Where-is-the-proof"><a href="#Where-is-the-proof" class="headerlink" title="Where is the proof?"></a>Where is the proof?</h2><p>我们使用 Scikit-learn 的 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" target="_blank" rel="noopener"><code>Make_Classification</code></a> 数据包，创建了一个包含 100 万个数据点、20 个特征（其中包括 2 个信息性特征与 2 个冗余特征）的随机样本集，并用它测试几种算法：逻辑回归、随机森林、标准梯度提升和 XGBoost。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*U72CpSTnJ-XTjCisJqCqLg.jpeg" alt="XGBoost vs. Other ML Algorithms using SKLearn’s Make_Classification Dataset"></p><p>如上图所示，与其它算法相比，XGBoost 模型得到了最好的预测性能与最短的处理时间。研究发现，在其它严格的<a href="https://github.com/szilard/benchm-ml" target="_blank" rel="noopener">基准测试</a>中，也能得到类似的结果。因此，XGBoost 在最近的数据科学比赛中被广泛采用，也是意料之中的事。</p><blockquote><p>“当你举棋不定的时候，用 XGBoost 就对了” —— <a href="http://blog.kaggle.com/2015/08/26/avito-winners-interview-1st-place-owen-zhang/" target="_blank" rel="noopener">Avito</a> Kaggle 上下文广告点击预测大赛冠军 Owen Zhang 如是说。</p></blockquote><hr><h2 id="我们是否可以在任何情况都用-XGBoost？"><a href="#我们是否可以在任何情况都用-XGBoost？" class="headerlink" title="我们是否可以在任何情况都用 XGBoost？"></a>我们是否可以在任何情况都用 XGBoost？</h2><p>在机器学习中（或者说在生命中），没有免费的午餐。作为数据科学家，必须为手头数据测试所有算法，以找到效果最好的算法。但是，选出正确算法还不够，还必须要为数据集正确地配置算法的<a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">超参数</a>。此外，在选择最优算法时，除了效果还要考虑其它的因素，比如计算复杂度、可解释性、易用性等等。这正是机器学习从科学转向艺术的部分，同时，也是魔法发生的地方！</p><hr><h2 id="未来会如何？"><a href="#未来会如何？" class="headerlink" title="未来会如何？"></a>未来会如何？</h2><p>机器学习是一个非常活跃的研究领域，目前已经出现了各种各样的 XGBoost 的变体。微软研究院最近提出了 <a href="https://www.microsoft.com/en-us/research/project/lightgbm/" target="_blank" rel="noopener">LightGBM</a> 梯度提升框架，体现出了巨大的潜力。Yandex 科技开发了 <a href="https://catboost.ai/" target="_blank" rel="noopener">CatBoost</a>，得到了令人印象深刻的基准测试结果。出现一个在预测性能、灵活性、可解释性和实用型都优于 XGBoost 的框架只是时间上的问题。然而，在这个更强的挑战者到来之前，XGBoost 将继续统治机器学习的世界！</p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5d484040e51d4561f95ee9de" target="_blank" rel="noopener">https://juejin.im/post/5d484040e51d4561f95ee9de</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/15650167189931.jpg&quot; alt=&quot;Photo By Jared Subia&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Algorithm" scheme="https://lsvih.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
      <category term="XGBoost" scheme="https://lsvih.com/tags/XGBoost/"/>
    
      <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>在机器学习中为什么要进行 One-Hot 编码？</title>
    <link href="https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/"/>
    <id>https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/</id>
    <published>2019-06-28T03:10:00.000Z</published>
    <updated>2019-06-28T03:12:13.013Z</updated>
    
    <content type="html"><![CDATA[<p>入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。</p><p>一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。</p><p>其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。</p><ul><li>为什么 One-Hot 编码是必要的？</li><li>为什么你不能直接使用数据来拟合模型？</li></ul><p>在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。</p><a id="more"></a><p>让我们开始吧！</p><p><img src="https://lsvih.com/images/Why-One-Hot-Encode-Data-in-Machine-Learning.jpg" alt=""></p><p><a href="https://www.flickr.com/photos/jiangkeren/8263176332/" target="_blank" rel="noopener">题图 by Karan Jain，保留部分权利</a></p><h2 id="什么是类别数据？"><a href="#什么是类别数据？" class="headerlink" title="什么是类别数据？"></a>什么是类别数据？</h2><p>类别数据是一种只有标签值而没有数值的变量。</p><p>它的值通常属于一个大小固定且有限的集合。</p><p>类别变量也常被称为<a href="https://en.wikipedia.org/wiki/Nominal_category" target="_blank" rel="noopener">标称值（nominal）</a>。</p><p>下面举例说明：</p><ul><li>宠物（pet）变量包含以下几种值：狗（dog）、猫（cat）。</li><li>颜色（color）变量包含以下几种值：红（red）、绿（green）、蓝（blue）。</li><li>位次（place）变量包含以下几种值：第一（first）、第二（second）和第三（third）。</li></ul><p>以上例子中的每个值都代表着一个不同的类别。</p><p>有些类别彼此间存在一定的自然关系，比如自然的排序关系。</p><p>上述例子中，位次（place）变量的值就有这种自然的排序关系。这种变量被称为序数变量（ordinal variable）。</p><h2 id="类别数据有什么问题？"><a href="#类别数据有什么问题？" class="headerlink" title="类别数据有什么问题？"></a>类别数据有什么问题？</h2><p>有些算法可以直接应用于类别数据。</p><p>比如，你可以不进行任何数据转换，将决策树算法直接应用于类别数据上（取决于具体实现方式）。</p><p>但还有许多机器学习算法并不能直接操作标签数据。这些算法要求所有的输入输出变量都是数值（numeric）。</p><p>通常来说，这种限制主要是因为这些机器学习算法的高效实现造成的，而不是算法本身的限制。</p><p>但这也意味着我们需要把类别数据转换成数值形式。如果输出变量是类别变量，那你可能还得将模型的预测值转换回类别形式，以便在一些应用中展示或使用它们。</p><h2 id="如何将类别数据转换成数值数据？"><a href="#如何将类别数据转换成数值数据？" class="headerlink" title="如何将类别数据转换成数值数据？"></a>如何将类别数据转换成数值数据？</h2><p>这包含两个步骤：</p><ol><li>整数编码</li><li>One-Hot 编码</li></ol><h3 id="1-整数编码"><a href="#1-整数编码" class="headerlink" title="1. 整数编码"></a>1. 整数编码</h3><p>第一步，先要给每个类别值都分配一个整数值。</p><p>比如，用 1 表示红色（red），2 表示绿色（green），3 表示蓝色（blue）。</p><p>这种方式被称为标签编码或者整数编码，可以很轻松地将它还原回类别值。</p><p>对于某些变量来说，这种编码就足够了。</p><p>整数之间存在自然的排序关系，机器学习算法也许可以理解并利用这种关系。</p><p>比如，前面的位次（place）例子中的序数变量就是一个很好的例子。对于它我们只需要进行标签编码就够了。</p><h3 id="2-One-Hot-编码"><a href="#2-One-Hot-编码" class="headerlink" title="2. One-Hot 编码"></a>2. One-Hot 编码</h3><p>但对于不存在次序关系的类别变量，仅使用上述的整数编码是不够的。</p><p>实际上，使用整数编码会让模型假设类别间存在自然的次序关系，从而导致结果不佳或得到意外的结果（预测值落在两个类别的中间）。</p><p>这种情况下，就要对整数表示使用 One-Hot 编码了。One-Hot 编码会去除整数编码，并为每个整数值都创建一个二值变量。</p><p>在颜色（color）的示例中，有 3 种类别，因此需要 3 个二值变量进行编码。对应的颜色位置上将被标为“1”，其它颜色位置上会被标为“0”。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">red, green, blue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1, 0, 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0, 1, 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">0, 0, 1</span></pre></td></tr></table></figure><p>在统计学等领域中，这种二值变量通常被称为“虚拟变量”或“哑变量”（dummy variable）。</p><h2 id="One-Hot-编码教程"><a href="#One-Hot-编码教程" class="headerlink" title="One-Hot 编码教程"></a>One-Hot 编码教程</h2><p>如果你想了解如何在 Python 对你的数据进行 One-Hot 编码，请参阅：</p><ul><li><a href="https://machinelearningmastery.com/data-preparation-gradient-boosting-xgboost-python/" target="_blank" rel="noopener">Data Preparation for Gradient Boosting with XGBoost in Python</a> — 在 Python 中使用 XGBoost 梯度提升法前的数据准备</li><li><a href="https://machinelearningmastery.com/how-to-one-hot-encode-sequence-data-in-python/" target="_blank" rel="noopener">How to One Hot Encode Sequence Data in Python</a> — 如何使用 Python 对序列数据进行 One-Hot 编码</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Categorical_variable" target="_blank" rel="noopener">类别变量（Categorical variable）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Nominal_category" target="_blank" rel="noopener">标称分类（Nominal category）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Dummy_variable_(statistics" target="_blank" rel="noopener">虚拟变量，哑变量（Dummy variable）</a>)，Wikipedia</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，你应该了解了为什么在使用机器学习算法时通常要对类别数据进行编码。</p><p>特别要注意：</p><ul><li>类别数据的定义是由一组有限集合中的值构成的变量。</li><li>大多数机器学习算法都需要输入数值变量，并会输出数值变量。</li><li>通过整数编码与 One-Hot 编码可以将类别数据转换为整型数据。</li></ul><p>文章首发于掘金：<a href="https://juejin.im/post/5d15840e5188255c23553204" target="_blank" rel="noopener">https://juejin.im/post/5d15840e5188255c23553204</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。&lt;/p&gt;
&lt;p&gt;一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。&lt;/p&gt;
&lt;p&gt;其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 One-Hot 编码是必要的？&lt;/li&gt;
&lt;li&gt;为什么你不能直接使用数据来拟合模型？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
      <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
      <category term="One Hot" scheme="https://lsvih.com/tags/One-Hot/"/>
    
      <category term="Tutorial" scheme="https://lsvih.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Graph Convolutional Networks for Text Classification 论文笔记</title>
    <link href="https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/"/>
    <id>https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/</id>
    <published>2019-06-27T04:04:00.000Z</published>
    <updated>2019-06-27T04:06:42.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：<a href="https://github.com/yao8839836/text_gcn" target="_blank" rel="noopener">https://github.com/yao8839836/text_gcn</a> </p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文解决的是自然语言处理中最基础的任务 - 文本分类任务。利用近年大火的图神经网络，作者通过词与文章的共现信息和 TF-IDF 权重和互信息权重将无结构数据文本进行了构图，并利用 Graph Convolutional Network（GCN）捕获图中的文档-词、词-词、文档-文档关系，从而进行文本分类。</p><p>具体来说，本文主要有以下两个贡献点：</p><ol><li>提出了使用图神经网络来解决文本分类问题，有效利用了文档、词等的异构信息</li><li>在 benchmark 上达到了 state-of-the-art 的效果</li></ol><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><p>传统的文本分类方法主要依靠特征工程，在深度学习兴起后，各种深度学习框架代替了这个步骤。人们利用文本的分布式表示（embedding），使用各种 CNN、RNN、LSTM 等神经网络来捕获 embedding 中的语义信息，进行分类。本文就是在此基础之上，用 GCN 来捕获 Graph 中的 语义信息从而实现准确分类。</p><h3 id="图网络"><a href="#图网络" class="headerlink" title="图网络"></a>图网络</h3><p>近些年为了突破传统神经网络只能应用于对齐的 grid 数据的限制，出现了可以应用于 Graph 的图神经网络。其中，GCN 方法简单有效，在图的各个节点上计算其邻居的聚合信息表示。因此，作者 employ 了 GCN 方法，将其用于图结构的学习。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>作者在 5 个常用的公开数据集上进行了实验。这 5 个数据集的基本信息如下：</p><p><img src="https://lsvih.com/images/15616083187154.jpg" alt="-w692"></p><p>在实验前，作者利用 NLTK 去除了前 4 个数据集的停用词，并去除了频次小于 5 的低频次。MR 数据集因为句子太短了，没有必要再删。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h3><p>作者最终构成的图结构如下图所示：</p><p><img src="https://lsvih.com/images/15616083306904.jpg" alt="-w922"></p><p>在图中，左边是文本构成的图，右边是经过 GCN 得到的图表示。在左图中，以“O”开头的节点是文档节点，白色圈里有单词的节点是单词节点，黑色的线是文档-单词关系，灰色的线是单词-单词关系。右图中的$R(x)$表示文档或单词$x$的表示。</p><p>具体来说，在这个情景中，构图主要在于如何对文档-单词和单词-单词的边赋权。作者使用了下面公式所示的构图方式：</p><script type="math/tex; mode=display">A _ { i j } = \left\{ \begin{array} { c } { \operatorname { PMI } ( i , j ) } \space \text{i,j 是单词，且 PMI(i,j)>0} \\ { \mathrm { TF } - \mathrm { IDF } _ { i j } } \space \text{i是单词，j是文档} \\ { 1 } \space i =j \\ { 0 } \space otherwise \end{array} \right.</script><p>$A_{ij}$表示从节点 i 连到节点 j 的边的权重。简单来说，就是对文档-单词的边算 TF-IDF 作为权重，对单词-单词的边使用 PMI 做权重。PMI 是单词与单词的互信息，具体计算方式是：</p><script type="math/tex; mode=display">\begin{aligned} \operatorname { PMI } ( i , j ) = & \log \frac { p ( i , j ) } { p ( i ) p ( j ) } \\ p ( i , j ) = & \frac { \# W ( i , j ) } { \# W } \\ p ( i ) = & \frac { \# W ( i ) } { \# W } \end{aligned}</script><p>其中，#W 是滑动窗口，具体来说，PMI 就是算单词 i 和单词 j 同时出现的概率比上单词 i 和单词 j 单独出现的概率。</p><h3 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h3><p>在 GCN 框架内，使用 BP 算法来优化节点表示，并在 GCN 后加一层 Dense 层和激活层，利用 softmax 来进行分类。作者将其表示如下：</p><script type="math/tex; mode=display">Z = \operatorname { softmax } \left( \tilde { A } \operatorname { ReL } \mathbf { U } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 } \right)</script><p>其中，$ \tilde { A } X W _ { 0 } $ 和前面的公式 $L ^ { ( 1 ) } = \rho \left( \tilde { A } X W _ { 0 } \right)$ 一致，都是通过对 W 的优化来进行节点的表示。对上面的公式进一步拆解，可以记为：</p><script type="math/tex; mode=display">E _ { 1 } = \tilde { A } X W _ { 0 }</script><p>$E_1$ 就是对单词和文档节点的表示。</p><script type="math/tex; mode=display">E _ { 2 } = \tilde { A } \operatorname { ReLU } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 }</script><p>$E_2$ 就是对节点的第二层级表示。因此，本文相当于用了 2 层 GCN 进行图表示，然后用 softmax 进行分类。在分类优化时，采用了交叉熵损失函数：</p><script type="math/tex; mode=display">\mathcal { L } = - \sum _ { d \in \mathcal { Y } _ { D } } \sum _ { f = 1 } ^ { F } Y _ { d f } \ln Z _ { d f }</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="baseline-设置"><a href="#baseline-设置" class="headerlink" title="baseline 设置"></a>baseline 设置</h3><p>作者设置了多种 baseline，包括：</p><ul><li>TF-IDF + 线性分类器</li><li>CNN 文本分类（Convolutional neural networks for sentence classification，EMNLP）</li><li>LSTM 文本分类（Recurrent neural network for text classiﬁcation with multi-task learning，IJCAI）</li><li>Bi-LSTM</li><li>PV-DBOW（Distributed representations of sentences and documents，ICML）</li><li>PV-DM（同上）</li><li>PTE（Automatic lymphoma classiﬁcation with sentence subgraph mining from pathology reports）</li><li>FastText（Bag of tricks for efﬁcient text classiﬁcation，EACL）</li><li>SWEM（Baseline needs more love: On simple wordembedding-based models and associated pooling mechanisms，ACL）</li><li>LEAM（Joint embedding of words and labels for text classiﬁcation，ACL）</li><li>Graph-CNN-C（Convolutional neural networks on graphs with fast localized spectral ﬁltering，NIPS）</li><li>Graph-CNN-S（Spectral networks and locally connected networks on graphs，ICLR）</li><li>Graph-CNN-F（Deep convolutional networks on graphstructured data）</li></ul><p>可以看到，作者的实验非常完善且置信，应用了当时几乎全部的文本分类方法来进行对比。</p><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>作者用了 200 维作为 embedding 维数，20 作为滑动窗口大小，学习率设为 0.02，Dorpout 设为 0.5，分别随机采样 10 % 数据作为验证集和测试集。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>最终，得到了如下表所示的实验结果：</p><p><img src="https://lsvih.com/images/15616083449147.jpg" alt="-w1067"></p><p>该表有两个维度，数据集和模型。从此也可以看出，作者实验做的非常充分。</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>从上表可以看到，除了 MR 数据集外，作者提出的 Text GCN 方法在其余全部数据集上都得到了最好的结果。猜测可能是由于 MR 数据集中数据过于短，构图效果不佳造成的。</p><p>此外，作者利用 t-SNE 方法（Visualizing data using t-sne，JMLR）对结果进行了可视化，用于分析训练得到的 embedding 的效果。结果如下：</p><p><img src="https://lsvih.com/images/15616083604339.jpg" alt="-w513"></p><p>可以看到，作者提出的 Text GCN 方法得到的文档表示在 t-SNE 表现是可分的，类间距离较大，优于用来对比的其余两种方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者提出的 Text GCN 方法在文本分类任务中，在多个数据集上得到了最好的结果。我认为其最大创新点在于：1、引入了 GCN 来做文本分类 2、提出了这种构建带权边图的方式。整个工作非常完备，应该要做的实验基本都做了，令人信服，我们做文本分类应当也要学习本文的实验方式。此外，文章最后的节点表示可视化也很有说服力。</p><p>对于后续工作，我觉得一个是可以 follow 一些新的构图方式和 GNN 框架，再有就是在 loss 方面进行改进，优化表示的空间分布。此外，可以考虑结合一些最新的语言模型方法（BERT、XLNET 等）改善结果。以及，可以对分类器那块进行一些改进，比如引入 Attention 等方法可能可以提升效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：&lt;a href=&quot;https://github.com/yao8839836/t
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="GNN" scheme="https://lsvih.com/tags/GNN/"/>
    
      <category term="GCN" scheme="https://lsvih.com/tags/GCN/"/>
    
      <category term="NLP" scheme="https://lsvih.com/tags/NLP/"/>
    
      <category term="Text classification" scheme="https://lsvih.com/tags/Text-classification/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 线性代数系列</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra/</id>
    <published>2019-06-26T02:00:00.000Z</published>
    <updated>2019-06-26T02:08:51.889Z</updated>
    
    <content type="html"><![CDATA[<p>本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 <a href="https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0" target="_blank" rel="noopener">Linear Algebra with Javascript</a>，旨在帮助复习线性代数的基本概念与运算，并了解如何使用 React、SVG、ThreeJS 等技术栈对线性代数的二维、三维向量、矩阵、线性变换进行可视化。</p><p>本系列共包含 5 篇文章：</p><ol><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/">用 React 制作线性代数教程示例：网格与箭头</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/">JavaScript 线性代数：向量</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/">JavaScript 线性代数：线性变换与矩阵</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/">JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/">线性代数：矩阵基本运算</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 &lt;a href=&quot;https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线性代数：矩阵基本运算</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/</id>
    <published>2019-06-26T01:05:00.000Z</published>
    <updated>2019-06-26T02:07:56.442Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。</p><h2 id="矩阵的加减法"><a href="#矩阵的加减法" class="headerlink" title="矩阵的加减法"></a>矩阵的加减法</h2><p>矩阵的<strong>加法</strong>与<strong>减法</strong>运算将接收两个矩阵作为输入，并输出一个新的矩阵。矩阵的加法和减法都是在分量级别上进行的，因此要进行加减的矩阵必须有着相同的维数。</p><p>为了避免重复编写加减法的代码，我们先创建一个可以接收运算函数的方法，这个方法将对两个矩阵的分量分别执行传入的某种运算。然后在加法、减法或者其它运算中直接调用它就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  componentWiseOperation(func, &#123; rows &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newRows = rows.map(<span class="function">(<span class="params">row, i</span>) =&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      row.map(<span class="function">(<span class="params">element, j</span>) =&gt;</span> func(<span class="keyword">this</span>.rows[i][j], element))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  add(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, other)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  subtract(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b, other)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">5</span>, <span class="number">6</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">7</span>, <span class="number">8</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.add(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 6, 8 ], [ 10, 12 ] ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(other.subtract(one))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 4 ], [ 4, 4 ] ] &#125;</span></span></pre></td></tr></table></figure><h2 id="矩阵的标量乘法"><a href="#矩阵的标量乘法" class="headerlink" title="矩阵的标量乘法"></a>矩阵的标量乘法</h2><p>矩阵的标量乘法与向量的缩放类似，就是将矩阵中的每个元素都乘上标量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  scaleBy(number) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newRows = <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      row.map(<span class="function"><span class="params">element</span> =&gt;</span> element * number)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix.scaleBy(<span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 6 ], [ 8, 10 ] ] &#125;</span></span></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>当 <strong>A</strong>、<strong>B</strong> 两个矩阵的维数是<strong>兼容</strong>的时候，就能对这两个矩阵进行矩阵乘法。所谓维数兼容，指的是 <strong>A</strong> 的列数与 <strong>B</strong> 的行数相同。矩阵乘法 <strong>AB</strong> 就是对举证 <strong>A</strong> 的每一行行与矩阵 <strong>B</strong> 的每一列分别进行点积运算：</p><p><img src="https://lsvih.com/images/15615137842832.jpg" alt="matrix-matrix multiplication"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  multiply(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows[<span class="number">0</span>].length !== other.rows.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The number of columns of this matrix is not equal to the number of rows of the given matrix.'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> columns = other.columns()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newRows = <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      columns.map(<span class="function"><span class="params">column</span> =&gt;</span> sum(row.map(<span class="function">(<span class="params">element, i</span>) =&gt;</span> element * column[i])))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>, <span class="number">-4</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">0</span>, <span class="number">-3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">6</span>, <span class="number">-2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">-1</span>, <span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>,  <span class="number">2</span>, <span class="number">-4</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">-3</span>,  <span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.multiply(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//   rows:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//    [ [ -7, 18, -32 ],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      [ -12, 9, -15 ],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      [ 10, 18, -34 ],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      [ 1, -5, 9 ] ]&#125;</span></span></pre></td></tr></table></figure><p>我们可以把矩阵乘法 <strong>AB</strong> 视为先后应用 <strong>A</strong> 和 <strong>B</strong> 两个线性变换矩阵。为了更好地理解这种概念，可以看一看我们的 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a>。</p><p>下图中黄色的部分就是对红色方块应用线性变换 <strong>C</strong> 的结果。而线性变换 <strong>C</strong> 就是矩阵乘法 <strong>AB</strong> 的结果，其中 <strong>A</strong> 是做相对于 y 轴进行反射的变换矩阵，<strong>B</strong> 是做剪切变换的矩阵。</p><p><img src="https://lsvih.com/images/15615138080956.jpg" alt="先旋转再剪切变换"></p><p>如果在矩阵乘法中调换 <strong>A</strong> 和 <strong>B</strong> 的顺序，我们会得到一个不同的结果，因为相当于先应用了 <strong>B</strong> 的剪切变换，再应用 <strong>A</strong> 的反射变换：</p><p><img src="https://lsvih.com/images/15615138231502.jpg" alt="shear than rotate"></p><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><p><strong>转置</strong>矩阵 $A^T$ 由公式 $a^T_{ij}=a_{ji}$ 定义。换句话说，我们通过关于矩阵的对角线对其进行翻转来得到转置矩阵。需要注意的是，矩阵对角线上的元素不受转置运算影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  transpose() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...this.columns())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix.transpose())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//   rows: [</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//     [ 0, 3, 6, 9 ],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//     [ 1, 4, 7, 10 ],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//     [ 2, 5, 8, 11 ]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//   ]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#125;</span></span></pre></td></tr></table></figure><h2 id="行列式运算"><a href="#行列式运算" class="headerlink" title="行列式运算"></a>行列式运算</h2><p>矩阵的<strong>行列式</strong>运算将计算矩阵中的所有系数，最后输出一个数字。准确地说，行列式可以描述一个由矩阵行构成的向量的相对几何指标（比如在欧式空间中的有向面积、体积等空间概念）。更准确地说，矩阵 <strong>A</strong> 的行列式相当于告诉你由 <strong>A</strong> 的行定义的方块的体积。$2\times 2$ 矩阵的行列式运算如下所示：</p><p><img src="https://lsvih.com/images/15615138461810.jpg" alt="det(2×2 matrix)"></p><p>$3\times 3$ 矩阵的行列式运算如下所示：</p><p><img src="https://lsvih.com/images/15615138625927.jpg" alt="det(3×3 matrix)"></p><p>我们的方法可以计算任意大小矩阵（只要其行列的数量相同）的行列式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  determinant() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows.length !== <span class="keyword">this</span>.rows[<span class="number">0</span>].length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Only matrices with the same number of rows and columns are supported.'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rows.length === <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.rows[<span class="number">0</span>][<span class="number">0</span>] * <span class="keyword">this</span>.rows[<span class="number">1</span>][<span class="number">1</span>] - <span class="keyword">this</span>.rows[<span class="number">0</span>][<span class="number">1</span>] * <span class="keyword">this</span>.rows[<span class="number">1</span>][<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> parts = <span class="keyword">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">coef, index</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> matrixRows = <span class="keyword">this</span>.rows.slice(<span class="number">1</span>).map(<span class="function"><span class="params">row</span> =&gt;</span> [ ...row.slice(<span class="number">0</span>, index), ...row.slice(index + <span class="number">1</span>)])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(...matrixRows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> result = coef * matrix.determinant()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span> ? result : -result</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum(parts)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix2 = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  [ <span class="number">0</span>, <span class="number">3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">-2</span>, <span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix2.determinant())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix3 = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">2</span>, <span class="number">-3</span>,  <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">2</span>,  <span class="number">0</span>, <span class="number">-1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>,  <span class="number">4</span>,  <span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix3.determinant())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 49</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix4 = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>,  <span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix4.determinant())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20</span></span></pre></td></tr></table></figure><p>行列式可以告诉我们变换时对象被拉伸的程度。因此我们可以将其视为一个线性变换对区域改变的一个因素。为了更好地理解这个概念，请参考 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a>：</p><p>在下图中，我们可以看到对红色的 <strong>1×1</strong> 方形进行线性变换后得到了一个 <strong>3×2</strong> 的长方形，面积从 <strong>1</strong> 变为了 <strong>6</strong>，这个数字与线性变换矩阵的行列式值相同。</p><p><img src="https://lsvih.com/images/15615138875261.jpg" alt="det(scale transformation)"></p><p>如果我们应用一个剪切变换，可以看到方形会变成一个面积不变的平行四边形。因此，剪切变换矩阵的行列式值等于 1：</p><p><img src="https://lsvih.com/images/15615139063445.jpg" alt="det(shear transformation)"></p><p>如果行列式的值是<strong>负数</strong>，则说明应用线性变换后，空间被反转了。比如在下图中，我们可以看到变换前 $\hat{\jmath}$ 在 $\hat{\imath}$ 的左边，而变换后 $\hat{\jmath}$ 在 $\hat{\imath}$ 的右边。</p><p><img src="https://lsvih.com/images/15615139284033.jpg" alt="negative determinant"></p><p>如果变换的行列式为 <strong>0</strong>，则表示它会将所有空间都压缩到一条线或一个点上。也就是说，计算一个给定矩阵的行列式是否为 0，可以判断这个矩阵对应的线性变换是否会将对象压缩到更小的维度去。</p><p><img src="https://lsvih.com/images/15615139536351.jpg" alt="2D 中的 0 行列式"></p><p>在三维空间里，行列式可以告诉你体积缩放了多少：</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a7937595f61716c476f2d4a31356877776c374e6766512e676966.gif" alt="det(scale transformation) in 3D"></p><p>变换行列式等于 0，意味着原来的空间会被完全压缩成体积为 0 的空间。如前文所说，如果在 2 维空间中变换的行列式为 0，则意味着变换的结果将空间压缩成了一条线或一个点；而在 3 维空间中变换的行列式为 0 意味着一个物体会被压扁成一个平面，如下图所示：</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a4b396f324f7268746671574f324e4e6f34684b354e412e676966.gif" alt="3D 中的 0 行列式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
      <category term="Matrix" scheme="https://lsvih.com/tags/Matrix/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/</id>
    <published>2019-06-26T01:04:00.000Z</published>
    <updated>2019-06-26T02:07:41.326Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我完成了一篇关于使用 JavaScript 进行线性变换的文章，并用 <strong>SVG</strong> 网格实现了 2D 的示例。你可以在<a href="https://juejin.im/post/5cefbc37f265da1bd260d129" target="_blank" rel="noopener">此处</a>查看之前的文章。但是，那篇文章没有三维空间的示例，因此本文将补全那篇文章的缺失。你可以在<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此处</a>查看本系列文章的 GitHub 仓库，与本文相关的 commit 可以在<a href="https://github.com/RodionChachura/linear-algebra/tree/6e9b5fe7f037ec12b115c915f33b58ce5e2e9c1f" target="_blank" rel="noopener">此处</a>查看。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本文中，我们将制作一个组件，用于对三维空间的对象的线性变换进行可视化。最终效果如下面的动图所示，或者你也可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此网页</a>体验。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323533322f312a42415a757839676e656956795a2d456a676b714565672e676966.gif" alt="applying different linear transformations on cube"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当我们要在浏览器中制作 3D 动画时，第一个想到的当然就是 <a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a> 库啦。所以让我们来安装它以及另一个可以让用户移动摄像机的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install --save three three-orbitcontrols</span></pre></td></tr></table></figure><p>下面构建一个组件，它可以由父组件的属性中接收矩阵，并且渲染一个立方体的转换动画。下面代码展示了这个组件的结构。我们用 <strong>styled-components</strong> 和 <strong>react-sizeme</strong> 库中的函数对这个组件进行了包装，以访问颜色主题和检测组件尺寸的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">'react-sizeme'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  render() &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  componentWillUnmount() &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WrappedScene = withTheme(withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(ThreeScene))</span></pre></td></tr></table></figure><p>在<strong>构造函数</strong>中，我们对状态进行了初始化，其中包括了视图的大小。因此，我们当接收新的状态值时，可以在 <strong>componentWillReceiveProps</strong> 方法中与初始状态进行对比。由于需要访问实际的 <strong>DOM</strong> 元素以注入 <strong>ThreeJS</strong> 的 <strong>renderer</strong>，因此需要在 <strong>render</strong> 方法中用到 <strong>ref</strong> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = styled.div<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">  width: 100%;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">  height: 100%;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      width: <span class="number">0</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      height: <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">ref</span>=<span class="string">&#123;el</span> =&gt;</span> (this.view = el)&#125; /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="xml">  // ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="xml">&#125;</span></span></pre></td></tr></table></figure><p>在 <strong>componentDidMount</strong> 方法中，我们对方块变换动画所需要的所有东西都进行了初始化。首先，我们创建了 ThreeJS 的场景（scene）并确定好摄像机（camera）的位置，然后我们创建了 ThreeJS 的 <strong>renderer</strong>，为它设置好了颜色及大小，最后将 <strong>renderer</strong> 加入到 <strong>View</strong> 组件中。</p><p>接下来创建需要进行渲染的对象：坐标轴、方块以及方块的边。由于我们需要手动改变矩阵，因此将方块和边的 <strong>matrixAutoUpdate</strong> 属性设为 false。创建好这些对象后，将它们加入场景（scene）中。为了让用户可以通过鼠标来移动摄像机位置，我们还用到了 <strong>OrbitControls</strong>。</p><p>最后要做的，就是将我们的库输出的矩阵转换成 <strong>ThreeJS</strong> 的格式，然后获取根据时间返回颜色和转换矩阵的函数。在 <strong>componentWillUnmount</strong>，取消动画（即停止 anime frame）并从 <strong>DOM</strong> 移除 <strong>renderer</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      size: &#123; width, height &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      matrix,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      theme</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; = <span class="keyword">this</span>.props</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.setState(&#123; width, height &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.scene = <span class="keyword">new</span> THREE.Scene()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">100</span>, width / height)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.camera.position.set(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.renderer.setClearColor(theme.color.background)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.renderer.setSize(width, height)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.view.appendChild(<span class="keyword">this</span>.renderer.domElement)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> initialColor = theme.color.red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> axes = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.segments = <span class="keyword">new</span> THREE.LineSegments(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">new</span> THREE.EdgesGeometry(geometry),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: theme.color.mainText &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.cube = <span class="keyword">new</span> THREE.Mesh(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      geometry,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: initialColor &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.objects = [<span class="keyword">this</span>.cube, <span class="keyword">this</span>.segments]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.matrixAutoUpdate = <span class="literal">false</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.scene.add(<span class="keyword">this</span>.cube, axes, <span class="keyword">this</span>.segments)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.controls = <span class="keyword">new</span> OrbitControls(<span class="keyword">this</span>.camera)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.getAnimatedColor = getGetAnimatedColor(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      initialColor,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">      theme.color.blue,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      PERIOD</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> fromMatrix = fromMatrix4(<span class="keyword">this</span>.cube.matrix)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> toMatrix = matrix.toDimension(<span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.getAnimatedTransformation = getGetAnimatedTransformation(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">      fromMatrix,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">      toMatrix,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">      PERIOD</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.frameId = requestAnimationFrame(<span class="keyword">this</span>.animate)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  componentWillUnmount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    cancelAnimationFrame(<span class="keyword">this</span>.frameId)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.view.removeChild(<span class="keyword">this</span>.renderer.domElement)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>不过此时我们还没有定义 <strong>animate</strong> 函数，因此什么也不会渲染。首先，我们更新立方体及其边缘的转换矩阵，并且更新立方体的颜色，然后进行渲染并且调用 <code>window.requestAnimationFrame</code>。</p><p><strong>componentWillReceiveProps</strong> 方法将接收当前组件的大小，当它检测到组件尺寸发生了变化时，会更新状态，改变 renderer 的尺寸，并调整 camera 的方位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  animate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> transformation = <span class="keyword">this</span>.getAnimatedTransformation()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> matrix4 = toMatrix4(transformation)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.cube.material.color.set(<span class="keyword">this</span>.getAnimatedColor())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> obj.matrix.set(...matrix4.toArray()))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.renderer.render(<span class="keyword">this</span>.scene, <span class="keyword">this</span>.camera)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.frameId = <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.animate)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.width !== width || <span class="keyword">this</span>.state.height !== height) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.setState(&#123; width, height &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.renderer.setSize(width, height)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.camera.aspect = width / height</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.camera.updateProjectionMatrix()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>为了将颜色变化以及矩阵变换做成动画，需要写个函数来返回动画函数。在写这块函数前，我们先要完成以下两种转换器：将我们库的矩阵转换为 <strong>ThreeJS</strong> 格式矩阵的函数，以及参考 StackOverflow 上代码的将 RGB 转换为 hex 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/matrix'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  matrix4.set(...matrix.components())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> matrix4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    .fill(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/matrix'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  matrix4.set(...matrix.components())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> matrix4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    .fill(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>首先，需要计算每种原色（RGB）变化的幅度。第一次调用 <strong>getGetAnimatedColor</strong> 时会返回新的色彩与时间戳的集合；并在后续被调用时，通过颜色变化的距离以及时间的耗费，可以计算出当前时刻新的 <strong>RGB</strong> 颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hexToRgb, rgbToHex &#125; <span class="keyword">from</span> <span class="string">'./generic'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedColor = <span class="function">(<span class="params">fromColor, toColor, period</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> fromRgb = hexToRgb(fromColor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> toRgb = hexToRgb(toColor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> distances = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> toPart = toRgb[index]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fromPart &lt;= toPart ? toPart - fromPart : <span class="number">255</span> - fromPart + toPart</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!start) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      start = <span class="built_in">Date</span>.now()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> timePassed = now - start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toColor</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> rgb = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> distance = distances[index]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round((fromPart + step) % <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> rgbToHex(...rgb)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>为了给线性变换做出动画效果，同样要进行上节的操作。我们首先找到矩阵变换前后的区别，然后在动画函数中，根据第一次调用 <strong>getGetAnimatedTransformation</strong> 时的状态，根据时间来更新各个组件的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedTransformation = <span class="function">(<span class="params">fromMatrix, toMatrix, period</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> distances = toMatrix.subtract(fromMatrix)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!start) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      start = <span class="built_in">Date</span>.now()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> timePassed = now - start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toMatrix</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newMatrix = fromMatrix.map(<span class="function">(<span class="params">fromComponent, i, j</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> distance = distances.rows[i][j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> fromComponent + step</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> newMatrix</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：线性变换与矩阵</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/</id>
    <published>2019-06-26T01:03:00.000Z</published>
    <updated>2019-06-26T02:08:06.143Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>矩阵</strong>是一种由 <strong>m</strong> 行 <strong>n</strong> 列实数组成的“矩形”数组。比如，一个 <strong>3x2</strong> 的矩阵如下所示：</p><p><img src="https://lsvih.com/images/15615130636391.jpg" alt="**3×2** 矩阵"></p><p><strong>Matrix</strong> 类的构造器（constructor）接收若干行元素作为参数。我们可以通过指定行号取出矩阵中的一行，然后再通过指定列号取出一个特定的元素。下面直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.rows = rows</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ] ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ 2, 3 ]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>][<span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span></pre></td></tr></table></figure><h2 id="矩阵与向量的乘积"><a href="#矩阵与向量的乘积" class="headerlink" title="矩阵与向量的乘积"></a>矩阵与向量的乘积</h2><p><strong>矩阵与向量的乘法</strong> —— $A\vec{x}$ 会将矩阵 $A$ 的列进行系数为 $\vec{x}$ 的线性组合。比如，一个 $3\times 2$ 的矩阵 A 与一个 <strong>2D</strong> 向量 <strong>x⃗</strong> 的乘积将得到一个 <strong>3D</strong> 向量，这个计算记为：$\vec{y} : \vec{y} = A\vec{x}$。</p><p><img src="https://lsvih.com/images/15615131095284.jpg" alt=""></p><p>假设有一组向量 ${\vec{e}_1,\vec{e}_2}$，另一个向量 $\vec{y}$ 是 $\vec{e}_1$ 和 $\vec{e}_2$ 的<strong>线性组合</strong>：$\vec{y} = \alpha\vec{e}_1 + \beta \vec{e}_2$。其中，$\alpha, \beta \in \mathbb{R}$ 就是这个线性组合的系数。</p><p>为了更好地学习线性组合，我们特地为此定义了矩阵向量乘法。我们可以将前面所说的线性组合记为以下矩阵向量乘法的形式：$\vec{y} = E \vec{x}$。矩阵 $E$ 有 $\vec{e}_1$、$\vec{e}_2$ 两列。矩阵的维数是 $n \times 2$，其中 $n$ 是向量 $\vec{e}_1$、$\vec{e}_2$ 与 $\vec{y}$ 的维数。</p><p>下图展示了将向量 $\vec{v}$ 表示为向量 $\vec{\imath}$ 和向量 $\vec{\jmath}$ 的线性组合：</p><p><img src="https://lsvih.com/images/15615131638823.jpg" alt="线性组合"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> j = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstCoeff = <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secondCoeff = <span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> linearCombination = i.scaleBy(firstCoeff).add(j.scaleBy(secondCoeff))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(linearCombination)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 2, 5 ] &#125;</span></span></pre></td></tr></table></figure><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>矩阵与向量的乘法是<strong>线性变换</strong>的抽象概念，这是学习线性代数中的关键概念之一。向量与矩阵的乘法可以视为对向量进行线性变换：将 n 维向量作为输入，并输出 m 维向量。也可以说，矩阵是定义好的某种空间变换。</p><p>我们可以通过一个示例来更清楚地理解线性变换。首先需要给 Matrix 类加上一个方法，用于返回矩阵的列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.rows = rows</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  columns() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="keyword">this</span>.rows.map(<span class="function"><span class="params">r</span> =&gt;</span> r[i]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(matrix.columns())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]</span></span></pre></td></tr></table></figure><p>乘法得到的向量的维数将与矩阵的行数相同。如果我们将一个 <strong>2D</strong> 向量和一个 <strong>3x2</strong> 矩阵相乘，将得到一个 <strong>3D</strong> 的向量；如果将一个 <strong>3D</strong> 向量和一个 <strong>2x3</strong> 矩阵相乘，将得到一个 <strong>2D</strong> 的向量；如果在做乘法时，矩阵的列数和向量的维数不相同，将报错。在下面的代码中，你可以看到几种不同的向量与矩阵相乘的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, value</span>) =&gt;</span> acc + value, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  transform(matrix) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> columns = matrix.columns()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(columns.length !== <span class="keyword">this</span>.components.length) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Matrix columns length should be equal to vector components length.'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> multiplied = columns</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      .map(<span class="function">(<span class="params">column, i</span>) =&gt;</span> column.map(<span class="function"><span class="params">c</span> =&gt;</span> c * <span class="keyword">this</span>.components[i]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newComponents = multiplied[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> sum(multiplied.map(<span class="function"><span class="params">column</span> =&gt;</span> column[i])))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(...newComponents)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector2D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector3D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix2x2D = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix2x3D = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix3x2D = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2D =&gt; 2D</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x2D))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3D =&gt; 2D</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector3D.transform(matrix2x3D))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 19, 49 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2D =&gt; 3D</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix3x2D))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29, 45 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x3D))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Matrix columns length should be equal to vector components length.</span></span></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在，我们将尝试对二维的对象应用线性变换。首先，需要创建一个新的 <strong>Contour</strong>（轮廓）类，它在 constructor 中接收一系列的向量（在 2D 平面中形成一个轮廓），然后用唯一的方法 —— <strong>transform</strong> 对轮廓中的所有向量坐标进行变换，最后返回一个新的轮廓。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contour</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(vectors) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.vectors = vectors</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  transform(matrix) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> newVectors = <span class="keyword">this</span>.vectors.map(<span class="function"><span class="params">v</span> =&gt;</span> v.transform(matrix))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contour(newVectors)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contour = <span class="keyword">new</span> Contour([</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">])</span></pre></td></tr></table></figure><p>现在，请在 <a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">linear-algebra-demo</a> 项目中试试各种转换矩阵。红色方块是初始化的轮廓，蓝色形状是应用变换矩阵后的轮廓。</p><p><img src="https://lsvih.com/images/15615132290264.jpg" alt="镜像"></p><p><img src="https://lsvih.com/images/15615132414178.jpg" alt="缩放"></p><p>通过下面的方式，我们可以构建一个矩阵，用于将给定的向量旋转指定的角度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> angle = toRadians(<span class="number">45</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  [<span class="built_in">Math</span>.cos(angle), -<span class="built_in">Math</span>.sin(angle)],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  [<span class="built_in">Math</span>.sin(angle), <span class="built_in">Math</span>.cos(angle)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/15615132769006.jpg" alt="旋转"></p><p><img src="https://lsvih.com/images/15615133004176.jpg" alt="剪切变换"></p><p>对 3D 空间内的对象进行变换也与此类似。你可以在下图中看到一个红色方块变换成一个蓝色的平行六边形的动画。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323433322f312a7a6f5472705f6c6d3170324851436c6b614f644d4f512e676966.gif" alt="3D 剪切变换"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：向量</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/</id>
    <published>2019-06-26T01:01:00.000Z</published>
    <updated>2019-06-26T02:08:28.243Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>向量</strong>是用于精确表示空间中方向的方法。向量由一系列数值构成，每维数值都是向量的一个<strong>分量</strong>。在下图中，你可以看到一个由两个分量组成的、在 2 维空间内的向量。在 3 维空间内，向量会由 3 个分量组成。</p><p><img src="https://lsvih.com/images/15615124754701.jpg" alt="the vector in 2D space"></p><p>我们可以为 2 维空间的向量创建一个 <strong>Vector2D</strong> 类，然后为 3 维空间的向量创建一个 <strong>Vector3D</strong> 类。但是这么做有一个问题：向量并不仅用于表示物理空间中的方向。比如，我们可能需要将颜色（RGBA）表示为向量，那么它会有 4 个分量：红色、绿色、蓝色和 alpha 通道。或者，我们要用向量来表示有不同占比的 <strong>n</strong> 种选择（比如表示 5 匹马赛马，每匹马赢得比赛的概率的向量）。因此，我们会创建一个不指定维度的类，并像这样使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> direction2d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> direction3d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> Vector(<span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.15</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> probabilities = <span class="keyword">new</span> Vector(<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.2</span>)</span></pre></td></tr></table></figure><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>考虑有两个向量的情况，可以对它们定义以下运算：</p><p><img src="https://lsvih.com/images/15615124998598.jpg" alt="basic vector operations"></p><p>其中，<strong>α ∈ R</strong> 为任意常数。</p><p>我们对除了叉积之外的运算进行了可视化，你可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此处</a>找到相关示例。<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此 GitHub 仓库</a>里有用来创建这些可视化示例的 React 项目和相关的库。如果你想知道如何使用 React 和 SVG 来制作这些二维可视化示例，请参考<a href="https://juejin.im/post/5cefbc37f265da1bd260d129" target="_blank" rel="noopener">本文</a>。</p><h3 id="加法与减法"><a href="#加法与减法" class="headerlink" title="加法与减法"></a>加法与减法</h3><p>与数值运算类似，你可以对向量进行加法与减法运算。对向量进行算术运算时，可以直接对向量各自的分量进行数值运算得到结果：</p><p><img src="https://lsvih.com/images/15615125322484.jpg" alt="vectors addition"></p><p><img src="https://lsvih.com/images/15615125380537.jpg" alt="vectors subtraction"></p><p>加法函数接收另一个向量作为参数，并将对应的向量分量相加，返回得出的新向量。减法函数与之类似，不过会将加法换成减法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  add(&#123; components &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="keyword">this</span>.components[index] + component)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  subtract(&#123; components &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="keyword">this</span>.components[index] - component)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.add(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 4, 4 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.subtract(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 0, 2 ] &#125;</span></span></pre></td></tr></table></figure><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们可以对一个向量进行缩放，缩放比例可为任意数值 <strong>α ∈ R</strong>。缩放时，对所有向量分量都乘以缩放因子 <strong>α</strong>。当 <strong>α &gt; 1</strong> 时，向量会变得更长；当 <strong>0 ≤ α \&lt; 1</strong> 时，向量会变得更短。如果 <strong>α</strong> 是负数，缩放后的向量将会指向原向量的反方向。</p><p><img src="https://lsvih.com/images/15615125690651.jpg" alt="scaling vector"></p><p>在 <strong>scaleBy</strong> 方法中，我们对所有的向量分量都乘上传入参数的数值，得到新的向量并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  scaleBy(number) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      ...this.components.map(<span class="function"><span class="params">component</span> =&gt;</span> component * number)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 2, 4 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">0.5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 0.5, 1 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">-1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ -1, -2 ] &#125;</span></span></pre></td></tr></table></figure><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>向量长度可由勾股定理导出：</p><p><img src="https://lsvih.com/images/15615125935367.jpg" alt="vectors length"></p><p>由于在 JavaScript 内置的 Math 对象中有现成的函数，因此计算长度的方法非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  length() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(...this.components)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector.length())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.6055512754639896</span></span></pre></td></tr></table></figure><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。两个向量的点积等于它们各自对应分量的乘积之和。</p><p><img src="https://lsvih.com/images/15615126207640.jpg" alt="dot product"></p><p>在 <strong>dotProduct</strong> 方法中，接收另一个向量作为参数，通过 reduce 方法来计算对应分量的乘积之和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  dotProduct(&#123; components &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> components.reduce(<span class="function">(<span class="params">acc, component, index</span>) =&gt;</span> acc + component * <span class="keyword">this</span>.components[index], <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.dotProduct(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10</span></span></pre></td></tr></table></figure><p>在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法。这种归一化后的向量在许多情景中都会用到。比如说当我们需要在空间中指定一个方向时，就需要用一个归一化后的向量来表示这个方向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  normalize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scaleBy(<span class="number">1</span> / <span class="keyword">this</span>.length())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalized = vector.normalize()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(normalized)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 0.4472135954999579, 0.8944271909999159 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(normalized.length())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/15615126527250.jpg" alt="using dot product"></p><p>如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。我们创建了 <strong>areEqual</strong> 函数用来比较两个浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EPSILON = <span class="number">0.00000001</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> areEqual = <span class="function">(<span class="params">one, other, epsilon = EPSILON</span>) =&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">Math</span>.abs(one - other) &lt; epsilon</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  haveSameDirectionWith(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">8</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.haveSameDirectionWith(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr></table></figure><p>如果两个归一化后的向量点积结果等于 -1，则表示它们的方向完全相反：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  haveOppositeDirectionTo(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">-4</span>, <span class="number">-8</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.haveOppositeDirectionTo(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr></table></figure><p>如果两个归一化后的向量的点积结果为 0，则表示这两个向量是相互垂直的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  isPerpendicularTo(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> dotProduct = <span class="keyword">this</span>.normalize().dotProduct(other.normalize())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">-2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.isPerpendicularTo(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr></table></figure><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量：</p><p><img src="https://lsvih.com/images/15615126731739.jpg" alt=""></p><p>我们实现叉积时，假定它只用于计算三维空间内的向量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只适用于 3 维向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  crossProduct(&#123; components &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.components[<span class="number">1</span>] * components[<span class="number">2</span>] - <span class="keyword">this</span>.components[<span class="number">2</span>] * components[<span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.components[<span class="number">2</span>] * components[<span class="number">0</span>] - <span class="keyword">this</span>.components[<span class="number">0</span>] * components[<span class="number">2</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.components[<span class="number">0</span>] * components[<span class="number">1</span>] - <span class="keyword">this</span>.components[<span class="number">1</span>] * components[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.crossProduct(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 0, -3, 3 ] &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(other.crossProduct(one))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 0, 3, -3 ] &#125;</span></span></pre></td></tr></table></figure><h2 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h2><p>在现实生活的应用中，上述方法是远远不够的。比如说，我们有时需要找到两个向量的夹角、将一个向量反向，或者计算一个向量在另一个向量上的投影等。</p><p>在开始编写上面说的方法前，需要先写下面两个函数，用于在角度与弧度间相互转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toDegrees = <span class="function"><span class="params">radians</span> =&gt;</span> (radians * <span class="number">180</span>) / <span class="built_in">Math</span>.PI</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toRadians = <span class="function"><span class="params">degrees</span> =&gt;</span> (degrees * <span class="built_in">Math</span>.PI) / <span class="number">180</span></span></pre></td></tr></table></figure><h3 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  angleBetween(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> toDegrees(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">Math</span>.acos(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.dotProduct(other) /</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        (<span class="keyword">this</span>.length() * other.length())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.angleBetween(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 45.00000000000001</span></span></pre></td></tr></table></figure><h3 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h3><p>当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  negate() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scaleBy(<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vector.negate())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ -2, -2 ] &#125;</span></span></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p><img src="https://lsvih.com/images/15615126897492.jpg" alt="project v on d"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  projectOn(other) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> normalized = other.normalize()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> normalized.scaleBy(<span class="keyword">this</span>.dotProduct(normalized))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">8</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">7</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(other.projectOn(one))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector &#123; components: [ 6, 3 ] &#125;</span></span></pre></td></tr></table></figure><h3 id="设定长度"><a href="#设定长度" class="headerlink" title="设定长度"></a>设定长度</h3><p>当需要给向量指定一个长度时，可以使用如下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  withLength(newLength) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.normalize().scaleBy(newLength)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.length())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.6055512754639896</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modified = one.withLength(<span class="number">10</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(modified.length())</span></pre></td></tr></table></figure><h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p>为了判断两个向量是否相等，可以对它们对应的分量使用  <strong>areEqual</strong> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.components = components</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  equalTo(&#123; components &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> components.every(<span class="function">(<span class="params">component, index</span>) =&gt;</span> areEqual(component, <span class="keyword">this</span>.components[index]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.equalTo(other))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.equalTo(another))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// false</span></span></pre></td></tr></table></figure><h2 id="单位向量与基底"><a href="#单位向量与基底" class="headerlink" title="单位向量与基底"></a>单位向量与基底</h2><p>我们可以将一个向量看做是“在 x 轴上走 $v_x$ 的距离、在 y 轴上走 $v_y$ 的距离、在 z 轴上走 $v_z$ 的距离”。我们可以使用 $\hat { \imath }$ 、$\hat { \jmath }$ 和 $\hat { k }$ 分别乘上一个值更清晰地表示上述内容。下图分别是 $x$、$y$、$z$ 轴上的<strong>单位向量</strong>：</p><script type="math/tex; mode=display">\hat { \imath } = ( 1,0,0 ) \quad \hat { \jmath } = ( 0,1,0 ) \quad \hat { k } = ( 0,0,1 )</script><p>任何数值乘以 $\hat { \imath }$ 向量，都可以得到一个第一维分量等于该数值的向量。例如：</p><script type="math/tex; mode=display">2 \hat { \imath } = ( 2,0,0 ) \quad 3 \hat { \jmath } = ( 0,3,0 ) \quad 5 \hat { K } = ( 0,0,5 )</script><p>向量中最重要的一个概念是<strong>基底</strong>。设有一个 3 维向量 $\mathbb{R}^3$，它的基底是一组向量：${\hat{e}_1,\hat{e}_2,\hat{e}_3}$，这组向量也可以作为 $\mathbb{R}^3$ 的坐标系统。如果 ${\hat{e}_1,\hat{e}_2,\hat{e}_3}$ 是一组基底，则可以将任何向量 $\vec{v} \in \mathbb{R}^3$ 表示为该基底的系数 $(v_1,v_2,v_3)$：</p><script type="math/tex; mode=display">\vec{v} = v_1 \hat{e}_1 + v_2 \hat{e}_2 + v_3 \hat{e}_3</script><p>向量 $\vec{v}$ 是通过在 $\hat{e}_1$ 方向上测量 $v_2$ 的距离、在 $\hat{e}_2$ 方向上测量 $v_1$ 的距离、在 $\hat{e}_3$ 方向上测量 $v_3$ 的距离得出的。</p><p>在不知道一个向量的基底前，向量的系数三元组并没有什么意义。只有知道向量的基底，才能将类似于 $(a,b,c)$ 三元组的数学对象转化为现实世界中的概念（比如颜色、概率、位置等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用 React 制作线性代数教程示例：网格与箭头</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/</id>
    <published>2019-06-26T01:00:00.000Z</published>
    <updated>2019-06-26T02:08:16.948Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我撰写了这个线性代数系列的<a href="https://medium.com/@geekrodion/linear-algebra-vectors-f7610e9a0f23" target="_blank" rel="noopener">开篇之作</a>。在新篇开始动笔前，我有了一个想法：使用 React 开发一个项目，来为这个系列的所有示例提供可视化功能一定很好玩！本系列的所有代码都存放于<a href="https://github.com/RodionChachura/linear-algebra" target="_blank" rel="noopener">此 GitHub 仓库</a>，本文相关代码的提交记录位于<a href="https://github.com/RodionChachura/linear-algebra/tree/813cfecfda70cb3a9415c21ead97e09242e08f49" target="_blank" rel="noopener">此处</a>。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本系列刚开始写作时，只有一个章节涉及了向量的基本运算。所以，目前实现一个能渲染二维坐标网格以及能将向量可视化为箭头的组件就够用了。本文最后做出的效果如下图所示，你也可以在<a href="https://rodionchachura.github.io/linear-algebra/" target="_blank" rel="noopener">此处</a>进行体验。</p><p><img src="https://lsvih.com/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f333833302f312a3338743653416c5363676d42476a58516e39635475412e676966.gif" alt="二维空间中的基本向量运算"></p><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>其实已经有关于创建 React 项目的最佳实践指南文章可供参考，不过在本文中，我们将尽可能减少依赖的库，并简化对项目的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">create-react-app linear-algebra-demo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linear-algebra-demo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">npm install --save react-sizeme styled-components</span></pre></td></tr></table></figure><p>上面的脚本安装了两个库。第一个库 <code>react-sizeme</code> 可以实现当窗体大小发生变化时，重新渲染网格组件。第二个库 <code>styled-components</code> 则能让我们更轻松地编写组件的样式。此外，要用到我们正在开发的 <strong>linear-algebra</strong> 库，需要在 <strong>package.json</strong> 中进行如下引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &quot;linear-algebra&quot;: &quot;file:..&#x2F;library&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://lsvih.com/images/15615123069092.jpg" alt="项目结构"></p><p>本系列为每个示例都在 <code>views</code> 目录中创建了各自的组件。我们在 <strong>index.js</strong> 中导出一个以示例名称为键、以对应组件为值的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorLength &#125; <span class="keyword">from</span> <span class="string">'./vector-length'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorScale &#125; <span class="keyword">from</span> <span class="string">'./vector-scale'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsAddition &#125; <span class="keyword">from</span> <span class="string">'./vectors-addition'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsSubtraction &#125; <span class="keyword">from</span> <span class="string">'./vectors-subtraction'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsDotProduct &#125; <span class="keyword">from</span> <span class="string">'./vectors-dot-product'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'vectors: addition'</span>: VectorsAddition,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'vectors: subtraction'</span>: VectorsSubtraction,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'vectors: length'</span>: VectorLength,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'vectors: scale'</span>: VectorScale,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="string">'vectors: dot product'</span>: VectorsDotProduct</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>接着在 <code>Main</code> 组件中导入该对象，并在菜单中展示出所有的键。当用户通过菜单选择示例后，更新组件状态，并渲染新的 <code>view</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> views <span class="keyword">from</span> <span class="string">'./views'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MenuItem <span class="keyword">from</span> <span class="string">'./menu-item'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">  ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Menu = styled.div<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">  ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      view: <span class="built_in">Object</span>.keys(views)[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; view &#125; = <span class="keyword">this</span>.state</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> View = views[view]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> viewsNames = <span class="built_in">Object</span>.keys(views)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> MenuItems = <span class="function"><span class="params">()</span> =&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      viewsNames.map(<span class="function"><span class="params">name</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &lt;MenuItem</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">          key=&#123;name&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          selected=&#123;name === view&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">          text=&#123;name&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">          onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">view</span>: name &#125;)&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">      ))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      &lt;Container&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &lt;View /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &lt;Menu&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">          &lt;MenuItems /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/Menu&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>Container&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span></pre></td></tr></table></figure><h2 id="网格组件"><a href="#网格组件" class="headerlink" title="网格组件"></a>网格组件</h2><p>为了在之后的示例中渲染向量和其它内容，我们设计了一个功能强大的组件，这个组件需要有这么一种投影功能：将我们熟知的直角坐标系（原点在中间，y 轴正向朝上）投影到 <strong>SVG</strong> 坐标系（原点在左上角，y 轴正向朝下）中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.updateProject(<span class="function"><span class="params">vector</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 在 vector 类中没有任何用于缩放的方法，因此在这里进行计算：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> scaled = vector.scaleBy(step)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> withNegatedY = <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    scaled.components[<span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    -scaled.components[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> middle = getSide(size) / <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> withNegatedY.add(<span class="keyword">new</span> Vector(middle, middle))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure><p>为了捕获到网格组件容器的大小变动，我们使用 <strong>react-size</strong> 库提供的函数将这个组件包装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">'react-sizeme'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  updateProject = <span class="function">(<span class="params">size, cells</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> step = getStepLen(size, cells)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.props.updateProject(<span class="function"><span class="params">()</span> =&gt;</span> /...)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  componentWillReceiveProps(&#123; size, cells &#125;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.updateProject) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> newStepLen = getStepLen(size, cells)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> oldStepLen = getStepLen(<span class="keyword">this</span>.props.size, cells)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (newStepLen !== oldStepLen) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.updateProject(size, cells)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.updateProject) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">this</span>.updateProject(<span class="keyword">this</span>.props.size, <span class="keyword">this</span>.props.cells)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(Grid)</span></pre></td></tr></table></figure><p>为了便于在不同的示例中使用这个网格组件，我们编写了一个 <strong>GridExample</strong> 组件，它可以接收两个参数：一个用于渲染信息（例如向量的名称）的函数 <code>renderInformation</code>，以及一个用于在网格上呈现内容（如后面的箭头组件）的函数 <code>renderGridContent</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Grid <span class="keyword">from</span> <span class="string">'./grid'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(props)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.state = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      project: <span class="literal">undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  render() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; project &#125; = <span class="keyword">this</span>.state</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; renderInformation, renderGridContent &#125; = <span class="keyword">this</span>.props</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> Content = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (project &amp;&amp; renderGridContent) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> renderGridContent(&#123; project &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> Information = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (renderInformation) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> renderInformation()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      &lt;Container&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &lt;Grid cells=&#123;<span class="number">10</span>&#125; updateProject=&#123;project =&gt; <span class="keyword">this</span>.setState(&#123; project &#125;)&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">          &lt;Content /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/Grid&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        &lt;InfoContainer&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">          &lt;Information /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &lt;<span class="regexp">/InfoContainer&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;/</span>Container&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span></pre></td></tr></table></figure><p>这样就能在 view 中使用这个组件了。下面以向量的加法为例测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/vector'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GridExample <span class="keyword">from</span> <span class="string">'../grid-example'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Arrow <span class="keyword">from</span> <span class="string">'../arrow'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VectorView <span class="keyword">from</span> <span class="string">'../vector'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VectorsAddition = <span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">6</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> oneName = <span class="string">'v⃗'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> otherName = <span class="string">'w⃗'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> oneColor = theme.color.green</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> otherColor = theme.color.red</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> sum = one.add(other)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> sumColor = theme.color.blue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> sumText = <span class="string">`<span class="subst">$&#123;oneName&#125;</span> + <span class="subst">$&#123;otherName&#125;</span>`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> renderInformation = <span class="function"><span class="params">()</span> =&gt;</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &lt;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      &lt;VectorView components=&#123;one.components&#125; name=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &lt;VectorView</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        components=&#123;other.components&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        name=&#123;otherName&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        color=&#123;otherColor&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      &lt;VectorView components=&#123;sum.components&#125; name=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  const renderGridContent = (&#123; project &#125;) =&gt; (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;Arrow project=&#123;project&#125; vector=&#123;one&#125; text=&#123;oneName&#125; color=&#123;oneColor&#125; /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">      &lt;Arrow</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        project=&#123;project&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        vector=&#123;other&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        text=&#123;otherName&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        color=&#123;otherColor&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;sum&#125; text=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  const props = &#123; renderInformation, renderGridContent &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="regexp"></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  return &lt;GridExample &#123;...props&#125; /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTheme(VectorsAddition)</span></pre></td></tr></table></figure><h2 id="箭头组件"><a href="#箭头组件" class="headerlink" title="箭头组件"></a>箭头组件</h2><p>箭头组件由 3 个 <strong>SVG</strong> 元素组成：<strong>line</strong> 用于显示箭头的线、<strong>polygon</strong> 用于显示箭头的头、<strong>text</strong> 用于显示向量名称。此外，我们需要接收 <strong>project</strong> 函数，用于将箭头放在网格中正确的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">'linear-algebra/vector'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Arrow = styled.line<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">  stroke-width: 2px;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">  stroke: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Head = styled.polygon<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Text = styled.text<span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">  font-size: 24px;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="string">`</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; vector, text, color, project &#125;) =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> direction = vector.normalize()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> headStart = direction.scaleBy(vector.length() - <span class="number">0.6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> headSide = <span class="keyword">new</span> Vector(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    direction.components[<span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    -direction.components[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  ).scaleBy(<span class="number">0.2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> headPoints = [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    headStart.add(headSide),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    headStart.subtract(headSide),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    vector</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    .map(project)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    .map(<span class="function"><span class="params">v</span> =&gt;</span> v.components)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> projectedStart = project(<span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> projectedEnd = project(vector)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> PositionedText = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!text) <span class="keyword">return</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> &#123; components &#125; = project(vector.withLength(vector.length() + <span class="number">0.2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">      &lt;Text color=&#123;color&#125; x=&#123;components[<span class="number">0</span>]&#125; y=&#123;components[<span class="number">1</span>]&#125;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#123;text&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">      &lt;<span class="regexp">/Text&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  return (</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">    &lt;g&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      &lt;Arrow</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        color=&#123;color&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        x1=&#123;projectedStart.components[0]&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        y1=&#123;projectedStart.components[1]&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        x2=&#123;projectedEnd.components[0]&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">        y2=&#123;projectedEnd.components[1]&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">      /</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">      &lt;Head color=&#123;color&#125; points=&#123;headPoints&#125; /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">      &lt;PositionedText /&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="regexp">/g&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">  )</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="regexp">&#125;</span></span></pre></td></tr></table></figure><hr><p>通过结合 <strong>React</strong> 与 <strong>SVG</strong> 可以做更多有意思的事。在本系列的后面章节中，我们会给这个可视化示例添加更多的功能。最后推荐另一篇类似的文章：<a href="https://medium.com/@geekrodion/bar-chart-with-react-3b20b7907633" target="_blank" rel="noopener">使用 <strong>React</strong> 与 <strong>SVG</strong> 制作复杂的条形图</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>An Online Social Network-based Recommendation System 论文笔记</title>
    <link href="https://lsvih.com/2019/05/23/An%20Online%20Social%20Network-based%20Recommendation%20System/"/>
    <id>https://lsvih.com/2019/05/23/An%20Online%20Social%20Network-based%20Recommendation%20System/</id>
    <published>2019-05-23T14:48:00.000Z</published>
    <updated>2019-05-23T14:48:31.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作者提出了一种基于社会网络的推荐系统，这种推荐系统利用用户资料以及用户与用户之间的连接进行推荐（具体来说是通过用户的打分矩阵和对应的朋友关系来推荐）。</p><blockquote><p>本文的数据来源于一个名为 BoardGameGeek（BGG）的网站，在数据一节详细描述</p></blockquote><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p>所谓推荐系统，是一种基于用户以往数据、通过某些算法计算，向用户推送新内容的一种机制，在 20 世纪互联网经济发展中被广泛使用。最早利用推荐系统扩大利润的是电商 Amazon，他们利用用户曾经购买或评分的商品来预测用户之后可能会购买的商品并进行推送，从而促使用户购买更多的商品。</p><p>推荐系统最常用的方式就是基于内容的<strong>协同过滤</strong>方法（这种方式在今天也被广泛使用，好处是推荐较为准确，坏处是计算量极大），具体来说就是通过计算多个用户喜好的相似，来推荐对应的对象。</p><p>推荐系统研究的一个难点就是数据的获取，使用用户数据容易触及隐私问题，因此各个公司都是在利用用户的公开数据来进行推荐系统的研究。这又有另一个问题：很多用户的公开数据并不完全（比如获取不到用户间的联系），导致困难重重。此外，传统的算法的前提假设为用户是独立的存在，因此无法利用用户的结构信息来进行推荐。</p><p>作者通过对社会学和机器学习的研究，为 boardgaming 开发了一种 Online Social Network-based（OSN）推荐系统，实现了较好的推荐效果。</p><p>最后作者还对数据的隐私问题和算法的应用进行了讨论。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>BoardGameGeek（BGG）是一个知名的游戏站点，人们在其中讨论各种游戏机和卡带，并且会对各个游戏、主机等产品进行评价、打分。比较特殊的是，这个网站包含了大量的公开社交信息（玩家会公开加好友，并进行讨论），因此适合用来使用社会网络来构建推荐系统。</p><p>最终，作者使用的数据包括：</p><ul><li>大约 3 万条被用户评价过的游戏数据</li><li>大约 4 万条曾经评价过游戏的用户数据</li><li>所有的任意用户对任意游戏的评价数据</li><li>各个用户“愿望清单”的游戏列表</li><li>用户与用户之间的好友关系</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>作者使用了概率矩阵分解算法（probabilistic matrix factorization，简称 PMF 算法）。在此简单描述一下这个算法：</p><p>给定一个维数为 $M \times N$ 的评价矩阵 $R$，其中 $R_{ij}$ 可以表示用户 $i$ 对游戏 $j$ 的评价分数。而 PMF 算法的目的就是对评价矩阵 $R$ 进行矩阵分解，找到评价矩阵的因子：</p><script type="math/tex; mode=display">R \approx U G</script><p>其中 $U \in \mathcal { R } ^ { M \times D } $, $G \in \mathcal { R } ^ { D \times N }$。作者假设有一些“原型用户”（prototype user），这种用户具有评分和喜好的代表性。上式中的$D$就是这种“原型用户”的数量。因此上面的矩阵分解就能得出原型用户的评分矩阵。作者直接利用 FA、PCA 之类的矩阵分解算法，使用方差 $\left( \sum _ { i , j } R _ { i j } - U _ { i } ^ { T } G _ { j } \right) ^ { 2 }$ 作为损失函数，对矩阵分解算法进行优化。（注，这应该是非常稀疏的矩阵分析）</p><p>为了把社会网络的信息加入模型中，作者将社交信息定义为矩阵 $F$，其维数是 $M \times M$。在 $F$ 中，如果用户 $i$ 和 $j$ 是好友关系，则 $F_{ij} = 1$，否则为 0。由此，作者将前面的矩阵分析式子改写为：</p><script type="math/tex; mode=display">R \approx F U G</script><p>转换问题，写作：</p><script type="math/tex; mode=display">F^{-1} R \approx U G</script><p>这样就可以继续用前文的方法求出原型用户的评分了。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者使用 SE（方差）loss 对矩阵分解进行优化，在训练迭代过程中 loss 下降情况如下图所示：</p><p><img src="https://lsvih.com/images/15586229007735.jpg" alt="-w445"></p><p>可以看到算法确实收敛了。（个人觉得可能过拟合了）</p><p>这个实验因为没有标注数据，所以也不好进行评价。因此作者用少数的数据作为测试集来验证效果，发现结果不错，最后直接将这个 baseline 做成了一款 Web 应用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种同时利用社会网络信息和用户评分信息的推荐算法，改善了推荐系统的效果。其意义是找了一种方法来把简单的社会网络信息给整合进传统的评分矩阵分解法中。总体来说整个文章的方法非常简单，而且实验不够置信，但可以用来参考了解“基于社会网络的推荐系统”这一课题。</p><p>此外，这篇文献的年代其实比较久远，目前已经有各种各样利用 Network Embedding 的方法，利用各种异构网络信息去做推荐系统，但其实主要的方法还是这篇文章中的方法：将评分矩阵与网络表示矩阵进行合并，然后再做矩阵分析。区别是本文的 Social Network 的表示实质上就是最简单的 one-hot Network Embedding，如果换成现代先进的 node2vec、deep walk 之类的方法应该会有所提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="recommendation system" scheme="https://lsvih.com/tags/recommendation-system/"/>
    
      <category term="social network" scheme="https://lsvih.com/tags/social-network/"/>
    
  </entry>
  
  <entry>
    <title>使用 PyTorch 在 MNIST 数据集上进行逻辑回归</title>
    <link href="https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/"/>
    <id>https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/</id>
    <published>2019-04-29T04:02:00.000Z</published>
    <updated>2019-06-30T04:16:29.630Z</updated>
    
    <content type="html"><![CDATA[<p><strong>逻辑回归（Logistic Regression）</strong>既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了<strong>逻辑回归</strong>与<strong>线性回归</strong>的区别。</p><p><img src="https://lsvih.com/images/15618681795750.jpg" alt=""></p><p>本文将展示如何使用 PyTorch 编写逻辑回归模型。<br><a id="more"></a><br>我们将尝试在 MNIST 数据集上解决分类问题。首先，导入我们所需要的所有库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dsets</span></pre></td></tr></table></figure><p>在创建模型前，我喜欢列一个如下的步骤表。PyTorch 官网[2]上也有这个步骤列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：加载数据集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二步：使数据集可迭代</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三步：创建模型类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第四步：将模型类实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第五步：实例化 Loss 类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第六步：实例化优化器类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第七步：训练模型</span></span></pre></td></tr></table></figure><p>下面我们将一步步完成上述的步骤。</p><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>我们使用 <strong>torchvision.datasets</strong> 来加载数据集。这个库中包含了几乎全部的用于机器学习的流行数据集。在[3]中可以看到完整的数据集列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">train_dataset = dsets.MNIST(root=<span class="string">'./data'</span>, train=<span class="keyword">True</span>, transform=transforms.ToTensor(), download=<span class="keyword">False</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">test_dataset = dsets.MNIST(root=<span class="string">'./data'</span>, train=<span class="keyword">False</span>, transform=transforms.ToTensor())</span></pre></td></tr></table></figure><h3 id="使数据集可迭代"><a href="#使数据集可迭代" class="headerlink" title="使数据集可迭代"></a>使数据集可迭代</h3><p>我们利用 DataLoader 类，使用以下代码来让我们的数据集可被迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="keyword">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="keyword">False</span>)</span></pre></td></tr></table></figure><h3 id="创建模型类"><a href="#创建模型类" class="headerlink" title="创建模型类"></a>创建模型类</h3><p>现在，我们将创建一个用来定义逻辑回归模型结构的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">(torch.nn.Module)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim, output_dim)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        super(LogisticRegression, self).__init__()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.linear = torch.nn.Linear(input_dim, output_dim)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        outputs = self.linear(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> outputs</span></pre></td></tr></table></figure><h3 id="将模型类实例化"><a href="#将模型类实例化" class="headerlink" title="将模型类实例化"></a>将模型类实例化</h3><p>在将模型类实例化之前，我们先初始化如下所示的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">n_iters = <span class="number">3000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">epochs = n_iters / (len(train_dataset) / batch_size)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">input_dim = <span class="number">784</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">output_dim = <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">lr_rate = <span class="number">0.001</span></span></pre></td></tr></table></figure><p>然后，就能初始化我们的逻辑回归模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">model = LogisticRegression(input_dim, output_dim)</span></pre></td></tr></table></figure><h3 id="实例化-Loss-类"><a href="#实例化-Loss-类" class="headerlink" title="实例化 Loss 类"></a>实例化 Loss 类</h3><p>我们使用交叉熵损失来计算 loss：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.CrossEntropyLoss() <span class="comment"># 计算 softmax 分布之上的交叉熵损失</span></span></pre></td></tr></table></figure><h3 id="实例化优化器类"><a href="#实例化优化器类" class="headerlink" title="实例化优化器类"></a>实例化优化器类</h3><p>优化器（optimizer）就是我们即将使用的学习算法。在本例中，我们将使用随机梯度下降（SGD）作为优化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=lr_rate)</span></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>这就是最后一步了。我们将用以下的代码来训练模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">iter = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(int(epochs)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span> * <span class="number">28</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        labels = Variable(labels)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        optimizer.zero_grad()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        outputs = model(images)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        loss = criterion(outputs, labels)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        loss.backward()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        optimizer.step()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        iter+=<span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> iter%<span class="number">500</span>==<span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 计算准确率</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            correct = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            total = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                outputs = model(images)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                total+= labels.size(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="comment"># 如果用的是 GPU，则要把预测值和标签都取回 CPU，才能用 Python 来计算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                correct+= (predicted == labels).sum()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            accuracy = <span class="number">100</span> * correct/total</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            print(<span class="string">"Iteration: &#123;&#125;. Loss: &#123;&#125;. Accuracy: &#123;&#125;."</span>.format(iter, loss.item(), accuracy))</span></pre></td></tr></table></figure><p>在训练时，这个模型只需要进行 3000 次迭代就能达到 <strong>82%</strong> 的准确率。你可以试着继续调整一下参数，看看还能不能把准确率再调高一点。</p><p>如果你想加深对在 PyTorch 中实现逻辑回归的理解，可以把上面的模型应用于任何分类问题。比如，你可以训练一个逻辑回归模型来对你最喜爱的<strong>漫威英雄</strong>的图像做个分类（有一半已经化灰了，所以做分类应该不是很难）:)</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] <a href="https://www.statisticssolutions.com/what-is-logistic-regression/" target="_blank" rel="noopener">https://www.statisticssolutions.com/what-is-logistic-regression/</a></p><p>[2] <a href="https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py" target="_blank" rel="noopener">https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py</a></p><p>[3] <a href="https://pytorch.org/docs/stable/torchvision/datasets.html" target="_blank" rel="noopener">https://pytorch.org/docs/stable/torchvision/datasets.html</a></p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5cc66d946fb9a032286173a7" target="_blank" rel="noopener">https://juejin.im/post/5cc66d946fb9a032286173a7</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;逻辑回归（Logistic Regression）&lt;/strong&gt;既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了&lt;strong&gt;逻辑回归&lt;/strong&gt;与&lt;strong&gt;线性回归&lt;/strong&gt;的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/15618681795750.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将展示如何使用 PyTorch 编写逻辑回归模型。&lt;br&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="pytorch" scheme="https://lsvih.com/tags/pytorch/"/>
    
      <category term="MNIST" scheme="https://lsvih.com/tags/MNIST/"/>
    
  </entry>
  
  <entry>
    <title>Robust Classification with Convolutional Prototype Learning 论文笔记</title>
    <link href="https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-07T10:48:00.000Z</published>
    <updated>2019-04-08T01:36:59.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。<br>论文地址：<a href="https://arxiv.org/abs/1805.03438v1" target="_blank" rel="noopener">https://arxiv.org/abs/1805.03438v1</a><br>论文代码：<a href="https://github.com/YangHM/Convolutional-Prototype-Learning" target="_blank" rel="noopener">https://github.com/YangHM/Convolutional-Prototype-Learning</a></p></blockquote><p>这篇文章在原型学习（prototype learning）与 CNN 的基础之上，提出了一种有效的学习方式，并设计了几种不同的 loss 函数，这些损失函数均能从直观上理解其效果并在实验中证明它们的有效性。通过学习这篇文章，可以更好地了解原型学习以及 loss 的设计，同时可以直接将文中的方法用于一些下游应用。</p><p><strong>此外需要注意的是</strong>，这篇文章的“Robust classification”和 Goodfellow 提出的对抗样本型“Robust model”是两码事。这篇文章没有对模型对于对抗样本的 Robust 进行分析，但本文提出的方法学习到的分类器对于任务来说是 Robust 的。从文章的实验结果来看，将这篇文章提出的方法称为“Robust”一点也不为过，毕竟“Robust”又不是 Goodfellow 发明的，各人可以有自己的理解。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章主要按以下的框架描述了作者提出的方法：</p><ul><li>背景与相关工作</li><li>卷积原型学习（Convolutional prototype learning）</li><li>设计的各种 loss 函数</li><li>实验结果与分析</li></ul><p>因此，这篇笔记也按照论文作者的写作顺序记录。</p><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p><img src="https://lsvih.com/images/15546341569411.jpg" alt=""></p><p>文章开头就给了这张图，描述了传统的 CNN 模型 + cross entropy loss 在 MNIST 上训练出来的特征的二维表示。作者用此图片说明了传统 CNN 模型的问题：学习出来的分类特征在特征空间内非常集中，甚至有很多类内距离（intra-class）小于类间距离（inter-class）的情况。这种情况也就会导致最终的分类效果变差，并且分类模型不易拓展等不够“Robust”的问题。</p><blockquote><p>这个图片的具体作图方法，是把模型输出层前的最后隐层（bottleneck layer）设定为两个神经元，训练完成后，将样本送入神经网络，取出这两个神经元的输出，将输出分别设为 X 与 Y 轴，即得到了这张图。（这个方法可以用在别的需要可视化特征的场景中，可以免去 PCA 等降维步骤。不过在一些比较复杂的任务里貌似这么训练会很难收敛）</p></blockquote><p>尽管后来还有人为此做了各种改进，比如 triple loss、centre loss 等，来改善这种情况，但这些方法都没有离开 softmax + cross entropy 的范畴，也没有根本解决问题。因此作者基于原型学习的思想，利用 CNN 作为特征提取的工具，提出了一种原型学习框架 Convolutional prototype learning（后文直接记为 CPL），同时为它设计了几种模式的 loss 函数，在实验上取得了良好的效果。</p><blockquote><p>关于什么是原型学习，可以了解一下 LVQ 算法。</p></blockquote><h2 id="卷积原型学习"><a href="#卷积原型学习" class="headerlink" title="卷积原型学习"></a>卷积原型学习</h2><p><img src="https://lsvih.com/images/15546341698125.jpg" alt=""></p><p>如图所示。这个框架其实思路很简单：</p><ol><li>利用 CNN 进行特征提取：直接将 CNN 看做是一个 $f(x,\theta)$ 的函数，输入的 x 是数据，$\theta$ 是 CNN 的参数；输出的是特征。</li><li>用一个或多个原型来对应每一个分类（文章后来用实验证明了一个分类对应一个原型就可以有足够好的效果）。</li><li>在训练时，让原型与原型间的欧式距离尽量远，让特征与对应类别原型的欧式距离尽量近：</li></ol><script type="math/tex; mode=display">\begin{array} { l } { x \in \text { class arg } \max _ { i = 1 } ^ { C } g _ { i } ( x ) } \\ { g _ { i } ( x ) = - \min _ { j = 1 } \left\| f ( x ; \theta ) - m _ { i j } \right\| _ { 2 } ^ { 2 } } \end{array}</script><p>（上式中各符号代表的含义请参考原论文 3.1 与 3.2）</p><h2 id="loss-函数"><a href="#loss-函数" class="headerlink" title="loss 函数"></a>loss 函数</h2><p>这部分是文章的核心。为了实现上面一节说的 CPL，必须要有合适的 loss 函数，这种 loss 函数需要满足以下几个条件：</p><ol><li>符合 CPL 的思路，及让原型与原型间距离尽量远，让特征与对应原型的距离尽量近。</li><li>需要对 CNN 可导（这样才能通过 BP 算法去优化 CNN 的参数 $\theta$，也就才能让 CNN 提取出正确的特征）</li><li>需要对原型可导（这样才符合原型学习的思想，才能去不断调整原型在特征空间中的位置）</li></ol><p>因此，这篇文章设计的几个 loss 函数都会去证明 $\frac { \partial l } { \partial f }$ 与 $\frac { \partial l } { \partial M }$ 的可导性。（l 是 loss 函数，f 是 CNN 特征提取器，M 是原型集），笔记中就不再赘述。</p><p>下文将逐个说明论文提出的 loss 函数。</p><h3 id="Minimum-classification-error-loss-MCE"><a href="#Minimum-classification-error-loss-MCE" class="headerlink" title="Minimum classification error loss(MCE)"></a>Minimum classification error loss(MCE)</h3><p>MCE 即“最小分类误差”，是《Discriminative learning for minimum error classification》提出的一种经典的测量指标，主要公式如下：</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + \left[ \frac { 1 } { C - 1 } \sum _ { j \neq y } g _ { j } ( x ) ^ { \eta } \right] ^ { 1 / \eta }</script><p>作者在列这个公式的时候貌似忘了解释 $\eta$ 的作用了。查阅原文发现，这个指标可以用来控制考虑误分类的程度多少。当 $\eta$ 为正无穷的时候，上式等于</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + g _ { r } ( x )</script><p>其中 $g _ { r } ( x ) = \max _ { k \neq y } g _ { k } ( x )$，是“错的最离谱”的错分距离。因此可以将 MCE 记为</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = \left\| f ( x ) - m _ { y i } \right\| _ { 2 } ^ { 2 } - \left\| f ( x ) - m _ { r j } \right\| _ { 2 } ^ { 2 }</script><p>作者按照《Discriminative learning for minimum error classification》中的 Translated sigmoid 公式定义了这个方法最终的 loss 函数计算公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \frac { 1 } { 1 + e ^ { - \xi \mu _ { y } } }</script><p>综上，这个 loss 方法其实优化的是 MCE 指标，重点是作者将 $\mu_y$ 转换为了原型的形式，换句话就是说这个 loss 在优化时，除了会让 CNN 提取出正确的特征外，还会尽量让原型靠近正确的类的特征分布密集区域，远离错误的类的特征分布区域。通过这种方式，可以实现笔记最开头提到的目标。</p><h3 id="Margin-based-classification-loss-MCL"><a href="#Margin-based-classification-loss-MCL" class="headerlink" title="Margin based classification loss(MCL)"></a>Margin based classification loss(MCL)</h3><p>顾名思义，这个 loss 是“基于边距的分类 loss”。这个“margin”在 triple loss 等方法中其实都有用到。作者提出这个方法的思想就是“让一个样本的特征和对应分类的原型在特征空间中的距离，要小于和其它原型在特征空间内的距离”，通过这种思路，就能使得样本尽量不被误分类。按照这个思路，作者提出了公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) \right] _ { + }</script><p>这个公式中的 d 函数就是求样本和原型在特征空间中的欧式距离。整个 loss 用 $\left[ \right] _+$ 包含着，表示只取正值。因为如果样本距离正确分类的原型的距离已经满足要求时，loss 值应该为 0。</p><p>根据上式，作者进一步对这个 loss 进行完善，为它添加了 margin（作用和 triple loss、centre loss 的 margin 是一致的），让“样本离本类原型”的距离要比“样本离其它类原型”距离+margin要更小：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) + m \right] _ { + }</script><p>这样就能达成前文所说的目的。</p><p>作者在此基础上，又为 margin 的值做了进一步的改进。因为在上述 loss 中，margin 的值必须和“样本与原型的距离”值在同一个数量级上才能顺利进行优化。为此，作者稍作转换：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ \frac { d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) } { d \left( f ( x ) , m _ { y i } \right) + d \left( f ( x ) , m _ { r j } \right) } + m \right] _ { + }</script><p>这样，m 在 (0,1) 的范围内取值即可保证数量级的一致性。</p><h3 id="Distance-based-cross-entropy-loss-DCE"><a href="#Distance-based-cross-entropy-loss-DCE" class="headerlink" title="Distance based cross entropy loss(DCE)"></a>Distance based cross entropy loss(DCE)</h3><p> 这个 loss 函数是基于一个约等式：</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) \propto - \left\| f ( x ) - m _ { i j } \right\| _ { 2 } ^ { 2 }</script><p> 这个式子的意义是，可以用“样本距离原型的距离”来测度“样本属于一个原型类别的概率”。这样就能用 cross entropy 之类的方法对概率进行优化了。因此，需要用一个确切的值来把上式给写出来，同时满足：</p><ol><li>概率值是正数</li><li><p>所有概率（即一个样本属于各个原型的概率）的和需要为 1</p><p>为此，作者定义</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) = \frac { e ^ { - \gamma d \left( f ( x ) , m _ { i j } \right) } } { \sum _ { k = 1 } ^ { C } \sum _ { l = 1 } ^ { K } e ^ { - \gamma d \left( f ( x ) , m _ { k l } \right) } }</script><p>此时，样本属于一个分类的概率即为样本属于这个分类的各个原型的概率之和，即为：</p><script type="math/tex; mode=display">p ( y | x ) = \sum _ { j = 1 } ^ { K } p \left( x \in m _ { y j } | x \right)</script><p>应用 cross entropy，可以将最终的 loss 函数写出来：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = - \log p ( y | x )</script><p>这个 loss 相当于换了一个角度考虑，把距离换成了概率然后代入 cross entropy。</p></li></ol><h3 id="Generalized-CPL-with-prototype-loss-GCPL"><a href="#Generalized-CPL-with-prototype-loss-GCPL" class="headerlink" title="Generalized CPL with prototype loss(GCPL)"></a>Generalized CPL with prototype loss(GCPL)</h3><p>除了上述的 loss 之外，作者还提出了一种可以加入上述 loss 中的约束方法。作者给的理由是，由于 CPL 中的参数比较少（因为 CNN 的参数本来就不多），很容易过拟合，因此需要这么一个约束来防止 overfit 情况的发生：</p><script type="math/tex; mode=display">p l ( ( x , y ) ; \theta , M ) = \left\| f ( x ) - m _ { y j } \right\| _ { 2 } ^ { 2 }</script><p>这个式子的意义是，计算在特征空间内样本的位置与对应分类的原型（且为距离最近的一个原型）位置的距离。利用这个约束，可以将前文提到的几种 loss 记为：</p><script type="math/tex; mode=display">\operatorname { loss } ( ( x , y ) ; \theta , M ) = l ( ( x , y ) ; \theta , M ) + \lambda p l ( ( x , y ) ; \theta , M )</script><p>上式中的 $\lambda$ 作用是控制此约束的强硬程度。通过这个约束，可以让同类的原型间的距离更近，不同类的原型间的距离更远。与此同时，就能保证样本在特征空间中的类内距离更近，类间距离更远。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>基于以上方法，作者在 MNIST、CIFAR-10、OLHWDB 数据集上进行了实验。其中，OLHWDB 数据集是一个大规模的中文手写文字数据集，甚至比 ImageNet 还要大。（不过我觉得作者还是应该在 ImageNet 上进行实验，不然整个实验还是不够完整。另外，作者的实验虽然都很置信且完善，但是对比实验选择的 baseline 不够 solid，只用了最基本的 softmax 作为对比，没有考虑最近几年涌现出的各种 softmax 的进阶版。）</p><h3 id="基本分类实验结果"><a href="#基本分类实验结果" class="headerlink" title="基本分类实验结果"></a>基本分类实验结果</h3><ul><li><p>MNIST:<br><img src="https://lsvih.com/images/15546341823585.jpg" alt=""></p></li><li><p>CIFAR-10:<br><img src="https://lsvih.com/images/15546341912068.jpg" alt=""></p></li><li><p>OLHWDB<br><img src="https://lsvih.com/images/15546342050566.jpg" alt=""></p></li></ul><p>可以看到，结果还是不错的，至少证明这篇文章提出的方法在最基本的分类效果上不会比 softmax 差。</p><h3 id="拒识实验"><a href="#拒识实验" class="headerlink" title="拒识实验"></a>拒识实验</h3><p><img src="https://lsvih.com/images/15546342149853.jpg" alt=""></p><p>这个实验结果比较亮眼。最近对模型的“拒识能力”的要求越来越高，所谓拒识，就是在输入 invalid 的测试样本时，模型可以判断出这个是 out-of-domain 的东西，返回拒绝的结果。</p><p>作者的实验方法是，在 MNIST 上进行训练，然后混入 CIFAR 数据集的数据来测试模型的拒识能力。在这种 open-domain 的实验中，我们经常会用某种类似于 min-confidence 的指标来判断送入的数据是不是 out-of-domain，但是像传统的 softmax + cross-entropy 方法中，min-confidence 越大，拒识率虽然会增加，但是准确率却也会明显下降。</p><p>作者提出的方法由于让不同类别的特征分布非常紧密，留出了大量的类间空间，因此在拒识率这块效果很好。</p><p>不过这个实验结果表格还是很微妙，因为每一横行参数啥的都不一样，虽然是为了做 AR 和 RR 的 trade-off 研究，但这样放着还是很奇怪。</p><h3 id="类增量实验"><a href="#类增量实验" class="headerlink" title="类增量实验"></a>类增量实验</h3><p><img src="https://lsvih.com/images/15546342235530.jpg" alt=""></p><p>这个实验其实还不是很常见，一般在 life-long learning 相关的工作里会有这个实验。目的是，测试一个模型在训练完成后新增一个类别的能力。对于标准的 softmax + cross-entropy 来说，自然不存在这一种能力，原因可以参考这篇笔记的第一个图，本来各个类就离的近了，再加一个类直接就乱套了。</p><p>而本文的方法，可以在“基本分类实验”一章的图中看出，样本按照类原型聚集的非常紧密。这样新增一个类并不是什么很困难的事。</p><p>作者的实验方法是，在 MNIST 训练出的模型中，增加 CIFAR-10 的类。可以看上图，做出来的结果依然很不错。</p><h3 id="小样本训练"><a href="#小样本训练" class="headerlink" title="小样本训练"></a>小样本训练</h3><p><img src="https://lsvih.com/images/15546342332247.jpg" alt=""></p><p>这个实验其实槽点也是 baseline 太 weak 了。现在做小样本的模型其实不占少数，但作者还是只选了 softmax 做比较。尽管如此，可以看到 GCPL 的效果还是很不错的。</p><h3 id="多原型实验"><a href="#多原型实验" class="headerlink" title="多原型实验"></a>多原型实验</h3><p>前面的所有实验都是在“一个类别对应一个原型”的设定之下完成的，都有不错的效果。作者在文章最后用“一个类别对应多个原型”的假设进行了实验，结果如下表所示：</p><p><img src="https://lsvih.com/images/15546342428370.jpg" alt=""></p><p>可以观察到，一个类别对应的原型数量其实对结果没有太大的影响。作者给出的解释是，CNN 提取特征的能力已经足够强大，即使初始数据的分布非常复杂，经过 CNN 变换之后，依然可以得到符合单高斯分布的特征分布，也就是一个类别一个原型的分布。</p><p>不过，在更复杂的情景下，一些更复杂的分类状况，多原型可能会发挥它应有的作用。</p><blockquote><p>这块其实也是 trade-off。因为增加一个原型相当于在隐层输出时增加了 Dense Node，会极大地增加空间占用和计算量。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章提出的方法足够新颖，并且取得的结果也非常好。虽然实验部分有些小遗憾（没有和各个任务顶尖的方法对比），但是仍然体现了这篇文章方法的综合性能的优越性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。&lt;br&gt;论文地址：&lt;a h
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="CNN" scheme="https://lsvih.com/tags/CNN/"/>
    
      <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="https://lsvih.com/tags/cnn/"/>
    
      <category term="prototype learning" scheme="https://lsvih.com/tags/prototype-learning/"/>
    
  </entry>
  
  <entry>
    <title>Web 开发者需要了解的基础色彩理论</title>
    <link href="https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/"/>
    <id>https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/</id>
    <published>2019-02-20T01:42:00.000Z</published>
    <updated>2019-02-20T01:55:55.996Z</updated>
    
    <content type="html"><![CDATA[<p>如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。</p><a id="more"></a><p><img src="https://lsvih.com/images/1-1.png" alt="1"></p><p>在小学美术课上应该讲过<strong>一次色</strong>（primary color，即三原色）与<strong>二次色</strong>（seondary color，间色），如果你在小学之后还上过美术课，应该还了解过<strong>三次色</strong>（tertiary color，副色）。</p><p><img src="https://lsvih.com/images/2-1.jpeg" alt="2"></p><p>不过如果你在高中或者更高层次的学校中学习过艺术，那你就会发现，色轮是展示<a href="https://en.wikipedia.org/wiki/Color_theory" target="_blank" rel="noopener">色彩理论</a>、练习混色以及研究色彩组合的最简单的方法。</p><h2 id="何谓色彩理论？"><a href="#何谓色彩理论？" class="headerlink" title="何谓色彩理论？"></a>何谓色彩理论？</h2><p><strong>色彩理论简史</strong>：爱德华·马奈（Édouard Manet）、埃德加·德加（Edgar Degas）、克洛德·莫奈（Claude Monet）等印象派的画家在抛弃写实，而开始尝试捕捉<strong>光色</strong>时，色彩理论就诞生了。</p><p><img src="https://lsvih.com/images/3-2.jpeg" alt="3"></p><p>上图为莫奈的 Haystacks 系列画作</p><p><strong>简单来说</strong>：色彩理论研究的是人的眼睛如何将光波转化为颜色。匹配或相似的色彩往往有着相似或互补的波。</p><p>因此可以将色彩理论归结为光波科学，来解释为什么可以看到各种颜色。不过在本文中，我们只专注于两个问题：</p><ul><li>为什么有些颜色可以完美搭配？</li><li>我们该如何选择“正确”的颜色？</li></ul><p>颜色的搭配问题有点像“与生俱来”的东西。不管怎样，在网页或者 App 里用纯绿色的背景是绝对让人无法忍受的！</p><p>下面我列了一个简表，当你遇到与色彩有关的问题时可以参考：</p><h2 id="Level-1：单色"><a href="#Level-1：单色" class="headerlink" title="Level 1：单色"></a>Level 1：单色</h2><p><strong>单色</strong>就是单一的颜色，或者同种颜色的多个色调的组合。</p><blockquote><p><strong>在 Web 开发时</strong>，你可以在<a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">这个网页中</a>选择并查询某种颜色的 Hex 代码，并且可以在不影响色调的情况下让颜色更亮或更暗。</p></blockquote><p><img src="https://lsvih.com/images/4-1.jpeg" alt="4"></p><p>这就是最简单的网页配色方法。诸如 <a href="http://facebook.com" target="_blank" rel="noopener">Facebook</a>、<a href="http://twitter.com" target="_blank" rel="noopener">Twitter</a> 之类的网站大都是用的这种单色配色方案。黑色、白色、天蓝色组合而成的简单配色，让这些社交 App 更加简洁。</p><p>只有用户的头像、链接、照片有着不同的颜色，这些不同的颜色可以被用户识别，更好地找到他们感兴趣的帖子和账号。</p><p>如果 Twitter 的网页上还有其它的颜色，就会让区分帖子、发帖人变得困难。</p><p>一般来说，即使你需要多种颜色，也得有个主色，所谓背景或者标题的颜色。</p><blockquote><p><strong>专业建议</strong>：如果你的网页要使用单色配色，请确保阴影可以清晰地将各个元素区分开了。否则用户在阅读文本或分离网页元素时将很不方便。</p></blockquote><h2 id="Level-2：互补色"><a href="#Level-2：互补色" class="headerlink" title="Level 2：互补色"></a>Level 2：互补色</h2><p>如果不想在配色中只用各种各样的“橙色”怎么办？如果你想让链接突出，但又不和导航栏或者背景色冲突怎么办？</p><p>如果我们遵循基本色彩理论，解决上述问题的方案就是去寻找<strong>互补色</strong>。</p><p>可以在色轮中一种颜色相对的位置找到它的<strong>互补</strong>色。</p><p><img src="https://lsvih.com/images/5-1.jpeg" alt="5"></p><p>每种<strong>主色</strong>都与一种<strong>副色</strong>作为互补色相对应。有种方法可以轻松记住颜色如何匹配：如果一种<strong>副色</strong>和一种<strong>主色</strong>匹配，那么<strong>副色</strong>的构成色一定不含<strong>主色</strong>。比如，红色的互补色是绿色，而绿色由蓝色和黄色组成。</p><blockquote><p><strong>专业建议</strong>：一次只增加一种颜色，并保持页面简单。不要为了呈现一个完整的彩虹配色牺牲了你干净、好用的布局。不然，你可能会做出上世纪 90 年代流行的经典网站（比如<a href="https://spacejam.com/" target="_blank" rel="noopener">这个</a>）。</p></blockquote><h2 id="继续升级…"><a href="#继续升级…" class="headerlink" title="继续升级…"></a>继续升级…</h2><p>随着你的设计水平的提高，就能自如地挑战自己的极限了。配色并不是什么可怕的工作。你可以多多关注一些配色水平高的开发者（比如<a href="https://www.alispit.tel/#/" target="_blank" rel="noopener">他</a> ）和设计师。多问问自己喜欢什么配色、不喜欢什么配色、为什么，这样就能建立自己的品味与品牌。</p><h2 id="Web-开发者的色彩-Hack"><a href="#Web-开发者的色彩-Hack" class="headerlink" title="Web 开发者的色彩 Hack"></a>Web 开发者的色彩 Hack</h2><p>试试自己手写一些 hex 代码、RBG 数字来尝试各种色彩的组合与混合。如果你是 SASS 的粉丝，可以把配好的颜色存储在文件中，日后在项目中导入。如果你的工作是构建页面结构而不是视觉设计（由客户或者产品经理决定），可以把这些颜色当做是占位符，让页面看起来更加明了。</p><p>请确保：</p><ul><li>所有东西都是可读的。</li><li>链接、标题等你想要强调的东西应该与纯文本有所区别。</li><li>用户可以轻松地区分网页的不同部分（比如导航栏、主要内容、文章等）。</li></ul><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><a href="http://paletton.com/" target="_blank" rel="noopener">Palleton.com</a></li><li><a href="https://coolors.co/" target="_blank" rel="noopener">Coolors.co</a></li></ul><p><a href="https://dev.to/ferkungamaboobo" target="_blank" rel="noopener">Doug R. Thomas, Esq.</a> 强烈推荐以下网站：</p><ul><li><a href="https://color.adobe.com/" target="_blank" rel="noopener">Color.Adobe.com</a></li><li><a href="https://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM — 颜色对比度检查器</a> — 确保文本在背景上的可读性。</li><li><a href="https://www.color-blindness.com/coblis-color-blindness-simulator/" target="_blank" rel="noopener">Coblis — 色盲模拟器</a> — 用色盲滤镜来测试你的布局截图，以确保内容对所有受众都是可读的。</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>希望在读完这篇文章后，你不再为给网站、网页、app 配色感到犯愁。如果你对这个主题感兴趣，强烈建议去了解<a href="https://www.colormatters.com/color-and-design/basic-color-theory" target="_blank" rel="noopener">更多相关知识</a>。本文只是浅显地进行了讲解，你可以读<a href="https://99designs.com/blog/tips/the-7-step-guide-to-understanding-color-theory/" target="_blank" rel="noopener">这篇文章</a>了解更多关于色调和阴影的知识。</p><p>最后我想说，在你给自己的项目进行配色时，并不存在”错误答案“。许多人认为品味是天生就有的，正是它帮助你寻找美妙的设计、带来灵感、尝试各种组合，最终为你和你的品牌找到最适合方案。祝你好运！</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c6caee26fb9a049df24a4df" target="_blank" rel="noopener">https://juejin.im/post/5c6caee26fb9a049df24a4df</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="Color" scheme="https://lsvih.com/tags/Color/"/>
    
      <category term="Design" scheme="https://lsvih.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>十件你不知道的关于 WebPageTest.org 的事(译)</title>
    <link href="https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/"/>
    <id>https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/</id>
    <published>2019-02-16T04:52:00.000Z</published>
    <updated>2019-02-16T05:17:51.304Z</updated>
    
    <content type="html"><![CDATA[<p>够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。</p><p>如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！</p><p>最近我在 Santa Clara 参加了 <a href="http://conferences.oreilly.com/velocity" target="_blank" rel="noopener">Velocity Conference</a>，偶遇了 <a href="https://github.com/pmeenan" target="_blank" rel="noopener">Pat Meenan</a>（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），<del>希望你还没有用过它们</del>。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。</p><a id="more"></a><h2 id="10-模拟单点失效"><a href="#10-模拟单点失效" class="headerlink" title="10. 模拟单点失效"></a>10. 模拟单点失效</h2><p>你的网站很可能依赖了一些第三方库来提供额外的功能（包括且不仅限于监控脚本、A/B 测试和广告）。问题就有可能出在这些你使用的部署在别人服务器上的库，这就是<a href="https://en.wikipedia.org/wiki/Single_point_of_failure" target="_blank" rel="noopener">单点失效</a>（SPOF）风险。如果出于某些原因，导致托管这些库的服务器出现故障或响应缓慢，你的网站也会不幸地收到影响。这种事情可能发生在任何人身上！</p><p>使用 WebPageTest 模拟单点失效与正常测试网站的设置一模一样，不过你需要将第三方库的域名屏蔽。例如，如果你想对 ccn.com 测试单点失效，可以将以下域名复制并粘贴到 SPOF 选项卡中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cdn3.optimizely.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">a.visualrevenue.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">www.google-analytics.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">pixel.quantserve.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">budgetedbauer.com</span></pre></td></tr></table></figure><p>粘贴好后界面应该如下所示：</p><p><img src="https://lsvih.com/images/1-1.jpeg" alt="1"></p><p>当查看此网站的加载视频时，你会发现 WebPagetest 已经对 SPOF 进行了模拟，导致该网站的加载时间长了不少。在<a href="http://www.webpagetest.org/video/compare.php?tests=160705_CE_HJQ,160705_JS_HJR" target="_blank" rel="noopener">上述测试</a>中，网站最终加载完毕共花了 20 多秒！这个功能是测试你的网站在 SPOF 情况下响应情况的好工具。</p><h2 id="9-创建个人-WebPagetest-实例"><a href="#9-创建个人-WebPagetest-实例" class="headerlink" title="9. 创建个人 WebPagetest 实例"></a>9. 创建个人 WebPagetest 实例</h2><p>WebPageTest 公共实例非常方便，你可以免费用它来快速获取需要的信息。不过公共实例有一些限制，比如在某个忙碌的日子里，你可能会需要在排队等待测试结果。如果你将 WebPageTest 用于商业用途，也许需要创建属于自己的私有 WebPageTest 实例。</p><p>Pat Meenan 写了一篇名为 <a href="http://calendar.perfplanet.com/2014/webpagetest-private-instances-in-five-minutes/" target="_blank" rel="noopener">5 分钟上手 WebPagetest 私有实例</a>的指南，介绍了在 Amazon EC2 上如何设置自己的实例。代理在所有 EC2 域中以 AMI 的形式提供，如果你需要在公司防火墙内部进行测试，也可以自行配置。</p><p>私有实例用起来很方便，因为你可以控制测试的基础架构，并且 API 请求数量没有限制。</p><h2 id="8-编写登录脚本"><a href="#8-编写登录脚本" class="headerlink" title="8. 编写登录脚本"></a>8. 编写登录脚本</h2><p>WebPageTest 不仅可以用于测试公开的网站，如果有需要，它也可以通过编写登录网站的脚本测试需要登录的网站。WebPageTest 具有脚本功能，可以自动执行多步测试（比如登录网站和发送电子邮件）。</p><p>例如，如果你想为 AOL 网站编写登录步骤的脚本，可以执行类似于以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">logData0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bring up the login screen</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">navigatehttp:&#x2F;&#x2F;webmail.aol.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">logData1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; log in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">setValuename&#x3D;loginIdsomeuser@aol.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">setValuename&#x3D;passwordsomepassword</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">submitFormname&#x3D;AOLLoginForm</span></pre></td></tr></table></figure><p>请记住不要将重要的登录凭证放在里面！除非你将它们明确设为私有，否则 webpagetest.org 网站上的测试都是公开的。如果你想了解更多有关编写脚本的信息，请查阅此<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/scripting" target="_blank" rel="noopener">链接</a>。</p><h2 id="7-WebPagetest-发明的-Speed-Index-指标"><a href="#7-WebPagetest-发明的-Speed-Index-指标" class="headerlink" title="7.WebPagetest 发明的 Speed Index 指标"></a>7.WebPagetest 发明的 Speed Index 指标</h2><p>WebPagetest 于 2012 年添加了 Speed Index 指标（速度指数），它可以用于标化页面可视内容的填充速度。你可以尝试将不同的页面相互比较（优化之前与之后、自己的网站与竞品等），并与其他指标（加载时间，开始渲染时刻等）结合，来更好地理解这个对于描述网站性能非常有用的指标。如果你想了解更多有关 Speed Index 的信息，请参阅<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="noopener">此链接</a>。</p><h2 id="6-收集自定义指标"><a href="#6-收集自定义指标" class="headerlink" title="6. 收集自定义指标"></a>6. 收集自定义指标</h2><p>WebPageTest 提供了大量有用的统计指标。但你知道吗？你还可以用它来收集你自定义的指标。WebPageTest 可以在测试的最后执行任意的 JavaScript 脚本并收集<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/custom-metrics" target="_blank" rel="noopener">自定义指标</a>。你可以在服务器配置中静态地配置或在每个基础测试进行时配置它。</p><p>其实，自定义指标可以覆写内置指标。当你需要通过 JavaScript 验证强制让测试失败时，可以通过自定义指标得到“测试结果”。<a href="http://httparchive.org/" target="_blank" rel="noopener">HTTP Archive</a> 还通过 <a href="https://github.com/HTTPArchive/httparchive/tree/master/custom_metrics" target="_blank" rel="noopener">自定义指标</a> 采集了一些统计数据。</p><h2 id="5-将-WebPageTest-整合进你的-CI-测试中"><a href="#5-将-WebPageTest-整合进你的-CI-测试中" class="headerlink" title="5. 将 WebPageTest 整合进你的 CI 测试中"></a>5. 将 WebPageTest 整合进你的 CI 测试中</h2><p>如果你想在每次部署新代码时，都确保新代码不会让你在 Web 性能上的努力前功尽弃，那么 WebPageTest 可以帮上忙！你可以在页面上设置“budget”（预算），如果测试结果超过预算值则会导致测试失败。<a href="https://timkadlec.com/2013/01/setting-a-performance-budget/" target="_blank" rel="noopener">Tim Kadlec</a> 创建了一个有用的 <a href="https://github.com/tkadlec/grunt-perfbudget" target="_blank" rel="noopener">Grunt任务</a>，可以用 WebPagetest 的公开或私有实例对指定的 URL 执行测试。Marcel Duran 还为 NodeJS 创建了一个 <a href="https://github.com/marcelduran/webpagetest-api" target="_blank" rel="noopener">WebPageTest API 包装器</a>，可以让你自定义测试的运行方式。</p><p>通过这些方法，每当更新代码时，都能检查网站性能。网页的性能并不是儿戏，而是维系网站生命的重要事项！</p><h2 id="4-你可以自定义瀑布图的显示方式"><a href="#4-你可以自定义瀑布图的显示方式" class="headerlink" title="4. 你可以自定义瀑布图的显示方式"></a>4. 你可以自定义瀑布图的显示方式</h2><p>你知道吗？WebPageTest 可以自定义瀑布图的显示方式。运行测试后，单击瀑布图像并向下滚动，可以看到一个“customize waterfall”（自定义瀑布）的链接。</p><p><img src="https://lsvih.com/images/2.jpeg" alt="2"></p><p>点击这个链接，可以自定义瀑布图的显示方式。很好用！</p><p><img src="https://lsvih.com/images/3-1.jpeg" alt="3"></p><p>如果你要在幻灯片里使用瀑布图，这个功能可让你精准地展示需要展示的部分。</p><h2 id="3-在测试历史记录中对比多个测试结果"><a href="#3-在测试历史记录中对比多个测试结果" class="headerlink" title="3. 在测试历史记录中对比多个测试结果"></a>3. 在测试历史记录中对比多个测试结果</h2><p>在测试历史记录页面中，你可以查看针对特定实例运行过的测试列表。这个页面可以让你以幻灯片的形式直观地比较多个测试。</p><p><img src="https://lsvih.com/images/4.jpeg" alt="4"></p><p>选择要进行比较的测试，就能看到一个幻灯片视图，比较所有过去运行过的测试。</p><p><img src="https://lsvih.com/images/5.jpeg" alt="5"></p><p>需要注意，在运行测试时最好对测试设置标签。这样有助于帮你在历史记录中找到对应的测试，并且在幻灯片、视频视图中显示时也会显示标签。</p><h2 id="2-你也可以为-WebPageTest-代码库做贡献"><a href="#2-你也可以为-WebPageTest-代码库做贡献" class="headerlink" title="2. 你也可以为 WebPageTest 代码库做贡献"></a>2. 你也可以为 WebPageTest 代码库做贡献</h2><p>整个 WebPageTest 的代码库都是开源的！代码库位于 <a href="https://github.com/WPO-Foundation/webpagetest" target="_blank" rel="noopener">Github</a>，包括了 Web UI 和可用于在各种浏览器上运行测试的代码。Pat 提到，这个代码库使用的是非常宽松的 BSD 协议，也就是说你可以出于任何的目的（包括商业等用途）使用项目的任何部分。</p><p>如果你觉得有些东西可以让社区受益，请务必为这个非常棒的工具做出贡献！</p><h2 id="1-检查你的-JavaScript-执行是否导致性能瓶颈"><a href="#1-检查你的-JavaScript-执行是否导致性能瓶颈" class="headerlink" title="1. 检查你的 JavaScript 执行是否导致性能瓶颈"></a>1. 检查你的 JavaScript 执行是否导致性能瓶颈</h2><p>现在 JavaScript 在全世界都非常流行，这也意味着 JavaScript 的执行已经成为了妨碍浏览器性能的一个严重瓶颈。你知道吗？使用 WebPageTest，可以模拟在设备上运行网站，并得到主线程运作的详细情况。</p><p>在运行测试前，打开 Chrome 标签，然后勾选“Capture Dev Tools Timeline”（捕获开开发者工具时间轴）。</p><p><img src="https://lsvih.com/images/6.jpeg" alt="6"></p><p>在测试完成后，点击“Processing Breakdown”（处理详情）按钮，将得到主线程处理过程中的详细视图。通过展示主线程的处理过程的详细情况，可以让你更好地了解网站在真实设备上的确切运行情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：如果你经常使用 WebPageTest，希望这篇文章能帮你了解更多关于它的内容。感谢 <a href="http://blog.patrickmeenan.com/" target="_blank" rel="noopener">Pat Meenan</a> 提供信息并帮忙检查文章！</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c679531f265da2dc45367ab" target="_blank" rel="noopener">https://juejin.im/post/5c679531f265da2dc45367ab</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。&lt;/p&gt;
&lt;p&gt;如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！&lt;/p&gt;
&lt;p&gt;最近我在 Santa Clara 参加了 &lt;a href=&quot;http://conferences.oreilly.com/velocity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Velocity Conference&lt;/a&gt;，偶遇了 &lt;a href=&quot;https://github.com/pmeenan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pat Meenan&lt;/a&gt;（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），&lt;del&gt;希望你还没有用过它们&lt;/del&gt;。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="FrontEnd" scheme="https://lsvih.com/tags/FrontEnd/"/>
    
      <category term="Test" scheme="https://lsvih.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>5 个可以立刻在你的 Ionic App 中用上的动画包</title>
    <link href="https://lsvih.com/2019/01/30/5-%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AB%8B%E5%88%BB%E5%9C%A8%E4%BD%A0%E7%9A%84-Ionic-App-%E4%B8%AD%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%8C%85/"/>
    <id>https://lsvih.com/2019/01/30/5-%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AB%8B%E5%88%BB%E5%9C%A8%E4%BD%A0%E7%9A%84-Ionic-App-%E4%B8%AD%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%8C%85/</id>
    <published>2019-01-30T10:20:00.000Z</published>
    <updated>2019-02-16T05:31:10.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.png" alt="1"></p><p>使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。</p><p>在本文中我们将介绍 <strong>5 个不同的动画包</strong>，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。</p><a id="more"></a><p><img src="https://lsvih.com/images/2.gif" alt="2"></p><p>你可以使用以下代码初始化一个空白的 Ionic 4 App：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ionic start animationPackages blank --type&#x3D;angular</span></pre></td></tr></table></figure><p>我们不会完整地摘录这些包的文档，只会展示如何将它们整合进你的 App 这一重要部分。</p><h2 id="1-Anime-js"><a href="#1-Anime-js" class="headerlink" title="1. Anime.js"></a>1. <a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">Anime.js</a></h2><p>只要安装好这个包，不需要任何别的操作就能将它引入你的 App 中了。你只需要简单地按照下列代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install animejs</span></pre></td></tr></table></figure><p>通过它你可以让你<strong>在你的 Javascript 代码中</strong>创建动画。这也是它与绝大多数包不同的地方：别的包大多是通过添加 CSS class，或者在你的 class 中用特定的语法来创建动画的。</p><p>通过 Anime.js，你能轻松地为屏幕中的元素设定动画并移动它们。下面是创建一个小方块，并用一个函数来创建动画效果的代码（我们给小方块加了一些 CSS 样式，这样它才能在屏幕上有一定的大小）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;animate-me&quot; #box&gt;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SCSS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">.animate-me &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    width: 50px;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    height: 50px;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    padding: 20px;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    background: #0000ff;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">import * as anime from &#39;animejs&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">callAnime() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    anime(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      targets: &#39;.animate-me&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      translateX: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#123; value: 100, duration: 1200 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#123; value: 0, duration: 800 &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      ],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      rotate: &#39;1turn&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      backgroundColor: &#39;#ff00ff&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      duration: 2000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>我们可以用元素的 CSS class 来轻松指定应用动画效果的目标（即 target 参数），其它的参数都不言自明。这也是这个包的强大之处：</p><p>你可以轻松理解这个包的一些基本命令，<strong>快速上手并创建强大的动画效果</strong>。如果选择用这个包来创建动画，你不需要学习又臭又长的 API。</p><h2 id="2-Magic-CSS"><a href="#2-Magic-CSS" class="headerlink" title="2. Magic CSS"></a>2. <a href="https://github.com/miniMAC/magic" target="_blank" rel="noopener">Magic CSS</a></h2><p>这个包依赖于预设好的 CSS 动画，你可以将这些动画加入到元素中。安装方式与前文相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install magic.css</span></pre></td></tr></table></figure><p>不过此时你需要从 node module 将实际的 CSS 文件导入进来，因此你得用类似下面的方法来修改你的 <strong>src/global.scss</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@import &#39;~magic.css&#x2F;magic.min.css&#39;;</span></pre></td></tr></table></figure><p>现在可以在你的 app 中用 Magic CSS 了。你可以直接在元素上添加动画的 class，或者用下面这种方式通过 <code>@ViewChild()</code> 标注将动画 class 加入到元素的 <code>classList</code> 中去，这样就能在特定的时间来创建动画了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;animate-me&quot; #box&gt;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">@ViewChild(&#39;box&#39;) box: ElementRef;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">doMagic() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    this.box.nativeElement.classList.add(&#39;magictime&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    this.box.nativeElement.classList.add(&#39;foolishIn&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>每次你都要先加入 <strong>magictime</strong> class，然后加入你要用的动画的 class 名。</p><p>这个包没有提供那么多的自定义选项，不过如果你只需要<strong>简单且快速的 CSS 动画</strong>，试试它准没错！</p><h2 id="3-Number-Flip"><a href="#3-Number-Flip" class="headerlink" title="3. Number Flip"></a>3. <a href="https://github.com/gaoryrt/number-flip" target="_blank" rel="noopener">Number Flip</a></h2><p>这是一个小巧的包。我最近才发现它，非常喜欢它的动画。不过只有在一种特定的情景下，你才会需要将它加入你的 app（你可以看看它的 Github page，那里面的效果就是它唯一的效果）。安装方式很简单，依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install number-flip</span></pre></td></tr></table></figure><p>假设你的 Ionic app 的顶栏上有一些计数器，现在你希望通过动画效果来修改它的数字。</p><p>这个情景中，number flip 包就非常好用，你可以用帅帅的动画效果让一个元素翻转，并在翻转时修改元素里面的数字。我用一些代码创建了对该元素的引用，当触发 <code>flip()</code> 函数的时候会直接调用动画包里面的 <code>flipTo()</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;ion-header&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &lt;ion-toolbar&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &lt;ion-title&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      Ionic Animations</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;ion-title&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &lt;ion-buttons slot&#x3D;&quot;end&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &lt;div #numberbtn&gt;&lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;ion-buttons&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &lt;&#x2F;ion-toolbar&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;ion-header&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">import &#123; Flip &#125; from &#39;number-flip&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">@ViewChild(&#39;numberbtn&#39;, &#123; read: ElementRef &#125;) private btn: ElementRef;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">flip() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  if (!this.flipAnim) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    this.flipAnim &#x3D; new Flip(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      node: this.btn.nativeElement,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      from: &#39;9999&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  this.flipAnim.flipTo(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    to: Math.floor((Math.random() * 1000) + 1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>当然这个包没有任何别的高级动画效果，它<strong>仅仅在这种特殊情景下特别好用</strong>。如果你要使用计时器或者创建数字动画，考虑考虑它吧！</p><h2 id="4-Animate-CSS"><a href="#4-Animate-CSS" class="headerlink" title="4. Animate CSS"></a>4. <a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">Animate CSS</a></h2><p>它可是一位重磅玩家，在这几个包中就属它的 Github star 最多。它的口号是“像倒水一样添加 CSS 动画”，事实上它的用法确特别简单。安装方法和前文一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install animate.css</span></pre></td></tr></table></figure><p>由于这个包依赖于 CSS，因此使用它前我们也要通过下面的方式将 CSS 文件导入 <strong>src/global.scss</strong> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@import &#39;~animate.css&#x2F;animate.min.css&#39;;</span></pre></td></tr></table></figure><p>现在，我们就可以享受这个包各种预设好的超帅的 CSS 动画了（每个用例都对应着一种动画）。我们还可以添加一些其它的 class，比如说 <code>infinite</code> 让动画循环播放，或者让动画延迟一段时间播放。</p><p>在下面的例子中，我们 ngFor 和它的 index 来定义不同的动画延迟（当然在真实的 app 中不会有这么慢的动画），然后用 <code>ViewChildren</code> 列表来为需要飞出来的元素增加相应的动画 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;h1 text-center class&#x3D;&quot;animated infinite rubberBand delay-1s&quot;&gt;Example&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;ion-list&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;ion-item *ngFor&#x3D;&quot;let val of [&#39;First&#39;, &#39;Second&#39;, &#39;Third&#39;]; let i &#x3D; index;&quot; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    class&#x3D;&quot;animated fadeInLeft delay-&#123;&#123; i &#125;&#125;s&quot; #itemlist&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      &#123;&#123; val &#125;&#125; Item</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;ion-item&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;ion-list&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">@ViewChildren(&#39;itemlist&#39;, &#123; read: ElementRef &#125;) items: QueryList&lt;ElementRef&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">animateItems() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  let elements &#x3D; this.items.toArray();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  elements.map(elem &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return elem.nativeElement.classList.add(&#39;zoomOutRight&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如果你想要个<strong>预设好大量 CSS 动画的武器库</strong>，你一定要试试它。虽然它已经预设好了很多东西，但你也可以根据你的需要来进行组合！</p><h2 id="5-Bounce-js"><a href="#5-Bounce-js" class="headerlink" title="5. Bounce.js"></a>5. <a href="https://github.com/tictail/bounce.js" target="_blank" rel="noopener">Bounce.js</a></h2><p>最后，我想测试这个特别灵活的包。它也可以用 Javascript 来编写动画。这个包的安装方法和其它几个包一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install bounce.js</span></pre></td></tr></table></figure><p>这个包的文档非常完整，你可能要多花一点时间来探索所有的配置，比如下面是他们页面广告中的一个片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;ion-button expand&#x3D;&quot;block&quot; (click)&#x3D;&quot;bounce()&quot; #bouncebtn&gt;Bounce&lt;&#x2F;ion-button&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">import * as Bounce from &#39;bounce.js&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">@ViewChild(&#39;bouncebtn&#39;, &#123; read: ElementRef &#125;)bouncebtn: ElementRef;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">bounce() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  var bounce &#x3D; new Bounce();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  bounce</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    .translate(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      from: &#123; x: -300, y: 0 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      to: &#123; x: 0, y: 0 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      duration: 600,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      stiffness: 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    .scale(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      to: &#123; x: 0.1, y: 2.3 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      easing: &quot;sway&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      duration: 800,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      delay: 65,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      stiffness: 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    .scale(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      to: &#123; x: 5, y: 1 &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      easing: &quot;sway&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      duration: 300,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      delay: 30,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    .applyTo(this.bouncebtn.nativeElement);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如你所见，所有步骤都在你的 Javascript 代码中。你可以用这个包在任何粒度上<strong>创建复杂的关键帧动画</strong>。</p><p>不过这种灵活性是要付出代价的，你需要深入地研究它的文档，因此比起其它的包你需要更多的时间才能入门。不过，如果你付出了时间，它也会回报你的付出：你可以用它在 app 中创建任何你想要的动画！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在推荐的这几个包中，有一些包可以让你快速做出产品，有些包则需要你学习它们的语法；有些包已经预设好了一切动画，而有些包则可以让你创建更灵活的动画；有些包是纯 CSS，还有一些是纯 JS。</p><p>没有哪个是真正“最好的”，因为它们在不同的场景下有着各自的优势。另外，注意这些包的大小也是一件重要的事，你也不希望加太多的东西影响 app 的下载时间吧。</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c517544f265da613b702848" target="_blank" rel="noopener">https://juejin.im/post/5c517544f265da613b702848</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。&lt;/p&gt;
&lt;p&gt;在本文中我们将介绍 &lt;strong&gt;5 个不同的动画包&lt;/strong&gt;，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Ionic" scheme="https://lsvih.com/tags/Ionic/"/>
    
      <category term="Angular" scheme="https://lsvih.com/tags/Angular/"/>
    
      <category term="Animation" scheme="https://lsvih.com/tags/Animation/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>DNS over TLS：端到端加密的 DNS</title>
    <link href="https://lsvih.com/2019/01/23/DNS-over-TLS-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%9A%84%20DNS/"/>
    <id>https://lsvih.com/2019/01/23/DNS-over-TLS-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%9A%84%20DNS/</id>
    <published>2019-01-23T11:13:00.000Z</published>
    <updated>2019-01-23T11:15:54.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.jpeg" alt="1"></p><p>为了加密互联网流量中未被加密的最后一部分，我们与 <a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener">Cloudflare DNS</a> 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 <a href="https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/" target="_blank" rel="noopener">TLS</a>，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。</p><a id="more"></a><h2 id="DNS-的历史"><a href="#DNS-的历史" class="headerlink" title="DNS 的历史"></a>DNS 的历史</h2><p>二十世纪八十年代末，域名系统（DNS）被提出，可以让人们用简短易记的名称来连接实体（比如 facebook.com），这使得网络安全发生了极大的变化。人们为网络安全做了许多的改进，比如现在大部分的网络流量都是通过 HTTPS 连接，但在线上传输明文时仍然存在一些问题。</p><p>2010 年，<a href="https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" target="_blank" rel="noopener">DNS 安全拓展</a>（DNSSEC）部署实施，DNS 协议由此支持身份验证功能。虽然 DNSSEC 支持对消息进行身份验证，但仍然会使用明文来传输 DNS 请求与应答。这也使得传输的内容可以被请求方与响应方中间路径上任意节点轻松获取。2014 年 10 月，国际互联网工程任务组（IETF）建立了 <a href="https://datatracker.ietf.org/wg/dprive/about/" target="_blank" rel="noopener">DPRIVE 工作组</a>，其章程包括为 DNS 提供保密性与身份验证功能。</p><p>此工作组在于 2016 年提出 <a href="https://tools.ietf.org/html/rfc7858" target="_blank" rel="noopener">RFC 7858</a> 指定了 DoT 标准。为此，Cloudflare 的 1.1.1.1 与 Quad9 的 9.9.9.9 等开放的解析器在 DoT 的支持下更加关注使用者的隐私。这也保护了终端用户设备到 DNS 解析器这一部分 DNS 通信。但连接的其它部分仍然是明文传输。在 2018 年 5 月，DPRIVE 重新开发了一个方法，用于加密从解析器到域名服务器间的通信。</p><p><img src="https://lsvih.com/images/2.png" alt="2"></p><p><strong>DoT 以前的 DNS</strong></p><h2 id="DoT-试验"><a href="#DoT-试验" class="headerlink" title="DoT 试验"></a>DoT 试验</h2><p>我们在过去的几个月中一直在进行一项试验，在 Cloudflare 1.1.1.1 递归解析器与我们的主域名服务器间开启 DoT。这个试验的目的是了解大规模使用 DoT 的可行性，收集信息以更好地了解 DoT 在接受应答时的延迟产生的开销，并确定计算开销。这个试验让我们更好地了解了 DoT 协议在真实环境下的表现。另外在生产环境负载中试验把 DNS 从 UDP 等即发即弃方法换成 TLS 之类的加密连接协议，可以将一些设计协议时发现不了的问题给暴露出来。</p><p><img src="https://lsvih.com/images/3.jpeg" alt="3"></p><p><strong>DoT 下的 DNS</strong></p><p>截至目前，通过观察 Cloudflare DNS 与 Facebook 域名服务器间的生产环境流量，已经可以证明该试验是可行的解决方案。在初始化一个新连接的时候由于需要初始化请求，因此增加了延时；但我们可以重用 TLS 连接来处理其它更多的请求。因此，初始化增加的负载在均摊之后，降低到了 Cloudflare DNS 与 Facebook 主域名服务器 UDP 基线的 p99 相同的程度。</p><p>下图展示了我们从 TLS 切换回 UDP 时（在 17:30 时刻）延时的变化。它可以让我们比较两个协议请求的延时。第一个图显示了在没有 TCP/TLS 会话建立开销情况下的延时百分比。它展示了当连接建立后，TLS 与 UDP 在查询和响应间的延时是相同的。</p><p><img src="https://lsvih.com/images/4.png" alt="4"></p><p>第二张图加上了建立连接的时间来考虑请求的总体延迟。从图中可以看到，使用 TLS 还是 UDP 对连接的总体延时也没有影响。这是因为我们使用 TLS 的会话恢复技术，通过相同的 TLS 连接来执行多个请求，实质上分摊了初始化连接的开销。</p><p><img src="https://lsvih.com/images/5.png" alt="5"></p><p>作为参考，下图展示了在不使用 TLS 会话恢复技术，并在建立连接后仅处理少量请求时总延时的差异。在比 22:35 稍早的时刻完成了 TLS 到 UDP 的切换，可以看到总体而言 TLS 对大多数的请求的影响与 UDP 类似，但在 p95 或更高的统计指标下，请求的延时收到了影响。后面一张图显示，当链接已经建立时，延时不受影响。这两张图表明，第一张图中的差异是由于建立新连接时产生的，并且实际上，建立新连接的频率很高。</p><p><img src="https://lsvih.com/images/6.png" alt="6"></p><p><img src="https://lsvih.com/images/7.png" alt="7"></p><p>基本来说，浏览 Facebook 和使用带 DoT 的 Cloudflare DNS 的用户，无论是在用 HTTPS 连接时还是在 DNS 层面上，都可以享受完全加密的体验。虽然我们已经实现了 TLS 会话恢复技术，但还没有充分利用现代协议栈提供的全部优化方法。在将来，我们可以利用 TLS 的最新版本（<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">TLS 1.3</a>）和 <a href="https://en.wikipedia.org/wiki/TCP_Fast_Open" target="_blank" rel="noopener">TCP Fast Open</a> 等技术带来的改进，进一步降低延时。</p><h2 id="DoT-的下一步"><a href="#DoT-的下一步" class="headerlink" title="DoT 的下一步"></a>DoT 的下一步</h2><p>这个试验已经证明了，我们可以使用 DoT 大规模处理生产环境的负荷，并且不会对用户体验产生任何负面影响。我们将这个试验所得到的经验和知识，作为一种可行的经验回馈给 DNS 社区。</p><p><a href="https://www.ietf.org/" target="_blank" rel="noopener">IETF</a> 等标准社区开发协议时，有时候会缺乏与最终实施与运行协议的组织的意见，这导致了协议设计者、实施者、运营者间的脱节。通过这个试验，我们可以根据在生产环境中运行协议得到的经验，及时向工作组报告具体结果，同时也为有意于部署 DoT 的运营商和软件供应商提供了最佳实践。</p><p>我们希望这些初步的试验结果可以激励其它的行业合作伙伴加入我们的试验，扩大 DoT 运营商的数量，并得到更多制定此协议时得到的经验，从而提高反馈水准、得到更多的运营知识和最佳实践。</p><p><strong>感谢 Cloudflare 的 Marek Vavruša 在这个试验中做出的贡献。</strong></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c4849d06fb9a049c30b967b" target="_blank" rel="noopener">https://juejin.im/post/5c4849d06fb9a049c30b967b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.jpeg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了加密互联网流量中未被加密的最后一部分，我们与 &lt;a href=&quot;https://www.cloudflare.com/dns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloudflare DNS&lt;/a&gt; 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 &lt;a href=&quot;https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TLS&lt;/a&gt;，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Back End" scheme="https://lsvih.com/tags/Back-End/"/>
    
      <category term="DNS" scheme="https://lsvih.com/tags/DNS/"/>
    
      <category term="TLS" scheme="https://lsvih.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>Translation of &#39;Deep Variational Bayes Filters Unsupervised Learning of State Space Models from Raw Data&#39;.</title>
    <link href="https://lsvih.com/2018/12/15/Translation-of-DVBF/"/>
    <id>https://lsvih.com/2018/12/15/Translation-of-DVBF/</id>
    <published>2018-12-15T14:06:00.000Z</published>
    <updated>2019-01-21T13:28:03.985Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/files/DVBF.pdf" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/files/DVBF.pdf&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; align=&quot;&quot; height=&quot;600px&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Char-BiLSTM-CRF Incorporating POS and Dictionaries for Chinese OTE&#39; used in ACML conference.</title>
    <link href="https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/"/>
    <id>https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/</id>
    <published>2018-11-26T04:29:00.000Z</published>
    <updated>2018-11-26T04:30:09.709Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.h
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="conference" scheme="https://lsvih.com/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Algorithms for Non-negative Matrix Factorization&#39; used in assignment.</title>
    <link href="https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/</id>
    <published>2018-10-30T08:00:00.000Z</published>
    <updated>2018-10-30T08:00:49.004Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html&quot; scrolling=&quot;no&quot; fram
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="assignment" scheme="https://lsvih.com/tags/assignment/"/>
    
      <category term="optimization" scheme="https://lsvih.com/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms for Non-negative Matrix Factorization，非负矩阵分解 论文翻译</title>
    <link href="https://lsvih.com/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/</id>
    <published>2018-10-29T19:08:00.000Z</published>
    <updated>2019-04-07T07:47:51.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NIPS 2000 经典论文 非负矩阵分解算法 翻译</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>非负矩阵分解（NMF）是一种可以有效处理多变量数据的方法。本文介绍、分析了两种不同的 NMF 算法，这两种算法仅在更新规则（update rule）中使用的乘性因子（multiplicative factor）有所区别。其中一种可以对传统的最小二乘误差进行最小化（minimize），而另一种可以对广义 Kullback-Leibler 散度（KL 散度）进行最小化。可以使用与证明最大化期望算法收敛性类似的辅助函数来证明这两种算法的单调收敛性。这两种算法均可理解为用斜向最陡下降法（diagonally rescaled gradient descent）对因子进行最优化，以保证算法收敛。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PCA、矢量量化（Vector Quantization）等无监督学习算法可以理解为在不同约束条件下对数据矩阵进行分解。根据其约束的不同，分解所得的因子的会表现出大相径庭的性质。比如，PCA 仅使用了弱正交约束，从而得到非常分散的表示，对这些表示使用消去法来产生多样性；矢量量化使用一种严格的全局最优型约束，最终会得到互斥的数据聚类原型。</p><p>我们之前已经证明过，在矩阵分解用于学习数据的部分表示中，非负性（non-negative）是一种非常有用的约束。学习得到的非负基向量是分散的，但仍可通过稀疏的组合，在重建时得到效果良好的表达向量。在本文中，我们详细分析了这两种用于在数据中学习最优的非负因子的数值算法。</p><h2 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h2><p>下面我们正式开始分析如何用算法解决以下问题：</p><p><strong>在非负矩阵分解（NMF）中</strong>，给定非负矩阵V，找到非负矩阵因子W和H，使得：</p><script type="math/tex; mode=display">(1):  V\approx WH</script><p>NMF 可以应用下面的方法用于对多变量数据进行统计分析。给定一组多变量的 n 维数据向量，其向量位于一个 $n\times x$ 矩阵 V 的列中（m 表示数据集中的示例数）。然后将此矩阵近似分解为 $n\times r$ 的 W 矩阵与 $r\times m$的 H 矩阵。通常 r 要小于 n 或 m，以使 W 和 H 小于原始矩阵 V。最终得到的是原始数据矩阵的压缩形态。</p><p>公式(1)中约等于的意义在于它可以将公式逐列用 $v\approx Wh$ 来表示，其中 v 和 h 是矩阵 V 和矩阵 H 的对应的列。也就是说，每个数据向量 v 近似地由矩阵 W 的各列线性组合而成，同时用 h 的分量进行加权。因此可以被认为 W 包含了对 V 中的数据的线性近似优化的基向量。由于要使用少量的基向量来表示大量的数据向量，因此只有在基向量发现数据中的潜在结构时才能实现较好的近似。</p><p>本文不会涉及关于 NMF 的应用，而会侧重于在技术方面探讨非负矩阵分解的技术。当然，已经有许多其它的矩阵分解方式在数值线性代数中得到了广泛的研究，但是以前的大多数工作都不适用于非负性约束情况。</p><p>在此，我们讨论了基于迭代更新 W 和 H 的两种 NMF 算法。由于这两种算法易于实现，同时能保证其收敛性，因此它们在现实情况中非常实用。其他算法可能在总计算时间方面更有效率，但是更难实现，并且很难推广到不同的代价函数（cost function）。因子与我们类似的算法，已经被用于对发射断层扫描和天文图像进行反卷积（deconvolution）。</p><p>在我们算法的每次迭代中，会用当前值乘某些取决于公式(1)中的“近似程度”的因数，来找到 W 或 H 的新值。我们可以证明“近似程度”会随着不断应用这些乘法更新规则而单调减小。这正意味着更新规则的重复迭代可以保证矩阵分解算法收敛到局部最优。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>为了找到$ V\approx WH  $的近似解，我们首先需要定义一个代价函数，用以量化近似的程度。可以使用两个非负矩阵 A 和 B 的距离来构造此代价函数。一种使用的距离度量方法为：计算 A  和 B 之间的欧几里得距离（Euclidean distance）的平方值。</p><script type="math/tex; mode=display">(2): ||A-B||^2 = \sum_{ij}(A_{ij} - B_{ij})^2</script><p>此公式下界为 0，仅当 A=B 时距离消失。</p><p>另一种实用的度量方式为：</p><script type="math/tex; mode=display">(3): D(A||B) = \sum_{ij}(A_{ij} \log{\frac{A_{ij}}{B_{ij}}} - A_{ij}+B_{ij})</script><p>与欧几里得距离相同，它的下界也为 0，且在 A=B 时距离消失。但它不能被称为“距离”，因为这个式子在 A 与 B 中并不对称，因此我们将其称为 A 对于 B 的“散度”（divergence）。它可以归纳为 KL 散度或者相对熵，当 $\sum_{ij}A_{ij}=\sum_{ij}B_{ij}=1$ 时，A 与 B 可以看做是标准化的概率分布。</p><p>现在，我们可以按照以下两种公式来将 NMF 化为最优化问题：</p><p><strong>最优化问题1</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $||V - WH||^2$。</p><p><strong>最优化问题2</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $D(V||WH)$。</p><p>虽然方程 $||V - WH||^2$ 和 $D(V||WH)$ 在只考虑 W 或 H 之一时为凸，但在同时考虑 WH 两个变量时不为凸。因此，寻找一种可以找到全局最小值的算法去解决以上两个最优化问题是不切实际的。但是，还有许多数值优化方法可以用于寻找局部最小值。</p><p>虽然梯度下降法（Gradient descent）的收敛速度很慢，但它的实现最为简单。其它方法（比如共轭梯度法）可以更快地收敛（至少在局部最小值附近会更快），但是它们比梯度下降更复杂。此外，梯度下降方法的收敛对步长的选择非常敏感，这对于大规模应用十分不利。</p><h2 id="乘法更新规则"><a href="#乘法更新规则" class="headerlink" title="乘法更新规则"></a>乘法更新规则</h2><p>我们发现在解决上述两个最优化问题时，在速度与实现难度中权衡，“乘法更新规则”是一种综合性能很好方法。</p><p><strong>定理1</strong>：欧几里得距离 $||V-WH||$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(4): H_{a\mu} \leftarrow H_{a\mu}\frac{(W^T V)_{a\mu}}{(W^T W H)_{a\mu}}</script><script type="math/tex; mode=display">(4): W_{ia} \leftarrow W_{ia}\frac{(V H^T)_{ia}}{(W H H^T)_{ia}}</script><p>在上述更新规则中，W 与 H 在距离公式的驻点上时，欧几里得距离将固定不动。</p><p><strong>定理2</strong>：散度 $D(V|WH)$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(5): H_{a\mu} \leftarrow H_{a\mu}\frac{\frac{\sum_{i}W_{ia}V_{i\mu}}{WH_{i\mu}}}{\sum_k W_{ka}}</script><script type="math/tex; mode=display">(5): W_{ia} \leftarrow W_{ia}\frac{\frac{\sum_{\mu}H_{a\mu}V_{i\mu}}{WH_{i\mu}}}{\sum_v H_{av}}</script><p>在上述更新规则中，W 和 H 在散度公式的驻点上时，散度将不再更新。</p><p>上述定理的证明将在后面给出。我们可以发现，每次更新都是乘以一个因子。特别地，当V = WH时，可以直观地看出这个乘数因子是一样的，当更新规则固定时，才会得到完美的分解。</p><h2 id="乘法与加法更新规则"><a href="#乘法与加法更新规则" class="headerlink" title="乘法与加法更新规则"></a>乘法与加法更新规则</h2><p>可以将乘法更新与梯度下降更新进行对比。特别的，对 H 进行更新以减小平方距离可以记为：</p><script type="math/tex; mode=display">(6):H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[(W^TV)_{a\mu} - (W^T WH)_{a\mu}]</script><p>如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $||V-WH||$。</p><p>如果我们按照斜向最陡调整变量，并设置：</p><script type="math/tex; mode=display">(7): \eta_{a\mu}=\frac{H_{a\mu}}{(W^TWH)_{a\mu}}</script><p>就能得到定理 1 中给出的 H 更新规则。注意，该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>对于散度公式，我们按照下述公式调整斜向最陡梯度下降：</p><script type="math/tex; mode=display">(8): H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[\sum_{i}W_{ia}\frac{V_{i\mu}}{(WH)_{i\mu}}-\sum_{i}W_{ia}]</script><p>同样的，如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $D(V||WH)$。如果设置：</p><script type="math/tex; mode=display">(9): \eta_{a\mu} = \frac{H_{a\mu}}{\sum_i W_{ia}}</script><p>那么就能得到定理 2 中给出的 H 更新规则。该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>由于我们对 $\eta_{a\mu}$ 的取值并不够小，看起来不能保证这种调整过后的梯度下降的代价函数减小。不过让人惊讶的是，如下节所示，上述假设是事实。</p><h2 id="收敛证明"><a href="#收敛证明" class="headerlink" title="收敛证明"></a>收敛证明</h2><p>我们将使用一个类似于 EM 算法的辅助函数来证明定理 1 与定理 2。</p><p><strong>定义 1</strong>：$G(h,h’)$ 是 $F(h)$ 的辅助函数，满足以下条件成立：</p><script type="math/tex; mode=display">(10): G(h,h')\geq F(h), G(h,h)=F(h)</script><p>根据下面的引理，此辅助函数是一个有用的概念。（在图1中的插图也显示了这一点）</p><p><strong>引理 1</strong>：如果 G 为辅助函数，则 F 在下述更新时为非增：</p><script type="math/tex; mode=display">(11): h^{t+1} = \arg\min_{h}G(h,h^t)</script><p><strong>证明</strong>：$F(h^{t+1}) \leq G(h^{t+1}, h^t) \leq G(h^t,h^t) = F(h^t)$</p><p>请注意，只有在$h^t$为$G(h,h^t)$的全局最小值时满足$F(h^{t+1})=F(h^t)$。如果 F 的导数存在，且在$h^{t}$的邻域连续，也就是说$\nabla F(h^t) = 0 $。因此通过公式11反复更新，我们就能得到目标函数收敛的局部最小值 $h_{min} = \arg\min_h F(h)$</p><script type="math/tex; mode=display">(12): F(h_{min}) \leq ... F(h^{t+1})\leq F(h^t) ... \leq F(h_2) \leq F(h_1) \leq F(h_0)</script><p><img src="https://lsvih.com/images/15408401601646.jpg" alt="-w663"></p><p>下面，我们证明如何为$||V-WH||$与$D(V,WH)$定义适当的辅助函数$G(h,h^t)$。定理 1 与定理 2 可以直接遵循公式 11 的更新规则。</p><p><strong>引理 2</strong>：如果$K(h^t)$为对角矩阵，</p><script type="math/tex; mode=display">(13): K_{ab}(h^t) = \delta_{ab}\frac{W^T Wh^t}{h^t_a}</script><p>则</p><script type="math/tex; mode=display">(14): G(h,h^t)=F(h^t)+(h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T K(h^t)(h-h^t)</script><p>为</p><script type="math/tex; mode=display">(15): F(h)=\frac{1}{2} \sum_i(v_i- \sum_a W_{ia} h_a)^2</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。为了证明此不等式，需要将</p><script type="math/tex; mode=display">(16): F(h) = F(h^t) + (h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T(W^TW)(h-h^t)</script><p>与公式 14 进行对比，发现 $G(h,h’) \geq F(h)$ 等价于</p><script type="math/tex; mode=display">(17): 0 \leq (h-h^t)^T[K(h^t) - W^TW](h-h^t)</script><p>为证明半正定情况，考虑矩阵：</p><script type="math/tex; mode=display">(18): M_{ab}(h^t)=h_a^t(K(h^t)-W^TW)_{ab}h_b^t</script><p>仅是$K-W^TW$的调整形式。因此，仅当 M 符合下列公式时，$K-W^TW$具有半正定性：</p><script type="math/tex; mode=display">(19):v^T Mv = \sum_{ab}v_a M_{ab} v_b \\(20):=\sum_{ab}h^t_a(W^TW)_{ab}h^t_bv_a^2-v_ah^t_a(W^TW)_{ab}h_b^tv_b \\(21):=\sum_{ab}(W^TW)_{ab}h_a^th_b^t[\frac{1}{2}v_a^2 + \frac{1}{2}v_b^2 - v_av_b] \\(22):=\frac{1}{2}\sum_{ab}(W^TW)_{ab}h_a^th_b^t(v_a-v_b)^2 \\(23):\geq 0</script><p>现在，我们可以证明定理 1 的收敛性。</p><p><strong>定理 1 证明</strong>：使用公式14的结果替换公式11中的$G(h,h^t)$，得到更新规则：</p><script type="math/tex; mode=display">(24): h^{t+1}=h^t - K(h^t)^{-1} \nabla F(h^t)</script><p>因为公式14为辅助函数，根据引理1，F 在更新规则中为非增。将上式完整的写下来，可以得到：</p><script type="math/tex; mode=display">(25): h^{t+1}_a= h^{t}_a \frac{(W^Tv)_a}{(W^TWh^t)_a}</script><p>反转引理 1 与引理 2 中 W 和 H 的角色，F 可以以类似的方法证明在 W 的更新规则下为非增。</p><p>接下来，我们为散度代价方程寻找辅助函数。</p><p><strong>引理 3</strong>：定义</p><script type="math/tex; mode=display">(26): G(h,h^t)=\sum_i(v_i \log{v_i} - v_i) + \sum_{ia} W_{ia}h_a \\(27):-\sum_{ia}v_i\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b} (\log{W_{ia} h_a - \log{\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b}}})</script><p>为</p><script type="math/tex; mode=display">(28): F(h)=\sum_i v_i \log(\frac{v_i}{\sum_a W_{ia} h_a})- v_i + \sum_a W_{ia} h_a</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。我们通过对数函数的凸性来推导此不等式：</p><script type="math/tex; mode=display">(29): -\log \sum_a W_{ia} h_a \leq -\sum_a a_a \log \frac{ W_{ia} h_a}{a_a}</script><p>上式对所有的联合求合数 $a_a$ 均成立。设</p><script type="math/tex; mode=display">(30): a_a =\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b}</script><p>可以得到：</p><script type="math/tex; mode=display">(31): -\log \sum_a W_{ia} h_a \leq - \sum_a \frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} (\log W_{ia} h_a - \log\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} )</script><p>上面的不等式遵循 $G(h,h’) \geq F(h)$。</p><p>定理 2 的证明遵循引理 1 及其应用：</p><p><strong>定理 2 证明</strong>：要令 $G(h,h^t)$ 最小化，则需要将梯度设为 0 来求出 h：</p><script type="math/tex; mode=display">(32): \frac{dG(h,h^t)}{dh_a} = - \sum_i v_i \frac{ W_{ia} h_a^t}{\sum_b W_{ib} h_b^t} \frac{1}{h_a} + \sum_i W_{ia} = 0</script><p>因此，公式 11 采取的更新规则应当如下所示：</p><script type="math/tex; mode=display">(33): h_a^{t+1} = \frac{h_a^t}{\sum_b W_{kb}} \sum_i \frac{v_i}{\sum_b W_{ib}h_b^t} W_{ia}</script><p>因为 G 为辅助函数，公式 28 中的 F 在更新规则中为非增。用矩阵形式重写上述公式，发现与 公式 5 的更新规则等价。反转 W 和 H 的角色，可以以类似的方法证明 F 在 W 的更新规则下为非增。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们已经证明了在公式 4 与公式 5 中应用更新规则，可以找到问题 1 与问题 2 的局部最优解。借助定义合适的辅助函数证明了函数的收敛性。我们将把这些证明推广到更复杂的约束条件下去。更新规则在计算上非常容易实现，有望进行广泛的应用。</p><p>感谢贝尔实验室的支持，以及 Carlos Brody, Ken Clarkson, Corinna Cortes, Roland Freund, Linda Kaufman, Yann Le Cun, Sam Roweis, Larry Saul, Margaret Wright 的帮助与讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NIPS 2000 经典论文 非负矩阵分解算法 翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;非负矩阵分解（NM
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="algorithm" scheme="https://lsvih.com/tags/algorithm/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="gradient descent" scheme="https://lsvih.com/tags/gradient-descent/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
  </entry>
  
</feed>
