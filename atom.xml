<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My note</title>
  
  <subtitle>lsvih</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lsvih.com/"/>
  <updated>2019-04-08T01:36:59.196Z</updated>
  <id>https://lsvih.com/</id>
  
  <author>
    <name>lsvih</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Robust Classification with Convolutional Prototype Learning 论文笔记</title>
    <link href="https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-论文笔记/</id>
    <published>2019-04-07T10:48:00.000Z</published>
    <updated>2019-04-08T01:36:59.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。<br>论文地址：<a href="https://arxiv.org/abs/1805.03438v1" target="_blank" rel="noopener">https://arxiv.org/abs/1805.03438v1</a><br>论文代码：<a href="https://github.com/YangHM/Convolutional-Prototype-Learning" target="_blank" rel="noopener">https://github.com/YangHM/Convolutional-Prototype-Learning</a></p></blockquote><p>这篇文章在原型学习（prototype learning）与 CNN 的基础之上，提出了一种有效的学习方式，并设计了几种不同的 loss 函数，这些损失函数均能从直观上理解其效果并在实验中证明它们的有效性。通过学习这篇文章，可以更好地了解原型学习以及 loss 的设计，同时可以直接将文中的方法用于一些下游应用。</p><p><strong>此外需要注意的是</strong>，这篇文章的“Robust classification”和 Goodfellow 提出的对抗样本型“Robust model”是两码事。这篇文章没有对模型对于对抗样本的 Robust 进行分析，但本文提出的方法学习到的分类器对于任务来说是 Robust 的。从文章的实验结果来看，将这篇文章提出的方法称为“Robust”一点也不为过，毕竟“Robust”又不是 Goodfellow 发明的，各人可以有自己的理解。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章主要按以下的框架描述了作者提出的方法：</p><ul><li>背景与相关工作</li><li>卷积原型学习（Convolutional prototype learning）</li><li>设计的各种 loss 函数</li><li>实验结果与分析</li></ul><p>因此，这篇笔记也按照论文作者的写作顺序记录。</p><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p><img src="https://lsvih.com/images/15546341569411.jpg" alt=""></p><p>文章开头就给了这张图，描述了传统的 CNN 模型 + cross entropy loss 在 MNIST 上训练出来的特征的二维表示。作者用此图片说明了传统 CNN 模型的问题：学习出来的分类特征在特征空间内非常集中，甚至有很多类内距离（intra-class）小于类间距离（inter-class）的情况。这种情况也就会导致最终的分类效果变差，并且分类模型不易拓展等不够“Robust”的问题。</p><blockquote><p>这个图片的具体作图方法，是把模型输出层前的最后隐层（bottleneck layer）设定为两个神经元，训练完成后，将样本送入神经网络，取出这两个神经元的输出，将输出分别设为 X 与 Y 轴，即得到了这张图。（这个方法可以用在别的需要可视化特征的场景中，可以免去 PCA 等降维步骤。不过在一些比较复杂的任务里貌似这么训练会很难收敛）</p></blockquote><p>尽管后来还有人为此做了各种改进，比如 triple loss、centre loss 等，来改善这种情况，但这些方法都没有离开 softmax + cross entropy 的范畴，也没有根本解决问题。因此作者基于原型学习的思想，利用 CNN 作为特征提取的工具，提出了一种原型学习框架 Convolutional prototype learning（后文直接记为 CPL），同时为它设计了几种模式的 loss 函数，在实验上取得了良好的效果。</p><blockquote><p>关于什么是原型学习，可以了解一下 LVQ 算法。</p></blockquote><h2 id="卷积原型学习"><a href="#卷积原型学习" class="headerlink" title="卷积原型学习"></a>卷积原型学习</h2><p><img src="https://lsvih.com/images/15546341698125.jpg" alt=""></p><p>如图所示。这个框架其实思路很简单：</p><ol><li>利用 CNN 进行特征提取：直接将 CNN 看做是一个 $f(x,\theta)$ 的函数，输入的 x 是数据，$\theta$ 是 CNN 的参数；输出的是特征。</li><li>用一个或多个原型来对应每一个分类（文章后来用实验证明了一个分类对应一个原型就可以有足够好的效果）。</li><li>在训练时，让原型与原型间的欧式距离尽量远，让特征与对应类别原型的欧式距离尽量近：</li></ol><script type="math/tex; mode=display">\begin{array} { l } { x \in \text { class arg } \max _ { i = 1 } ^ { C } g _ { i } ( x ) } \\ { g _ { i } ( x ) = - \min _ { j = 1 } \left\| f ( x ; \theta ) - m _ { i j } \right\| _ { 2 } ^ { 2 } } \end{array}</script><p>（上式中各符号代表的含义请参考原论文 3.1 与 3.2）</p><h2 id="loss-函数"><a href="#loss-函数" class="headerlink" title="loss 函数"></a>loss 函数</h2><p>这部分是文章的核心。为了实现上面一节说的 CPL，必须要有合适的 loss 函数，这种 loss 函数需要满足以下几个条件：</p><ol><li>符合 CPL 的思路，及让原型与原型间距离尽量远，让特征与对应原型的距离尽量近。</li><li>需要对 CNN 可导（这样才能通过 BP 算法去优化 CNN 的参数 $\theta$，也就才能让 CNN 提取出正确的特征）</li><li>需要对原型可导（这样才符合原型学习的思想，才能去不断调整原型在特征空间中的位置）</li></ol><p>因此，这篇文章设计的几个 loss 函数都会去证明 $\frac { \partial l } { \partial f }$ 与 $\frac { \partial l } { \partial M }$ 的可导性。（l 是 loss 函数，f 是 CNN 特征提取器，M 是原型集），笔记中就不再赘述。</p><p>下文将逐个说明论文提出的 loss 函数。</p><h3 id="Minimum-classification-error-loss-MCE"><a href="#Minimum-classification-error-loss-MCE" class="headerlink" title="Minimum classification error loss(MCE)"></a>Minimum classification error loss(MCE)</h3><p>MCE 即“最小分类误差”，是《Discriminative learning for minimum error classification》提出的一种经典的测量指标，主要公式如下：</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + \left[ \frac { 1 } { C - 1 } \sum _ { j \neq y } g _ { j } ( x ) ^ { \eta } \right] ^ { 1 / \eta }</script><p>作者在列这个公式的时候貌似忘了解释 $\eta$ 的作用了。查阅原文发现，这个指标可以用来控制考虑误分类的程度多少。当 $\eta$ 为正无穷的时候，上式等于</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + g _ { r } ( x )</script><p>其中 $g _ { r } ( x ) = \max _ { k \neq y } g _ { k } ( x )$，是“错的最离谱”的错分距离。因此可以将 MCE 记为</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = \left\| f ( x ) - m _ { y i } \right\| _ { 2 } ^ { 2 } - \left\| f ( x ) - m _ { r j } \right\| _ { 2 } ^ { 2 }</script><p>作者按照《Discriminative learning for minimum error classification》中的 Translated sigmoid 公式定义了这个方法最终的 loss 函数计算公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \frac { 1 } { 1 + e ^ { - \xi \mu _ { y } } }</script><p>综上，这个 loss 方法其实优化的是 MCE 指标，重点是作者将 $\mu_y$ 转换为了原型的形式，换句话就是说这个 loss 在优化时，除了会让 CNN 提取出正确的特征外，还会尽量让原型靠近正确的类的特征分布密集区域，远离错误的类的特征分布区域。通过这种方式，可以实现笔记最开头提到的目标。</p><h3 id="Margin-based-classification-loss-MCL"><a href="#Margin-based-classification-loss-MCL" class="headerlink" title="Margin based classification loss(MCL)"></a>Margin based classification loss(MCL)</h3><p>顾名思义，这个 loss 是“基于边距的分类 loss”。这个“margin”在 triple loss 等方法中其实都有用到。作者提出这个方法的思想就是“让一个样本的特征和对应分类的原型在特征空间中的距离，要小于和其它原型在特征空间内的距离”，通过这种思路，就能使得样本尽量不被误分类。按照这个思路，作者提出了公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) \right] _ { + }</script><p>这个公式中的 d 函数就是求样本和原型在特征空间中的欧式距离。整个 loss 用 $\left[ \right] _+$ 包含着，表示只取正值。因为如果样本距离正确分类的原型的距离已经满足要求时，loss 值应该为 0。</p><p>根据上式，作者进一步对这个 loss 进行完善，为它添加了 margin（作用和 triple loss、centre loss 的 margin 是一致的），让“样本离本类原型”的距离要比“样本离其它类原型”距离+margin要更小：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) + m \right] _ { + }</script><p>这样就能达成前文所说的目的。</p><p>作者在此基础上，又为 margin 的值做了进一步的改进。因为在上述 loss 中，margin 的值必须和“样本与原型的距离”值在同一个数量级上才能顺利进行优化。为此，作者稍作转换：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ \frac { d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) } { d \left( f ( x ) , m _ { y i } \right) + d \left( f ( x ) , m _ { r j } \right) } + m \right] _ { + }</script><p>这样，m 在 (0,1) 的范围内取值即可保证数量级的一致性。</p><h3 id="Distance-based-cross-entropy-loss-DCE"><a href="#Distance-based-cross-entropy-loss-DCE" class="headerlink" title="Distance based cross entropy loss(DCE)"></a>Distance based cross entropy loss(DCE)</h3><p> 这个 loss 函数是基于一个约等式：</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) \propto - \left\| f ( x ) - m _ { i j } \right\| _ { 2 } ^ { 2 }</script><p> 这个式子的意义是，可以用“样本距离原型的距离”来测度“样本属于一个原型类别的概率”。这样就能用 cross entropy 之类的方法对概率进行优化了。因此，需要用一个确切的值来把上式给写出来，同时满足：</p><ol><li>概率值是正数</li><li><p>所有概率（即一个样本属于各个原型的概率）的和需要为 1</p><p>为此，作者定义</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) = \frac { e ^ { - \gamma d \left( f ( x ) , m _ { i j } \right) } } { \sum _ { k = 1 } ^ { C } \sum _ { l = 1 } ^ { K } e ^ { - \gamma d \left( f ( x ) , m _ { k l } \right) } }</script><p>此时，样本属于一个分类的概率即为样本属于这个分类的各个原型的概率之和，即为：</p><script type="math/tex; mode=display">p ( y | x ) = \sum _ { j = 1 } ^ { K } p \left( x \in m _ { y j } | x \right)</script><p>应用 cross entropy，可以将最终的 loss 函数写出来：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = - \log p ( y | x )</script><p>这个 loss 相当于换了一个角度考虑，把距离换成了概率然后代入 cross entropy。</p></li></ol><h3 id="Generalized-CPL-with-prototype-loss-GCPL"><a href="#Generalized-CPL-with-prototype-loss-GCPL" class="headerlink" title="Generalized CPL with prototype loss(GCPL)"></a>Generalized CPL with prototype loss(GCPL)</h3><p>除了上述的 loss 之外，作者还提出了一种可以加入上述 loss 中的约束方法。作者给的理由是，由于 CPL 中的参数比较少（因为 CNN 的参数本来就不多），很容易过拟合，因此需要这么一个约束来防止 overfit 情况的发生：</p><script type="math/tex; mode=display">p l ( ( x , y ) ; \theta , M ) = \left\| f ( x ) - m _ { y j } \right\| _ { 2 } ^ { 2 }</script><p>这个式子的意义是，计算在特征空间内样本的位置与对应分类的原型（且为距离最近的一个原型）位置的距离。利用这个约束，可以将前文提到的几种 loss 记为：</p><script type="math/tex; mode=display">\operatorname { loss } ( ( x , y ) ; \theta , M ) = l ( ( x , y ) ; \theta , M ) + \lambda p l ( ( x , y ) ; \theta , M )</script><p>上式中的 $\lambda$ 作用是控制此约束的强硬程度。通过这个约束，可以让同类的原型间的距离更近，不同类的原型间的距离更远。与此同时，就能保证样本在特征空间中的类内距离更近，类间距离更远。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>基于以上方法，作者在 MNIST、CIFAR-10、OLHWDB 数据集上进行了实验。其中，OLHWDB 数据集是一个大规模的中文手写文字数据集，甚至比 ImageNet 还要大。（不过我觉得作者还是应该在 ImageNet 上进行实验，不然整个实验还是不够完整。另外，作者的实验虽然都很置信且完善，但是对比实验选择的 baseline 不够 solid，只用了最基本的 softmax 作为对比，没有考虑最近几年涌现出的各种 softmax 的进阶版。）</p><h3 id="基本分类实验结果"><a href="#基本分类实验结果" class="headerlink" title="基本分类实验结果"></a>基本分类实验结果</h3><ul><li><p>MNIST:<br><img src="https://lsvih.com/images/15546341823585.jpg" alt=""></p></li><li><p>CIFAR-10:<br><img src="https://lsvih.com/images/15546341912068.jpg" alt=""></p></li><li><p>OLHWDB<br><img src="https://lsvih.com/images/15546342050566.jpg" alt=""></p></li></ul><p>可以看到，结果还是不错的，至少证明这篇文章提出的方法在最基本的分类效果上不会比 softmax 差。</p><h3 id="拒识实验"><a href="#拒识实验" class="headerlink" title="拒识实验"></a>拒识实验</h3><p><img src="https://lsvih.com/images/15546342149853.jpg" alt=""></p><p>这个实验结果比较亮眼。最近对模型的“拒识能力”的要求越来越高，所谓拒识，就是在输入 invalid 的测试样本时，模型可以判断出这个是 out-of-domain 的东西，返回拒绝的结果。</p><p>作者的实验方法是，在 MNIST 上进行训练，然后混入 CIFAR 数据集的数据来测试模型的拒识能力。在这种 open-domain 的实验中，我们经常会用某种类似于 min-confidence 的指标来判断送入的数据是不是 out-of-domain，但是像传统的 softmax + cross-entropy 方法中，min-confidence 越大，拒识率虽然会增加，但是准确率却也会明显下降。</p><p>作者提出的方法由于让不同类别的特征分布非常紧密，留出了大量的类间空间，因此在拒识率这块效果很好。</p><p>不过这个实验结果表格还是很微妙，因为每一横行参数啥的都不一样，虽然是为了做 AR 和 RR 的 trade-off 研究，但这样放着还是很奇怪。</p><h3 id="类增量实验"><a href="#类增量实验" class="headerlink" title="类增量实验"></a>类增量实验</h3><p><img src="https://lsvih.com/images/15546342235530.jpg" alt=""></p><p>这个实验其实还不是很常见，一般在 life-long learning 相关的工作里会有这个实验。目的是，测试一个模型在训练完成后新增一个类别的能力。对于标准的 softmax + cross-entropy 来说，自然不存在这一种能力，原因可以参考这篇笔记的第一个图，本来各个类就离的近了，再加一个类直接就乱套了。</p><p>而本文的方法，可以在“基本分类实验”一章的图中看出，样本按照类原型聚集的非常紧密。这样新增一个类并不是什么很困难的事。</p><p>作者的实验方法是，在 MNIST 训练出的模型中，增加 CIFAR-10 的类。可以看上图，做出来的结果依然很不错。</p><h3 id="小样本训练"><a href="#小样本训练" class="headerlink" title="小样本训练"></a>小样本训练</h3><p><img src="https://lsvih.com/images/15546342332247.jpg" alt=""></p><p>这个实验其实槽点也是 baseline 太 weak 了。现在做小样本的模型其实不占少数，但作者还是只选了 softmax 做比较。尽管如此，可以看到 GCPL 的效果还是很不错的。</p><h3 id="多原型实验"><a href="#多原型实验" class="headerlink" title="多原型实验"></a>多原型实验</h3><p>前面的所有实验都是在“一个类别对应一个原型”的设定之下完成的，都有不错的效果。作者在文章最后用“一个类别对应多个原型”的假设进行了实验，结果如下表所示：</p><p><img src="https://lsvih.com/images/15546342428370.jpg" alt=""></p><p>可以观察到，一个类别对应的原型数量其实对结果没有太大的影响。作者给出的解释是，CNN 提取特征的能力已经足够强大，即使初始数据的分布非常复杂，经过 CNN 变换之后，依然可以得到符合单高斯分布的特征分布，也就是一个类别一个原型的分布。</p><p>不过，在更复杂的情景下，一些更复杂的分类状况，多原型可能会发挥它应有的作用。</p><blockquote><p>这块其实也是 trade-off。因为增加一个原型相当于在隐层输出时增加了 Dense Node，会极大地增加空间占用和计算量。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章提出的方法足够新颖，并且取得的结果也非常好。虽然实验部分有些小遗憾（没有和各个任务顶尖的方法对比），但是仍然体现了这篇文章方法的综合性能的优越性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。&lt;br&gt;论文地址：&lt;a h
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="CNN" scheme="https://lsvih.com/tags/CNN/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="https://lsvih.com/tags/cnn/"/>
    
      <category term="prototype learning" scheme="https://lsvih.com/tags/prototype-learning/"/>
    
  </entry>
  
  <entry>
    <title>Web 开发者需要了解的基础色彩理论</title>
    <link href="https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/"/>
    <id>https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/</id>
    <published>2019-02-20T01:42:00.000Z</published>
    <updated>2019-02-20T01:55:55.996Z</updated>
    
    <content type="html"><![CDATA[<p>如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。</p><a id="more"></a><p><img src="https://lsvih.com/images/1-1.png" alt="1"></p><p>在小学美术课上应该讲过<strong>一次色</strong>（primary color，即三原色）与<strong>二次色</strong>（seondary color，间色），如果你在小学之后还上过美术课，应该还了解过<strong>三次色</strong>（tertiary color，副色）。</p><p><img src="https://lsvih.com/images/2-1.jpeg" alt="2"></p><p>不过如果你在高中或者更高层次的学校中学习过艺术，那你就会发现，色轮是展示<a href="https://en.wikipedia.org/wiki/Color_theory" target="_blank" rel="noopener">色彩理论</a>、练习混色以及研究色彩组合的最简单的方法。</p><h2 id="何谓色彩理论？"><a href="#何谓色彩理论？" class="headerlink" title="何谓色彩理论？"></a>何谓色彩理论？</h2><p><strong>色彩理论简史</strong>：爱德华·马奈（Édouard Manet）、埃德加·德加（Edgar Degas）、克洛德·莫奈（Claude Monet）等印象派的画家在抛弃写实，而开始尝试捕捉<strong>光色</strong>时，色彩理论就诞生了。</p><p><img src="https://lsvih.com/images/3-2.jpeg" alt="3"></p><p>上图为莫奈的 Haystacks 系列画作</p><p><strong>简单来说</strong>：色彩理论研究的是人的眼睛如何将光波转化为颜色。匹配或相似的色彩往往有着相似或互补的波。</p><p>因此可以将色彩理论归结为光波科学，来解释为什么可以看到各种颜色。不过在本文中，我们只专注于两个问题：</p><ul><li>为什么有些颜色可以完美搭配？</li><li>我们该如何选择“正确”的颜色？</li></ul><p>颜色的搭配问题有点像“与生俱来”的东西。不管怎样，在网页或者 App 里用纯绿色的背景是绝对让人无法忍受的！</p><p>下面我列了一个简表，当你遇到与色彩有关的问题时可以参考：</p><h2 id="Level-1：单色"><a href="#Level-1：单色" class="headerlink" title="Level 1：单色"></a>Level 1：单色</h2><p><strong>单色</strong>就是单一的颜色，或者同种颜色的多个色调的组合。</p><blockquote><p><strong>在 Web 开发时</strong>，你可以在<a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">这个网页中</a>选择并查询某种颜色的 Hex 代码，并且可以在不影响色调的情况下让颜色更亮或更暗。</p></blockquote><p><img src="https://lsvih.com/images/4-1.jpeg" alt="4"></p><p>这就是最简单的网页配色方法。诸如 <a href="http://facebook.com" target="_blank" rel="noopener">Facebook</a>、<a href="http://twitter.com" target="_blank" rel="noopener">Twitter</a> 之类的网站大都是用的这种单色配色方案。黑色、白色、天蓝色组合而成的简单配色，让这些社交 App 更加简洁。</p><p>只有用户的头像、链接、照片有着不同的颜色，这些不同的颜色可以被用户识别，更好地找到他们感兴趣的帖子和账号。</p><p>如果 Twitter 的网页上还有其它的颜色，就会让区分帖子、发帖人变得困难。</p><p>一般来说，即使你需要多种颜色，也得有个主色，所谓背景或者标题的颜色。</p><blockquote><p><strong>专业建议</strong>：如果你的网页要使用单色配色，请确保阴影可以清晰地将各个元素区分开了。否则用户在阅读文本或分离网页元素时将很不方便。</p></blockquote><h2 id="Level-2：互补色"><a href="#Level-2：互补色" class="headerlink" title="Level 2：互补色"></a>Level 2：互补色</h2><p>如果不想在配色中只用各种各样的“橙色”怎么办？如果你想让链接突出，但又不和导航栏或者背景色冲突怎么办？</p><p>如果我们遵循基本色彩理论，解决上述问题的方案就是去寻找<strong>互补色</strong>。</p><p>可以在色轮中一种颜色相对的位置找到它的<strong>互补</strong>色。</p><p><img src="https://lsvih.com/images/5-1.jpeg" alt="5"></p><p>每种<strong>主色</strong>都与一种<strong>副色</strong>作为互补色相对应。有种方法可以轻松记住颜色如何匹配：如果一种<strong>副色</strong>和一种<strong>主色</strong>匹配，那么<strong>副色</strong>的构成色一定不含<strong>主色</strong>。比如，红色的互补色是绿色，而绿色由蓝色和黄色组成。</p><blockquote><p><strong>专业建议</strong>：一次只增加一种颜色，并保持页面简单。不要为了呈现一个完整的彩虹配色牺牲了你干净、好用的布局。不然，你可能会做出上世纪 90 年代流行的经典网站（比如<a href="https://spacejam.com/" target="_blank" rel="noopener">这个</a>）。</p></blockquote><h2 id="继续升级…"><a href="#继续升级…" class="headerlink" title="继续升级…"></a>继续升级…</h2><p>随着你的设计水平的提高，就能自如地挑战自己的极限了。配色并不是什么可怕的工作。你可以多多关注一些配色水平高的开发者（比如<a href="https://www.alispit.tel/#/" target="_blank" rel="noopener">他</a> ）和设计师。多问问自己喜欢什么配色、不喜欢什么配色、为什么，这样就能建立自己的品味与品牌。</p><h2 id="Web-开发者的色彩-Hack"><a href="#Web-开发者的色彩-Hack" class="headerlink" title="Web 开发者的色彩 Hack"></a>Web 开发者的色彩 Hack</h2><p>试试自己手写一些 hex 代码、RBG 数字来尝试各种色彩的组合与混合。如果你是 SASS 的粉丝，可以把配好的颜色存储在文件中，日后在项目中导入。如果你的工作是构建页面结构而不是视觉设计（由客户或者产品经理决定），可以把这些颜色当做是占位符，让页面看起来更加明了。</p><p>请确保：</p><ul><li>所有东西都是可读的。</li><li>链接、标题等你想要强调的东西应该与纯文本有所区别。</li><li>用户可以轻松地区分网页的不同部分（比如导航栏、主要内容、文章等）。</li></ul><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><a href="http://paletton.com/" target="_blank" rel="noopener">Palleton.com</a></li><li><a href="https://coolors.co/" target="_blank" rel="noopener">Coolors.co</a></li></ul><p><a href="https://dev.to/ferkungamaboobo" target="_blank" rel="noopener">Doug R. Thomas, Esq.</a> 强烈推荐以下网站：</p><ul><li><a href="https://color.adobe.com/" target="_blank" rel="noopener">Color.Adobe.com</a></li><li><a href="https://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM — 颜色对比度检查器</a> — 确保文本在背景上的可读性。</li><li><a href="https://www.color-blindness.com/coblis-color-blindness-simulator/" target="_blank" rel="noopener">Coblis — 色盲模拟器</a> — 用色盲滤镜来测试你的布局截图，以确保内容对所有受众都是可读的。</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>希望在读完这篇文章后，你不再为给网站、网页、app 配色感到犯愁。如果你对这个主题感兴趣，强烈建议去了解<a href="https://www.colormatters.com/color-and-design/basic-color-theory" target="_blank" rel="noopener">更多相关知识</a>。本文只是浅显地进行了讲解，你可以读<a href="https://99designs.com/blog/tips/the-7-step-guide-to-understanding-color-theory/" target="_blank" rel="noopener">这篇文章</a>了解更多关于色调和阴影的知识。</p><p>最后我想说，在你给自己的项目进行配色时，并不存在”错误答案“。许多人认为品味是天生就有的，正是它帮助你寻找美妙的设计、带来灵感、尝试各种组合，最终为你和你的品牌找到最适合方案。祝你好运！</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c6caee26fb9a049df24a4df" target="_blank" rel="noopener">https://juejin.im/post/5c6caee26fb9a049df24a4df</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="Color" scheme="https://lsvih.com/tags/Color/"/>
    
      <category term="Design" scheme="https://lsvih.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>十件你不知道的关于 WebPageTest.org 的事(译)</title>
    <link href="https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/"/>
    <id>https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/</id>
    <published>2019-02-16T04:52:00.000Z</published>
    <updated>2019-02-16T05:17:51.304Z</updated>
    
    <content type="html"><![CDATA[<p>够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。</p><p>如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！</p><p>最近我在 Santa Clara 参加了 <a href="http://conferences.oreilly.com/velocity" target="_blank" rel="noopener">Velocity Conference</a>，偶遇了 <a href="https://github.com/pmeenan" target="_blank" rel="noopener">Pat Meenan</a>（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），<del>希望你还没有用过它们</del>。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。</p><a id="more"></a><h2 id="10-模拟单点失效"><a href="#10-模拟单点失效" class="headerlink" title="10. 模拟单点失效"></a>10. 模拟单点失效</h2><p>你的网站很可能依赖了一些第三方库来提供额外的功能（包括且不仅限于监控脚本、A/B 测试和广告）。问题就有可能出在这些你使用的部署在别人服务器上的库，这就是<a href="https://en.wikipedia.org/wiki/Single_point_of_failure" target="_blank" rel="noopener">单点失效</a>（SPOF）风险。如果出于某些原因，导致托管这些库的服务器出现故障或响应缓慢，你的网站也会不幸地收到影响。这种事情可能发生在任何人身上！</p><p>使用 WebPageTest 模拟单点失效与正常测试网站的设置一模一样，不过你需要将第三方库的域名屏蔽。例如，如果你想对 ccn.com 测试单点失效，可以将以下域名复制并粘贴到 SPOF 选项卡中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cdn3.optimizely.com</span><br><span class="line">a.visualrevenue.com</span><br><span class="line">www.google-analytics.com</span><br><span class="line">pixel.quantserve.com</span><br><span class="line">budgetedbauer.com</span><br></pre></td></tr></table></figure><p>粘贴好后界面应该如下所示：</p><p><img src="https://lsvih.com/images/1-1.jpeg" alt="1"></p><p>当查看此网站的加载视频时，你会发现 WebPagetest 已经对 SPOF 进行了模拟，导致该网站的加载时间长了不少。在<a href="http://www.webpagetest.org/video/compare.php?tests=160705_CE_HJQ,160705_JS_HJR" target="_blank" rel="noopener">上述测试</a>中，网站最终加载完毕共花了 20 多秒！这个功能是测试你的网站在 SPOF 情况下响应情况的好工具。</p><h2 id="9-创建个人-WebPagetest-实例"><a href="#9-创建个人-WebPagetest-实例" class="headerlink" title="9. 创建个人 WebPagetest 实例"></a>9. 创建个人 WebPagetest 实例</h2><p>WebPageTest 公共实例非常方便，你可以免费用它来快速获取需要的信息。不过公共实例有一些限制，比如在某个忙碌的日子里，你可能会需要在排队等待测试结果。如果你将 WebPageTest 用于商业用途，也许需要创建属于自己的私有 WebPageTest 实例。</p><p>Pat Meenan 写了一篇名为 <a href="http://calendar.perfplanet.com/2014/webpagetest-private-instances-in-five-minutes/" target="_blank" rel="noopener">5 分钟上手 WebPagetest 私有实例</a>的指南，介绍了在 Amazon EC2 上如何设置自己的实例。代理在所有 EC2 域中以 AMI 的形式提供，如果你需要在公司防火墙内部进行测试，也可以自行配置。</p><p>私有实例用起来很方便，因为你可以控制测试的基础架构，并且 API 请求数量没有限制。</p><h2 id="8-编写登录脚本"><a href="#8-编写登录脚本" class="headerlink" title="8. 编写登录脚本"></a>8. 编写登录脚本</h2><p>WebPageTest 不仅可以用于测试公开的网站，如果有需要，它也可以通过编写登录网站的脚本测试需要登录的网站。WebPageTest 具有脚本功能，可以自动执行多步测试（比如登录网站和发送电子邮件）。</p><p>例如，如果你想为 AOL 网站编写登录步骤的脚本，可以执行类似于以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logData0</span><br><span class="line"></span><br><span class="line">// bring up the login screen</span><br><span class="line">navigatehttp://webmail.aol.com</span><br><span class="line"></span><br><span class="line">logData1</span><br><span class="line"></span><br><span class="line">// log in</span><br><span class="line">setValuename=loginIdsomeuser@aol.com</span><br><span class="line">setValuename=passwordsomepassword</span><br><span class="line">submitFormname=AOLLoginForm</span><br></pre></td></tr></table></figure><p>请记住不要将重要的登录凭证放在里面！除非你将它们明确设为私有，否则 webpagetest.org 网站上的测试都是公开的。如果你想了解更多有关编写脚本的信息，请查阅此<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/scripting" target="_blank" rel="noopener">链接</a>。</p><h2 id="7-WebPagetest-发明的-Speed-Index-指标"><a href="#7-WebPagetest-发明的-Speed-Index-指标" class="headerlink" title="7.WebPagetest 发明的 Speed Index 指标"></a>7.WebPagetest 发明的 Speed Index 指标</h2><p>WebPagetest 于 2012 年添加了 Speed Index 指标（速度指数），它可以用于标化页面可视内容的填充速度。你可以尝试将不同的页面相互比较（优化之前与之后、自己的网站与竞品等），并与其他指标（加载时间，开始渲染时刻等）结合，来更好地理解这个对于描述网站性能非常有用的指标。如果你想了解更多有关 Speed Index 的信息，请参阅<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="noopener">此链接</a>。</p><h2 id="6-收集自定义指标"><a href="#6-收集自定义指标" class="headerlink" title="6. 收集自定义指标"></a>6. 收集自定义指标</h2><p>WebPageTest 提供了大量有用的统计指标。但你知道吗？你还可以用它来收集你自定义的指标。WebPageTest 可以在测试的最后执行任意的 JavaScript 脚本并收集<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/custom-metrics" target="_blank" rel="noopener">自定义指标</a>。你可以在服务器配置中静态地配置或在每个基础测试进行时配置它。</p><p>其实，自定义指标可以覆写内置指标。当你需要通过 JavaScript 验证强制让测试失败时，可以通过自定义指标得到“测试结果”。<a href="http://httparchive.org/" target="_blank" rel="noopener">HTTP Archive</a> 还通过 <a href="https://github.com/HTTPArchive/httparchive/tree/master/custom_metrics" target="_blank" rel="noopener">自定义指标</a> 采集了一些统计数据。</p><h2 id="5-将-WebPageTest-整合进你的-CI-测试中"><a href="#5-将-WebPageTest-整合进你的-CI-测试中" class="headerlink" title="5. 将 WebPageTest 整合进你的 CI 测试中"></a>5. 将 WebPageTest 整合进你的 CI 测试中</h2><p>如果你想在每次部署新代码时，都确保新代码不会让你在 Web 性能上的努力前功尽弃，那么 WebPageTest 可以帮上忙！你可以在页面上设置“budget”（预算），如果测试结果超过预算值则会导致测试失败。<a href="https://timkadlec.com/2013/01/setting-a-performance-budget/" target="_blank" rel="noopener">Tim Kadlec</a> 创建了一个有用的 <a href="https://github.com/tkadlec/grunt-perfbudget" target="_blank" rel="noopener">Grunt任务</a>，可以用 WebPagetest 的公开或私有实例对指定的 URL 执行测试。Marcel Duran 还为 NodeJS 创建了一个 <a href="https://github.com/marcelduran/webpagetest-api" target="_blank" rel="noopener">WebPageTest API 包装器</a>，可以让你自定义测试的运行方式。</p><p>通过这些方法，每当更新代码时，都能检查网站性能。网页的性能并不是儿戏，而是维系网站生命的重要事项！</p><h2 id="4-你可以自定义瀑布图的显示方式"><a href="#4-你可以自定义瀑布图的显示方式" class="headerlink" title="4. 你可以自定义瀑布图的显示方式"></a>4. 你可以自定义瀑布图的显示方式</h2><p>你知道吗？WebPageTest 可以自定义瀑布图的显示方式。运行测试后，单击瀑布图像并向下滚动，可以看到一个“customize waterfall”（自定义瀑布）的链接。</p><p><img src="https://lsvih.com/images/2.jpeg" alt="2"></p><p>点击这个链接，可以自定义瀑布图的显示方式。很好用！</p><p><img src="https://lsvih.com/images/3-1.jpeg" alt="3"></p><p>如果你要在幻灯片里使用瀑布图，这个功能可让你精准地展示需要展示的部分。</p><h2 id="3-在测试历史记录中对比多个测试结果"><a href="#3-在测试历史记录中对比多个测试结果" class="headerlink" title="3. 在测试历史记录中对比多个测试结果"></a>3. 在测试历史记录中对比多个测试结果</h2><p>在测试历史记录页面中，你可以查看针对特定实例运行过的测试列表。这个页面可以让你以幻灯片的形式直观地比较多个测试。</p><p><img src="https://lsvih.com/images/4.jpeg" alt="4"></p><p>选择要进行比较的测试，就能看到一个幻灯片视图，比较所有过去运行过的测试。</p><p><img src="https://lsvih.com/images/5.jpeg" alt="5"></p><p>需要注意，在运行测试时最好对测试设置标签。这样有助于帮你在历史记录中找到对应的测试，并且在幻灯片、视频视图中显示时也会显示标签。</p><h2 id="2-你也可以为-WebPageTest-代码库做贡献"><a href="#2-你也可以为-WebPageTest-代码库做贡献" class="headerlink" title="2. 你也可以为 WebPageTest 代码库做贡献"></a>2. 你也可以为 WebPageTest 代码库做贡献</h2><p>整个 WebPageTest 的代码库都是开源的！代码库位于 <a href="https://github.com/WPO-Foundation/webpagetest" target="_blank" rel="noopener">Github</a>，包括了 Web UI 和可用于在各种浏览器上运行测试的代码。Pat 提到，这个代码库使用的是非常宽松的 BSD 协议，也就是说你可以出于任何的目的（包括商业等用途）使用项目的任何部分。</p><p>如果你觉得有些东西可以让社区受益，请务必为这个非常棒的工具做出贡献！</p><h2 id="1-检查你的-JavaScript-执行是否导致性能瓶颈"><a href="#1-检查你的-JavaScript-执行是否导致性能瓶颈" class="headerlink" title="1. 检查你的 JavaScript 执行是否导致性能瓶颈"></a>1. 检查你的 JavaScript 执行是否导致性能瓶颈</h2><p>现在 JavaScript 在全世界都非常流行，这也意味着 JavaScript 的执行已经成为了妨碍浏览器性能的一个严重瓶颈。你知道吗？使用 WebPageTest，可以模拟在设备上运行网站，并得到主线程运作的详细情况。</p><p>在运行测试前，打开 Chrome 标签，然后勾选“Capture Dev Tools Timeline”（捕获开开发者工具时间轴）。</p><p><img src="https://lsvih.com/images/6.jpeg" alt="6"></p><p>在测试完成后，点击“Processing Breakdown”（处理详情）按钮，将得到主线程处理过程中的详细视图。通过展示主线程的处理过程的详细情况，可以让你更好地了解网站在真实设备上的确切运行情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：如果你经常使用 WebPageTest，希望这篇文章能帮你了解更多关于它的内容。感谢 <a href="http://blog.patrickmeenan.com/" target="_blank" rel="noopener">Pat Meenan</a> 提供信息并帮忙检查文章！</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c679531f265da2dc45367ab" target="_blank" rel="noopener">https://juejin.im/post/5c679531f265da2dc45367ab</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。&lt;/p&gt;
&lt;p&gt;如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！&lt;/p&gt;
&lt;p&gt;最近我在 Santa Clara 参加了 &lt;a href=&quot;http://conferences.oreilly.com/velocity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Velocity Conference&lt;/a&gt;，偶遇了 &lt;a href=&quot;https://github.com/pmeenan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pat Meenan&lt;/a&gt;（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），&lt;del&gt;希望你还没有用过它们&lt;/del&gt;。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="FrontEnd" scheme="https://lsvih.com/tags/FrontEnd/"/>
    
      <category term="Test" scheme="https://lsvih.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>5 个可以立刻在你的 Ionic App 中用上的动画包</title>
    <link href="https://lsvih.com/2019/01/30/5-%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AB%8B%E5%88%BB%E5%9C%A8%E4%BD%A0%E7%9A%84-Ionic-App-%E4%B8%AD%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8A%A8%E7%94%BB%E5%8C%85/"/>
    <id>https://lsvih.com/2019/01/30/5-个可以立刻在你的-Ionic-App-中用上的动画包/</id>
    <published>2019-01-30T10:20:00.000Z</published>
    <updated>2019-02-16T05:31:10.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.png" alt="1"></p><p>使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。</p><p>在本文中我们将介绍 <strong>5 个不同的动画包</strong>，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。</p><a id="more"></a><p><img src="https://lsvih.com/images/2.gif" alt="2"></p><p>你可以使用以下代码初始化一个空白的 Ionic 4 App：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionic start animationPackages blank --type=angular</span><br></pre></td></tr></table></figure><p>我们不会完整地摘录这些包的文档，只会展示如何将它们整合进你的 App 这一重要部分。</p><h2 id="1-Anime-js"><a href="#1-Anime-js" class="headerlink" title="1. Anime.js"></a>1. <a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">Anime.js</a></h2><p>只要安装好这个包，不需要任何别的操作就能将它引入你的 App 中了。你只需要简单地按照下列代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animejs</span><br></pre></td></tr></table></figure><p>通过它你可以让你<strong>在你的 Javascript 代码中</strong>创建动画。这也是它与绝大多数包不同的地方：别的包大多是通过添加 CSS class，或者在你的 class 中用特定的语法来创建动画的。</p><p>通过 Anime.js，你能轻松地为屏幕中的元素设定动画并移动它们。下面是创建一个小方块，并用一个函数来创建动画效果的代码（我们给小方块加了一些 CSS 样式，这样它才能在屏幕上有一定的大小）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div class=&quot;animate-me&quot; #box&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">// SCSS</span><br><span class="line"> </span><br><span class="line">.animate-me &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    background: #0000ff;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import * as anime from &apos;animejs&apos;;</span><br><span class="line"> </span><br><span class="line">callAnime() &#123;</span><br><span class="line">    anime(&#123;</span><br><span class="line">      targets: &apos;.animate-me&apos;,</span><br><span class="line">      translateX: [</span><br><span class="line">        &#123; value: 100, duration: 1200 &#125;,</span><br><span class="line">        &#123; value: 0, duration: 800 &#125;</span><br><span class="line">      ],</span><br><span class="line">      rotate: &apos;1turn&apos;,</span><br><span class="line">      backgroundColor: &apos;#ff00ff&apos;,</span><br><span class="line">      duration: 2000</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用元素的 CSS class 来轻松指定应用动画效果的目标（即 target 参数），其它的参数都不言自明。这也是这个包的强大之处：</p><p>你可以轻松理解这个包的一些基本命令，<strong>快速上手并创建强大的动画效果</strong>。如果选择用这个包来创建动画，你不需要学习又臭又长的 API。</p><h2 id="2-Magic-CSS"><a href="#2-Magic-CSS" class="headerlink" title="2. Magic CSS"></a>2. <a href="https://github.com/miniMAC/magic" target="_blank" rel="noopener">Magic CSS</a></h2><p>这个包依赖于预设好的 CSS 动画，你可以将这些动画加入到元素中。安装方式与前文相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install magic.css</span><br></pre></td></tr></table></figure><p>不过此时你需要从 node module 将实际的 CSS 文件导入进来，因此你得用类似下面的方法来修改你的 <strong>src/global.scss</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~magic.css/magic.min.css&apos;;</span><br></pre></td></tr></table></figure><p>现在可以在你的 app 中用 Magic CSS 了。你可以直接在元素上添加动画的 class，或者用下面这种方式通过 <code>@ViewChild()</code> 标注将动画 class 加入到元素的 <code>classList</code> 中去，这样就能在特定的时间来创建动画了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div class=&quot;animate-me&quot; #box&gt;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">@ViewChild(&apos;box&apos;) box: ElementRef;</span><br><span class="line"> </span><br><span class="line">doMagic() &#123;</span><br><span class="line">    this.box.nativeElement.classList.add(&apos;magictime&apos;);</span><br><span class="line">    this.box.nativeElement.classList.add(&apos;foolishIn&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次你都要先加入 <strong>magictime</strong> class，然后加入你要用的动画的 class 名。</p><p>这个包没有提供那么多的自定义选项，不过如果你只需要<strong>简单且快速的 CSS 动画</strong>，试试它准没错！</p><h2 id="3-Number-Flip"><a href="#3-Number-Flip" class="headerlink" title="3. Number Flip"></a>3. <a href="https://github.com/gaoryrt/number-flip" target="_blank" rel="noopener">Number Flip</a></h2><p>这是一个小巧的包。我最近才发现它，非常喜欢它的动画。不过只有在一种特定的情景下，你才会需要将它加入你的 app（你可以看看它的 Github page，那里面的效果就是它唯一的效果）。安装方式很简单，依然是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install number-flip</span><br></pre></td></tr></table></figure><p>假设你的 Ionic app 的顶栏上有一些计数器，现在你希望通过动画效果来修改它的数字。</p><p>这个情景中，number flip 包就非常好用，你可以用帅帅的动画效果让一个元素翻转，并在翻转时修改元素里面的数字。我用一些代码创建了对该元素的引用，当触发 <code>flip()</code> 函数的时候会直接调用动画包里面的 <code>flipTo()</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;ion-header&gt;</span><br><span class="line">  &lt;ion-toolbar&gt;</span><br><span class="line">    &lt;ion-title&gt;</span><br><span class="line">      Ionic Animations</span><br><span class="line">    &lt;/ion-title&gt;</span><br><span class="line">    &lt;ion-buttons slot=&quot;end&quot;&gt;</span><br><span class="line">      &lt;div #numberbtn&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/ion-buttons&gt;</span><br><span class="line">  &lt;/ion-toolbar&gt;</span><br><span class="line">&lt;/ion-header&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import &#123; Flip &#125; from &apos;number-flip&apos;;</span><br><span class="line"> </span><br><span class="line">@ViewChild(&apos;numberbtn&apos;, &#123; read: ElementRef &#125;) private btn: ElementRef;</span><br><span class="line"> </span><br><span class="line">flip() &#123;</span><br><span class="line">  if (!this.flipAnim) &#123;</span><br><span class="line">    this.flipAnim = new Flip(&#123;</span><br><span class="line">      node: this.btn.nativeElement,</span><br><span class="line">      from: &apos;9999&apos;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  this.flipAnim.flipTo(&#123;</span><br><span class="line">    to: Math.floor((Math.random() * 1000) + 1)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个包没有任何别的高级动画效果，它<strong>仅仅在这种特殊情景下特别好用</strong>。如果你要使用计时器或者创建数字动画，考虑考虑它吧！</p><h2 id="4-Animate-CSS"><a href="#4-Animate-CSS" class="headerlink" title="4. Animate CSS"></a>4. <a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">Animate CSS</a></h2><p>它可是一位重磅玩家，在这几个包中就属它的 Github star 最多。它的口号是“像倒水一样添加 CSS 动画”，事实上它的用法确特别简单。安装方法和前文一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animate.css</span><br></pre></td></tr></table></figure><p>由于这个包依赖于 CSS，因此使用它前我们也要通过下面的方式将 CSS 文件导入 <strong>src/global.scss</strong> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~animate.css/animate.min.css&apos;;</span><br></pre></td></tr></table></figure><p>现在，我们就可以享受这个包各种预设好的超帅的 CSS 动画了（每个用例都对应着一种动画）。我们还可以添加一些其它的 class，比如说 <code>infinite</code> 让动画循环播放，或者让动画延迟一段时间播放。</p><p>在下面的例子中，我们 ngFor 和它的 index 来定义不同的动画延迟（当然在真实的 app 中不会有这么慢的动画），然后用 <code>ViewChildren</code> 列表来为需要飞出来的元素增加相应的动画 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;h1 text-center class=&quot;animated infinite rubberBand delay-1s&quot;&gt;Example&lt;/h1&gt;</span><br><span class="line"> </span><br><span class="line">&lt;ion-list&gt;</span><br><span class="line">    &lt;ion-item *ngFor=&quot;let val of [&apos;First&apos;, &apos;Second&apos;, &apos;Third&apos;]; let i = index;&quot; </span><br><span class="line">    class=&quot;animated fadeInLeft delay-&#123;&#123; i &#125;&#125;s&quot; #itemlist&gt;</span><br><span class="line">      &#123;&#123; val &#125;&#125; Item</span><br><span class="line">    &lt;/ion-item&gt;</span><br><span class="line">&lt;/ion-list&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">@ViewChildren(&apos;itemlist&apos;, &#123; read: ElementRef &#125;) items: QueryList&lt;ElementRef&gt;;</span><br><span class="line"> </span><br><span class="line">animateItems() &#123;</span><br><span class="line">  let elements = this.items.toArray();</span><br><span class="line">  elements.map(elem =&gt; &#123;</span><br><span class="line">    return elem.nativeElement.classList.add(&apos;zoomOutRight&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要个<strong>预设好大量 CSS 动画的武器库</strong>，你一定要试试它。虽然它已经预设好了很多东西，但你也可以根据你的需要来进行组合！</p><h2 id="5-Bounce-js"><a href="#5-Bounce-js" class="headerlink" title="5. Bounce.js"></a>5. <a href="https://github.com/tictail/bounce.js" target="_blank" rel="noopener">Bounce.js</a></h2><p>最后，我想测试这个特别灵活的包。它也可以用 Javascript 来编写动画。这个包的安装方法和其它几个包一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bounce.js</span><br></pre></td></tr></table></figure><p>这个包的文档非常完整，你可能要多花一点时间来探索所有的配置，比如下面是他们页面广告中的一个片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;ion-button expand=&quot;block&quot; (click)=&quot;bounce()&quot; #bouncebtn&gt;Bounce&lt;/ion-button&gt;</span><br><span class="line"> </span><br><span class="line">// TS</span><br><span class="line">import * as Bounce from &apos;bounce.js&apos;;</span><br><span class="line"> </span><br><span class="line">@ViewChild(&apos;bouncebtn&apos;, &#123; read: ElementRef &#125;)bouncebtn: ElementRef;</span><br><span class="line"> </span><br><span class="line">bounce() &#123;</span><br><span class="line">  var bounce = new Bounce();</span><br><span class="line">  bounce</span><br><span class="line">    .translate(&#123;</span><br><span class="line">      from: &#123; x: -300, y: 0 &#125;,</span><br><span class="line">      to: &#123; x: 0, y: 0 &#125;,</span><br><span class="line">      duration: 600,</span><br><span class="line">      stiffness: 4</span><br><span class="line">    &#125;)</span><br><span class="line">    .scale(&#123;</span><br><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span><br><span class="line">      to: &#123; x: 0.1, y: 2.3 &#125;,</span><br><span class="line">      easing: &quot;sway&quot;,</span><br><span class="line">      duration: 800,</span><br><span class="line">      delay: 65,</span><br><span class="line">      stiffness: 2</span><br><span class="line">    &#125;)</span><br><span class="line">    .scale(&#123;</span><br><span class="line">      from: &#123; x: 1, y: 1 &#125;,</span><br><span class="line">      to: &#123; x: 5, y: 1 &#125;,</span><br><span class="line">      easing: &quot;sway&quot;,</span><br><span class="line">      duration: 300,</span><br><span class="line">      delay: 30,</span><br><span class="line">    &#125;)</span><br><span class="line">    .applyTo(this.bouncebtn.nativeElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，所有步骤都在你的 Javascript 代码中。你可以用这个包在任何粒度上<strong>创建复杂的关键帧动画</strong>。</p><p>不过这种灵活性是要付出代价的，你需要深入地研究它的文档，因此比起其它的包你需要更多的时间才能入门。不过，如果你付出了时间，它也会回报你的付出：你可以用它在 app 中创建任何你想要的动画！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在推荐的这几个包中，有一些包可以让你快速做出产品，有些包则需要你学习它们的语法；有些包已经预设好了一切动画，而有些包则可以让你创建更灵活的动画；有些包是纯 CSS，还有一些是纯 JS。</p><p>没有哪个是真正“最好的”，因为它们在不同的场景下有着各自的优势。另外，注意这些包的大小也是一件重要的事，你也不希望加太多的东西影响 app 的下载时间吧。</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c517544f265da613b702848" target="_blank" rel="noopener">https://juejin.im/post/5c517544f265da613b702848</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 Ionic 与 Angular 有许多方法可以让你在你的 app 中制作动画。你可以直接使用 Angular Animations，也可以使用其它的包（仅需几分钟就能装好）来实现动画。&lt;/p&gt;
&lt;p&gt;在本文中我们将介绍 &lt;strong&gt;5 个不同的动画包&lt;/strong&gt;，可以轻松地将它们引入你的 APP，使用它们预设的动画或者利用这几个框架轻松自定义动画效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Ionic" scheme="https://lsvih.com/tags/Ionic/"/>
    
      <category term="Angular" scheme="https://lsvih.com/tags/Angular/"/>
    
      <category term="Animation" scheme="https://lsvih.com/tags/Animation/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>DNS over TLS：端到端加密的 DNS</title>
    <link href="https://lsvih.com/2019/01/23/DNS-over-TLS-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%9A%84%20DNS/"/>
    <id>https://lsvih.com/2019/01/23/DNS-over-TLS-端到端加密的 DNS/</id>
    <published>2019-01-23T11:13:00.000Z</published>
    <updated>2019-01-23T11:15:54.690Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/1.jpeg" alt="1"></p><p>为了加密互联网流量中未被加密的最后一部分，我们与 <a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener">Cloudflare DNS</a> 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 <a href="https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/" target="_blank" rel="noopener">TLS</a>，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。</p><a id="more"></a><h2 id="DNS-的历史"><a href="#DNS-的历史" class="headerlink" title="DNS 的历史"></a>DNS 的历史</h2><p>二十世纪八十年代末，域名系统（DNS）被提出，可以让人们用简短易记的名称来连接实体（比如 facebook.com），这使得网络安全发生了极大的变化。人们为网络安全做了许多的改进，比如现在大部分的网络流量都是通过 HTTPS 连接，但在线上传输明文时仍然存在一些问题。</p><p>2010 年，<a href="https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" target="_blank" rel="noopener">DNS 安全拓展</a>（DNSSEC）部署实施，DNS 协议由此支持身份验证功能。虽然 DNSSEC 支持对消息进行身份验证，但仍然会使用明文来传输 DNS 请求与应答。这也使得传输的内容可以被请求方与响应方中间路径上任意节点轻松获取。2014 年 10 月，国际互联网工程任务组（IETF）建立了 <a href="https://datatracker.ietf.org/wg/dprive/about/" target="_blank" rel="noopener">DPRIVE 工作组</a>，其章程包括为 DNS 提供保密性与身份验证功能。</p><p>此工作组在于 2016 年提出 <a href="https://tools.ietf.org/html/rfc7858" target="_blank" rel="noopener">RFC 7858</a> 指定了 DoT 标准。为此，Cloudflare 的 1.1.1.1 与 Quad9 的 9.9.9.9 等开放的解析器在 DoT 的支持下更加关注使用者的隐私。这也保护了终端用户设备到 DNS 解析器这一部分 DNS 通信。但连接的其它部分仍然是明文传输。在 2018 年 5 月，DPRIVE 重新开发了一个方法，用于加密从解析器到域名服务器间的通信。</p><p><img src="https://lsvih.com/images/2.png" alt="2"></p><p><strong>DoT 以前的 DNS</strong></p><h2 id="DoT-试验"><a href="#DoT-试验" class="headerlink" title="DoT 试验"></a>DoT 试验</h2><p>我们在过去的几个月中一直在进行一项试验，在 Cloudflare 1.1.1.1 递归解析器与我们的主域名服务器间开启 DoT。这个试验的目的是了解大规模使用 DoT 的可行性，收集信息以更好地了解 DoT 在接受应答时的延迟产生的开销，并确定计算开销。这个试验让我们更好地了解了 DoT 协议在真实环境下的表现。另外在生产环境负载中试验把 DNS 从 UDP 等即发即弃方法换成 TLS 之类的加密连接协议，可以将一些设计协议时发现不了的问题给暴露出来。</p><p><img src="https://lsvih.com/images/3.jpeg" alt="3"></p><p><strong>DoT 下的 DNS</strong></p><p>截至目前，通过观察 Cloudflare DNS 与 Facebook 域名服务器间的生产环境流量，已经可以证明该试验是可行的解决方案。在初始化一个新连接的时候由于需要初始化请求，因此增加了延时；但我们可以重用 TLS 连接来处理其它更多的请求。因此，初始化增加的负载在均摊之后，降低到了 Cloudflare DNS 与 Facebook 主域名服务器 UDP 基线的 p99 相同的程度。</p><p>下图展示了我们从 TLS 切换回 UDP 时（在 17:30 时刻）延时的变化。它可以让我们比较两个协议请求的延时。第一个图显示了在没有 TCP/TLS 会话建立开销情况下的延时百分比。它展示了当连接建立后，TLS 与 UDP 在查询和响应间的延时是相同的。</p><p><img src="https://lsvih.com/images/4.png" alt="4"></p><p>第二张图加上了建立连接的时间来考虑请求的总体延迟。从图中可以看到，使用 TLS 还是 UDP 对连接的总体延时也没有影响。这是因为我们使用 TLS 的会话恢复技术，通过相同的 TLS 连接来执行多个请求，实质上分摊了初始化连接的开销。</p><p><img src="https://lsvih.com/images/5.png" alt="5"></p><p>作为参考，下图展示了在不使用 TLS 会话恢复技术，并在建立连接后仅处理少量请求时总延时的差异。在比 22:35 稍早的时刻完成了 TLS 到 UDP 的切换，可以看到总体而言 TLS 对大多数的请求的影响与 UDP 类似，但在 p95 或更高的统计指标下，请求的延时收到了影响。后面一张图显示，当链接已经建立时，延时不受影响。这两张图表明，第一张图中的差异是由于建立新连接时产生的，并且实际上，建立新连接的频率很高。</p><p><img src="https://lsvih.com/images/6.png" alt="6"></p><p><img src="https://lsvih.com/images/7.png" alt="7"></p><p>基本来说，浏览 Facebook 和使用带 DoT 的 Cloudflare DNS 的用户，无论是在用 HTTPS 连接时还是在 DNS 层面上，都可以享受完全加密的体验。虽然我们已经实现了 TLS 会话恢复技术，但还没有充分利用现代协议栈提供的全部优化方法。在将来，我们可以利用 TLS 的最新版本（<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener">TLS 1.3</a>）和 <a href="https://en.wikipedia.org/wiki/TCP_Fast_Open" target="_blank" rel="noopener">TCP Fast Open</a> 等技术带来的改进，进一步降低延时。</p><h2 id="DoT-的下一步"><a href="#DoT-的下一步" class="headerlink" title="DoT 的下一步"></a>DoT 的下一步</h2><p>这个试验已经证明了，我们可以使用 DoT 大规模处理生产环境的负荷，并且不会对用户体验产生任何负面影响。我们将这个试验所得到的经验和知识，作为一种可行的经验回馈给 DNS 社区。</p><p><a href="https://www.ietf.org/" target="_blank" rel="noopener">IETF</a> 等标准社区开发协议时，有时候会缺乏与最终实施与运行协议的组织的意见，这导致了协议设计者、实施者、运营者间的脱节。通过这个试验，我们可以根据在生产环境中运行协议得到的经验，及时向工作组报告具体结果，同时也为有意于部署 DoT 的运营商和软件供应商提供了最佳实践。</p><p>我们希望这些初步的试验结果可以激励其它的行业合作伙伴加入我们的试验，扩大 DoT 运营商的数量，并得到更多制定此协议时得到的经验，从而提高反馈水准、得到更多的运营知识和最佳实践。</p><p><strong>感谢 Cloudflare 的 Marek Vavruša 在这个试验中做出的贡献。</strong></p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c4849d06fb9a049c30b967b" target="_blank" rel="noopener">https://juejin.im/post/5c4849d06fb9a049c30b967b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/1.jpeg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了加密互联网流量中未被加密的最后一部分，我们与 &lt;a href=&quot;https://www.cloudflare.com/dns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloudflare DNS&lt;/a&gt; 合作进行了一个试点项目。这个试点项目利用安全传输层协议（即 &lt;a href=&quot;https://code.fb.com/networking-traffic/deploying-tls-1-3-at-scale-with-fizz-a-performant-open-source-tls-library/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TLS&lt;/a&gt;，一种被广泛应用的、经过时间证明的机制，可用于双方在不安全信道上建立通讯时，为通讯提供身份认证及加密）与 DNS 进行结合。这个 DNS over TLS（DoT）方案能够加密并验证 Web 流量的最后一部分。在 DoT 测试中，人们可以在浏览 Facebook 时使用 Cloudflare DNS 享受完全加密的体验：不仅是在连接 Facebook 时用的 HTTPS 时进行了加密，而且在 DNS 级别，从用户计算机到 Cloudflare DNS、从 Cloudflare DNS 到 Facebook 域名服务器（NAMESERVER）中全程都采用了加密技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Back End" scheme="https://lsvih.com/tags/Back-End/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="DNS" scheme="https://lsvih.com/tags/DNS/"/>
    
      <category term="TLS" scheme="https://lsvih.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>Translation of &#39;Deep Variational Bayes Filters Unsupervised Learning of State Space Models from Raw Data&#39;.</title>
    <link href="https://lsvih.com/2018/12/15/Translation-of-DVBF/"/>
    <id>https://lsvih.com/2018/12/15/Translation-of-DVBF/</id>
    <published>2018-12-15T14:06:00.000Z</published>
    <updated>2019-01-21T13:28:03.985Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/files/DVBF.pdf" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/files/DVBF.pdf&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; align=&quot;&quot; height=&quot;600px&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Char-BiLSTM-CRF Incorporating POS and Dictionaries for Chinese OTE&#39; used in ACML conference.</title>
    <link href="https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/"/>
    <id>https://lsvih.com/2018/11/26/Slide-of-ChineseOTE/</id>
    <published>2018-11-26T04:29:00.000Z</published>
    <updated>2018-11-26T04:30:09.709Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-11-16/Char-BiLSTM-CRF%20Incorporating%20POS%20and%20Dictionaries%20for%20Chinese%20OTE.h
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="conference" scheme="https://lsvih.com/tags/conference/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Algorithms for Non-negative Matrix Factorization&#39; used in assignment.</title>
    <link href="https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Slide-of-Algorithms-for-Non-negative-Matrix-Factorization/</id>
    <published>2018-10-30T08:00:00.000Z</published>
    <updated>2018-10-30T08:00:49.004Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/18-10-30/Algorithms%20for%20Non-negative%20Matrix%20Factorization.html&quot; scrolling=&quot;no&quot; fram
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="assignment" scheme="https://lsvih.com/tags/assignment/"/>
    
      <category term="optimization" scheme="https://lsvih.com/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms for Non-negative Matrix Factorization，非负矩阵分解 论文翻译</title>
    <link href="https://lsvih.com/2018/10/30/Algorithms%20for%20Non-negative%20Matrix%20Factorization/"/>
    <id>https://lsvih.com/2018/10/30/Algorithms for Non-negative Matrix Factorization/</id>
    <published>2018-10-29T19:08:00.000Z</published>
    <updated>2019-04-07T07:47:51.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NIPS 2000 经典论文 非负矩阵分解算法 翻译</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>非负矩阵分解（NMF）是一种可以有效处理多变量数据的方法。本文介绍、分析了两种不同的 NMF 算法，这两种算法仅在更新规则（update rule）中使用的乘性因子（multiplicative factor）有所区别。其中一种可以对传统的最小二乘误差进行最小化（minimize），而另一种可以对广义 Kullback-Leibler 散度（KL 散度）进行最小化。可以使用与证明最大化期望算法收敛性类似的辅助函数来证明这两种算法的单调收敛性。这两种算法均可理解为用斜向最陡下降法（diagonally rescaled gradient descent）对因子进行最优化，以保证算法收敛。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PCA、矢量量化（Vector Quantization）等无监督学习算法可以理解为在不同约束条件下对数据矩阵进行分解。根据其约束的不同，分解所得的因子的会表现出大相径庭的性质。比如，PCA 仅使用了弱正交约束，从而得到非常分散的表示，对这些表示使用消去法来产生多样性；矢量量化使用一种严格的全局最优型约束，最终会得到互斥的数据聚类原型。</p><p>我们之前已经证明过，在矩阵分解用于学习数据的部分表示中，非负性（non-negative）是一种非常有用的约束。学习得到的非负基向量是分散的，但仍可通过稀疏的组合，在重建时得到效果良好的表达向量。在本文中，我们详细分析了这两种用于在数据中学习最优的非负因子的数值算法。</p><h2 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h2><p>下面我们正式开始分析如何用算法解决以下问题：</p><p><strong>在非负矩阵分解（NMF）中</strong>，给定非负矩阵V，找到非负矩阵因子W和H，使得：</p><script type="math/tex; mode=display">(1):  V\approx WH</script><p>NMF 可以应用下面的方法用于对多变量数据进行统计分析。给定一组多变量的 n 维数据向量，其向量位于一个 $n\times x$ 矩阵 V 的列中（m 表示数据集中的示例数）。然后将此矩阵近似分解为 $n\times r$ 的 W 矩阵与 $r\times m$的 H 矩阵。通常 r 要小于 n 或 m，以使 W 和 H 小于原始矩阵 V。最终得到的是原始数据矩阵的压缩形态。</p><p>公式(1)中约等于的意义在于它可以将公式逐列用 $v\approx Wh$ 来表示，其中 v 和 h 是矩阵 V 和矩阵 H 的对应的列。也就是说，每个数据向量 v 近似地由矩阵 W 的各列线性组合而成，同时用 h 的分量进行加权。因此可以被认为 W 包含了对 V 中的数据的线性近似优化的基向量。由于要使用少量的基向量来表示大量的数据向量，因此只有在基向量发现数据中的潜在结构时才能实现较好的近似。</p><p>本文不会涉及关于 NMF 的应用，而会侧重于在技术方面探讨非负矩阵分解的技术。当然，已经有许多其它的矩阵分解方式在数值线性代数中得到了广泛的研究，但是以前的大多数工作都不适用于非负性约束情况。</p><p>在此，我们讨论了基于迭代更新 W 和 H 的两种 NMF 算法。由于这两种算法易于实现，同时能保证其收敛性，因此它们在现实情况中非常实用。其他算法可能在总计算时间方面更有效率，但是更难实现，并且很难推广到不同的代价函数（cost function）。因子与我们类似的算法，已经被用于对发射断层扫描和天文图像进行反卷积（deconvolution）。</p><p>在我们算法的每次迭代中，会用当前值乘某些取决于公式(1)中的“近似程度”的因数，来找到 W 或 H 的新值。我们可以证明“近似程度”会随着不断应用这些乘法更新规则而单调减小。这正意味着更新规则的重复迭代可以保证矩阵分解算法收敛到局部最优。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>为了找到$ V\approx WH  $的近似解，我们首先需要定义一个代价函数，用以量化近似的程度。可以使用两个非负矩阵 A 和 B 的距离来构造此代价函数。一种使用的距离度量方法为：计算 A  和 B 之间的欧几里得距离（Euclidean distance）的平方值。</p><script type="math/tex; mode=display">(2): ||A-B||^2 = \sum_{ij}(A_{ij} - B_{ij})^2</script><p>此公式下界为 0，仅当 A=B 时距离消失。</p><p>另一种实用的度量方式为：</p><script type="math/tex; mode=display">(3): D(A||B) = \sum_{ij}(A_{ij} \log{\frac{A_{ij}}{B_{ij}}} - A_{ij}+B_{ij})</script><p>与欧几里得距离相同，它的下界也为 0，且在 A=B 时距离消失。但它不能被称为“距离”，因为这个式子在 A 与 B 中并不对称，因此我们将其称为 A 对于 B 的“散度”（divergence）。它可以归纳为 KL 散度或者相对熵，当 $\sum_{ij}A_{ij}=\sum_{ij}B_{ij}=1$ 时，A 与 B 可以看做是标准化的概率分布。</p><p>现在，我们可以按照以下两种公式来将 NMF 化为最优化问题：</p><p><strong>最优化问题1</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $||V - WH||^2$。</p><p><strong>最优化问题2</strong>：在约束条件 $W, H \geq 0$ 下，以 W 和 H 作为参数，最小化 $D(V||WH)$。</p><p>虽然方程 $||V - WH||^2$ 和 $D(V||WH)$ 在只考虑 W 或 H 之一时为凸，但在同时考虑 WH 两个变量时不为凸。因此，寻找一种可以找到全局最小值的算法去解决以上两个最优化问题是不切实际的。但是，还有许多数值优化方法可以用于寻找局部最小值。</p><p>虽然梯度下降法（Gradient descent）的收敛速度很慢，但它的实现最为简单。其它方法（比如共轭梯度法）可以更快地收敛（至少在局部最小值附近会更快），但是它们比梯度下降更复杂。此外，梯度下降方法的收敛对步长的选择非常敏感，这对于大规模应用十分不利。</p><h2 id="乘法更新规则"><a href="#乘法更新规则" class="headerlink" title="乘法更新规则"></a>乘法更新规则</h2><p>我们发现在解决上述两个最优化问题时，在速度与实现难度中权衡，“乘法更新规则”是一种综合性能很好方法。</p><p><strong>定理1</strong>：欧几里得距离 $||V-WH||$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(4): H_{a\mu} \leftarrow H_{a\mu}\frac{(W^T V)_{a\mu}}{(W^T W H)_{a\mu}}</script><script type="math/tex; mode=display">(4): W_{ia} \leftarrow W_{ia}\frac{(V H^T)_{ia}}{(W H H^T)_{ia}}</script><p>在上述更新规则中，W 与 H 在距离公式的驻点上时，欧几里得距离将固定不动。</p><p><strong>定理2</strong>：散度 $D(V|WH)$ 在下面的更新规则中呈非增：</p><script type="math/tex; mode=display">(5): H_{a\mu} \leftarrow H_{a\mu}\frac{\frac{\sum_{i}W_{ia}V_{i\mu}}{WH_{i\mu}}}{\sum_k W_{ka}}</script><script type="math/tex; mode=display">(5): W_{ia} \leftarrow W_{ia}\frac{\frac{\sum_{\mu}H_{a\mu}V_{i\mu}}{WH_{i\mu}}}{\sum_v H_{av}}</script><p>在上述更新规则中，W 和 H 在散度公式的驻点上时，散度将不再更新。</p><p>上述定理的证明将在后面给出。我们可以发现，每次更新都是乘以一个因子。特别地，当V = WH时，可以直观地看出这个乘数因子是一样的，当更新规则固定时，才会得到完美的分解。</p><h2 id="乘法与加法更新规则"><a href="#乘法与加法更新规则" class="headerlink" title="乘法与加法更新规则"></a>乘法与加法更新规则</h2><p>可以将乘法更新与梯度下降更新进行对比。特别的，对 H 进行更新以减小平方距离可以记为：</p><script type="math/tex; mode=display">(6):H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[(W^TV)_{a\mu} - (W^T WH)_{a\mu}]</script><p>如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $||V-WH||$。</p><p>如果我们按照斜向最陡调整变量，并设置：</p><script type="math/tex; mode=display">(7): \eta_{a\mu}=\frac{H_{a\mu}}{(W^TWH)_{a\mu}}</script><p>就能得到定理 1 中给出的 H 更新规则。注意，该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>对于散度公式，我们按照下述公式调整斜向最陡梯度下降：</p><script type="math/tex; mode=display">(8): H_{a\mu} \leftarrow H_{a\mu} + \eta_{a\mu}[\sum_{i}W_{ia}\frac{V_{i\mu}}{(WH)_{i\mu}}-\sum_{i}W_{ia}]</script><p>同样的，如果将 $\eta_{a\mu}$ 设置为较小的正数，上式就和常规的梯度下降等价。只要数字充分小，就能在更新时减小 $D(V||WH)$。如果设置：</p><script type="math/tex; mode=display">(9): \eta_{a\mu} = \frac{H_{a\mu}}{\sum_i W_{ia}}</script><p>那么就能得到定理 2 中给出的 H 更新规则。该调整可得出乘性因子（分母中的梯度的正分量和因子的分子中的负分量的绝对值）。</p><p>由于我们对 $\eta_{a\mu}$ 的取值并不够小，看起来不能保证这种调整过后的梯度下降的代价函数减小。不过让人惊讶的是，如下节所示，上述假设是事实。</p><h2 id="收敛证明"><a href="#收敛证明" class="headerlink" title="收敛证明"></a>收敛证明</h2><p>我们将使用一个类似于 EM 算法的辅助函数来证明定理 1 与定理 2。</p><p><strong>定义 1</strong>：$G(h,h’)$ 是 $F(h)$ 的辅助函数，满足以下条件成立：</p><script type="math/tex; mode=display">(10): G(h,h')\geq F(h), G(h,h)=F(h)</script><p>根据下面的引理，此辅助函数是一个有用的概念。（在图1中的插图也显示了这一点）</p><p><strong>引理 1</strong>：如果 G 为辅助函数，则 F 在下述更新时为非增：</p><script type="math/tex; mode=display">(11): h^{t+1} = \arg\min_{h}G(h,h^t)</script><p><strong>证明</strong>：$F(h^{t+1}) \leq G(h^{t+1}, h^t) \leq G(h^t,h^t) = F(h^t)$</p><p>请注意，只有在$h^t$为$G(h,h^t)$的全局最小值时满足$F(h^{t+1})=F(h^t)$。如果 F 的导数存在，且在$h^{t}$的邻域连续，也就是说$\nabla F(h^t) = 0 $。因此通过公式11反复更新，我们就能得到目标函数收敛的局部最小值 $h_{min} = \arg\min_h F(h)$</p><script type="math/tex; mode=display">(12): F(h_{min}) \leq ... F(h^{t+1})\leq F(h^t) ... \leq F(h_2) \leq F(h_1) \leq F(h_0)</script><p><img src="https://lsvih.com/images/15408401601646.jpg" alt="-w663"></p><p>下面，我们证明如何为$||V-WH||$与$D(V,WH)$定义适当的辅助函数$G(h,h^t)$。定理 1 与定理 2 可以直接遵循公式 11 的更新规则。</p><p><strong>引理 2</strong>：如果$K(h^t)$为对角矩阵，</p><script type="math/tex; mode=display">(13): K_{ab}(h^t) = \delta_{ab}\frac{W^T Wh^t}{h^t_a}</script><p>则</p><script type="math/tex; mode=display">(14): G(h,h^t)=F(h^t)+(h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T K(h^t)(h-h^t)</script><p>为</p><script type="math/tex; mode=display">(15): F(h)=\frac{1}{2} \sum_i(v_i- \sum_a W_{ia} h_a)^2</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。为了证明此不等式，需要将</p><script type="math/tex; mode=display">(16): F(h) = F(h^t) + (h-h^t)^T \nabla F(h^t) + \frac{1}{2}(h-h^t)^T(W^TW)(h-h^t)</script><p>与公式 14 进行对比，发现 $G(h,h’) \geq F(h)$ 等价于</p><script type="math/tex; mode=display">(17): 0 \leq (h-h^t)^T[K(h^t) - W^TW](h-h^t)</script><p>为证明半正定情况，考虑矩阵：</p><script type="math/tex; mode=display">(18): M_{ab}(h^t)=h_a^t(K(h^t)-W^TW)_{ab}h_b^t</script><p>仅是$K-W^TW$的调整形式。因此，仅当 M 符合下列公式时，$K-W^TW$具有半正定性：</p><script type="math/tex; mode=display">(19):v^T Mv = \sum_{ab}v_a M_{ab} v_b \\(20):=\sum_{ab}h^t_a(W^TW)_{ab}h^t_bv_a^2-v_ah^t_a(W^TW)_{ab}h_b^tv_b \\(21):=\sum_{ab}(W^TW)_{ab}h_a^th_b^t[\frac{1}{2}v_a^2 + \frac{1}{2}v_b^2 - v_av_b] \\(22):=\frac{1}{2}\sum_{ab}(W^TW)_{ab}h_a^th_b^t(v_a-v_b)^2 \\(23):\geq 0</script><p>现在，我们可以证明定理 1 的收敛性。</p><p><strong>定理 1 证明</strong>：使用公式14的结果替换公式11中的$G(h,h^t)$，得到更新规则：</p><script type="math/tex; mode=display">(24): h^{t+1}=h^t - K(h^t)^{-1} \nabla F(h^t)</script><p>因为公式14为辅助函数，根据引理1，F 在更新规则中为非增。将上式完整的写下来，可以得到：</p><script type="math/tex; mode=display">(25): h^{t+1}_a= h^{t}_a \frac{(W^Tv)_a}{(W^TWh^t)_a}</script><p>反转引理 1 与引理 2 中 W 和 H 的角色，F 可以以类似的方法证明在 W 的更新规则下为非增。</p><p>接下来，我们为散度代价方程寻找辅助函数。</p><p><strong>引理 3</strong>：定义</p><script type="math/tex; mode=display">(26): G(h,h^t)=\sum_i(v_i \log{v_i} - v_i) + \sum_{ia} W_{ia}h_a \\(27):-\sum_{ia}v_i\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b} (\log{W_{ia} h_a - \log{\frac{W_{ia}h^t_a}{\sum_b W_{ib} h^t_b}}})</script><p>为</p><script type="math/tex; mode=display">(28): F(h)=\sum_i v_i \log(\frac{v_i}{\sum_a W_{ia} h_a})- v_i + \sum_a W_{ia} h_a</script><p>的辅助函数。</p><p><strong>证明</strong>：因为显然 $G(h,h)=F(h)$，因此只需证明 $G(h,h’) \geq F(h)$。我们通过对数函数的凸性来推导此不等式：</p><script type="math/tex; mode=display">(29): -\log \sum_a W_{ia} h_a \leq -\sum_a a_a \log \frac{ W_{ia} h_a}{a_a}</script><p>上式对所有的联合求合数 $a_a$ 均成立。设</p><script type="math/tex; mode=display">(30): a_a =\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b}</script><p>可以得到：</p><script type="math/tex; mode=display">(31): -\log \sum_a W_{ia} h_a \leq - \sum_a \frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} (\log W_{ia} h_a - \log\frac{ W_{ia} h_a}{\sum_b W_{ib} h_b} )</script><p>上面的不等式遵循 $G(h,h’) \geq F(h)$。</p><p>定理 2 的证明遵循引理 1 及其应用：</p><p><strong>定理 2 证明</strong>：要令 $G(h,h^t)$ 最小化，则需要将梯度设为 0 来求出 h：</p><script type="math/tex; mode=display">(32): \frac{dG(h,h^t)}{dh_a} = - \sum_i v_i \frac{ W_{ia} h_a^t}{\sum_b W_{ib} h_b^t} \frac{1}{h_a} + \sum_i W_{ia} = 0</script><p>因此，公式 11 采取的更新规则应当如下所示：</p><script type="math/tex; mode=display">(33): h_a^{t+1} = \frac{h_a^t}{\sum_b W_{kb}} \sum_i \frac{v_i}{\sum_b W_{ib}h_b^t} W_{ia}</script><p>因为 G 为辅助函数，公式 28 中的 F 在更新规则中为非增。用矩阵形式重写上述公式，发现与 公式 5 的更新规则等价。反转 W 和 H 的角色，可以以类似的方法证明 F 在 W 的更新规则下为非增。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们已经证明了在公式 4 与公式 5 中应用更新规则，可以找到问题 1 与问题 2 的局部最优解。借助定义合适的辅助函数证明了函数的收敛性。我们将把这些证明推广到更复杂的约束条件下去。更新规则在计算上非常容易实现，有望进行广泛的应用。</p><p>感谢贝尔实验室的支持，以及 Carlos Brody, Ken Clarkson, Corinna Cortes, Roland Freund, Linda Kaufman, Yann Le Cun, Sam Roweis, Larry Saul, Margaret Wright 的帮助与讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NIPS 2000 经典论文 非负矩阵分解算法 翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;非负矩阵分解（NM
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="algorithm" scheme="https://lsvih.com/tags/algorithm/"/>
    
      <category term="matrix" scheme="https://lsvih.com/tags/matrix/"/>
    
      <category term="gradient descent" scheme="https://lsvih.com/tags/gradient-descent/"/>
    
  </entry>
  
  <entry>
    <title>关键词规则生成</title>
    <link href="https://lsvih.com/2018/10/29/%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90/"/>
    <id>https://lsvih.com/2018/10/29/关键词规则生成/</id>
    <published>2018-10-29T03:25:00.000Z</published>
    <updated>2018-10-29T03:29:33.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>提取关键词将得到一系列的词库，要将这些词应用于文本筛查、分类则必须要对这些词进行拆分、组合，形成特定的规则，再应用这些规则对文本进行匹配，得到某文本所对应的模式。</p><p>要生成规则，即需要从系列关键词通过某些算法找出在不同样本文本下关键词的共有特征（或规律），再对多种特征（或规律）进行组合得到某种策略，最终通过策略对目标文本进行判定。因此关键词规则生成可以总结为以下几个主要步骤：</p><ol><li>关键词特征或规律查找</li><li>策略生成</li><li>策略优化与化简</li></ol><p>对于关键词特征与规律的查找，可以视为机器学习中的分类问题的反向过程。分类问题简要来说即给定标注样本，通过特征训练，得到一个可适用于同类样本的分类策略。常用的分类方法包括决策树、SVM、神经网络等方法。</p><p>决策树算法是常用的数据分类算法。决策树算法具有以下优点：</p><ol><li>决策树算法中学习简单的决策规则建立决策树模型的过程非常容易理解</li><li>决策树模型可以可视化，非常直观</li><li>应用范围广，可用于分类和回归，而且非常容易做多类别的分类</li><li>能够处理数值型和连续的样本特征</li></ol><p>由于它生成分类策略的可解释性，以及树状结构的可编辑性，在本步骤中可选用决策树算法作为样本分类策略。</p><p>下图为对某样本文本进行决策树（CART）生成的分类器策略可视化图像：</p><p><img src="https://lsvih.com/images/15407837052758.jpg" alt="-w889"></p><p>可以从图片中看出，决策树算法根据样本标注训练而成了对应的基于关键词的文本分类器。此分类器策略为清晰的树状结构，每个节点代表一个判断条件，每个树杈代表一个条件分支。为了得到在特定计算性能高、可解释性更好的策略，需要对其进行进一步的策略挖掘及精简。</p><p>由于决策树得到的策略为树状结构，因此在这种结构上的进一步策略挖掘可选用盲目搜索算法；又由于此模型为树状结构，最终分类落于叶子节点中，故采用深度优先搜索（DFS）对此树的路径进行检索，进一步优化策略。</p><p>在决策树得到的规则通过深度优先搜索之后，会得到一系列的组别，每个组别中包含各个关键词的“与”和“或”两种逻辑关系。在目标文本中使用时，即可通过这些逻辑关系的匹配找出对应的模式。</p><p>但由于决策树得到的策略叶子节点通常较多（如上图所示），通过深度优先搜索得到的策略也非常繁杂，最终生成得到的规则也会非常复杂，因此还可以进行进一步的策略化简。</p><p>在此步骤中，实质上是对多个逻辑代数运算及逻辑代数复合运算组合而成的逻辑函数进行化简。逻辑函数的化简方法一般有如下三种：</p><ol><li>公式化简法</li><li>卡诺图法</li><li>Q-M 法</li></ol><p>由于在此步骤实际应用时逻辑规则较为繁杂，且“与”—“或”逻辑对较多，比起公式化简法或卡诺图法，Q-M 算法在选取出可以覆盖逻辑规则真值的最小质蕴涵项时更能发挥优势。</p><p>最终，通过决策树算法生成树、对决策树进行深度优先搜索得到包含“与”、“或”的分类逻辑、对分类逻辑应用 Q-M 算法，最终得到了包含“与”、“或”、“非”三种逻辑关系的可解释性强、精简的规则。</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一个树结构，其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。运用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树算法是通过一系列规则对数据进行分类的过程。</p><p>决策树算法构造决策树来发现数据中蕴涵的分类规则．如何构造精度高、规模小的决策树是决策树算法的核心内容。决策树构造可以分两步进行：</p><p>第一步，决策树的生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集。</p><p>第二步，决策树的剪枝：决策树的剪枝是对上一阶段生成的决策树进行检验、校正和修下的过程，主要是用新的样本数据集（称为测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除。</p><p>在第一步决策树的生成中，需要确定树杈的分裂属性（即在多个自变量中，优先选择哪个自变量进行分叉）。而采用何种计算方式选择树杈决定了决策树算法的类型，典型的分裂属性的选择的方法有 ID3 算法、C4.5 算法、CART 算法三种，三种决策树算法选择树杈的方式是不一样的。</p><h3 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h3><p>ID3 算法是目前决策树算法中较有影响力的算法，于 1986 年由 Quinlan 提出。该算法只是一个启发式算法。ID3 算法的核心是判断测试哪个属性为最佳的分类属性。ID3 算法选择分裂后信息增益最大的属性进行分裂，以信息增益度量属性选择。ID3 算法中常用到的两个概念是熵和信息增益。</p><p>熵是刻画任意样本例集的纯度，如果目标属性具有 m 个不同的值，那么 D 相对于 m 这个状态的分类的熵定义为：</p><script type="math/tex; mode=display">\text{inf}\ o(D) = -\sum^m_{i=1}p_i \log_2 (P_i)</script><p>其中 Pi 表示 Pi 是 m 类别的比例。</p><p>一个属性的信息增益就是由于使用这个属性分割样例而导致的期望熵降低，更精确来讲，一个属性A相对样本例集合S的信息增益 Gain(S，A) 被定义为：</p><script type="math/tex; mode=display">gain(A) = info(D) - infoA(D)</script><p>A 对 D 划分的期望信息为：</p><script type="math/tex; mode=display">\text{inf}\ o_A(D) = \sum^v_{j=1} \frac{|D_j|}{|D|} \text{inf}\ o(D_j)</script><p>ID3 算法不足之处是只能处理离散型数据，信息增益的选择分裂属性的方式会偏向选择具有大量值得属性。</p><h3 id="C4-5-算法"><a href="#C4-5-算法" class="headerlink" title="C4.5 算法"></a>C4.5 算法</h3><p>ID3 算法在实际应用中存在一些问题，于是 Quilan 在保留 ID3 算法优点基础上提出了 C4.5 算法，C4.5 算法只是 ID3 算法的改进算法。C4.5 算法采用最大信息增益率的属性被选为分裂属性。C4.5 算法中用到了“分裂信息”这一概念，该概念可以表示为：</p><script type="math/tex; mode=display">split\_ \text{inf}\ o_A(D) = -\sum^v_{j=1} \frac{|D_j|}{|D|} \log_2\frac{|D_j|}{|D|}</script><p>信息增益率的定义是：</p><script type="math/tex; mode=display">gain\_ratio(A) = \frac{gainA}{split\_\text{inf}\ o(A)}</script><p>C4.5 算法是对 ID3 算法的一种改进，改进后可以计算连续型属性的值。对于连续型属性的值，只需将连续型变量由小到大递增排序，取相邻连个值的中点作为分裂点，然后按照离散型变量计算信息增益的方法计算信息增益，取其中最大的信息增益作为最终的分裂点。</p><p>C4.5 算法继承了 ID3 算法的优点，并在以下几方面对 ID3 算法进行了改进：</p><ul><li><p>用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；</p></li><li><p>在树构造过程中进行剪枝；</p></li><li><p>能够完成对连续属性的离散化处理；能够对不完整的数据进行处理。</p></li></ul><h3 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h3><p>CART 算法选择分裂属性的方式首先要计算不纯度，然后利用不纯度计算 Gini 指标，然后计算有效子集的不纯度和 Gini 指标，选择最小的 Gini 指标作为分裂属性。</p><script type="math/tex; mode=display">Gini(D) = 1 - \sum^n_{i=0}(\frac{Di}{D})^2</script><script type="math/tex; mode=display">Gini(D|A) = \sum^n_{i=0} \frac{Di}{D} Gini(D i)</script><p>由于 CART 算法在处理离散数据上具有优势，因此对于关键词规则的生成可选用此方法生成决策树。</p><h2 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h2><p>搜索算法可分为盲目搜索算法和启发式搜索算法两种，二者的区别在于：启发式搜索算法的每一步都试图向着目标状态方向进行搜索，而盲目搜索算法则是每一步按照固定的规则进行搜索，然后判断是否达到目标状态。相比之下，启发式搜索算法克服了盲目搜索算法的盲目性问题。</p><p>虽然启发式搜索算法可以解决盲目搜索算法的盲搜索问题，但是在实际问题求解中，缺少一些必要的信息来构建启发式搜索算法，此时采用盲目搜索算法仍然是解决问题的有效手段。盲目搜索算法有两种：一种按照广度优先展开搜索树的搜索算法，叫广度优先搜索法；另一种则是按照深度优先展开搜索的搜索算法，叫深度优先搜索法算法。</p><p>深度优先搜索算法是优先扩展尚未扩展的且具有最大深度的节点；广度优先搜索法是在扩展完第 K 层的节点后才扩展 K+1 层的节点。在此应用深度优先搜索算法。</p><p>假设初始状态是图中所有顶点未曾被访问，从图中某个顶点 i 出发，访问此顶点，然后依次从 i 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 i 有路径的顶点都被访问为止。若此时图中尚有顶点未被访问，则另选图中未曾访问的顶点为起始点，重复上述过程，直至图中所有顶点都被访问为止。在节点遍历过程中，应该注意节点的回溯搜索以及避免节点被重复搜索。</p><p>在搜索过程中，如何避免被搜过的节点不被重复搜索以及节点的回溯是主要难点。根据关联矩阵以及深度优先搜索算法，从节点 i 搜索出节点 j，如果节点 j 已经被搜索过，那么修改关联矩阵中对应节点 i 和节点 j 的元素为 0，并返回节点 i 重新搜索与之相联的另一节点。当节点 j 是该条树枝的最后一个节点时，修改关联矩阵中相应的元素，并且返回节点 i 重新搜索与之相连的另一树枝。依此类推，直至遍历所有节点，也就是关联矩阵的所有元素都变为 0 时，停止搜索。在遍历各节点的同时，根据节点的先后顺序以及树枝集合，合理地安排各节点坐标。其搜索过程逻辑如下图所示：</p><p><img src="https://lsvih.com/images/15407837517781.jpg" alt="-w241"></p><h2 id="Q-M-算法"><a href="#Q-M-算法" class="headerlink" title="Q-M 算法"></a>Q-M 算法</h2><p>在得到只包含“与”、“或”的逻辑函数之后，可对逻辑进行更进一步的简化与合并，并加上“非”逻辑来使得逻辑函数更具解释性。</p><p>下图为一个简单逻辑函数的卡诺图，101 项被覆盖了 3 次，明显可对函数进行化简。</p><p><img src="https://lsvih.com/images/15407837648773.jpg" alt="-w386"></p><p>Q-M 算法是由 Quine 和 Mccluskey 提出的一种系统列表化简法。这种化简方法和卡诺图化简法的基本思想大致相同, 是通过找出函数 F 的全部质蕴涵项、必要质蕴涵项以及最简质蕴涵项集来求得最简表达式。</p><p>下面为蕴含项与质蕴涵项的定义：</p><p>蕴涵项：在函数的“与”—“或”表达式中，每个“与”项被称为该函数的蕴涵项。显然在函数卡诺图中，任何一个  1 方格所对应的最小项或者卡诺圈中的 $2^n$ 个 1 方格所对应的“与”项都是函数的蕴涵项。</p><p>质蕴涵项：若函数的一个蕴涵项不是该函数中其它蕴涵项的子集，则此蕴涵项称为质蕴涵项，简称为质项。显然在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈不可能被其它更大的卡诺圈包含，那么该卡诺圈所对应的“与”项为质蕴涵项。</p><p>必要质蕴涵项：若函数的一个质蕴涵项所包含的某一个最小项不被函数的其它任何质蕴涵项包含，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项。在函数卡诺图中，若某个卡诺圈包含了不可能被任何其它卡诺圈包含的 1 方格，那么该卡诺圈所对应的“与”项为必要质蕴涵项。</p><p>一般的化简步骤是：  </p><p>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每—个最小项。</p><p>第二步：找出函数的全部质蕴涵项。先将 n 个变量函数中的相邻最小项合并，消去相异的—个变量，得到 (n-1) 个变量的“与”项，再将相邻的 (n-1) 个变量的“与”项合并，消去相异的变量，得到 (n-2) 个变量的“与”项。依此类推，直到不能再合并为止。所得到的全部不能再合并的“与”项（包括不能合并的最小项），即所要求的全部质蕴涵项。</p><p>第三步：找出函数的必要质蕴涵项。 </p><p>第四步：找出函数的最小覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;提取关键词将得到一系列的词库，要将这些词应用于文本筛查、分类则必须要对这些词进行拆分、组合，形成特定的规则，再应用这些规则对文本进行匹配，得
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://lsvih.com/categories/Algorithm/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Python 的多线程与多进程</title>
    <link href="https://lsvih.com/2018/08/28/Python-%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://lsvih.com/2018/08/28/Python-的多线程与多进程/</id>
    <published>2018-08-28T07:04:00.000Z</published>
    <updated>2018-10-28T16:12:59.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初学者的并行编程指南"><a href="#初学者的并行编程指南" class="headerlink" title="初学者的并行编程指南"></a>初学者的并行编程指南</h2><p><img src="https://lsvih.com/images/pasted-322.png" alt="upload successful"></p><p>在参加 Kaggle 的 <a href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space" target="_blank" rel="noopener">Understanding the Amazon from Space</a> 比赛时，我试图对自己代码的各个部分进行加速。速度在 Kaggle 比赛中至关重要。高排名常常需要尝试数百种模型结构与超参组合，能在一个持续一分钟的 epoch 中省出 10 秒都是一个巨大的胜利。</p><p>让我吃惊的是，数据处理是最大的瓶颈。我用了 Numpy 的矩阵旋转、矩阵翻转、缩放及裁切等操作，在 CPU 上进行运算。Numpy 和 Pytorch 的 DataLoader 在某些情况中使用了并行处理。我同时会运行 3 到 5 个实验，每个实验都各自进行数据处理。但这种处理方式看起来效率不高，我希望知道我是否能用并行处理来加快所有实验的运行速度。</p><a id="more"></a><h3 id="什么是并行处理？"><a href="#什么是并行处理？" class="headerlink" title="什么是并行处理？"></a>什么是并行处理？</h3><p>简单来说就是在同一时刻做两件事情，也可以是在不同的 CPU 上分别运行代码，或者说当程序等待外部资源（文件加载、API 调用等）时把“浪费”的 CPU 周期充分利用起来提高效率。</p><p>下面的例子是一个“正常”的程序。它会使用单线程，依次进行下载一个 URL 列表的内容。</p><p><img src="https://lsvih.com/images/pasted-323.png" alt="upload successful"></p><p>下面是一个同样的程序，不过使用了 2 个线程。它把 URL 列表分给不同的线程，处理速度几乎翻倍。</p><p><img src="https://lsvih.com/images/pasted-324.png" alt="upload successful"></p><p>如果你对如何绘制以上图表感到好奇，可以参考<a href="https://github.com/bfortuner/ml-study/blob/master/multitasking_python.ipynb" target="_blank" rel="noopener">源码</a>，下面也简单介绍一下：</p><ol><li>在你函数内部加上一个计时器，并返回函数执行的起始与结束时间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URLS = [url1, url2, url3, ...]</span><br><span class="line">def download(url, base):</span><br><span class="line">    start = time.time() - base</span><br><span class="line">    resp = urlopen(url)</span><br><span class="line">    stop = time.time() - base</span><br><span class="line">    return start,stop</span><br></pre></td></tr></table></figure><ol><li>单线程程序的可视化如下：多次执行你的函数，并将多个开始结束的时间存储下来</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = [download(url, 1) for url in URLS]</span><br></pre></td></tr></table></figure><ol><li>将 [start, stop] 的结果数组进行转置，绘制柱状图</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def visualize_runtimes(results):</span><br><span class="line">    start,stop = np.array(results).T</span><br><span class="line">    plt.barh(range(len(start)), stop-start, left=start)</span><br><span class="line">    plt.grid(axis=’x’)</span><br><span class="line">    plt.ylabel(&quot;Tasks&quot;)</span><br><span class="line">    plt.xlabel(&quot;Seconds&quot;)</span><br></pre></td></tr></table></figure><p>多线程的图表生成方式与此类似。Python 的并发库一样可以返回结果数组。</p><h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a><strong>进程 vs 线程</strong></h3><p>一个<strong>进程</strong>就是一个程序的实例（比如 Jupyter notebook 或 Python 解释器）。进程启动<strong>线程</strong>（子进程）来处理一些子任务（比如按键、加载 HTML 页面、保存文件等）。线程存活于进程内部，线程间共享相同的内存空间。</p><p><strong>举例：Microsoft Word</strong><br>当你打开 Word 时，你其实就是创建了一个进程。当你开始打字时，进程启动了一些线程：一个线程专门用于获取键盘输入，一个线程用于显示文本，一个线程用于自动保存文件，还有一个线程用于拼写检查。在启动这些线程之后，Word 就能更好的利用空闲的 CPU 时间（等待键盘输入或文件加载的时间）让你有更高的工作效率。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h4><ul><li>由操作系统创建，以运行程序</li><li>一个进程可以包括多个线程</li><li>两个进程可以在 Python 程序中同时执行代码</li><li>启动与终止进程需要花费更多的时间，因此用进程比用线程的开销更大</li><li>由于进程不共享内存空间，因此进程间交换信息比线程间交换信息要慢很多。在 Python 中，用序列化数据结构（如数组）的方法进行信息交换会花费 IO 处理级别的时间。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h4><ul><li>线程是在进程内部的类似迷你进程的东西</li><li>不同的线程共享同样的内存空间，可以高效地读写相同的变量</li><li>两个线程不能在同一个 Python 程序中执行代码（有解决这个问题的方法<code>*</code>）</li></ul><h4 id="CPU-vs-核"><a href="#CPU-vs-核" class="headerlink" title="CPU vs 核"></a>CPU vs 核</h4><p><strong>CPU</strong>，或者说处理器，管理着计算机最基本的运算工作。CPU 有一个或着多个<strong>核</strong>，可以让 CPU 同时执行代码。</p><p>如果只有一个核，那么对 CPU 密集型任务（比如循环、运算等）不会有速度的提升。操作系统需要在很小的时间片在不同的任务间来回切换调度。因此，做一些很琐碎的操作（比如下载一些图片）时，多任务处理反而会降低处理性能。这个现象的原因是在启动与维护多个任务时也有性能的开销。</p><h4 id="Python-的-GIL-锁问题"><a href="#Python-的-GIL-锁问题" class="headerlink" title="Python 的 GIL 锁问题"></a><strong>Python 的 GIL 锁问题</strong></h4><p>CPython（python 的标准实现）有一个叫做 <a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">GIL</a>（全局解释锁）的东西，会阻止在程序中同时执行两个线程。一些人非常不喜欢它，但也有一些人喜欢它。目前有一些解决它的方法，不过 Numpy 之类的库大都是通过执行外部 C 语言代码来绕过这种限制。</p><h4 id="何时使用线程，何时使用进程？"><a href="#何时使用线程，何时使用进程？" class="headerlink" title="何时使用线程，何时使用进程？"></a><strong>何时使用线程，何时使用进程？</strong></h4><ul><li>得益于多核与不存在 GIL，<strong>多进程</strong>可以加速 CPU 密集型的 Python 程序。</li><li><strong>多线程</strong>可以很好的处理 IO 任务或涉及外部系统的任务，因为线程可以将不同的工作高效地结合起来。而进程需要对结果进行序列化才能汇聚多个结果，这需要消耗额外的时间。</li><li>由于 GIL 的存在，<strong>多线程</strong>对 CPU 密集的 Python 程序没有什么帮助。</li></ul><p><code>*</code>对于点积等某些运算，Numpy 绕过了 Python 的 GIL 锁，能够并行执行代码。</p><h3 id="并行处理示例"><a href="#并行处理示例" class="headerlink" title="并行处理示例"></a>并行处理示例</h3><p>Python 的 <a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener">concurrent.futures 库</a>用起来轻松愉快。你只需要简单的将函数、待处理的对象列表和并发的数量传给它即可。在下面几节中，我会以几种实验来演示何时使用线程何时使用进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def multithreading(func, args, </span><br><span class="line">                   workers):</span><br><span class="line">    with ThreadPoolExecutor(workers) as ex:</span><br><span class="line">        res = ex.map(func, args)</span><br><span class="line">    return list(res)</span><br><span class="line"></span><br><span class="line">def multiprocessing(func, args, </span><br><span class="line">                    workers):</span><br><span class="line">    with ProcessPoolExecutor(work) as ex:</span><br><span class="line">        res = ex.map(func, args)</span><br><span class="line">    return list(res)</span><br></pre></td></tr></table></figure><h4 id="API-调用"><a href="#API-调用" class="headerlink" title="API 调用"></a><strong>API 调用</strong></h4><p>对于 API 调用，多线程明显比串行处理与多进程速度要快很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def download(url):</span><br><span class="line">    try:</span><br><span class="line">        resp = urlopen(url)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print (&apos;ERROR: %s&apos; % e)</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/pasted-325.png" alt="upload successful"></p><p><strong>2 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-326.png" alt="upload successful"></p><p><strong>4 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-327.png" alt="upload successful"></p><p><strong>2 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-328.png" alt="upload successful"></p><p><strong>4 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-329.png" alt="upload successful"></p><h4 id="IO-密集型任务"><a href="#IO-密集型任务" class="headerlink" title="IO 密集型任务"></a><strong>IO 密集型任务</strong></h4><p>我传入了一个巨大的文本，以观测线程与进程的写入性能。线程效果较好，但多进程也让速度有所提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def io_heavy(text):</span><br><span class="line">    f = open(&apos;output.txt&apos;, &apos;wt&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    f.write(text)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p><strong>串行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%timeit -n 1 [io_heavy(TEXT,1) for i in range(N)]</span><br><span class="line">&gt;&gt; 1 loop, best of 3: 1.37 s per loop</span><br></pre></td></tr></table></figure><p><strong>4 个线程</strong></p><p><img src="https://lsvih.com/images/pasted-330.png" alt="upload successful"></p><p><strong>4 个进程</strong></p><p><img src="https://lsvih.com/images/pasted-331.png" alt="upload successful"></p><h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p>由于没有 GIL，可以在多核上同时执行代码，多进程理所当然的胜出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def cpu_heavy(n):</span><br><span class="line">    count = 0</span><br><span class="line">    for i in range(n):</span><br><span class="line">        count += i</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/pasted-332.png" alt="upload successful"></p><p><strong>串行：</strong> 4.2 秒<br><strong>4 个线程：</strong> 6.5 秒<br><strong>4 个进程：</strong> 1.9 秒</p><h4 id="Numpy-中的点积"><a href="#Numpy-中的点积" class="headerlink" title="Numpy 中的点积"></a>Numpy 中的点积</h4><p>不出所料，无论是用多线程还是多进程都不会对此代码有什么帮助。Numpy 在幕后执行外部的 C 语言代码，绕开了 GIL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def dot_product(i, base):</span><br><span class="line">    start = time.time() - base</span><br><span class="line">    res = np.dot(a,b)</span><br><span class="line">    stop = time.time() - base</span><br><span class="line">    return start,stop</span><br></pre></td></tr></table></figure><p><strong>串行：</strong> 2.8 秒<br><strong>2 个线程：</strong> 3.4 秒<br><strong>2 个进程：</strong> 3.3 秒</p><p>以上实验的 Notebook 请<a href="https://github.com/bfortuner/ml-study/blob/master/multitasking_python.ipynb" target="_blank" rel="noopener">参考此处</a>，你可以自己来复现这些实验。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><p>以下是我在探索这个主题时的一些参考文章。特别推荐 Nathan Grigg 的<a href="https://nathangrigg.com/2015/04/python-threading-vs-processes" target="_blank" rel="noopener">这篇博客</a>，给了我可视化方法的灵感。</p><ul><li><p><a href="http://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python" target="_blank" rel="noopener"><strong>Multiprocessing vs Threading Python</strong>: I am trying to understand the advantages of multiprocessing over threading. I know that multiprocessing gets around the…</a></p></li><li><p><a href="http://stackoverflow.com/questions/5260068/multithreaded-blas-in-python-numpy" target="_blank" rel="noopener"><strong>multithreaded blas in python/numpy</strong>: I re-run the the benchmark on our new HPC. Both the hardware as well as the software stack changed from the setup in…</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank" rel="noopener"><strong>Amdahl’s law - Wikipedia</strong>: In computer architecture, Amdahl’s law (or Amdahl’s argument) is a formula which gives the theoretical speedup in…</a></p></li><li><p><a href="http://stackoverflow.com/questions/8463741/how-linux-handles-threads-and-process-scheduling" target="_blank" rel="noopener"><strong>How Linux handles threads and process scheduling</strong>: The Linux kernel scheduler is actually scheduling tasks, and these are either threads or (single-threaded) processes…</a></p></li><li><p><a href="http://stackoverflow.com/questions/1718465/optimal-number-of-threads-per-core/10670440#10670440" target="_blank" rel="noopener"><strong>Optimal number of threads per core</strong>: Let’s say I have a 4-core CPU, and I want to run some process in the minimum amount of time. The process is ideally…</a></p></li><li><p><a href="http://stackoverflow.com/questions/481970/how-many-threads-is-too-many" target="_blank" rel="noopener"><strong>How many threads is too many?</strong>: I am writing a server, and I branch each action of into a thread when the request is incoming. I do this because almost…</a></p></li></ul><blockquote><p>juejin:<a href="https://juejin.im/post/5b84f3086fb9a01a1a27cedb#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5b84f3086fb9a01a1a27cedb#heading-14</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初学者的并行编程指南&quot;&gt;&lt;a href=&quot;#初学者的并行编程指南&quot; class=&quot;headerlink&quot; title=&quot;初学者的并行编程指南&quot;&gt;&lt;/a&gt;初学者的并行编程指南&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/pasted-322.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;在参加 Kaggle 的 &lt;a href=&quot;https://www.kaggle.com/c/planet-understanding-the-amazon-from-space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding the Amazon from Space&lt;/a&gt; 比赛时，我试图对自己代码的各个部分进行加速。速度在 Kaggle 比赛中至关重要。高排名常常需要尝试数百种模型结构与超参组合，能在一个持续一分钟的 epoch 中省出 10 秒都是一个巨大的胜利。&lt;/p&gt;
&lt;p&gt;让我吃惊的是，数据处理是最大的瓶颈。我用了 Numpy 的矩阵旋转、矩阵翻转、缩放及裁切等操作，在 CPU 上进行运算。Numpy 和 Pytorch 的 DataLoader 在某些情况中使用了并行处理。我同时会运行 3 到 5 个实验，每个实验都各自进行数据处理。但这种处理方式看起来效率不高，我希望知道我是否能用并行处理来加快所有实验的运行速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Back End" scheme="https://lsvih.com/tags/Back-End/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="python" scheme="https://lsvih.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 PhpFastCache 提升网站性能</title>
    <link href="https://lsvih.com/2018/07/23/%E4%BD%BF%E7%94%A8-PhpFastCache-%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/"/>
    <id>https://lsvih.com/2018/07/23/使用-PhpFastCache-提升网站性能/</id>
    <published>2018-07-22T18:48:00.000Z</published>
    <updated>2018-10-28T16:13:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>本文将与你一同探索 PhpFastCache 库，来为你的 PHP 应用实现缓存功能。通过缓存功能，能够提升网站的整体性能与页面加载速度。</p><h2 id="什么是-PhpFastCache？"><a href="#什么是-PhpFastCache？" class="headerlink" title="什么是 PhpFastCache？"></a>什么是 PhpFastCache？</h2><p>PhpFastCache 是一个能让你轻松在 PHP 应用中实现缓存功能的库。它的功能强大，且简单易用，提供了一些 API 以无痛实现缓存策略。</p><p>PhpFastCache 不是一个纯粹的传统文件系统式缓存。它支持各种各样的文件适配器（Files Adapter），可以让你选择 Memcache、Redis、MongoDB、CouchDB 等高性能的后端服务。</p><p>让我们先总览一遍最流行的适配器：</p><ul><li>文件系统</li><li>Memcache、Redis 和 APC</li><li>CouchDB 和 MongoDB</li><li>Zend Disk Cache 和 Zend Memory Cache</li></ul><p>如果你用的文件适配器不在上面的列表中，也可以简单地开发一个自定义驱动，插入到系统中，同样也能高效地运行。</p><p>除了基本功能外，PhpFastCache 还提供了事件机制，可以让你对预定义好的事件进行响应。例如，当某个事物从缓存中被删除时，你可以接收到这个事件，并去刷新或删除相关的数据。</p><p>在下面的章节中，我们将通过一些示例来了解如何安装及配置 PhpFastCache。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在本节中，我们将了解如何安装及配置 PhpFastCache。下面是几种将它集成进项目的方法。</p><p>如果你嫌麻烦，仅准备下载这个库的 <strong>.zip</strong> 或者 <strong>.tar.gz</strong> 文件，可以去<a href="https://www.phpfastcache.com/" target="_blank" rel="noopener">官方网站</a>直接下载。</p><p>或者你也可以用 Composer 包的方式来安装它。这种方式更好，因为在之后的维护和升级时会更方便。如果你还没有安装 Composer，需要先去安装它。</p><p>当你安装好 Composer 之后，可以用以下命令下载 PhpFastCache：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$composer</span> require phpfastcache/phpfastcache</span><br></pre></td></tr></table></figure><p>命令完成后，你会得到一个 vendor 目录，在此目录中包括了全部 PhpFastCache 所需的文件。另外，如果你缺失了 PhpFastCache 依赖的库或插件，Composer 会提醒你先去安装依赖。</p><p>你需要找到 <code>composer.json</code> 文件，它类似于下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"phpfastcache/phpfastcache"</span>: <span class="string">"^6.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你通过什么方式来安装的 PhpFastCache，都要在应用中 include <strong>autoload.php</strong> 文件。</p><p>如果你用的是基于 Composer 的工作流，<strong>autoload.php</strong> 文件会在 <strong>vendor</strong> 目录中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'&#123;YOUR_APP_PATH&#125;/vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure><p>另外，如果你是直接下载的 <strong>.zip</strong> 和 <strong>.tar.gz</strong>，<strong>autoload.php</strong> 的路径会在 <strong>src/autoload.php</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'&#123;YOUR_APP_PATH&#125;/src/autoload.php'</span>;</span><br></pre></td></tr></table></figure><p>只要完成上面的操作，就能开始进行缓存，享受 PhpFastCache 带来的好处了。在下一章节中，我们将以一个简单的示例来介绍如何在你的应用中使用 PhpFastCache。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>前面我提到过，PhpFastCache 支持多种文件适配器进行缓存。在本节中，我会以文件系统和 Redis 这两种文件适配器为例进行介绍。</p><h3 id="使用文件适配器进行缓存"><a href="#使用文件适配器进行缓存" class="headerlink" title="使用文件适配器进行缓存"></a>使用文件适配器进行缓存</h3><p>创建 <strong>file_cache_example.php</strong> 文件并写入下面的代码。在此我假设你使用的是 Composer workflow，因此 <strong>vendor</strong> 目录会与 <strong>file_cache_example.php</strong> 文件同级。如果你是手动安装的 PhpFastCache，需要根据实际情况修改文件结构。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with "file system" adapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for "files" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"path"</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">"/cache"</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objFilesCache = CacheManager::getInstance(<span class="string">'files'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objFilesCache-&gt;getItem($key);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objFilesCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们一块一块地来理解代码。首先看到的是将 <strong>autoload.php</strong> 文件引入，然后导入要用到的 namespace：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br></pre></td></tr></table></figure><p>当你使用文件缓存的时候，最好提供一个目录路径来存放缓存系统生成的文件。下面的代码就是做的这件事：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for "files" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"path"</span> =&gt; <span class="keyword">__DIR__</span> . <span class="string">"/cache"</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>当然，你需要确保 <strong>cache</strong> 目录存在且 web server 有写入权限。</p><p>接下来，我们将缓存对象实例化，用 <strong>welcome_message</strong> 加载对应的缓存对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objFilesCache = CacheManager::getInstance(<span class="string">'files'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objFilesCache-&gt;getItem($key);</span><br></pre></td></tr></table></figure><p>如果缓存中不存在此对象，就将它以 60s 过期时间加入缓存，并从缓存中读取与展示它。如果它存在于缓存中，则直接获取：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objFilesCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常容易上手对吧！你可以试着自己去运行一下这个程序来查看结果。</p><p>当你第一次运行这个程序时，应该会看到以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Not in cache yet, we set it in cache and try to get it from cache!</span><br><span class="line">The value of welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure><p>之后再运行的时候，输出会是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Already in cache!</span><br><span class="line">The value of welcome_message: This website uses PhpFastCache!</span><br></pre></td></tr></table></figure><p>现在就能随手实现文件系统缓存了。在下一章节中，我们将模仿这个例子来使用 Redis Adapter 实现缓存。</p><h3 id="使用-Redis-Adapter-进行缓存"><a href="#使用-Redis-Adapter-进行缓存" class="headerlink" title="使用 Redis Adapter 进行缓存"></a>使用 Redis Adapter 进行缓存</h3><p>假定你在阅读本节前已经安装好了 Redis 服务，并让它运行在 6379 默认端口上。</p><p>下面进行配置。创建 <strong>redis_cache_example.php</strong> 文件并写入以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis_cache_example.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Demonstrates usage of phpFastCache with "redis" adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Make sure php-redis extension is installed along with Redis server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Include composer autoloader</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">phpFastCache</span>\<span class="title">CacheManager</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Init default configuration for "redis" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"host"</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  <span class="string">"port"</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Get instance of files cache</span></span><br><span class="line">$objRedisCache = CacheManager::getInstance(<span class="string">'redis'</span>);</span><br><span class="line"> </span><br><span class="line">$key = <span class="string">"welcome_message"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Try to fetch cached item with "welcome_message" key</span></span><br><span class="line">$CachedString = $objRedisCache-&gt;getItem($key);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_null($CachedString-&gt;get()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry doesn't exist</span></span><br><span class="line">    $numberOfSeconds = <span class="number">60</span>;</span><br><span class="line">    $CachedString-&gt;set(<span class="string">"This website uses PhpFastCache!"</span>)-&gt;expiresAfter($numberOfSeconds);</span><br><span class="line">    $objRedisCache-&gt;save($CachedString);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Not in cache yet, we set it in cache and try to get it from cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The cached entry exists</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Already in cache!&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value of welcome_message:"</span> . $CachedString-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，除了初始化 Redis 适配器的配置一段之外，这个文件与之前基本一样。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init default configuration for "redis" adapter</span></span><br><span class="line">CacheManager::setDefaultConfig([</span><br><span class="line">  <span class="string">"host"</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  <span class="string">"port"</span> =&gt; <span class="number">6379</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>当然如果你要在非本机运行 Redis 服务，需要根据需求修改 host 与 port 的设置。</p><p>运行 <strong>redis_cache_example.php</strong> 文件来查看它的工作原理。你也可以在 Redis CLI 中查看输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;welcome_message&quot;</span><br></pre></td></tr></table></figure><p>以上就是使用 Redis 适配器的全部内容。你可以去多试试其它不同的适配器和配置！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了 PhpFastCache 这个 PHP 中非常热门的库。在文章前半部分，我们讨论了它的基本知识以及安装和配置。在文章后半部分，我们通过几个例子来详细演示了前面提到的概念。</p><p>希望你喜欢这篇文章，并将 PhpFastCache 集成到你即将开发的项目中。随时欢迎提问和讨论！</p><blockquote><p>掘金：<a href="https://juejin.im/post/5b54d01be51d4517c5649965" target="_blank" rel="noopener">https://juejin.im/post/5b54d01be51d4517c5649965</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将与你一同探索 PhpFastCache 库，来为你的 PHP 应用实现缓存功能。通过缓存功能，能够提升网站的整体性能与页面加载速度。&lt;/p&gt;
&lt;h2 id=&quot;什么是-PhpFastCache？&quot;&gt;&lt;a href=&quot;#什么是-PhpFastCache？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="PHP" scheme="https://lsvih.com/tags/PHP/"/>
    
      <category term="Cache" scheme="https://lsvih.com/tags/Cache/"/>
    
      <category term="Backend" scheme="https://lsvih.com/tags/Backend/"/>
    
  </entry>
  
  <entry>
    <title>使用多重赋值与元组解包提升 Python 代码的可读性</title>
    <link href="https://lsvih.com/2018/07/04/%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%85%83%E7%BB%84%E8%A7%A3%E5%8C%85%E6%8F%90%E5%8D%87-Python-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    <id>https://lsvih.com/2018/07/04/使用多重赋值与元组解包提升-Python-代码的可读性/</id>
    <published>2018-07-04T02:16:00.000Z</published>
    <updated>2018-10-28T16:13:09.827Z</updated>
    
    <content type="html"><![CDATA[<p>无论是教导新手还是资深 Python 程序员，我都发现 <strong>很多 Python 程序员没有充分利用多重赋值这一特性</strong>。</p><p>多重赋值（也经常被称为元组解包或者可迭代对象解包）能让你在一行代码内同时对多个变量进行赋值。这种特性在学习时看起来很简单，但在真正需要使用时再去回想它可能会比较麻烦。</p><p>在本文中，将介绍什么是多重赋值，举一些常用的多重赋值的样例，并了解一些较少用、常被忽视的多重赋值用法。</p><p>请注意在本文中会用到 <a href="https://cito.github.io/blog/f-strings/" target="_blank" rel="noopener">f-strings</a> 这种 Python 3.6 以上版本才有的特性，如果你的 Python 版本较老，可以使用字符串的 <code>format</code> 方法来代替这种特性。</p><h2 id="多重赋值的实现原理"><a href="#多重赋值的实现原理" class="headerlink" title="多重赋值的实现原理"></a>多重赋值的实现原理</h2><p>在本文中，我将使用“多重赋值”、“元组解包”、“迭代对象解包”等不同的词，但他们其实表示的是同一个东西。</p><p>Python 的多重赋值如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = 10, 20</span><br></pre></td></tr></table></figure><p>在这儿我们将 <code>x</code> 设为了 <code>10</code>，<code>y</code> 设为了 <code>20</code>。</p><p>从更底层的角度看，我们其实是创建了一个 <code>10, 20</code> 的元组，然后遍历这个元组，将拿到的两个数字按照顺序分别赋给 <code>x</code> 与 <code>y</code>。</p><p>写成下面这种语法应该更容易理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (x, y) = (10, 20)</span><br></pre></td></tr></table></figure><p>在 Python 中，元组周围的括号是可以忽略的，因此在“多重赋值”（写成上面这种元组形式的语法）时也可以省去。下面几行代码都是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = 10, 20</span><br><span class="line">&gt;&gt;&gt; x, y = (10, 20)</span><br><span class="line">&gt;&gt;&gt; (x, y) = 10, 20</span><br><span class="line">&gt;&gt;&gt; (x, y) = (10, 20)</span><br></pre></td></tr></table></figure><p>多重赋值常被直接称为“元组解包”，因为它在大多数情况下都是用于元组。但其实我们可以用除了元组之外的任何可迭代对象进行多重赋值。下面是使用列表（list）的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = [10, 20]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>下面是使用字符串（string）的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = &apos;hi&apos;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&apos;h&apos;</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&apos;i&apos;</span><br></pre></td></tr></table></figure><p>任何可以用于循环的东西都能和元组解包、多重赋值一样被“解开”。</p><p>下面是另一个可以证明多重赋值能用于任何数量、任何变量（甚至是我们自己创建的对象）的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; point = 10, 20, 30</span><br><span class="line">&gt;&gt;&gt; x, y, z = point</span><br><span class="line">&gt;&gt;&gt; print(x, y, z)</span><br><span class="line">10 20 30</span><br><span class="line">&gt;&gt;&gt; (x, y, z) = (z, y, x)</span><br><span class="line">&gt;&gt;&gt; print(x, y, z)</span><br><span class="line">30 20 10</span><br></pre></td></tr></table></figure><p>请注意，在上面例子中的最后一行我们仅交换了变量的名称。多重赋值可以让我们轻松地实现这种情形。</p><p>下面我们将讨论如何使用多重赋值。</p><h2 id="在-for-循环中解包"><a href="#在-for-循环中解包" class="headerlink" title="在 for 循环中解包"></a>在 for 循环中解包</h2><p>你会经常在 <code>for</code> 循环中看到多重赋值。下面举例说明：</p><p>先创建一个字典（dict）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person_dictionary = &#123;&apos;name&apos;: &quot;Trey&quot;, &apos;company&apos;: &quot;Truthful Technology LLC&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面这种循环遍历字典的方法比较少见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in person_dictionary.items():</span><br><span class="line">    print(f&quot;Key &#123;item[0]&#125; has value &#123;item[1]&#125;&quot;)</span><br></pre></td></tr></table></figure><p>但你会经常看到 Python 程序员通过多重赋值来这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for key, value in person_dictionary.items():</span><br><span class="line">    print(f&quot;Key &#123;key&#125; has value &#123;value&#125;&quot;)</span><br></pre></td></tr></table></figure><p>当你在 for 循环中写 <code>for X in Y</code> 时，其实是告诉 Python 在循环的每次遍历时都对 <code>X</code> 做一次赋值。与用 <code>=</code> 符号赋值一样，这儿也可以使用多重赋值。</p><p>这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for key, value in person_dictionary.items():</span><br><span class="line">    print(f&quot;Key &#123;key&#125; has value &#123;value&#125;&quot;)</span><br></pre></td></tr></table></figure><p>在本质上与这种写法是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in person_dictionary.items():</span><br><span class="line">    key, value = item</span><br><span class="line">    print(f&quot;Key &#123;key&#125; has value &#123;value&#125;&quot;)</span><br></pre></td></tr></table></figure><p>与前一个例子相比，我们其实就是去掉了一个没有必要的额外赋值。</p><p>因此，多重赋值在用于将字典元素解包为键值对时十分有用。此外，它还在其它地方也可以使用：</p><p>在内置函数 <code>enumerate</code> 的值拆分成对时，也是多重赋值的一个很有用的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, line in enumerate(my_file):</span><br><span class="line">    print(f&quot;Line &#123;i&#125;: &#123;line&#125;&quot;)</span><br></pre></td></tr></table></figure><p>还有 <code>zip</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for color, ratio in zip(colors, ratios):</span><br><span class="line">    print(f&quot;It&apos;s &#123;ratio*100&#125;% &#123;color&#125;.&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (product, price, color) in zip(products, prices, colors):</span><br><span class="line">    print(f&quot;&#123;product&#125; is &#123;color&#125; and costs $&#123;price:.2f&#125;&quot;)</span><br></pre></td></tr></table></figure><p>如果你还对 <code>enumerate</code> 和 <code>zip</code> 不熟悉，请参阅作者之前的文章 <a href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/" target="_blank" rel="noopener">looping with indexes in Python</a>。</p><p>有些 Python 新手经常在 <code>for</code> 循环中看到多重赋值，然后就认为它只能与循环一起使用。但其实，多重赋值不仅可以用在循环赋值时，还可以用在其它任何需要赋值的地方。</p><h2 id="替代硬编码索引"><a href="#替代硬编码索引" class="headerlink" title="替代硬编码索引"></a>替代硬编码索引</h2><p>很少有人在代码中对索引进行硬编码（比如 <code>point[0]</code>、<code>items[1]</code>、<code>vals[-1]</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f&quot;The first item is &#123;items[0]&#125; and the last item is &#123;items[-1]&#125;&quot;)</span><br></pre></td></tr></table></figure><p>当你在 Python 代码中看到有硬编码索引时，一般都可以设法<strong>使用多重赋值来让你的代码更具可读性</strong>。</p><p>下面是一些使用了硬编码索引的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reformat_date</span><span class="params">(mdy_date_string)</span>:</span></span><br><span class="line">    <span class="string">"""Reformat MM/DD/YYYY string into YYYY-MM-DD string."""</span></span><br><span class="line">    date = mdy_date_string.split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;date[<span class="number">2</span>]&#125;</span>-<span class="subst">&#123;date[<span class="number">0</span>]&#125;</span>-<span class="subst">&#123;date[<span class="number">1</span>]&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>我们可以通过多重赋值，分别对月、天、年三个变量进行赋值，让代码更具可读性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reformat_date</span><span class="params">(mdy_date_string)</span>:</span></span><br><span class="line">    <span class="string">"""Reformat MM/DD/YYYY string into YYYY-MM-DD string."""</span></span><br><span class="line">    month, day, year = mdy_date_string.split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;year&#125;</span>-<span class="subst">&#123;month&#125;</span>-<span class="subst">&#123;day&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>因此当你准备对索引进行硬编码时，请停下来想一想是不是应该用多重赋值来改善代码的可读性。</p><h2 id="多重赋值是十分严格的"><a href="#多重赋值是十分严格的" class="headerlink" title="多重赋值是十分严格的"></a>多重赋值是十分严格的</h2><p>在我们对可迭代对象进行解包时，多重赋值的条件是非常严格的。</p><p>如果将一个较大的可迭代对象解包到一组数量更小的对象中，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = (10, 20, 30)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected 2)</span><br></pre></td></tr></table></figure><p>如果将一个较小的可迭代对象解包到一组数量更多的对象中，会报下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y, z = (10, 20)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: not enough values to unpack (expected 3, got 2)</span><br></pre></td></tr></table></figure><p>这种严格的限制其实很棒，如果我们在处理元素时出现了非预期的对象数量，多重赋值会直接报错，这样我们就能发现一些还没有被发现的 bug。</p><p>举个例子。假设我们有一个简单的命令行程序，通过原始的方式接受参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">new_file = sys.argv[1]</span><br><span class="line">old_file = sys.argv[2]</span><br><span class="line">print(f&quot;Copying &#123;new_file&#125; to &#123;old_file&#125;&quot;)</span><br></pre></td></tr></table></figure><p>这个程序希望接受两个参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_program.py file1.txt file2.txt</span><br><span class="line">Copying file1.txt to file2.txt</span><br></pre></td></tr></table></figure><p>但如果在运行程序时输入了三个参数，也不会有任何报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ my_program.py file1.txt file2.txt file3.txt</span><br><span class="line">Copying file1.txt to file2.txt</span><br></pre></td></tr></table></figure><p>由于我们没有验证接收到的参数是否为 2 个，因此不会报错。</p><p>如果使用多重赋值来代替硬编码索引，在赋值时将会验证程序是否真的接收到了期望个数的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">_, new_file, old_file = sys.argv</span><br><span class="line">print(f&quot;Copying &#123;new_file&#125; to &#123;old_file&#125;&quot;)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 我们用了一个名为 <code>_</code> 的变量，意思是我们不想关注 <code>sys.argv[0]</code>（对应的是我们程序的名称）。用 <code>_</code> 对象来忽略不需关注的变量是一种常用的语法。</p><h2 id="替代数组拆分"><a href="#替代数组拆分" class="headerlink" title="替代数组拆分"></a>替代数组拆分</h2><p>根据上文，我们一直多重赋值可以用来代替硬编码的索引，并且它严格的条件可以确保我们处理的元组或可迭代对象的大小是正确的。</p><p>此外，多重赋值还能用于代替硬编码的数组拆分。</p><p>“拆分”是一种手动将 list 或其它序列中的部分元素取出的方法、</p><p>下面是一种用数字索引进行“硬编码”拆分的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_after_first = items[1:]</span><br><span class="line">all_but_last_two = items[:-2]</span><br><span class="line">items_with_ends_removed = items[1:-1]</span><br></pre></td></tr></table></figure><p>当你在拆分时发现没有在拆分索引中用到变量，那么就能用多重赋值来替代它。为了实现多重赋值拆分数组，我们将用到一个之前没提过的特性：<code>*</code> 符号。</p><p><code>*</code> 符号于 Python 3 中加入了多重赋值的语法中，它可以让我们在解包时拿到“剩余”的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; first, *rest = numbers</span><br><span class="line">&gt;&gt;&gt; rest</span><br><span class="line">[2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; first</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>因此，<code>*</code> 可以让我们在取数组末尾时替换硬编码拆分。</p><p>下面两行是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; beginning, last = numbers[:-1], numbers[-1]</span><br><span class="line">&gt;&gt;&gt; *beginning, last = numbers</span><br></pre></td></tr></table></figure><p>下面两行也是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; head, middle, tail = numbers[0], numbers[1:-1], numbers[-1]</span><br><span class="line">&gt;&gt;&gt; head, *middle, tail = numbers</span><br></pre></td></tr></table></figure><p>有了 <code>*</code> 和多重赋值之后，你可以替换一切类似于下面这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(sys.argv[0], sys.argv[1:])</span><br></pre></td></tr></table></figure><p>可以写成下面这种更具自描述性的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">program_name, *arguments = sys.argv</span><br><span class="line">main(program_name, arguments)</span><br></pre></td></tr></table></figure><p>总之，如果你写了硬编码的拆分代码，请考虑一下你可以用多重赋值来让这些拆分的逻辑更加清晰。</p><h2 id="深度解包"><a href="#深度解包" class="headerlink" title="深度解包"></a>深度解包</h2><p>这个特性是 Python 程序员长期以来经常忽略的一个东西。它虽然不如我之前提到的几种多重复值用法常用，但是当你用到它的时候会深刻体会到它的好处。</p><p>在前文，我们已经看到多重赋值用于解包元组或者其它的可迭代对象，但还没看过它<strong>更进一步</strong>地进行深度解包。</p><p>下面例子中的多重赋值是<strong>浅度</strong>的，因为它只进行了一层的解包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; color, point = (&quot;red&quot;, (1, 2, 3))</span><br><span class="line">&gt;&gt;&gt; color</span><br><span class="line">&apos;red&apos;</span><br><span class="line">&gt;&gt;&gt; point</span><br><span class="line">(1, 2, 3)</span><br></pre></td></tr></table></figure><p>而下面这种多重赋值可以认为是<strong>深度</strong>的，因为它将 <code>point</code> 元组也进一步解包成了 <code>x</code>、<code>y</code>、<code>z</code> 变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; color, (x, y, z) = (&quot;red&quot;, (1, 2, 3))</span><br><span class="line">&gt;&gt;&gt; color</span><br><span class="line">&apos;red&apos;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>上面的例子可能比较让人迷惑，所以我们在赋值语句两端加上括号来让这个例子更加明了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (color, (x, y, z)) = (&quot;red&quot;, (1, 2, 3))</span><br></pre></td></tr></table></figure><p>可以看到在第一层解包时得到了两个对象，但是这个语句将第二个对象再次解包，得到了另外的三个对象。然后将第一个对象及新解出的三个对象赋值给了新的对象（<code>color</code>、<code>x</code>、<code>y</code>、<code>z</code>）。</p><p>下面以这两个 list 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_points = [(1, 2), (3, 4), (5, 6)]</span><br><span class="line">end_points = [(-1, -2), (-3, 4), (-6, -5)]</span><br></pre></td></tr></table></figure><p>下面的代码是举例用浅层解包来处理上面的两个 list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for start, end in zip(start_points, end_points):</span><br><span class="line">    if start[0] == -end[0] and start[1] == -end[1]:</span><br><span class="line">        print(f&quot;Point &#123;start[0]&#125;,&#123;start[1]&#125; was negated.&quot;)</span><br></pre></td></tr></table></figure><p>下面用深度解包来做同样的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (x1, y1), (x2, y2) in zip(start_points, end_points):</span><br><span class="line">    if x1 == -x2 and y1 == -y2:</span><br><span class="line">        print(f&quot;Point &#123;x1&#125;,&#123;y1&#125; was negated.&quot;)</span><br></pre></td></tr></table></figure><p>请注意在第二个例子中，在处理对象时，对象的类型明显更加清晰易懂。深度解包让我们可以明显的看到，在每次循环中我们都会收到两个二元组。</p><p>深度解包通常会在每次得到多个元素的嵌套循环中使用。例如，你能在同时使用 <code>enumerate</code> 与 <code>zip</code> 时应用深度多重赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items = [1, 2, 3, 4, 2, 1]</span><br><span class="line">for i, (first, last) in enumerate(zip(items, reversed(items))):</span><br><span class="line">    if first != last:</span><br><span class="line">        raise ValueError(f&quot;Item &#123;i&#125; doesn&apos;t match: &#123;first&#125; != &#123;last&#125;&quot;)</span><br></pre></td></tr></table></figure><p>前面我提到过多重赋值对于可迭代对象的大小以及解包的大小是非常严格的，在复读解包中我们也可以利用这点<strong>严格控制可迭代对象的大小</strong>。</p><p>这么写可以正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2), (-1, -2))</span><br><span class="line">&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -point[1][1]</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>这种看起来 bug 的代码也能正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))</span><br><span class="line">&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -point[1][1]</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>这种写法也能运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2), (-1, -2))</span><br><span class="line">&gt;&gt;&gt; (x1, y1), (x2, y2) = points</span><br><span class="line">&gt;&gt;&gt; x1 == -x2 and y1 == -y2</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>但是这样不行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))</span><br><span class="line">&gt;&gt;&gt; (x1, y1), (x2, y2) = points</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected 2)</span><br></pre></td></tr></table></figure><p>在给变量多重赋值时我们其实也对可迭代对象做了一次特殊的断言（assert）。因此多重赋值既能让别人更容易理清你的代码（<strong>因为有着更好的代码可读性</strong>），也能让电脑更好地理解你的代码（<strong>因为对代码进行了确认保证了正确性</strong>）。</p><h2 id="使用-list-类型语法"><a href="#使用-list-类型语法" class="headerlink" title="使用 list 类型语法"></a>使用 list 类型语法</h2><p>在前文我提到的多重赋值都用的是元组类型的语法（tuple-like），但其实多重赋值可以用于任何可迭代对象。而这种类似元组的语法也使得多重赋值常被称为“元组解包”。而更准确地来说，多重赋值应该叫做“可迭代对象解包”。</p><p>前文中我还没有提到过，多重赋值可以写成 list 类型的语法（list-like）。</p><p>下面是一个应用 list 语法的最简单多重赋值示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x, y, z] = 1, 2, 3</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这种写法看起来很奇怪。为什么在元组语法之外还要允许这种 list 语法呢？</p><p>我也很少使用这种特性，但它在一些特殊情况下能让代码更加<strong>简洁</strong>。</p><p>举例，假设我有下面这种代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def most_common(items):</span><br><span class="line">    return Counter(items).most_common(1)[0][0]</span><br></pre></td></tr></table></figure><p>我们用心良苦的同事决定用深度多重赋值将代码重构成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most_common(items):</span><br><span class="line">    (value, times_seen), = Counter(items).most_common(1)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><p>看到赋值语句左侧的最后一个逗号了吗？很容易会将它漏掉，而且这个逗号让代码看起来不伦不类。这个逗号在这段代码中是做什么事的呢？</p><p>此处的尾部逗号其实是构造了一个单元素的元组，然后对此处进行深度解包。</p><p>可以将上面的代码换种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most_common(items):</span><br><span class="line">    ((value, times_seen),) = Counter(items).most_common(1)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><p>这种写法让深度解包的语法更加明显了。但我更喜欢下面这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def most_common(items):</span><br><span class="line">    [(value, times_seen)] = Counter(items).most_common(1)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><p>赋值中的 list 语法让它更加的清晰，可以明确看出我们将一个单元素可迭代对象进行了解包，并将单元素又解包并赋值给 <code>value</code> 与 <code>times_seen</code> 对象。</p><p>当我看到这种代码时，可以非常确定我们解包的是一个单元组 list（事实上代码做的也正是这个）。我们在此处用了 collections 模组中的 <a href="https://docs.python.org/3/library/collections.html#collections.Counter" target="_blank" rel="noopener">Counter</a> 对象。<code>Counter</code> 对象的 <code>most_common</code> 方法可以让我们指定返回 list 的长度。在此处我们将 list 限制为仅返回一个元素。</p><p>当你在解包有很多的值的结构（比如说 list）或者有确定个数值的结构（比如说元组）时，可以考虑用 list 语法来对这些类似 list 的结构进行解包，这样能让代码更加具有“语法正确性”。</p><p>如果你乐意，还可以用对类 list 结构使用 list 语法解包时应用一些 list 的语法（常见的例子为在多重赋值时使用 <code>*</code> 符号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [first, *rest] = numbers</span><br></pre></td></tr></table></figure><p>我自己其实不常用这种写法，因为我没有这个习惯。但如果你觉得这种写法有用，可以考虑在你自己的代码中用上它。</p><p>结论：当你在代码中用多重赋值时，可以考虑在何时的时候用 list 语法来让你的代码更具自解释性并更加简洁。这有时也能提升代码的可读性。</p><h2 id="不要忘记这些多重赋值的用法"><a href="#不要忘记这些多重赋值的用法" class="headerlink" title="不要忘记这些多重赋值的用法"></a>不要忘记这些多重赋值的用法</h2><p>多重赋值可以提高代码的可读性与正确性。它能使你代码<strong>更具自描述性</strong>，同时也可以对正在进行解包的可迭代对象的<strong>大小</strong>进行隐式断言。</p><p>据我观察，人们经常忘记多重赋值可以<strong>替换硬编码索引</strong>，以及<strong>替换硬编码拆分</strong>（用 <code>*</code> 语法）。深度多重赋值，以及同时使用元组语法和 list 语法也常被忽视。</p><p>认清并记住所有多重赋值的用例是很麻烦的。请随意使用本文作为你使用多重赋值的参考指南。</p><blockquote><p>juejin: <a href="https://juejin.im/post/5b3c2cf1e51d451925625b94" target="_blank" rel="noopener">https://juejin.im/post/5b3c2cf1e51d451925625b94</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是教导新手还是资深 Python 程序员，我都发现 &lt;strong&gt;很多 Python 程序员没有充分利用多重赋值这一特性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多重赋值（也经常被称为元组解包或者可迭代对象解包）能让你在一行代码内同时对多个变量进行赋值。这种特性在学习时看起
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Python" scheme="https://lsvih.com/tags/Python/"/>
    
      <category term="语法糖" scheme="https://lsvih.com/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
      <category term="多重赋值" scheme="https://lsvih.com/tags/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC/"/>
    
      <category term="元组解包" scheme="https://lsvih.com/tags/%E5%85%83%E7%BB%84%E8%A7%A3%E5%8C%85/"/>
    
      <category term="代码可读性" scheme="https://lsvih.com/tags/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>什么是 JavaScript 生成器？如何使用生成器？</title>
    <link href="https://lsvih.com/2018/06/04/%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F/"/>
    <id>https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/</id>
    <published>2018-06-04T08:47:00.000Z</published>
    <updated>2018-10-28T16:13:07.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg" alt=""></p><p>在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。</p><h3 id="什么是-JavaScript-生成器？"><a href="#什么是-JavaScript-生成器？" class="headerlink" title="什么是 JavaScript 生成器？"></a>什么是 JavaScript 生成器？</h3><p>生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。</p><p>上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 <strong>for 循环</strong>之类的迭代器有什么区别。</p><p>下面是一个 <strong>for 循环</strong>的例子，它会在执行后立刻返回一些值。这段代码其实就是简单地生成了 0-5 这些数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 5; i += 1) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 它将会立刻返回 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p>现在看看生成器函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function * generatorForLoop(num) &#123;</span><br><span class="line">  for (let i = 0; i &lt; num; i += 1) &#123;</span><br><span class="line">    yield console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const genForLoop = generatorForLoop(5);</span><br><span class="line"></span><br><span class="line">genForLoop.next(); // 首先 console.log - 0</span><br><span class="line">genForLoop.next(); // 1</span><br><span class="line">genForLoop.next(); // 2</span><br><span class="line">genForLoop.next(); // 3</span><br><span class="line">genForLoop.next(); // 4</span><br></pre></td></tr></table></figure><p>它做了什么？它实际上只是对上面例子中的 <strong>for 循环</strong>做了一点改动，但产生了很大的变化。这种变化是由生成器最重要的特性造成的 —— 只有在需要的时候它才会产生下一个值，而不会一次性产生所有的值。在某些情景下，这种特性十分方便。</p><h3 id="生成器语法"><a href="#生成器语法" class="headerlink" title="生成器语法"></a>生成器语法</h3><p>如何定义一个生成器函数呢？下面列出了各种可行的定义方法，不过万变不离其宗的是在函数关键词后加上一个星号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function * generator () &#123;&#125;</span><br><span class="line">function* generator () &#123;&#125;</span><br><span class="line">function *generator () &#123;&#125;</span><br><span class="line"></span><br><span class="line">let generator = function * () &#123;&#125;</span><br><span class="line">let generator = function* () &#123;&#125;</span><br><span class="line">let generator = function *() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let generator = *() =&gt; &#123;&#125; // SyntaxError</span><br><span class="line">let generator = ()* =&gt; &#123;&#125; // SyntaxError</span><br><span class="line">let generator = (*) =&gt; &#123;&#125; // SyntaxError</span><br></pre></td></tr></table></figure><p>如上面的例子所示，我们并不能使用箭头函数来创建一个生成器。</p><p>下面将生成器作为方法（method）来创建。定义方法与定义函数的方式是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  *generator() &#123;&#125;</span><br><span class="line">  * generator() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  *generator() &#123;&#125;</span><br><span class="line">  * generator() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>现在让我们一起看看新的关键词 <code>yield</code>。它有些类似 <code>return</code>，但又不完全相同。<code>return</code> 会在完成函数调用后简单地将值返回，在 <code>return</code> 语句之后你无法进行任何操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withReturn(a) &#123;</span><br><span class="line">  let b = 5;</span><br><span class="line">  return a + b;</span><br><span class="line">  b = 6; // 不可能重新定义 b 了</span><br><span class="line">  return a * b; // 这儿新的值没可能返回了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">withReturn(6); // 11</span><br><span class="line">withReturn(6); // 11</span><br></pre></td></tr></table></figure><p>而 <code>yield</code> 的工作方式却不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function * withYield(a) &#123;</span><br><span class="line">  let b = 5;</span><br><span class="line">  yield a + b;</span><br><span class="line">  b = 6; // 在第一次调用后仍可以重新定义变量</span><br><span class="line">  yield a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calcSix = withYield(6);</span><br><span class="line"></span><br><span class="line">calcSix.next().value; // 11</span><br><span class="line">calcSix.next().value; // 36</span><br></pre></td></tr></table></figure><p>用 <code>yield</code> 返回的值只会返回一次，当你再次调用同一个函数的时候，它会执行至下一个 <code>yield</code> 语句处（译者注：前面的 <code>yield</code> 不再返回东西了）。</p><p>在生成器中，我们通常会在输出时得到一个对象。这个对象有两个属性：<code>value</code> 与 <code>done</code>。如你所想，<code>value</code> 为返回值，<code>done</code> 则会显示生成器是否完成了它的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 5, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; - 之后的任何调用都会返回相同的结果</span><br></pre></td></tr></table></figure><p>在生成器中，不仅可以使用 <code>yield</code>，也可以使用 <code>return</code> 来返回同样的对象。但是，在函数执行到第一个 <code>return</code> 语句的时候，生成器将结束它的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  return 2;</span><br><span class="line">  yield 3; // 到不了这个 yield 了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 2, done: true&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><h4 id="yield-委托迭代"><a href="#yield-委托迭代" class="headerlink" title="yield 委托迭代"></a>yield 委托迭代</h4><p>带星号的 <code>yield</code> 可以将它的工作委托给另一个生成器。通过这种方式，你就能将多个生成器连接在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function * anotherGenerator(i) &#123;</span><br><span class="line">  yield i + 1;</span><br><span class="line">  yield i + 2;</span><br><span class="line">  yield i + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * generator(i) &#123;</span><br><span class="line">  yield* anotherGenerator(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = generator(1);</span><br><span class="line"></span><br><span class="line">gen.next().value; // 2</span><br><span class="line">gen.next().value; // 3</span><br><span class="line">gen.next().value; // 4</span><br></pre></td></tr></table></figure><p>在开始下一节前，我们先观察一个第一眼看上去比较奇特的行为。</p><p>下面是正常的代码，不会报出任何错误，这表明 <code>yield</code> 可以在 <code>next()</code> 方法调用后返回传递的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arr) &#123;</span><br><span class="line">  for (const i in arr) &#123;</span><br><span class="line">    yield i;</span><br><span class="line">    yield yield;</span><br><span class="line">    yield(yield);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator([0,1]);</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: &quot;0&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: &quot;A&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: &quot;A&quot;, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: &quot;B&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: &quot;B&quot;, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，你可以看到 <code>yield</code> 默认是 <code>undefined</code>，但如果我们在调用 <code>yield</code> 时传递了任何值，它就会返回我们传入的值。我们将很快利用这个特性。</p><h4 id="初始化与方法"><a href="#初始化与方法" class="headerlink" title="初始化与方法"></a>初始化与方法</h4><p>生成器是可以被复用的，但是你需要对它们进行初始化。还好初始化的方法十分简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arg = &apos;Nothing&apos;) &#123;</span><br><span class="line">  yield arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen0 = generator(); // OK</span><br><span class="line">const gen1 = generator(&apos;Hello&apos;); // OK</span><br><span class="line">const gen2 = new generator(); // 不 OK</span><br><span class="line"></span><br><span class="line">generator().next(); // 可以运行，但每次都会从头开始运行</span><br></pre></td></tr></table></figure><p>如上所示，<code>gen0</code> 与 <code>gen1</code> 不会互相影响，<code>gen2</code> 完全不会运行（会报错）。因此初始化对于保证程序流程的状态是十分重要的。</p><p>下面让我们一起看看生成器给我们提供的方法。</p><p><strong>next() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; 之后所有的 next 调用都会返回同样的输出</span><br></pre></td></tr></table></figure><p>这是最常用的方法。它每次被调用时都会返回下一个对象。在生成器工作结束时，<code>next()</code> 会将 <code>done</code> 属性设为 <code>true</code>，<code>value</code> 属性设为 <code>undefined</code>。</p><p>我们不仅可以用 <code>next()</code> 来迭代生成器，还可以用 <code>for of</code> 循环来一次得到生成器所有的值（而不是对象）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arr) &#123;</span><br><span class="line">  for (const el in arr)</span><br><span class="line">    yield el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator([0, 1, 2]);</span><br><span class="line"></span><br><span class="line">for (const g of gen) &#123;</span><br><span class="line">  console.log(g); // 0 -&gt; 1 -&gt; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>但它不适用于 <code>for in</code> 循环，并且不能直接用数字下标来访问属性：<code>generator[0] = undefined</code>。</p><p><strong>return() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.return(); // &#123;value: undefined, done: true&#125;</span><br><span class="line">gen.return(&apos;Heeyyaa&apos;); // &#123;value: &quot;Heeyyaa&quot;, done: true&#125;</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; - 在 return() 之后的所有 next() 调用都会返回相同的输出</span><br></pre></td></tr></table></figure><p><code>return()</code> 将会忽略生成器中的任何代码。它会根据传值设定 <code>value</code>，并将 <code>done</code> 设为 <code>true</code>。任何在 <code>return()</code> 之后进行的 <code>next()</code> 调用都会返回 <code>done</code> 属性为 <code>true</code> 的对象。</p><p><strong>throw() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.throw(&apos;Something bad&apos;); // 会报错 Error Uncaught Something bad</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p><code>throw()</code> 做的事非常简单 —— 就是抛出错误。我们可以用 <code>try-catch</code> 来处理。</p><h4 id="自定义方法的实现"><a href="#自定义方法的实现" class="headerlink" title="自定义方法的实现"></a>自定义方法的实现</h4><p>由于我们无法直接访问 <code>Generator</code> 的 constructor，因此如何增加新的方法需要另外说明。下面是我的方法，你也可以用不同的方式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;constructor: GeneratorFunction, next: ƒ, return: ƒ, throw: ƒ, Symbol(Symbol.toStringTag): &quot;Generator&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 由于 Generator 不是一个全局变量，因此我们只能这么写：</span><br><span class="line">generator.prototype.__proto__.math = function(e = 0) &#123;</span><br><span class="line">  return e * Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;math: ƒ, constructor: GeneratorFunction, next: ƒ, return: ƒ, throw: ƒ, …&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line">gen.math(1); // 3.141592653589793</span><br></pre></td></tr></table></figure><h4 id="生成器的用途"><a href="#生成器的用途" class="headerlink" title="生成器的用途"></a>生成器的用途</h4><p>在前面，我们用了已知迭代次数的生成器。但如果我们不知道要迭代多少次会怎么样呢？为了解决这个问题，需要在生成器函数中创建一个无限循环。下面以一个会返回随机数的函数为例进行演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * randomFrom(...arr) &#123;</span><br><span class="line">  while (true)</span><br><span class="line">    yield arr[Math.floor(Math.random() * arr.length)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getRandom = randomFrom(1, 2, 5, 9, 4);</span><br><span class="line"></span><br><span class="line">getRandom.next().value; // 返回随机的一个数</span><br></pre></td></tr></table></figure><p>这是个简单的例子。下面来举一些更复杂的函数为例，我们要写一个节流（throttle）函数。如果你还不知道节流函数是什么，请参阅<a href="https://medium.com/@_jh3y/throttling-and-debouncing-in-javascript-b01cad5c8edf" target="_blank" rel="noopener">这篇文章</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function * throttle(func, time) &#123;</span><br><span class="line">  let timerID = null;</span><br><span class="line">  function throttled(arg) &#123;</span><br><span class="line">    clearTimeout(timerID);</span><br><span class="line">    timerID = setTimeout(func.bind(window, arg), time);</span><br><span class="line">  &#125;</span><br><span class="line">  while (true)</span><br><span class="line">    throttled(yield);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thr = throttle(console.log, 1000);</span><br><span class="line"></span><br><span class="line">thr.next(); // &#123;value: undefined, done: false&#125;</span><br><span class="line">thr.next(&apos;hello&apos;); // 返回 &#123;value: undefined, done: false&#125; ，然后 1 秒后输出 &apos;hello&apos;</span><br></pre></td></tr></table></figure></p><p>还有没有更好的利用生成器的例子呢？如果你了解递归，那你肯定听过<a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数列</a>。通常我们是用递归来解决这个问题的，但有了生成器后，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function * fibonacci(seed1, seed2) &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield (() =&gt; &#123;</span><br><span class="line">      seed2 = seed2 + seed1;</span><br><span class="line">      seed1 = seed2 - seed1;</span><br><span class="line">      return seed2;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fib = fibonacci(0, 1);</span><br><span class="line">fib.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 5, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 8, done: false&#125;</span><br></pre></td></tr></table></figure><p>不再需要递归了！我们可以在需要的时候获得数列中的下一个数字。</p><h4 id="将生成器用在-HTML-上"><a href="#将生成器用在-HTML-上" class="headerlink" title="将生成器用在 HTML 上"></a>将生成器用在 HTML 上</h4><p>既然是讨论 JavaScript，那显然要用生成器来操作下 HTML。</p><p>假设有一些 HTML 块需要处理，可以使用生成器来轻松实现。（当然除了生成器之外还有很多方法可以做到）</p><p>我们只需要少许代码就能完成此需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const strings = document.querySelectorAll(&apos;.string&apos;);</span><br><span class="line">const btn = document.querySelector(&apos;#btn&apos;);</span><br><span class="line">const className = &apos;darker&apos;;</span><br><span class="line"></span><br><span class="line">function * addClassToEach(elements, className) &#123;</span><br><span class="line">  for (const el of Array.from(elements))</span><br><span class="line">    yield el.classList.add(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const addClassToStrings = addClassToEach(strings, className);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&apos;click&apos;, (el) =&gt; &#123;</span><br><span class="line">  if (addClassToStrings.next().done)</span><br><span class="line">    el.target.classList.add(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>仅有 5 行逻辑代码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还有更多使用生成器的方法。例如，在进行异步操作或者按需循环时生成器也非常有用。</p><p>我希望这篇文章能帮你更好地理解 JavaScript 生成器。</p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5b14faf2f265da6e4d5af3b9" target="_blank" rel="noopener">https://juejin.im/post/5b14faf2f265da6e4d5af3b9</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generato
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="ES6" scheme="https://lsvih.com/tags/ES6/"/>
    
      <category term="FrontEnd" scheme="https://lsvih.com/tags/FrontEnd/"/>
    
      <category term="Juejin" scheme="https://lsvih.com/tags/Juejin/"/>
    
      <category term="JavaScript" scheme="https://lsvih.com/tags/JavaScript/"/>
    
      <category term="Generator" scheme="https://lsvih.com/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>可用但最不常见的 HTML5 标签</title>
    <link href="https://lsvih.com/2018/05/19/%E5%8F%AF%E7%94%A8%E4%BD%86%E6%9C%80%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84-HTML5-%E6%A0%87%E7%AD%BE/"/>
    <id>https://lsvih.com/2018/05/19/可用但最不常见的-HTML5-标签/</id>
    <published>2018-05-19T13:33:00.000Z</published>
    <updated>2018-10-28T16:13:11.172Z</updated>
    
    <content type="html"><![CDATA[<p><code>&lt;!DOCTYPE html&gt;</code> HMLT5 于 2014 年 10 月由万维网联盟（W3C）发布，旨在通过改进 HTML 语言来支持最新的多媒体设备，在保证计算机与设备（如 Web 浏览器，解析器等）可解析的前提下增强对人类的可读性。</p><p><img src="https://lsvih.com/images/pasted-321.png" alt="upload successful"></p><p>我可以确定你们都已经在使用 HTML5 做网页了，并且会使用一些常见的标签，如 <code>&lt;header&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code> 和 <code>&lt;footer&gt;</code> 等等，除此之外，还有一些不常用的标签是有助于正确使用 HTML5 的语义化开发。</p><p>在此我将其中一些最重要的标签列出来，希望能帮助你遵循 HTML5 语义进行开发。</p><a id="more"></a><h4 id="lt-details-gt"><a href="#lt-details-gt" class="headerlink" title="&lt;details&gt;"></a><code>&lt;details&gt;</code></h4><p><code>&lt;details&gt;</code> 标签指定了用户可以按需查看或隐藏的内容，可以用它来创建能被用户关闭与打开的小工具。在语义上，你可以在其中使用任何类型的内容，不过如果没有对它设置 open 属性，内容将不可见。</p><p><code>&lt;details open&gt;&lt;p&gt;在预定时需要信用卡&lt;/p&gt;&lt;/details&gt;</code></p><h4 id="lt-dialog-gt"><a href="#lt-dialog-gt" class="headerlink" title="&lt;dialog&gt;"></a><code>&lt;dialog&gt;</code></h4><p><code>&lt;dialog&gt;</code> 定义了一个对话框元素或窗口。</p><p><code>&lt;dialog open&gt;&lt;p&gt;欢迎来到我们的酒店&lt;/p&gt;&lt;/dialog&gt;</code></p><h4 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="&lt;mark&gt;"></a><code>&lt;mark&gt;</code></h4><p><code>&lt;mark&gt;</code> 标签定义了被标记的文本，可以用于将你文本中的一部分高亮。</p><p><code>&lt;p&gt;在&lt;mark&gt;预定&lt;/mark&gt;时需要信用卡&lt;/p&gt;</code></p><h4 id="lt-summary-gt"><a href="#lt-summary-gt" class="headerlink" title="&lt;summary&gt;"></a><code>&lt;summary&gt;</code></h4><p><code>&lt;summary&gt;</code> 标签为 <code>&lt;details&gt;</code> 定义了一个可见的标题。点击这个标题可以显示或隐藏  <code>&lt;details&gt;</code> 内容。</p><p><code>&lt;details&gt;&lt;summary&gt;支付条件&lt;/summary&gt;&lt;p&gt;在预定时需要信用卡&lt;/p&gt;&lt;/details&gt;</code></p><h4 id="lt-time-gt-与-lt-datetime-gt"><a href="#lt-time-gt-与-lt-datetime-gt" class="headerlink" title="&lt;time&gt; 与 &lt;datetime&gt;"></a><code>&lt;time&gt;</code> 与 <code>&lt;datetime&gt;</code></h4><p><code>&lt;time&gt;</code> 标签定义了一个人类可读的日期或者时间。这个元素还能用以机器可读的方式对日期或时间进行编码，以便用户的工具或软件将生日提醒、计划事件之类的时间添加到用户的日历中。此外，还能让搜索引擎产生更智能的搜索结果。</p><p><code>&lt;p&gt;自助早餐于 &lt;time&gt;7.00 AM&lt;/time&gt; 在餐厅开始&lt;/p&gt;</code></p><p><code>&lt;p&gt;&lt;time datetime=&quot;2018-06-20T19:00&quot;&gt;6 月 20 日晚上 7 点&lt;/time&gt;在大厅举行音乐会&lt;/p&gt;</code></p><h4 id="lt-small-gt"><a href="#lt-small-gt" class="headerlink" title="&lt;small&gt;"></a><code>&lt;small&gt;</code></h4><p><code>&lt;small&gt;</code> 标签的规范解释，这个标签可以用于降低文本或信息的重要性。浏览器将通过缩小字体以减少视觉影响。</p><p><code>&lt;p&gt;取消预定必须提前 48 小时，&lt;small&gt;以免每房每夜的额外扣款&lt;/small&gt;&lt;/p&gt;</code></p><h4 id="lt-datalist-gt"><a href="#lt-datalist-gt" class="headerlink" title="&lt;datalist&gt;"></a><code>&lt;datalist&gt;</code></h4><p>你可以用 <code>&lt;datalist&gt;</code> 元素来定义 <code>&lt;input&gt;</code> 标签中用于有效选择的列表。这个组件在各个浏览器中的样子略有不同，但相同的是在字段右边显示一个小下拉箭头，提示此字段可以进行选择。<a href="https://codepen.io/pedromsduarte/pen/GxdNaB" target="_blank" rel="noopener">点这儿</a>查看效果。</p><p><code>&lt;datalist&gt;&lt;option value=&quot;Master Card&quot;&gt;&lt;option value=&quot;Visa&quot;&gt;&lt;option value=&quot;American Express&quot;&gt;&lt;/datalist&gt;</code></p><h4 id="lt-progress-gt"><a href="#lt-progress-gt" class="headerlink" title="&lt;progress&gt;"></a><code>&lt;progress&gt;</code></h4><p><code>&lt;progress&gt;</code> HTML 元素会显示一个指示器，用于显示某个任务的完成进度，通常显示为进度条。</p><p><code>&lt;progress value=&quot;70&quot; max=&quot;100&quot;&gt;70 %&lt;/progress&gt;</code></p><hr><blockquote><p>掘金地址：<a href="https://juejin.im/post/5b0026e8f265da0b8c253c2a" target="_blank" rel="noopener">https://juejin.im/post/5b0026e8f265da0b8c253c2a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt; HMLT5 于 2014 年 10 月由万维网联盟（W3C）发布，旨在通过改进 HTML 语言来支持最新的多媒体设备，在保证计算机与设备（如 Web 浏览器，解析器等）可解析的前提下增强对人类的可读性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/pasted-321.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;我可以确定你们都已经在使用 HTML5 做网页了，并且会使用一些常见的标签，如 &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt; 等等，除此之外，还有一些不常用的标签是有助于正确使用 HTML5 的语义化开发。&lt;/p&gt;
&lt;p&gt;在此我将其中一些最重要的标签列出来，希望能帮助你遵循 HTML5 语义进行开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Juejin" scheme="https://lsvih.com/tags/Juejin/"/>
    
      <category term="HTML5" scheme="https://lsvih.com/tags/HTML5/"/>
    
      <category term="W3C" scheme="https://lsvih.com/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>由 Node.js 发送 Web 推送通知</title>
    <link href="https://lsvih.com/2018/05/16/%E7%94%B1-Node-js-%E5%8F%91%E9%80%81-Web-%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/"/>
    <id>https://lsvih.com/2018/05/16/由-Node-js-发送-Web-推送通知/</id>
    <published>2018-05-16T14:03:00.000Z</published>
    <updated>2018-10-28T16:13:18.674Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">service workers API</a> 可以让你直接由 Node.js 应用向 Chrome 浏览器发送推送通知。<a href="https://www.npmjs.com/package/web-push" target="_blank" rel="noopener"><code>web-push</code> npm 模组</a>可以让你免去 <a href="https://www.pubnub.com/" target="_blank" rel="noopener">PubNub</a> 之类的中间商，直接推送消息。本文将在前端使用原生 JavaScript，在后端使用 <a href="https://www.npmjs.com/package/express" target="_blank" rel="noopener">Express</a> 框架，通过一个“Hello, World”级别的样例来带你了解如何进行 web 推送通知。最终的效果如下图所示。本项目的全部源码可在 <a href="https://github.com/vkarpov15/web-push-demo" target="_blank" rel="noopener">GitHub</a> 查阅。</p><p><img src="https://lsvih.com/images/pasted-318.png" alt="upload successful"></p><h2 id="鉴权及配置服务端"><a href="#鉴权及配置服务端" class="headerlink" title="鉴权及配置服务端"></a>鉴权及配置服务端</h2><p>要设置 web 推送，必须先创建 <a href="https://blog.mozilla.org/services/2016/04/04/using-vapid-with-webpush/" target="_blank" rel="noopener">VAPID keys</a>。VAPID keys 用于识别是谁发送了推送消息。npm 的 <code>web-push</code> 模组能够<a href="https://www.npmjs.com/package/web-push#command-line" target="_blank" rel="noopener">帮助你生成 VAPID keys</a>，下面我们将安装 <code>web-push</code> 及其依赖，并使用 <code>web-push generate-vapid-keys</code> 来创建 VAPID keys。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express@4.16.3 web-push@3.3.0 body-parser@1.18.2 express-static@1.2.5</span><br><span class="line">+ express@4.16.3</span><br><span class="line">+ web-push@3.3.0</span><br><span class="line">+ body-parser@1.18.2</span><br><span class="line">+ express-static@1.2.5</span><br><span class="line">added 62 packages in 1.42s</span><br><span class="line">$</span><br><span class="line">$ ./node_modules/.bin/web-push generate-vapid-keys</span><br><span class="line">=======================================</span><br><span class="line">Public Key:</span><br><span class="line">BOynOrGhgkj8Bfk4hsFENAQYbnqqLSigUUkCNaBsAmNuH6U9EWywR1JIdxBVQOPDbIuTaj0tVAQbczNLkC5zftw</span><br><span class="line">Private Key:</span><br><span class="line">&lt;OMITTED&gt;</span><br><span class="line">=======================================</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如果你需要支持低版本浏览器，那么还要获取 <a href="https://medium.com/@jasminejacquelin/integrating-push-notifications-in-your-node-react-web-app-4e8d8190a52c#9a53" target="_blank" rel="noopener">GCM API key</a>，但在桌面版 Chrome 63 或更高版本中不需要它。</p><p>下面创建 <code>index.js</code> 文件，其中包含你的服务。你需要使用 <code>require()</code> 导入 web-push 模组，并配置刚才的 VAPID keys。配置相当简单，将 VAPID keys 存放在 <code>PUBLIC_VAPID_KEY</code> 与 <code>PRIVATE_VAPID_KEY</code> 环境变量中即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpush = <span class="built_in">require</span>(<span class="string">'web-push'</span>);</span><br><span class="line"><span class="keyword">const</span> publicVapidKey = process.env.PUBLIC_VAPID_KEY;</span><br><span class="line"><span class="keyword">const</span> privateVapidKey = process.env.PRIVATE_VAPID_KEY;</span><br><span class="line"><span class="comment">// 此处换成你自己的邮箱</span></span><br><span class="line">webpush.setVapidDetails(<span class="string">'mailto:val@karpov.io'</span>, publicVapidKey, privateVapidKey);</span><br></pre></td></tr></table></figure><p>下一步，为 Express 应用添加一个名为 <code>/subscribe</code> 的端点。浏览器中的 JavaScript 将会发送一个 body 中包含 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription" target="_blank" rel="noopener"><code>PushSubscription</code> 对象</a>的 HTTP 请求。为了用 <code>webpush.sendNotification()</code> 发送推送通知，你需要获取 <code>PushSubscription</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'body-parser'</span>).json());</span><br><span class="line">app.post(<span class="string">'/subscribe'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = req.body;</span><br><span class="line">  res.status(<span class="number">201</span>).json(&#123;&#125;);</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">title</span>: <span class="string">'test'</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(subscription);</span><br><span class="line">  webpush.sendNotification(subscription, payload).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error.stack);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上就是服务端需要做的全部配置。你可以在 <a href="https://github.com/vkarpov15/web-push-demo/blob/master/index.js" target="_blank" rel="noopener">GitHub</a> 查阅完整代码。现在，我们就要创建客户端 <code>client.js</code> 与一个 service worker —— <code>worker.js</code> 了。</p><h2 id="客户端与-Service-Worker"><a href="#客户端与-Service-Worker" class="headerlink" title="客户端与 Service Worker"></a>客户端与 Service Worker</h2><p>首先，使用 <a href="http://npmjs.com/package/express-static" target="_blank" rel="noopener"><code>express-static</code> npm 模组</a>，<a href="https://github.com/vkarpov15/web-push-demo/blob/b356e53c1468c5611b9c4722411af3839bafc360/index.js#L26" target="_blank" rel="noopener">对 Express 应用进行配置</a>，为客户端部署静态资源，将静态资源部署在服务的最顶级目录下。<br>需要注意的是要在处理 <code>/subscribe</code> 路由之后再调用这个 <code>app.use()</code>，否则 Express 将不会根据你的配置处理路由，而是会去查找 <code>subscribe.html</code> 文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'express-static'</span>)(<span class="string">'./'</span>));</span><br></pre></td></tr></table></figure><p>接着，创建 <code>index.html</code> 文件，这个文件将部署为你的应用的入口。文件中仅有的关键之处就是 <code>&lt;script&gt;</code> 标签，它将加载客户端 JavaScript 代码；其余部分都无关紧要。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Push Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"/client.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Service Worker Demo</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在你的入口做好了。创建一个名为 <code>client.js</code> 的文件。<a href="https://github.com/vkarpov15/web-push-demo/blob/b356e53c1468c5611b9c4722411af3839bafc360/client.js" target="_blank" rel="noopener">这个文件</a> 将告知浏览器初始化你的 service worker 并向 <code>/subscribe</code> 发送 HTTP 请求。由于支持 service workers 的浏览器也应该能支持 async 与 await，因此上述示例中使用了 <a href="http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html" target="_blank" rel="noopener">async/await</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里写死的 public key 要换成你自己的。</span></span><br><span class="line"><span class="keyword">const</span> publicVapidKey = <span class="string">'BOynOrGhgkj8Bfk4hsFENAQYbnqqLSigUUkCNaBsAmNuH6U9EWywR1JIdxBVQOPDbIuTaj0tVAQbczNLkC5zftw'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Registering service worker'</span>);</span><br><span class="line">  run().catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Registering service worker'</span>);</span><br><span class="line">  <span class="keyword">const</span> registration = <span class="keyword">await</span> navigator.serviceWorker.</span><br><span class="line">    register(<span class="string">'/worker.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Registered service worker'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Registering push'</span>);</span><br><span class="line">  <span class="keyword">const</span> subscription = <span class="keyword">await</span> registration.pushManager.</span><br><span class="line">    subscribe(&#123;</span><br><span class="line">      userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// `urlBase64ToUint8Array()` 函数与以下网址中的描述一致</span></span><br><span class="line">      <span class="comment">// https://www.npmjs.com/package/web-push#using-vapid-key-for-applicationserverkey</span></span><br><span class="line">      applicationServerKey: urlBase64ToUint8Array(publicVapidKey)</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Registered push'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Sending push'</span>);</span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">'/subscribe'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(subscription),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Sent push'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，你需要实现 <code>client.js</code> 所加载的 <code>worker.js</code> 文件。<br>这个文件是 service worker 逻辑所在之处。当订阅者接受到一个推送消息时，service worker 将收到一个 <a href="https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications#handling_the_push_event_in_the_service_worker" target="_blank" rel="noopener">‘push’ 事件</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Loaded service worker!'</span>);</span><br><span class="line">self.addEventListener(<span class="string">'push'</span>, ev =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = ev.data.json();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got push'</span>, data);</span><br><span class="line">  self.registration.showNotification(data.title, &#123;</span><br><span class="line">    body: <span class="string">'Hello, World!'</span>,</span><br><span class="line">    icon: <span class="string">'http://mongoosejs.com/docs/images/mongoose5_62x30_transparent.png'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了！配置正确的环境变量并启动你的服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ env PUBLIC_VAPID_KEY=&apos;OMITTED&apos; env PRIVATE_VAPID_KEY=&apos;OMITTED&apos; node .</span><br></pre></td></tr></table></figure><p>在 Chrome 中访问 <code>http://localhost:3000</code>，你应该可以看到下面的推送通知！</p><p><img src="https://lsvih.com/images/pasted-319.png" alt="upload successful"></p><p>这种通知不仅在 Chrome 中可用，在 <a href="https://support.mozilla.org/en-US/kb/push-notifications-firefox" target="_blank" rel="noopener">Firefox</a> 也可以用同样的代码实现。</p><p><img src="https://lsvih.com/images/pasted-320.png" alt="upload successful"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Web 推送只是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">service workers</a> 带来的诸多好处的其中一种。<br>通过一个 <a href="https://www.npmjs.com/package/web-push" target="_blank" rel="noopener">npm 模组</a>，你就能给大多数现代浏览器推送通知。下次你要为你的 web 应用增加推送通知功能的时候，记得用 service workers 哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;service workers API&lt;/a&gt; 可
      
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Node.js" scheme="https://lsvih.com/tags/Node-js/"/>
    
      <category term="Service Worker" scheme="https://lsvih.com/tags/Service-Worker/"/>
    
      <category term="Web push" scheme="https://lsvih.com/tags/Web-push/"/>
    
  </entry>
  
  <entry>
    <title>Deconvolutional Paragraph Representation Learning</title>
    <link href="https://lsvih.com/2018/05/11/Deconvolutional-Paragraph-Representation-Learning/"/>
    <id>https://lsvih.com/2018/05/11/Deconvolutional-Paragraph-Representation-Learning/</id>
    <published>2018-05-11T06:32:00.000Z</published>
    <updated>2018-10-28T16:12:54.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在许多自然语言处理应用中，从长文本序列中学习其潜在的语义表示是重要的第一步。RNN 已经成为了这个任务的基石。然而，随着文本长度的增加，RNN 的解码重建（decoding、reconstraction）的质量也随之降低。因此，我们提出了一个 seq2seq、由纯粹的卷积与反卷积结构构成的自动编码框架，它没有上述 RNN 的问题，同时计算效率也很高。另外，此方法简单易行，可以在许多应用中作为一块积木使用。我们可以证明，此框架在重构长文本任务中的效果比 RNN 更好。同时，在半监督文本分类及文本摘要任务中的评价指标表明此框架能更好地利用无标注长文本数据。</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>学习句子或多个句子组成的段落是自然语言处理的一项重要任务，它常常是实现其它任务（如情感分析、机器翻译、对话系统、文本摘要等）的基础。从数据中学习句子的表示使用的是编码器 - 解码器结构。在标准的自动编码步骤中，首先由输入序列的 embedding 编码为向量表示，再解码到原始域重建输入序列。近期在 RNN 中，LSTM 及其变体在许多依赖句子表示的学习任务中取得了巨大的成功。</p><p>基于 RNN 的方法通常将句子递归建模为含有隐藏单元的马尔可夫过程，其中每个输入句子的单词都是由前一个单词及隐藏单元的状态生成的，通过 emission 与 transition 运算建模为神经网络。原则上，输入序列的神经元表示应当包含了足够的输入序列结构的信息，才能在之后通过解码恢复原句。然而由于 RNN 的递归性质，基于 RNN 将句子完全表示为向量存在着挑战。典型的问题是，RNN 在训练时是基于之前的置信单词的状态来生成序列中的单词，而不是由编码后的向量表示解码整个句子。现在已经证明这种强制性的策略（teacher forcing training）是有必要的，因为它可以让 RNN 的输出接近于置信序列。然而，由于在重建序列时 RNN 允许解码器使用置信信息，削弱了编码器独立生成向量表示的能力，导致编码后的表示没能携带足够的信息来引导解码器在没有其它指引的情况下进行解码。为了解决这个问题，[19] 提出了一种在训练过程中的采样方法，从同时使用潜在表示与置信信号进行学习逐渐转换为仅用编码的潜在表示进行学习。但 [20] 表明，这种计划采样本质上是一种不一致训练策略，在实际使用中会产生不稳定的结果，最终导致训练无法收敛。</p><p>在推理时，在遇到无法使用置信信号的句子时，仅能通过前一个单词及表示向量的状态来生成新的单词。此时，解码的错误随着序列长度的增加而成比例增加。这也意味着，在处理句子时，一旦出现一个错误，后续生成的句子将错的更离谱。这种现象是 [19] 中的 exposure bias 产生的。</p><p>我们提出了一种简单而强大的纯卷积结构，用于学习句子的表示。比较方便的是，由于这个结构中不含 RNN，因此 teacher forcing training 与 exposure bias 的问题自然就不存在了。这种方法使用 CNN 作为编码器，deCNN 作为解码器。我们认为，这种结构通过多层 CNN 迫使潜在表示从整个句子中提取信息，由此在不适用 RNN 解码器的情况下实现较高的重建质量。这种多层 CNN 能够让表示向量从整个句子中抽取信息而无需考虑句子长度，这也使它可以应用于长句子或段落相关任务。此外，由于这种结构不涉及递归编码及解码，因此可以使用图形处理单元（GPU）的特定卷积原语进行高效并行化，与 RNN 模型相比显著减少了计算成本。</p><h3 id="2-自动编码卷积文本模型"><a href="#2-自动编码卷积文本模型" class="headerlink" title="2 自动编码卷积文本模型"></a>2 自动编码卷积文本模型</h3><h4 id="2-1-卷积编码器"><a href="#2-1-卷积编码器" class="headerlink" title="2.1 卷积编码器"></a>2.1 卷积编码器</h4><p>用 $w^t$ 表示给定句子中的第 t 个词，将每个词 $w^t$ 进行 embedding，映射为 k 维的词向量 $x_t = W_e[w^t]$，其中 $ W_e \in \mathbb{R}^{k \times V} $ 为一个已经学习好的 Word embedding 矩阵，V 为单词数量；用 $ W_e[v]$ 来表示 $W_e$ 的第 v 列。$W_e$ 中的所有列都经过 l2-norm 处理，例如 $ ||W_e[v]||_2 = 1, \forall v $。在经过 embedding 之后，一个长度为 T 的句子（经过 padding）可以在将 embedding 进行 concat 后表示为 $X \in \mathbb{R}^{k \times T}$；其中 $x_t$ 为 X 的第 t 列。</p><p>对于句子做编码，我们采用了类似 [24] 中的 CNN 结构，这个结构最初是为做图像处理任务设计的。这个 CNN 结构包含 L 个层（L - 1 个卷积层，第 L 层为全连接层），此结构最后可以将一个输入句子转化为一个定长的表示向量 h。层 $l \in {1, … ,L}$ 由学习到的滤波器 $p_l$ 组成。对于第一层中的第 i 个滤波器来说，相当于对 X 进行一个步长（stride）为 $r^{(1)}$、滤波器为 $W_c^{(i,1)} \in \mathbb{R}^{k \times h}$ 的卷积运算（式中的 h 代表卷积滤波器的大小）。这一系列操作会生成一个潜在特征映射：$c^{(i,1)}=\gamma(X * W_c^{(i,1)} + b^{(i,1)}) \in \mathbb{R}^{(T-h)/r^{(1)}+1}$，其中 $\gamma(.)$ 为非线性激活函数，$b^{(i,1)} \in \mathbb{R}^{(T-h)/r^{(1)}+1}$ ，* 符号代表了卷积操作。在我们的实验中，$\gamma(.)$ 为 ReLU。需要注意的是，最初的 embedding 维数 k 在经过第一层卷积层后就发生了变化，$c^{(i,1)} \in \mathbb{R}^{(T-h)/r^{(1)}+1}$ for i = 1,…,p1。在第一层将 p1 滤波器得到的结果进行拼接，就得到了一个特征映射，$C^{(1)}= [c^{(1,1)}… c^{(p1,1)}] \in \mathbb{R}^{p_1 \times [(T-h)/r^{(1)}+1]}$。</p><p>在第一个卷积层之后，我们对得到的特征映射 $C^{(1)}$ 使用同样的滤波器大小 h 进行卷积操作，并在这 L - 1 层中不断重复此操作。每次操作都能将空间维数降低为 $T^{(l+1)}=[(T^{(l)} - h)/r^{(l)} + 1]$（$r^{(l)}$ 为步长，$T^{(l)}$ 为空间维数大小，l 为第 l 层，[] 为向下取整函数）。在最后一层 L 中，得到了特征映射 $C^{(L-1)}$，将其送入全连接层中制造潜在表示向量 h。在实现时，我们直接用了一个滤波器大小等于 $T^{(L-1)}$（不考虑 h）的卷积层，它就相当于一个全连接层。这个实现上的 trick 在 [24] 中有所使用。这个最后一层将所有的空间坐标 $T^{(L-1)}$ 汇聚成为标量特征，使用滤波器 ${W_c^{(i,l)}}$ for i=1,…,p1 and l=1,…,L 将句子的子结构依次封装为了向量表示。其中 $W_c^{(i,l)}$ 表示层 l 的滤波器 i。这也意味着提取出来的特征的维度是固定的，与输入句子的长度无关。</p><p><img src="https://lsvih.com/images/pasted-317.png" alt="upload successful"></p><p>图1，卷积自动编码结构。编码器：将输入序列展开为 embedding 矩阵 X，接着通过多个卷积层编码器压缩为表示向量 h，在最后一层中将向量折叠去除空间维度。解码器：将表示向量 h 送入多个反卷积解码器，以 X 为目标，使用余弦相似度交叉熵损失函数重建 $\hat{X}$。</p><p>在最后一层有 $p_L$ 个滤波器，将会构造出 $p_L$ 维的表示向量。对于输入句子来说，也记为 $h=C^{(L)}$。例如，在图一中，编码器由 L=3 个层构成，句子长度为 T=60，embedding 维数为 k=300，不同层的步长 ${ r^{(1)},r^{(2)},r^{(3)} } = {2,2,1}$ ，滤波器大小 $h = {5,5,12}$，滤波器数量 ${p_1,p_2,p_3 }={300,600,500}$。中间层得到的特征映射 $C^{(1)}$ 和 $C^{(2)}$ 的大小分别为 ${28 \times 300,12 \times 600}$。最后的特征映射大小为 1 x 500，对应的正是潜在表示向量 h。</p><p>从概念上看，较低层中的滤波器捕捉的是原始的句子信息（h-gram，类似于图像处理中的边缘信息），而叫高层中的滤波器捕捉的是更复杂的语言特征，比如语义和句法结构等（类似于图像处理中的图像元素）。这种自底向上的结构通过分层堆叠文本片段（h-gram）作为构建表示向量 h 的积木。这种方法在思路上类似于通过 concrete syntax trees [26] 对语言的语法结构进行建模。不过，我们没有事先去指定某种语法结构（比如英语），而是通过多层 CNN 网络提取此结构。</p><h4 id="2-2-反卷积解码器"><a href="#2-2-反卷积解码器" class="headerlink" title="2.2 反卷积解码器"></a>2.2 反卷积解码器</h4><p>我们按照一定步长应用卷积的变体 - 反卷积操作（比如 convolutional transpose），用于解码表示向量 h，将其还原至原来的文本域。随着反卷积的不断进行，向量的空间高度也不断增加，如图1所示，和之前描述的卷积操作刚好相反。空间维数首先展开至与卷积层的 L-1 层相同，接着逐渐展开为 $T^{(l+1)} = (T^{(l)}-1)*r^{(l)} + h$ for l=1,…直到第 L 个反卷积层（此层与卷积编码器的输入层相对应）。第 L 反卷积层的输出目标是重建 Word embedding 矩阵 $\hat{X}$。与 $W_e$ 一样，$\hat{X}$ 的每一列都经由 l2-norm 处理。</p><p>用 $\hat{w}^t$ 来表示重建后句子 $\hat{s}$ 中的第 t 个单词，$\hat{w}^t$ 为 v 的概率可表示为：</p><script type="math/tex; mode=display">p(\hat{w}^t = v) = \frac{\exp[\tau^{-1}D_{cos}(\hat{x}^t,W_e[v])]}{\sum_{v'\in V}\exp[\tau^{-1}D_{cos}(\hat{x}^t,W_e[v'])]}</script><p>式中，$D_{cos}(x,y)$ 代表余弦相似度，计算方法为 $\frac{&lt;{x,y}&gt;}{||x||||y||}$ ，$W_e[v]$ 是 $W_e$ 的第 v 列，$\hat{x}^t$ 是 $\hat{X}$ 的第 t 列，$\tau$ 是一个正数，我们将其定义为 temperature parameter [27]。此参数类似于 Dirichlet 分布的浓度参数，控制着概率向量 $[p(\hat{w}^t = 1)…p(\hat{w}^t = V)]$ 的扩散，较大的 $\tau$ 值会鼓励概率均匀地分布，较小的 $\tau$ 值会鼓励概率稀疏并集中。在实验中，我们设定 $\tau = 0.01$。此外在我们的实验中，余弦相似度可直接由经由 l2-norm 的 $W_e$ 与 $\hat{X}$ 内积得到。</p><h4 id="2-3-模型学习"><a href="#2-3-模型学习" class="headerlink" title="2.3 模型学习"></a>2.3 模型学习</h4><p>上述卷积自动编码器的目标可以记为所有句子（$s \in D$）的词级别的对数似然：</p><script type="math/tex; mode=display">\iota^{\alpha e} = \sum_{d \in D} \sum_t \log p(\hat{w}^t_d = w^t_d)</script><p>上述式子中，D 表示句子的集合。为了简单起见，使用随机梯度下降对式中的最大对数似然进行优化。实现相关的细节将在实验一节中详细描述。请注意，上述工作与之前的相关工作有两处不同：i) [22,28] 中使用了池化与上池化（pooling,unpooling）操作，而我们用了卷积与反卷积；ii) 更重要的是，[22,28] 没有像我们前面的步骤一样使用余弦相似度来重建句子，而是使用了基于 RNN 的解码器。我们将在第 3 节中更详细地讨论相关工作。在早期的实验（论文中未写出）中，我们使用了池化与上池化，但是没有观察到显著的性能提升；而卷积/反卷积运算则在内存占用方面更具效率。与标准的 LSTM RNN 自动编码器进行对比，两者参数数量大致相同，但我们的结构在单片 NVIDIA TITAN X GPU 上计算速度相当快（详见实验一节）。原因是 CNN 通过 cuDNN 原语处理有着很高的并行效率。</p><p><strong>反卷积解码器与 RNN 解码器的对比：</strong> 这种结构可以视为 NLP 模型的一种补充结构。与标准的基于 LSTM 的解码器相反，反卷积与 RNN 的区别在于它有着不严格的序列依赖性。具体来说，RNN 生成一个单词需要一个隐藏单元的向量，以递归的方式在整句中顺序地积累信息（长效信息主要依赖于向下权重）；而反卷积解码器，解码时的生成仅依赖一个封装了整个句子信息的表示向量，没有指定顺序结构。因此，对于语言生成任务，RNN 解码器会比反卷积解码器生成相关性更好的文本；与之相反，反卷积解码器在计算长句、远距离依赖的情况效果更好，因此在分类特征提取与文本摘要任务中更加有用。</p><h4 id="2-4-半监督分类与摘要"><a href="#2-4-半监督分类与摘要" class="headerlink" title="2.4 半监督分类与摘要"></a>2.4 半监督分类与摘要</h4><p>识别相关主题或情绪以及从用户生成的内容（如博客、产品评论等）生成摘要最近获得了大量的关注[1, 3, 4, 30, 31, 13, 11]。在大多数实际情况下，未标注数据非常丰富，但实际上很少能充分发挥这些未标注数据的潜力。以此为契机，我们希望能补充一些稀缺但更有价值的标注数据，以提高监督学习模型的泛化能力。无论是标注数据还是未标注数据，上述模型可以通过提取未标注数据，学习它们的潜在表示，捕获其语义信息。这可以将任务分为两步，在监督训练之前进行上述步骤。近期，应用这种思路的基于 RNN 的方法已经被广泛使用，并在许多任务中获得了 state-of-the-art 的效果 [1, 3, 4, 30, 31]。此外，还可以构建一个分类器与自动编码解码器联合的分类模型，对潜在向量表示 h 进行分类，详见 [32, 33]。</p><p>又比如，在产品评论中，每个评论可能包含了数百个词，这对基于 RNN 的序列编码器来说有着一定的困难。因为 RNN 需要在文本中滑动并抽取信息，这会导致信息的丢失，在长句子中更为严重[34]。另外，在训练过程中解码用到了置信的真实信息，这可能导致无法完全保留来自输入文本的所有信息，而这些丢失的信息对于重建句子、分类、摘要来说是至关重要的。</p><p>我们考虑将这个卷积自动编码解码结构应用于长句、段落的半监督学习任务中。我们将半监督问题视作 [35] 中的多任务学习问题，同时训练序列编码器与监督模型，而不是像 [1, 3] 中那样预训练无监督模型。理论上来说，这种联合训练方法得到的段落 embedding 向量会保持重建与分类的能力。</p><h3 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3 相关工作"></a>3 相关工作</h3><p>之前的工作 [22, 28, 21, 38, 39] 已经考虑了将 CNN 用作为一些 NLP 任务的编码器了。一般来说，基于 CNN 的编码器结构会使用一个单一的卷积层再加上池化层。这种结构在给定卷积滤波窗口大小为 h 时，实质上就是做了一个识别特定 h-gram 结构的检测器。从原理看，我们这种架构中的深层结构可以让高层学习到更复杂的语言特征。</p><h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h3><p>实验结果图：</p><p><img src="https://lsvih.com/images/15258102755361.jpg" alt=""></p><p><img src="https://lsvih.com/images/15258102868772.jpg" alt=""></p><p><img src="https://lsvih.com/images/15258102990486.jpg" alt=""></p><p><img src="https://lsvih.com/images/15258103106207.jpg" alt=""></p><p><img src="https://lsvih.com/images/15258103206038.jpg" alt=""></p><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h3><p>我们提出了一种只使用卷积与反卷积运算的用于文本模型的通用结构。这种结构没有进行序列条件生成，因此避免了 teacher forcing training 与 exposure bias 问题。这种方法可以将段落完全压缩至潜在表示向量中，此向量也能解压缩重建原始输入序列。总的来说，这种方法实现了高质量的长段落重建，并优于现有的拼写矫正算法、半监督序列分类算法、文本摘要算法，且减少了计算成本。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] Andrew M Dai and Quoc V Le. Semi-supervised sequence learning. In NIPS, 2015.</p><p>[2] Quoc Le and Tomas Mikolov. Distributed representations of sentences and documents. In ICML, 2014.</p><p>[3] Rie Johnson and Tong Zhang. Supervised and Semi-Supervised Text Categorization using LSTM for Region Embeddings. arXiv, February 2016.</p><p>[4] Takeru Miyato, Andrew M Dai, and Ian Goodfellow. Adversarial Training Methods for Semi-Supervised Text Classiﬁcation. In ICLR, May 2017.</p><p>[5] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural Machine Translation by Jointly Learning to Align and Translate. In ICLR, 2015.</p><p>[6] Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In EMNLP, 2014.</p><p>[7] Fandong Meng, Zhengdong Lu, Mingxuan Wang, Hang Li, Wenbin Jiang, and Qun Liu. Encoding source language with convolutional neural network for machine translation. In ACL, 2015.</p><p>[8] Tsung-Hsien Wen, Milica Gasic, Nikola Mrksic, Pei-Hao Su, David Vandyke, and Steve Young. Semantically conditioned lstm-based natural language generation for spoken dialogue systems. arXiv, 2015.</p><p>[9] Jiwei Li, Will Monroe, Alan Ritter, Michel Galley, Jianfeng Gao, and Dan Jurafsky. Deep reinforcement learning for dialogue generation. arXiv, 2016.</p><p>[10] Jiwei Li, Will Monroe, Tianlin Shi, Alan Ritter, and Dan Jurafsky. Adversarial learning for neural dialogue generation. arXiv:1701.06547, 2017.</p><p>[11] Ramesh Nallapati, Bowen Zhou, Cicero Nogueira dos santos, Caglar Gulcehre, and Bing Xiang. Abstractive Text Summarization Using Sequence-to-Sequence RNNs and Beyond. In CoNLL, 2016.</p><p>[12] Shashi Narayan, Nikos Papasarantopoulos, Mirella Lapata, and Shay B Cohen. Neural Extractive Summarization with Side Information. arXiv, April 2017.</p><p>[13] Alexander M Rush, Sumit Chopra, and Jason Weston. A Neural Attention Model for Abstractive Sentence Summarization. In EMNLP, 2015.</p><p>[14] Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to sequence learning with neural networks. In NIPS, 2014.</p><p>[15] Tomas Mikolov, Martin Karaﬁát, Lukas Burget, Jan Cernock`y, and Sanjeev Khudanpur. Recurrent neural network based language model. In INTERSPEECH, 2010.</p><p>[16] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. In Neural computation, 1997.</p><p>[17] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv, 2014.</p><p>[18] Ronald J Williams and David Zipser. A learning algorithm for continually running fully recurrent neural networks. Neural computation, 1(2):270–280, 1989.</p><p>[19] Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and Noam Shazeer. Scheduled sampling for sequence prediction with recurrent neural networks. In NIPS, 2015.</p><p>[20] Ferenc Huszár. How (not) to train your generative model: Scheduled sampling, likelihood, adversary? arXiv, 2015.</p><p>[21] Nal Kalchbrenner, Edward Grefenstette, and Phil Blunsom. A convolutional neural network for modelling sentences. In ACL, 2014.</p><p>[22] Yoon Kim. Convolutional neural networks for sentence classiﬁcation. In EMNLP, 2014.</p><p>[23] Ishaan Gulrajani, Kundan Kumar, Faruk Ahmed, Adrien Ali Taiga, Francesco Visin, David Vazquez, and Aaron Courville. Pixelvae: A latent variable model for natural images. arXiv, 2016.</p><p>[24] Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional generative adversarial networks. arXiv, 2015.</p><p>[25] Vinod Nair and Geoffrey E Hinton. Rectiﬁed linear units improve restricted boltzmann machines. In ICML, pages 807–814, 2010.</p><p>[26] Ian Chiswell and Wilfrid Hodges. Mathematical logic, volume 3. OUP Oxford, 2007.</p><p>[27] Emil Julius Gumbel and Julius Lieblein. Statistical theory of extreme values and some practical applications: a series of lectures. 1954.</p><p>[28] Ronan Collobert, Jason Weston, Léon Bottou, Michael Karlen, Koray Kavukcuoglu, and Pavel Kuksa. Natural language processing (almost) from scratch. In JMLR, 2011.</p><p>[29] Sharan Chetlur, Cliff Woolley, Philippe Vandermersch, Jonathan Cohen, John Tran, Bryan Catanzaro, and Evan Shelhamer. cudnn: Efﬁcient primitives for deep learning. arXiv, 2014.</p><p>[30] Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alex Smola, and Eduard Hovy. Hierarchical attention networks for document classiﬁcation. In NAACL, 2016.</p><p>[31] Adji B Dieng, Chong Wang, Jianfeng Gao, and John Paisley. TopicRNN: A Recurrent Neural Network with Long-Range Semantic Dependency. In ICLR, 2016.</p><p>[32] Diederik P Kingma, Shakir Mohamed, Danilo Jimenez Rezende, and Max Welling. Semi-supervised learning with deep generative models. In NIPS, 2014.</p><p>[33] Yunchen Pu, Zhe Gan, Ricardo Henao, Xin Yuan, Chunyuan Li, Andrew Stevens, and Lawrence Carin.</p><p>Variational autoencoder for deep learning of images, labels and captions. In NIPS, 2016.</p><p>[34] Sepp Hochreiter, Yoshua Bengio, Paolo Frasconi, and Jürgen Schmidhuber. Gradient ﬂow in recurrent nets: the difﬁculty of learning long-term dependencies, 2001.</p><p>[35] Richard Socher, Jeffrey Pennington, Eric H Huang, Andrew Y Ng, and Christopher D Manning. Semisupervised recursive autoencoders for predicting sentiment distributions. In EMNLP. Association for Computational Linguistics, 2011.</p><p>[36] Samuel R Bowman, Luke Vilnis, Oriol Vinyals, Andrew M Dai, Rafal Jozefowicz, and Samy Bengio. Generating sentences from a continuous space. arXiv, 2015.</p><p>[37] Zichao Yang, Zhiting Hu, Ruslan Salakhutdinov, and Taylor Berg-Kirkpatrick. Improved Variational Autoencoders for Text Modeling using Dilated Convolutions. arXiv, February 2017.</p><p>[38] Baotian Hu, Zhengdong Lu, Hang Li, and Qingcai Chen. Convolutional neural network architectures for matching natural language sentences. In NIPS, 2014.</p><p>[39] Rie Johnson and Tong Zhang. Effective use of word order for text categorization with convolutional neural networks. In NAACL HLT, 2015.</p><p>[40] Jost Tobias Springenberg, Alexey Dosovitskiy, Thomas Brox, and Martin Riedmiller. Striving for simplicity: The all convolutional net. arXiv, 2014.</p><p>[41] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR, 2015.</p><p>[42] Stanislau Semeniuta, Aliaksei Severyn, and Erhardt Barth. A Hybrid Convolutional Variational Autoencoder for Text Generation. arXiv, February 2017.</p><p>[43] Nal Kalchbrenner, Lasse Espeholt, Karen Simonyan, Aaron van den Oord, Alex Graves, and Koray Kavukcuoglu. Neural machine translation in linear time. arXiv, 2016.</p><p>[44] Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language Modeling with Gated Convolutional Networks. arXiv, December 2016.</p><p>[45] J. Gehring, M. Auli, D. Grangier, D. Yarats, and Y. N. Dauphin. Convolutional Sequence to Sequence Learning. arXiv, May 2017.</p><p>[46] Aaron van den Oord, Nal Kalchbrenner, Lasse Espeholt, Oriol Vinyals, Alex Graves, et al. Conditional image generation with pixelcnn decoders. In NIPS, pages 4790–4798, 2016.</p><p>[47] Jiwei Li, Minh-Thang Luong, and Dan Jurafsky. A hierarchical neural autoencoder for paragraphs and documents. In ACL, 2015.</p><p>[48] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representations of words and phrases and their compositionality. In NIPS, 2013.</p><p>[49] Kam-Fai Wong, Mingli Wu, and Wenjie Li. Extractive summarization using supervised and semi-supervised learning. In ICCL. Association for Computational Linguistics, 2008.</p><p>[50] Chin-Yew Lin. Rouge: A package for automatic evaluation of summaries. In ACL workshop, 2004.</p><p>[51] Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In ACL. Association for Computational Linguistics, 2002.</p><p>[52] Xiang Zhang, Junbo Zhao, and Yann LeCun. Character-level convolutional networks for text classiﬁcation. In NIPS, pages 649–657, 2015.</p><p>[53] Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu, Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron Courville, and Yoshua Bengio. An actor-critic algorithm for sequence prediction. arXiv, 2016.</p><p>[54] JP Woodard and JT Nelson. An information theoretic measure of speech recognition performance. In Workshop on standardisation for speech I/O, 1982.</p><p>[55] Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.</p><p>[56] Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural networks. In AISTATS, 2010.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;在许多自然语言处理应用中，从长文本序列中学习其潜在的语义表示是重要的第一步。RNN 已经成为了这个任务的基石。然而，随着文本长度的增加，RN
      
    
    </summary>
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="Paper Note" scheme="https://lsvih.com/tags/Paper-Note/"/>
    
      <category term="DeConv" scheme="https://lsvih.com/tags/DeConv/"/>
    
      <category term="Conv" scheme="https://lsvih.com/tags/Conv/"/>
    
      <category term="CNN" scheme="https://lsvih.com/tags/CNN/"/>
    
      <category term="Encoder-decoder" scheme="https://lsvih.com/tags/Encoder-decoder/"/>
    
  </entry>
  
  <entry>
    <title>ssh 不用手动输密码远程执行命令</title>
    <link href="https://lsvih.com/2018/04/18/ssh-%E4%B8%8D%E7%94%A8%E6%89%8B%E5%8A%A8%E8%BE%93%E5%AF%86%E7%A0%81%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://lsvih.com/2018/04/18/ssh-不用手动输密码远程执行命令/</id>
    <published>2018-04-18T04:15:00.000Z</published>
    <updated>2018-10-28T16:13:02.317Z</updated>
    
    <content type="html"><![CDATA[<p>小组使用了 GitLab，在某项目中需要利用 CI 进行远程部署，但生产服务器是另一台远程服务器，而 CI Runner 的运行环境是 Docker。</p><p>由于 ssh 的安全措施，在建立 ssh 连接时不允许自动化输入密码，必须在出现密码框后手动输入，因此在 CI 流程中无法实现；经过了解，一款名为 sshpass 的工具可以满足此需求；</p><p>在本机测试时，使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install sshpass</span><br></pre></td></tr></table></figure></p><p>提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We won&apos;t add sshpass because it makes it too easy for novice SSH users to ruin SSH&apos;s security.</span><br></pre></td></tr></table></figure></p><p>可知此工具的确是破坏了 ssh 的安全性。</p><p>但在内部机器的 CI Runner Docker 中，不考虑这个问题。Gitlab CI Runner 默认使用的是 <code>alpine:latest</code>，需要事先安装依赖及 sshpass，因此在 before_script 中加上 <code>apk add --update --no-cache openssh sshpass</code> 安装此工具。</p><p>在后续的 job/stage 中，加入远程执行命令脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshpass -p <span class="string">'password'</span> ssh -T -o StrictHostKeyChecking=no username@192.168.xxx.xxx <span class="string">'sh /home/remote/script.sh'</span></span><br></pre></td></tr></table></figure><p>即可绕过手动输入密码步骤，在 CI 中运行远程 sh 脚本。</p><blockquote><p>在联网环境慎用，防止泄密</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;小组使用了 GitLab，在某项目中需要利用 CI 进行远程部署，但生产服务器是另一台远程服务器，而 CI Runner 的运行环境是 Docker。&lt;/p&gt;
&lt;p&gt;由于 ssh 的安全措施，在建立 ssh 连接时不允许自动化输入密码，必须在出现密码框后手动输入，因此在 C
      
    
    </summary>
    
      <category term="Note" scheme="https://lsvih.com/categories/Note/"/>
    
    
      <category term="Note" scheme="https://lsvih.com/tags/Note/"/>
    
      <category term="Tool" scheme="https://lsvih.com/tags/Tool/"/>
    
      <category term="ssh" scheme="https://lsvih.com/tags/ssh/"/>
    
      <category term="sshpass" scheme="https://lsvih.com/tags/sshpass/"/>
    
      <category term="Docker" scheme="https://lsvih.com/tags/Docker/"/>
    
      <category term="alpine" scheme="https://lsvih.com/tags/alpine/"/>
    
      <category term="CI" scheme="https://lsvih.com/tags/CI/"/>
    
      <category term="GitLab" scheme="https://lsvih.com/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>为 JavaScript 程序员准备的 Flutter 指南</title>
    <link href="https://lsvih.com/2018/04/04/%E4%B8%BA-JavaScript-%E7%A8%8B%E5%BA%8F%E5%91%98%E5%87%86%E5%A4%87%E7%9A%84-Flutter-%E6%8C%87%E5%8D%97/"/>
    <id>https://lsvih.com/2018/04/04/为-JavaScript-程序员准备的-Flutter-指南/</id>
    <published>2018-04-04T02:49:00.000Z</published>
    <updated>2018-10-28T16:13:05.848Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a> 是一款用同一套代码构建高性能、高保真的 iOS 及安卓应用的跨平台移动端应用 SDK。</p><p><a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">文档</a>中提到：</p><blockquote><p>Flutter 包括一个 <strong>react 风格</strong>的框架、一个 2D 渲染引擎、一些预制的插件以及开发者工具。</p></blockquote><p><img src="https://lsvih.com/images/pasted-312.png" alt="upload successful"></p><p>文本希望能快速为 JavaScript 开发者们提供一个简练的入门指南，我会试着以 JS 与 npm 生态系统来类比 Flutter / Dart 与 <a href="https://pub.dartlang.org/" target="_blank" rel="noopener">Pub</a> 包库。</p><blockquote><p>如果你对最新的 Flutter 教程、库、公告及社区的更新感兴趣，我建议您订阅双周刊 <a href="http://flutternewsletter.com/" target="_blank" rel="noopener">Flutter Newsletter</a>。</p></blockquote><hr><p>我在 <a href="https://react-native.eu/" target="_blank" rel="noopener">React Native EU</a> 的演讲 <a href="https://www.youtube.com/watch?v=pFtvv0rJgPw" target="_blank" rel="noopener">React Native — 跨平台及超越</a>中讨论并演示了 React 生态系统中 <a href="https://github.com/necolas/react-native-web" target="_blank" rel="noopener">React Native Web</a>、<a href="https://github.com/lelandrichardson/react-primitives" target="_blank" rel="noopener">React Primitives</a> 和 <a href="https://microsoft.github.io/reactxp/" target="_blank" rel="noopener">ReactXP</a> 的不同之处，并且我也有机会讨论 <a href="https://weex.incubator.apache.org/" target="_blank" rel="noopener">Weex</a> 及 <a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a> 的不同之处。</p><p>在尝试 Flutter 之后，我认为它是近几年我所关注的前端技术中最让我激动的一个。在本文中，我将讨论为何它如此令我激动，并介绍如何尽可能快的入门 Flutter。</p><a id="more"></a><h4 id="如果你认识我，那么我知道你正在想什么…"><a href="#如果你认识我，那么我知道你正在想什么…" class="headerlink" title="如果你认识我，那么我知道你正在想什么…"></a>如果你认识我，那么我知道你正在想什么…</h4><p><img src="https://lsvih.com/images/pasted-313.png" alt="upload successful"></p><p>我是一名有着超过两年半经验的 React 与 React Native 开发者。现在，我仍然看好 React 和 React Native，并且我也知道有许多大公司正在使用它们，但我仍然乐于看到其他的能达到相同目的的想法方法，这无关乎我是否要去学习或改变技术栈。</p><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><blockquote><p>我可以做个概括：Flutter 令人惊叹, 我相信近几年它会成为更多人的选择。</p></blockquote><p>在使用了几周 Flutter SDK 之后，我正在应用它制作我的第一个 App，我十分享受这个过程。</p><p>在我开始介绍如何入门 Flutter 前，我将首先回顾一下我对它的 SDK 的优缺点的看法。</p><p><img src="https://lsvih.com/images/pasted-314.png" alt="upload successful"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>内置由核心团队维护的 UI 库（Material 及 Cupertino）。</li><li>Dart 团队与 Flutter 团队紧密合作，专门针对 Flutter 优化移动设备的 Dart VM。</li><li>有着崭新的、酷炫的文档。</li><li>强大的 CLI。</li><li>我能轻松、顺利地入门与运行它，没有碰到各种障碍与 Bug。</li><li>开箱即用的热加载功能，使得调试的体验相当好。此外，还有<a href="https://flutter.io/debugging/" target="_blank" rel="noopener">一系列关于调试技术的很好的文档</a>。</li><li>有由核心团队构建并维护的 nav 库，可靠且有见地。</li><li>Dart 语言诞生 6 年了，相当成熟。虽然 Dart 是一种基于类的面向对象编程语言，但如果你想用函数式编程，Dart 也有着作为第一公民的函数，并且支持许多函数式编程结构。</li><li>Dart 比我想象中的更容易入门，我十分喜欢它。</li><li>Dart 是一种无需任何多余配置的开箱即用的强类型语言（比如：TypeScript、Flow）。</li><li>如果你用过 React，会发现它有类似的状态机制（比如 lifecycle 方法与 <code>setState</code>）。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>你要去学习 Dart（相信我，这很简单）。</li><li>仍在测试中。</li><li>目标平台仅为 iOS 和安卓。</li><li>插件生态系统还很稚嫩，<a href="https://pub.dartlang.org/flutter" target="_blank" rel="noopener">https://pub.dartlang.org/flutter</a> <a href="https://t.co/KMMwbnVM6M" title="http://pub.dartlang.org" target="_blank" rel="noopener"></a>在 2017 年 9 月还只有 70 余个包。</li><li>布局与编写样式需要学习一种全新的范式与 API。</li><li>需要学习不一样的项目配置（pubspec.yaml vs package.json）。</li></ul><h3 id="入门及其它观点"><a href="#入门及其它观点" class="headerlink" title="入门及其它观点"></a>入门及其它观点</h3><ul><li>Flutter 文档推荐了 VS Code 编辑器与 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDE</a>。尽管 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDE</a> 内置支持热加载、在线加载这些 VS Code 没有的功能，但我还是选择使用安装了 <a href="https://marketplace.visualstudio.com/items?itemName=DanTup.dart-code" target="_blank" rel="noopener">Dart Code extension</a> 插件的 VS Code 编辑器，并得到了很好的开发体验。</li><li>Flutter 有一个模块系统，或者叫包管理系统 —— <a href="https://pub.dartlang.org/" target="_blank" rel="noopener">Pub Dart Package Manager</a>，它与 npm 有很多不同点。它的好坏取决于你对 npm 的看法。</li><li>我之前并没有 Dart 相关的知识，但我很快就入门了。它让我想起了 TypeScript，并且与 JavaScript 也有一些相似之处。</li><li>文档中有几个相当不错的代码实验室与教程，建议去查阅一番：1. <a href="https://codelabs.developers.google.com/codelabs/flutter/index.html#0" target="_blank" rel="noopener">构建 UIS</a> 2. <a href="https://codelabs.developers.google.com/codelabs/flutter-firebase/index.html#0" target="_blank" rel="noopener">增加 Firebase</a> 3. <a href="https://flutter.io/tutorials/layout/" target="_blank" rel="noopener">构建布局</a> 4. <a href="https://flutter.io/tutorials/interactive/" target="_blank" rel="noopener">增加交互</a></li></ul><h4 id="说的够多了，现在让我们开始创建一个新的工程吧！"><a href="#说的够多了，现在让我们开始创建一个新的工程吧！" class="headerlink" title="说的够多了，现在让我们开始创建一个新的工程吧！"></a><strong>说的够多了，现在让我们开始创建一个新的工程吧！</strong></h4><h3 id="在-macOS-中安装-CLI"><a href="#在-macOS-中安装-CLI" class="headerlink" title="在 macOS 中安装 CLI"></a>在 macOS 中安装 CLI</h3><p>如果你使用的是 Windows，请查阅 <a href="https://flutter.io/setup/" target="_blank" rel="noopener">此文档</a>。</p><p>如需查看完整的 macOS 平台下的安装指南，请查看 <a href="https://flutter.io/setup-macos/" target="_blank" rel="noopener">此文档</a>。</p><p>首先，我们需要克隆包含 flutter CLI 二进制文件的 repo，然后将其添加到系统目录中。比如我将 repo 克隆到了专门用于存放二进制文件的目录下，然后将这个新目录加到了 <code>$HOME/.bashrc</code> 和 <code>$HOME/.zshrc</code> 文件中。</p><ol><li>克隆 repo：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b alpha https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><ol><li>增加路径：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$HOME/bin/flutter/bin:$PATH (或者填你选择的安装路径)</span><br></pre></td></tr></table></figure><ol><li>在命令行中运行 flutter doctor，检测 flutter 路径能被正确识别，并安装一切所需的依赖：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><h3 id="安装其它依赖"><a href="#安装其它依赖" class="headerlink" title="安装其它依赖"></a>安装其它依赖</h3><p>如果你要部署 iOS app，那么必须安装 Xcode；如果你要部署安卓 app，那么必须要安装 Android Studio。</p><p><strong>了解关于安装这两个不同平台的知识，请参阅文档</strong>：<a href="https://flutter.io/setup-macos/#platform-setup" target="_blank" rel="noopener">文档</a>。</p><h3 id="创建你的第一个-Flutter-app"><a href="#创建你的第一个-Flutter-app" class="headerlink" title="创建你的第一个 Flutter app"></a>创建你的第一个 Flutter app</h3><p>现在我们已经安装好了 flutter CLI，可以创建我们的第一个 app 了。请运行 flutter create 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create myapp</span><br></pre></td></tr></table></figure><p>此命令会帮助你创建一个新的 app，进入新目录，打开 iOS 模拟器或安卓模拟器，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure><p><img src="https://lsvih.com/images/pasted-315.png" alt="upload successful"></p><p>此命令会在你打开的模拟器中运行 app。如果你同时打开了 iOS 与安卓模拟器，你可以用下面的命令来将程序传入指定的模拟器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d android / flutter run -d iPhone</span><br></pre></td></tr></table></figure><p>也可以同时运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d all</span><br></pre></td></tr></table></figure><p>此时你应该在控制台中看到了关于重启 app 的信息：</p><p><img src="https://lsvih.com/images/pasted-316.png" alt="upload successful"></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>你正在运行的代码处于 <code>lib/main.dart</code> 文件中。</p><p>你会发现有一个 andoird 文件夹和一个 iOS 文件夹，原生的项目存在这些目录中。</p><p>项目的配置在 <code>pubspec.yaml</code> 中，此文件与 JavaScript 生态系统中的 <code>package.json</code> 类似。</p><p>现在将目光转向 <code>lib/main.dart</code>。</p><p>在文件的头部，可以看见一个 import：</p><p><code>import ‘package:flutter/material.dart’;</code></p><p>这个依赖文件是哪儿来的？请查看 <code>pubspec.yaml</code> 文件，可以发现在依赖列表中单独有一个 flutter 依赖项，在这儿是引用的 <code>package:flutter/</code>。如果想添加或导入其它依赖项，那么需要将新的依赖加入 <code>pubspec.yaml</code>，然后用过 import 来使用它们。</p><p>在 <code>main.dart</code> 的头部，我们还可以看到有一个名为 main 的函数。在 Dart 中，<a href="https://www.dartlang.org/guides/language/language-tour#the-main-function" target="_blank" rel="noopener">main</a> 是一个特殊的、<strong>必要的</strong>、顶级的函数，也是 app 开始执行的地方。因为 Flutter 是由 Dart 构建的，main 也是这个工程的主入口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  runApp(new MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数调用了 <code>new MyApp()</code>，这个类。与 React App 类似，有一个由多个组件组合而成的主组件，然后调用 <code>ReactDOM.render</code> 或 <code>AppRegistry.registerComponent</code> 进行渲染。</p><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>Flutter <a href="https://flutter.io/technical-overview/" target="_blank" rel="noopener">技术总览</a>中的一个核心原则就是：“一切皆 Widget”。</p><blockquote><p>Widget 是每个 Flutter app 的最基本的构建模块。每个 Widget 都是用户界面的一个不可变定义。与其它框架分离视图、控制器、布局和其它属性不同，Flutter 有着统一的、一致的对象模型：Widget。</p></blockquote><p>类比 Web 术语或 JavaScript，你可以将 Widget 看成与 Component 类似的东西。Widget 通常由内部类构成，这些类可能包含或不包含一些本地状态（local state）或方法。</p><p>如果你观察 main.dart，可以发现类似 StatelessWidget、StatefulWidget、Center、Text 的类引用。这些都是 Widget。如果想了解所有可用的 Widget，请查阅<a href="https://docs.flutter.io/flutter/widgets/widgets-library.html" target="_blank" rel="noopener">文档</a>。</p><h3 id="布局与编写样式"><a href="#布局与编写样式" class="headerlink" title="布局与编写样式"></a>布局与编写样式</h3><p>虽然 Dart 和多数 Flutter 框架都很容易使用，但进行布局与编写样式让我最开始头疼了一阵子。</p><p>需要重点注意的是，与编写 Web 样式不同，以及与 React Native 的 View 会完成所有的布局和一些样式不同，Flutter 的布局由<strong>你选择的 Widget 类型</strong>及<strong>本身的布局与样式属性</strong>共同决定，也就是说它通常取决于你使用的 Widget。</p><p>例如，<a href="https://docs.flutter.io/flutter/widgets/Column-class.html" target="_blank" rel="noopener">Column</a> 能接收多个子 Widget，但不接受任何样式属性（<a href="https://docs.flutter.io/flutter/widgets/Flex/crossAxisAlignment.html" target="_blank" rel="noopener">CrossAxisAlignment</a> 及 <a href="https://docs.flutter.io/flutter/widgets/Flex/direction.html" target="_blank" rel="noopener">direction</a> 等布局属性除外）；而 <a href="https://docs.flutter.io/flutter/widgets/Container-class.html" target="_blank" rel="noopener">Container</a> 能接收各种布局及样式属性。</p><p>Flutter 还有一些布局专用的组件，比如 <a href="https://docs.flutter.io/flutter/widgets/Padding-class.html" target="_blank" rel="noopener">Padding</a>，它仅能接收一个子 Widget，但除了给子 Widget 添加 padding（边距）之外不会做其它任何事。</p><p>请参考这个完整的 <a href="https://flutter.io/widgets/layout/" target="_blank" rel="noopener">Widget 列表</a>，能帮你使用 Container、Row、Column、Center、GridView 及其它有着自己布局规范的组件实现布局。</p><h3 id="SetState-及生命周期函数"><a href="#SetState-及生命周期函数" class="headerlink" title="SetState 及生命周期函数"></a>SetState 及生命周期函数</h3><p>与 React 类似，Flutter 也有有状态、无状态组件或 Widget。有状态组件可以创建、更新、销毁状态，与 React 中使用的生命周期函数类似。</p><p>在 Flutter 中，也有一个名为 setState 的函数用来更新状态。你可以在我们刚才创建的项目的 <code>_incrementCounter</code> 方法中看到此函数。</p><p>更多信息请查阅：<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener">StatefulWidget</a>, <a href="https://docs.flutter.io/flutter/widgets/State-class.html" target="_blank" rel="noopener">State</a> 和 <a href="https://docs.flutter.io/flutter/widgets/StatelessWidget-class.html" target="_blank" rel="noopener">StatelessWidget</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为专门制作跨平台应用的开发者，我会保持关注 React Native 的竞争对手。对于客户来说，也多了一种选择，他们可能会因为某些原因而要求使用 Fluter。我认为 Flutter 为我的客户带来了一些他们想要的东西，比如内置的类型系统、一流的 UI 库、由核心团队维护的 nav 库等。</p><p>我会把 Flutter 加入我的技术栈中，当碰到 React Native 无法解决的问题和情况时，我将会使用 Flutter。只要我觉得可以将它用于生产环境，我会向客户展示我的第一个 Flutter app，供他们选择这个技术。</p><blockquote><p>掘金链接：<a href="https://juejin.im/post/5ac43c536fb9a028da7cbd59" target="_blank" rel="noopener">https://juejin.im/post/5ac43c536fb9a028da7cbd59</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://flutter.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter&lt;/a&gt; 是一款用同一套代码构建高性能、高保真的 iOS 及安卓应用的跨平台移动端应用 SDK。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://flutter.io/technical-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flutter 包括一个 &lt;strong&gt;react 风格&lt;/strong&gt;的框架、一个 2D 渲染引擎、一些预制的插件以及开发者工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/pasted-312.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;文本希望能快速为 JavaScript 开发者们提供一个简练的入门指南，我会试着以 JS 与 npm 生态系统来类比 Flutter / Dart 与 &lt;a href=&quot;https://pub.dartlang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pub&lt;/a&gt; 包库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你对最新的 Flutter 教程、库、公告及社区的更新感兴趣，我建议您订阅双周刊 &lt;a href=&quot;http://flutternewsletter.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter Newsletter&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;我在 &lt;a href=&quot;https://react-native.eu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Native EU&lt;/a&gt; 的演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=pFtvv0rJgPw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Native — 跨平台及超越&lt;/a&gt;中讨论并演示了 React 生态系统中 &lt;a href=&quot;https://github.com/necolas/react-native-web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Native Web&lt;/a&gt;、&lt;a href=&quot;https://github.com/lelandrichardson/react-primitives&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Primitives&lt;/a&gt; 和 &lt;a href=&quot;https://microsoft.github.io/reactxp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactXP&lt;/a&gt; 的不同之处，并且我也有机会讨论 &lt;a href=&quot;https://weex.incubator.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Weex&lt;/a&gt; 及 &lt;a href=&quot;https://flutter.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter&lt;/a&gt; 的不同之处。&lt;/p&gt;
&lt;p&gt;在尝试 Flutter 之后，我认为它是近几年我所关注的前端技术中最让我激动的一个。在本文中，我将讨论为何它如此令我激动，并介绍如何尽可能快的入门 Flutter。&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="iOS" scheme="https://lsvih.com/tags/iOS/"/>
    
      <category term="React Native" scheme="https://lsvih.com/tags/React-Native/"/>
    
      <category term="Juejin" scheme="https://lsvih.com/tags/Juejin/"/>
    
      <category term="Flutter" scheme="https://lsvih.com/tags/Flutter/"/>
    
      <category term="Android" scheme="https://lsvih.com/tags/Android/"/>
    
      <category term="JavaScript" scheme="https://lsvih.com/tags/JavaScript/"/>
    
      <category term="Dart" scheme="https://lsvih.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>为 Python Web App 编写 Dockerfiles</title>
    <link href="https://lsvih.com/2018/03/19/%E4%B8%BA-Python-Web-App-%E7%BC%96%E5%86%99-Dockerfiles/"/>
    <id>https://lsvih.com/2018/03/19/为-Python-Web-App-编写-Dockerfiles/</id>
    <published>2018-03-19T09:22:00.000Z</published>
    <updated>2019-01-30T00:39:04.630Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lsvih.com/images/pasted-311.png" alt="upload successful"></p><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><p>本文涵盖了从创建简单的 Dockerfile 到生产环境多级构建 Python 应用的例子。以下为本指南的内容摘要：</p><ul><li>使用合适的基础镜像（开发环境使用 debian，生产环境使用 alpine）。</li><li>在开发时使用 <code>gunicorn</code> 进行热加载。</li><li>优化 Docker 的 cache layer（缓存层）—— 按照正确的顺序使用命令，仅在必要时运行 <code>pip install</code>。</li><li>使用 <code>flask</code> 的 static 及 template 目录部署静态文件（比如 React、Vue、Angular 生成的 bundle）。</li><li>使用 <code>alpine</code> 进行生产环境下的多级构建，减少最终镜像文件的大小。</li><li>#彩蛋 — 在开发时可以用 gunicorn 的 <code>--reload</code> 与 <code>--reload_extra_files</code> 监视文件（包括 html、css 及 js）的修改。</li></ul><p>如果你需要以上步骤的代码，请参考 <a href="https://github.com/praveenweb/python-docker" target="_blank" rel="noopener">GitHub repo</a>.</p><a id="more"></a><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>简单的 Dockerfile 与 .dockerignore</li><li>使用 gunicorn 实现热加载</li><li>运行一个单文件 python 脚本</li><li>部署静态文件</li><li>生产环境中的直接构建</li><li>生产环境中的多级构建</li></ol><p>假设我们有一个名为 python-app 的应用，为其准备一个简单的目录结构。在顶级目录下，包含 <code>Dockerfile</code> 以及 <code>src</code> 文件夹。</p><p>python app 的源码就存放在 <code>src</code> 目录中，app 的依赖关系保存在 <code>requirements.txt</code> 里。为了简洁起见，我们假设 server.py 定义了一个运行于 8080 端口的 flask 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python-app</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── src</span><br><span class="line">    └── server.py</span><br><span class="line">    └── requirements.txt</span><br></pre></td></tr></table></figure><h3 id="1-简单的-Dockerfile-样例"><a href="#1-简单的-Dockerfile-样例" class="headerlink" title="1. 简单的 Dockerfile 样例"></a>1. 简单的 Dockerfile 样例</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">COPY src/requirements.txt ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 打包 app 源码</span></span></span><br><span class="line"><span class="bash">COPY src /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"python"</span>, <span class="string">"server.py"</span> ]</span></span><br></pre></td></tr></table></figure><p>我们将使用最新版本的 <code>python:3.6</code> 作为基础镜像。</p><p>在构建镜像时，docker 会获取所有位于 <code>context</code> 目录下的文件。为了提高 docker 构建的速度，可以在 context 目录中添加 <code>.dockerignore</code> 文件来排除不需要的文件与目录。</p><p>通常，你的 <code>.dockerignore</code> 文件件应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">__pycache__</span><br><span class="line">*.pyc</span><br><span class="line">*.pyo</span><br><span class="line">*.pyd</span><br><span class="line">.Python</span><br><span class="line">env</span><br></pre></td></tr></table></figure><p>构建并运行此镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> python-docker</span><br><span class="line">$ docker build -t python-docker-dev .</span><br><span class="line">$ docker run --rm -it -p 8080:8080 python-docker-dev</span><br></pre></td></tr></table></figure><p>你将能在 <code>[http://localhost:8080](http://localhost:8080.)</code> 访问此 app。使用 <code>Ctrl+C</code> 组合键可以退出程序。</p><p>现在，假设你希望在每次修改代码（比如在本地部署时）时都运行以上代码，那么你需要在启停 python 服务时将代码源文件挂载到容器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it -p 8080:8080 -v $(pwd):/app \</span><br><span class="line">             python-docker-dev bash</span><br><span class="line">root@id:/app# python src/server.py</span><br></pre></td></tr></table></figure><h3 id="2-使用-Gunicorn-实现热更新"><a href="#2-使用-Gunicorn-实现热更新" class="headerlink" title="2. 使用 Gunicorn 实现热更新"></a>2. 使用 Gunicorn 实现热更新</h3><p><a href="http://gunicorn.org" target="_blank" rel="noopener">gunicorn</a> 是一款运行于 Unix 下的 Python WSGI HTTP server，使用的是 pre-fork worker 模型（注，Arbiter 是 gunicorn 的 master，因此称 gunicorn 为 pre-fork worker）。你可以使用各种各样的选项来配置 gunicorn。向 gunicorn 命令中传入 <code>--reload</code> 或是将 <code>reload</code> 写入配置文件，就可以让 gunicorn 在有文件发生变化时自动重启 python 服务。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">COPY gunicorn_app/requirements.txt ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 打包 app 源码</span></span></span><br><span class="line"><span class="bash">COPY gunicorn_app /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br></pre></td></tr></table></figure><p>我们将构建镜像并运行 gunicorn，以便在 <code>app</code> 目录下文件发生变动时对代码进行 rebuild。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd python-docker</span><br><span class="line">$ docker build -t python-hot-reload-docker .</span><br><span class="line">$ docker run --rm -it -p 8080:8080 -v $(pwd):/app \</span><br><span class="line">             python-hot-reload-docker bash</span><br><span class="line">root@id:/app# gunicorn --config ./gunicorn_app/conf/gunicorn_config.py gunicorn_app:app</span><br></pre></td></tr></table></figure><p>一切在 <code>app</code> 目录下 python 文件的更改都会触发 rebuild，发生的变化都能在 <code>[http://localhost:8080](http://localhost:8080.)</code> 上实时展示。请注意，我们已经将文件挂载到了容器中，因此 gunicorn 才能正常工作。</p><p><strong>其它格式的文件怎么办？</strong> 如果你希望 gunicorn 在监视代码变动的时候也监视其它类型的文件（如 template、view 之类的文件），可以在 <code>reload_extra_files</code> 参数中进行指定。此参数接受数组形式的多个文件名。</p><h3 id="3-运行一个单文件-python-脚本"><a href="#3-运行一个单文件-python-脚本" class="headerlink" title="3. 运行一个单文件 python 脚本"></a>3. 运行一个单文件 python 脚本</h3><p>你可以通过 docker run，使用 python 镜像来简单地运行 python 单文件脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --name single-python-script -v <span class="string">"<span class="variable">$PWD</span>"</span>:/app -w /app python:3 python your-daemon-or-script.py</span><br></pre></td></tr></table></figure><p>你也可以给脚本传递一些参数。在上面的例子中，我们就已经挂载了当前工作目录，也就是说可以将目录中的文件当做参数传递。</p><h3 id="4-部署静态文件"><a href="#4-部署静态文件" class="headerlink" title="4. 部署静态文件"></a>4. 部署静态文件</h3><p>上面的 Dockerfile 假定了你是使用 Python 运行一个 API 服务器。如果你想用 Python 为 React.js、Vue.js、Angular.js app 提供服务，可以使用 Flask。Flask 为渲染静态文件提供了一种便捷的方式：html 文件放在 <code>templates</code> 目录中，css、js 及图片放在 <code>static</code> 目录中。</p><p>请<a href="https://github.com/praveenweb/python-docker/tree/master/static_app" target="_blank" rel="noopener">在此 repo</a> 中查看简单的 hello world 静态 app 的目录结构。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">COPY static_app/requirements.txt ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 打包 app 源码</span></span></span><br><span class="line"><span class="bash">COPY static_app /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>,<span class="string">"server.py"</span>]</span></span><br></pre></td></tr></table></figure><p>In your server.py,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></table></figure><p>请注意，host 需要设置为 <code>0.0.0.0</code> - 这样可以让你的服务在容器外被访问。如果不设置此参数，host 会默认设为 <code>localhost</code>。</p><h3 id="5-生产环境中的直接构建"><a href="#5-生产环境中的直接构建" class="headerlink" title="5. 生产环境中的直接构建"></a>5. 生产环境中的直接构建</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">COPY gunicorn_app/requirements.txt ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 打包 app 源码</span></span></span><br><span class="line"><span class="bash">COPY . /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"gunicorn"</span>, <span class="string">"--config"</span>, <span class="string">"./gunicorn_app/conf/gunicorn_config.py"</span>, <span class="string">"gunicorn_app:app"</span>]</span></span><br></pre></td></tr></table></figure><p>构建并运行这个一体化镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> python-docker</span><br><span class="line">$ docker build -t python-docker-prod .</span><br><span class="line">$ docker run --rm -it -p 8080:8080 python-docker-prod</span><br></pre></td></tr></table></figure><p>由于底层为 Debian，构建完成后镜像约为 700MB（具体数值取决于你的源码）。下面探讨如何减小这个文件的大小。</p><h3 id="6-生产环境中的多级构建"><a href="#6-生产环境中的多级构建" class="headerlink" title="6. 生产环境中的多级构建"></a>6. 生产环境中的多级构建</h3><p>使用多级构建时，将在 Dockerfile 中使用多个 <code>FROM</code> 语句，但最后仅会使用最终阶段构建的文件。这样，得到的镜像将仅包含生产服务器中所需的依赖，理想情况下文件将非常小。</p><p>当你需要使用依赖于系统的模块或需要编译的模块时，这种构建模式十分有用。比如 <code>pycrypto</code> 和 <code>numpy</code> 就很适合这种方法。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- 基础 python 镜像 ----</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span> AS base</span><br><span class="line"><span class="comment"># 创建 app 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># ---- 依赖 ----</span></span></span><br><span class="line"><span class="bash">FROM base AS dependencies  </span></span><br><span class="line"><span class="bash">COPY gunicorn_app/requirements.txt ./</span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># ---- 复制文件并 build ----</span></span></span><br><span class="line"><span class="bash">FROM dependencies AS build  </span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">COPY . /app</span></span><br><span class="line"><span class="bash"><span class="comment"># 在需要时进行 Build 或 Compile</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># --- 使用 Alpine 发布 ----</span></span></span><br><span class="line"><span class="bash">FROM python:3.6-alpine3.7 AS release  </span></span><br><span class="line"><span class="bash"><span class="comment"># 创建 app 目录</span></span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY --from=dependencies /app/requirements.txt ./</span></span><br><span class="line"><span class="bash">COPY --from=dependencies /root/.cache /root/.cache</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装 app 依赖</span></span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash">COPY --from=build /app/ ./</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"gunicorn"</span>, <span class="string">"--config"</span>, <span class="string">"./gunicorn_app/conf/gunicorn_config.py"</span>, <span class="string">"gunicorn_app:app"</span>]</span></span><br></pre></td></tr></table></figure><p>使用上面的方法，用 Alpine 构建的镜像文件大小约 90MB，比之前少了 8 倍。使用 <code>alpine</code> 版本进行构建能有效减小镜像的大小。</p><p><strong>注意：</strong>上面的 Dockerfiles 是为 <code>python 3</code> 编写的，你可以只做少数修改就能将其改为 <code>python 2</code> 版本。如果你要部署的是 <code>django</code> 应用，也应该能通过少数改动就做出可部署于生产环境的 Dockerfiles。</p><p>如果你对前面的方法有任何建议，或希望看到别的用例，请告知作者。</p><p>欢迎加入 <a href="https://www.reddit.com/r/flask/comments/80css4/how_to_write_dockerfiles_for_python_web_apps/" target="_blank" rel="noopener">Reddit</a> 或 <a href="https://news.ycombinator.com/item?id=16471630" target="_blank" rel="noopener">HackerNews</a> 参与讨论 :)</p><hr><p>此外，你是否试过将 python web app 部署在 Hasura 上呢？这其实是将 python 应用部署于 HTTPS 域名的最快的方法（仅需使用 git push）。尝试使用 <a href="https://hasura.io/hub/projects/hasura/hello-python-flask" target="_blank" rel="noopener">https://hasura.io/hub/projects/hasura/hello-python-flask</a> 的模板快速入门吧！Hasura 中所有的项目模板都带有 Dockerfile 与 Kubernetes 标准文件，你可以自由进行定义。</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5aaf8038518825557e783285" target="_blank" rel="noopener">https://juejin.im/post/5aaf8038518825557e783285</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://lsvih.com/images/pasted-311.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h3&gt;&lt;p&gt;本文涵盖了从创建简单的 Dockerfile 到生产环境多级构建 Python 应用的例子。以下为本指南的内容摘要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用合适的基础镜像（开发环境使用 debian，生产环境使用 alpine）。&lt;/li&gt;
&lt;li&gt;在开发时使用 &lt;code&gt;gunicorn&lt;/code&gt; 进行热加载。&lt;/li&gt;
&lt;li&gt;优化 Docker 的 cache layer（缓存层）—— 按照正确的顺序使用命令，仅在必要时运行 &lt;code&gt;pip install&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;flask&lt;/code&gt; 的 static 及 template 目录部署静态文件（比如 React、Vue、Angular 生成的 bundle）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;alpine&lt;/code&gt; 进行生产环境下的多级构建，减少最终镜像文件的大小。&lt;/li&gt;
&lt;li&gt;#彩蛋 — 在开发时可以用 gunicorn 的 &lt;code&gt;--reload&lt;/code&gt; 与 &lt;code&gt;--reload_extra_files&lt;/code&gt; 监视文件（包括 html、css 及 js）的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你需要以上步骤的代码，请参考 &lt;a href=&quot;https://github.com/praveenweb/python-docker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="Docker" scheme="https://lsvih.com/tags/Docker/"/>
    
      <category term="Python" scheme="https://lsvih.com/tags/Python/"/>
    
      <category term="Gunicorn" scheme="https://lsvih.com/tags/Gunicorn/"/>
    
  </entry>
  
</feed>
