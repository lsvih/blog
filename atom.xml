<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My note</title>
  
  <subtitle>lsvih</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lsvih.com/"/>
  <updated>2020-09-05T10:52:09.667Z</updated>
  <id>https://lsvih.com/</id>
  
  <author>
    <name>lsvih</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树莓派 4 GPIO 简介及使用 Node.js 控制树莓派</title>
    <link href="https://lsvih.com/2020/09/05/an-introduction-to-raspberry-pi-4-gpio-and-controlling-it-with-node-js/"/>
    <id>https://lsvih.com/2020/09/05/an-introduction-to-raspberry-pi-4-gpio-and-controlling-it-with-node-js/</id>
    <published>2020-09-05T10:25:00.000Z</published>
    <updated>2020-09-05T10:52:09.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567.jpeg" alt="68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567"></p><blockquote><p>通过本文，我们将熟悉树莓派 GPIO 及其技术规范。并且，我们将通过了一个简单例子，说明如何使用树莓派的 I/O 控制 LED 和开关。</p></blockquote><p>你可能见过 “<strong>IoT</strong>” 这个术语，它是 <strong>Internet of Things（物联网）</strong> 的缩写。意思是，人们可以通过互联网控制一台设备（即“物” <strong>thing</strong>）。比如，用手机控制你房间内的智能电灯泡就是一种物联网的应用。</p><p>由于物联网设备可通过互联网控制，所以 IoT 设备需要始终与互联网相连。我们主要有两种方式将设备连接至互联网：以太网网线和 WiFi。</p><p>物联网设备可被用于各种目的。例如，你可以使用物联网来控制你家的室内温度、照明或者在回家前打开某些设备，所有这些操作都只需要通过你的手机便能实现。</p><p>那么，物联网设备的技术规范有哪些？简言之，它应该包含连接到互联网的工具，有一些输入和输出接口来读写设备的模拟或数字信号，并且使用最少的硬件来读取和执行程序指令。</p><p>一个物联网设备配有一个硬件组件，为外部设备读取数字数据和取电提供接口。该接口就是 <strong>GPIO</strong> 或称作 <strong>General Purpose Input Output（通用输入输出接口）</strong> 。这种硬件组件基本上都是由一系列可以连接到外部设备的引脚（或管脚，pin）构成。</p><p>这些 GPIO 引脚可以被程序控制。比如，在满足一些条件的情况下，我们可以给一个 GPIO 引脚施以 5V 的电压，任何连接到该引脚的设备都会被开启。程序也能够监听来自互联网的信号，并根据该信号对 GPIO 引脚进行控制。这就是物联网。</p><a id="more"></a><p>从头开始构建这样一个物联网设备可能很困难，因为需要处理的组件有很多。幸运的是，我们可以购买售价低廉的现成的设备。这些设备配有 GPIO 硬件和连接互联网的工具。</p><h4 id="Arduino-微控制器"><a href="#Arduino-微控制器" class="headerlink" title="Arduino 微控制器"></a>Arduino 微控制器</h4><p>目前，如果我们想要实现简单的自动化，那么 <a href="https://en.wikipedia.org/wiki/Arduino"><strong>Arduino</strong></a> 是最好的选择。它是一个 <strong>微控制器（micro-controller）</strong> ，可以用 C 和 C++ 这样的编程语言来编写 Arduino 程序。</p><p><img src="/images/15993016013204.jpg" alt=""></p><p>然而，该控制器不配有内置 WiFi 或以太网插孔，并且必须连接外部外围设备（即<strong>屏蔽</strong>）才能将 Arduino 连接到互联网。</p><p>Arduino 旨在充当外部设备的控制器，而不是成熟的物联网设备。因此，该控制器价格非常便宜，某些最新款的售价可以低至 18 美元。</p><h4 id="树莓派微型电脑"><a href="#树莓派微型电脑" class="headerlink" title="树莓派微型电脑"></a>树莓派微型电脑</h4><p>相较于 Arduino，<a href="https://en.wikipedia.org/wiki/Raspberry_Pi"><strong>树莓派</strong></a> 更像是一只<strong>野兽</strong>。其发明之初的目的就是为了促进基础计算机科学教学在学校和发展中国家的进步。但它现在却被书呆子和业余爱好者们捡起来创造各种各样的小玩意儿。目前，它是世界上最受欢迎的<strong>单板计算机</strong>之一。</p><p>树莓派（<strong>最新版 4B</strong>）配有以太网连接器、WiFi、蓝牙、HDMI 输出、USB 连接器、 40 个 GPIO 引脚和其他基本功能。它由 <strong>ARM</strong> CPU、 <strong>博通</strong> GPU 和 1/2/4 GB 的 <strong>RAM</strong> 驱动。你可以在<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications"><strong>此维基百科</strong></a>的表格中查看这些规范。</p><p><img src="/images/15993016150996.jpg" alt=""></p><p>尽管树莓派的硬件很丰富，但它最新版的售价也仅在 $40 到 $80 间。别忘了，这可是一台拥有原生操作系统的成熟计算机。这意味着我们不需要连接外部计算机就能对其进行编程。</p><p>与我们日常使用的电脑不同，树莓派提供了一个 GPIO 硬件组件来控制外部设备。这使得树莓派成为了一种几乎可以做任何事情的设备。</p><p>让我们了解一下新版树莓派 GPIO 的技术规格。</p><hr><h2 id="树莓派-GPIO-引脚分配"><a href="#树莓派-GPIO-引脚分配" class="headerlink" title="树莓派 - GPIO 引脚分配"></a>树莓派 - GPIO 引脚分配</h2><p>树莓派（<strong>4B 版</strong>）总共 <strong>40 个 GPIO 引脚</strong>，分布在 <code>20 x 2</code> 的阵列当中。如下图所示，每个引脚都有特定的用途。</p><p><img src="/images/15993016268148.jpg" alt=""></p><p>在讨论每个引脚的功能之前，让我们先了解一些协议。每个引脚都有特定的编号，我们就是通过这些编号从软件中控制这些引脚。</p><p>在圆圈中，你可以看到的数字是 GPIO 硬件上的物理引脚编号。例如：<strong>1 号引脚</strong> 提供 3.3V 的恒定电压。该编号系统称为 <strong>Board pin</strong> 或<strong>物理引脚</strong>编号系统。</p><p>由于树莓派 4B 使用 <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/README.md"><strong>BCM2711</strong></a> 处理器芯片，因此，我们还有另一个由<a href="https://en.wikipedia.org/wiki/Broadcom_Inc."><strong>博通</strong></a>创建的引脚编号系统。此系统被称为 <strong>BCM</strong> 或 <strong>博通模式</strong>。上图中，每个引脚附带的标签都显示了 BCM 引脚编号。例如：物理 <strong>7 号引脚</strong>是 <strong>BCM 7 号引脚</strong>并被标记为 <strong>GPIO 4</strong>。</p><p>我们既可以选择遵循 <strong>Board pin</strong> 编码，也可以用 <strong>BCM</strong> 编码系统。然而，由于我们用 GPIO 编程库的原因，同时使用该两种编码系统可能会遇到问题。大多数库都偏好于 BCM 编号系统，因为它引用于博通 CPU 芯片。</p><blockquote><p>从现在开始，如果文中出现 <strong>x 号引脚</strong>，就意味着这是引脚板上的<strong>物理引脚编号</strong>。如果提到了 BCM，则意味着我们在使用 BCM 引脚编号。</p></blockquote><h4 id="💡-电源引脚和引脚分组"><a href="#💡-电源引脚和引脚分组" class="headerlink" title="💡 电源引脚和引脚分组"></a>💡 电源引脚和引脚分组</h4><p><strong>1 号</strong>和 <strong>17 号</strong>引脚提供 <strong>3.3V</strong> 电源，而 <strong>2 号</strong>和 <strong>4 号</strong>引脚提供 <strong>5V</strong> 电源。当你打开树莓派时，这些引脚便会提供<strong>恒定功率</strong>，并且无论在何种条件下，这几个引脚都是<strong>不可编程的</strong>。</p><p><strong>6 号</strong>、 <strong>9 号</strong>、 <strong>14 号</strong>、 <strong>20 号</strong>、 <strong>25 号</strong>、 <strong>30 号</strong>、 <strong>34 号</strong>和 <strong>39 号</strong>引脚支持接地。它们应该与电路的<strong>阴极</strong>相连。电路中所有的接地连接都可以用同一个接地引脚，因为它们都连接到同一根地线。</p><blockquote><p>如果你想知道为什么有这么多接地引脚，可以查看<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=132851"><strong>这个帖子</strong></a>。</p></blockquote><h4 id="🔌-GPIO-引脚"><a href="#🔌-GPIO-引脚" class="headerlink" title="🔌 GPIO 引脚"></a>🔌 GPIO 引脚</h4><p>除了<strong>电源</strong>和<strong>接地</strong>引脚外，其他引脚均为通用输入和输出引脚。当 GPIO 引脚用于<strong>输出模式</strong>时，它在开启时提供 3.3V 恒定功率。</p><p>在<strong>输入模式</strong>下，GPIO 引脚也可用于监听外部电源。从技术上看，当用 <strong>3.3V</strong> 电压供给处于输入模式的 GPIO 引脚时，该引脚将被读取为<strong>逻辑高电平</strong>或 <strong>1</strong>。当引脚接地或提供 <strong>0V</strong> 功率时，它会被读作<strong>逻辑低电平</strong>或 <strong>0</strong>。</p><p>而<strong>输出模式</strong>更加简单。在输出模式下，我们接通一个引脚，设备会通过该引脚提供 3.3V 的电压。而在引脚的输入端，我们需要监听引脚上的电压变化，当引脚处于逻辑高电平或低电平时，我们可以执行其他操作，如打开一个输出 GPIO 引脚。</p><h4 id="🧙‍♀️-SPI、-I²C-和-UART-协议"><a href="#🧙‍♀️-SPI、-I²C-和-UART-协议" class="headerlink" title="🧙‍♀️ SPI、 I²C 和 UART 协议"></a>🧙‍♀️ SPI、 I²C 和 UART 协议</h4><p>SPI（<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface"><strong>Serial Peripheral Interface (串行外设接口)</strong></a>）是一种同步串行通信接口，设备可以使用它来实现相互间的通信。此接口需要 3 条或更多数据线将主设备连接到（<strong>一个或多个</strong>）从设备。</p><p>I²C（<a href="http://C"><strong>Inter-Integrated Circuit (内置集成电路)</strong></a>）类似于 SPI，但它支持多个主设备。此外，与 SPI 不同，它只需要两条数据线来容纳多个从机。不过这会让 I²C 比 SPI 慢。</p><p>UART（<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">Universal asynchronous receiver-transmitter (通用异步收发传输器)</a>）也是一个串行通信接口，但数据是<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication"><strong>异步</strong></a>发送的。</p><p>树莓派提供了一个底层接口用于通过 GPIO 引脚就像我们前文讨论过的输入输出模式一样启用这些接口。然而，并非所有的 GPIO 引脚都可以实现这些通信方式。</p><p>在下图中，你可以看到哪些 GPIO 针脚是可以通过 SPI、I²C 和 UART 协议进行配置的。你可以访问 <strong><a href="https://pinout.xyz/">pinout.xyz</a></strong>，这个网页提供了一个交互界面供用户查看每个 GPIO 引脚的功能。</p><p><img src="/images/15993016462986.jpg" alt=""></p><p>除了简单的输入或输出模式，GPIO 引脚有 <strong>6 种模式</strong>，但每次只能在一种模式下工作。当你在上面那个网页中点击 GPIO 引脚时，你可以在屏幕右侧看到它的工作模式。右表中的 ALT0 至 ALT5 描述了这些模式。</p><blockquote><p>你还可以通过<a href="https://www.youtube.com/watch?v=IyGwvGzrqp8"><strong>这个视频</strong></a>来了解这些通信协议的规范。在本教程中，我们不会涉及这些通信协议，但是，我将在接下来的文章中讨论相关主题。</p></blockquote><h4 id="⚡-现行规范"><a href="#⚡-现行规范" class="headerlink" title="⚡ 现行规范"></a>⚡ 现行规范</h4><p>我们已经讨论过电源和 GPIO 引脚的电压规格。因为树莓派官方文件中未曾提及具体规范，所以现行规范还不太明确。</p><p>不过可以确定的是，我们在处理电流时，必须要遵循安全措施：从任何引脚获取的最大电流应小于或等于 <strong>16mA</strong>。因此，我们必须调整负载以满足这一要求。</p><p>如果我们已经将多个设备连接到树莓派 GPIO 和其他端口（如 USB），那么我们必须确保从电路获取的最大电流小于 <strong>50mA</strong>。</p><p>为了限制电流，我们可以在电路中增加电阻，使得最大电流不会超过这些限制。当一个设备需要的电流比树莓派的最大限制还要大时，应当使用继电器开关。</p><p><strong>输入</strong>模式使用的也是相同的规范。当 GPIO 引脚被用作<strong>漏极</strong>（<strong>而非</strong> 源 <strong>电流</strong>）时，我们不应该供应超过 <strong>16mA</strong> 的电流。此外，当多个 GPIO 引脚用作输入时，总共不应施加超过 <strong>50mA</strong> 的电流。</p><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>我相信你已经走过一遍树莓派的设置流程。这意味着你已经安装了一个 <a href="https://www.raspberrypi.org/downloads/raspbian/"><strong>Raspbian</strong></a> 之类的或是你个人偏好的操作系统，并且可以通过 SSH 或 HDMI 访问它。</p><p>我们需要做的第一件事就是创建项目目录。我已经在 <code>/home/pi/Programs/io-examples</code> 这个路径下创建了项目目录，我们所有的程序都将作为教程示例保存在该路径下。</p><p>由于我们想通过 Node.js 来控制 GPIO 引脚，首先我们必须安装 Node。你可以选择你最喜欢的方法，但我个人会使用 <strong><a href="https://github.com/nvm-sh/nvm">NVM</a></strong>（Node 版本管理器）来安装。你可以遵循<a href="https://github.com/nvm-sh/nvm#install--update-script"><strong>该建议步骤</strong></a>安装 NVM。</p><p>一旦装好了 NVM，我们就可以安装特定版本的 Node。我将使用 Node v12，因为它是最新的稳定版本。要安装 Node v12，请输入以下命令行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 12</span><br><span class="line">nvm use 12</span><br></pre></td></tr></table></figure><p>一旦树莓派安装了 Node.js，我们就可以继续创建项目了。因为我们想要控制 GPIO 引脚，所以我们需要一个库来为我们提供一个简单的应用编程接口。</p><p><a href="https://www.npmjs.com/package/onoff"><strong>onoff</strong></a> 是一个知名的用树莓派控制 GPIO 的库。首先，在项目目录中创建 package.json，然后安装 <code>onoff</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/pi/Programs/io-examples</span><br><span class="line">npm init -y</span><br><span class="line">npm i -S onoff</span><br></pre></td></tr></table></figure><p>现在一切准备就绪，我们可以开始电路设计并编写第一个程序来测试 GPIO 的能力。</p><hr><h2 id="LED-输出示例"><a href="#LED-输出示例" class="headerlink" title="LED 输出示例"></a>LED 输出示例</h2><p>在本例中，我们将以编程方式打开红色 LED。让我们先看看下面的电路图：</p><p><img src="/images/15993016620920.jpg" alt=""></p><p>从上图可以看出，我们已经将 <strong>6 号引脚</strong>（<strong>接地引脚</strong>）连接到了线路板的负极（<strong>地线</strong>）上，并将 <strong>BCM 4</strong> 连接到了 <strong>1k ohm</strong> 电阻的一端。电阻器的另一端连接到红色 LED 的输入端上，LED 的输出端接地。</p><p>除了有个电阻，这个电路没什么特别的。需要这个额外的电阻是因为红色 LED 在 <strong>2.4V</strong> 电压下工作，而提供 <strong>3.3V</strong> 电压的 GPIO 会损坏 LED。此外，LED 采用的 <strong>20mA</strong> 超过了树莓派的安全阈值，因此，也需要这个电阻来防止电流过大。</p><blockquote><p>我们可以选择 330 ohms 到 1k ohms 的电阻。这个数值范围的电阻会影响电流大小，但都不会损坏 LED。</p></blockquote><p>从上述电路来看，电路中唯一的变量是 BCM 4 引脚输出。如果引脚打开（<strong>3.3V</strong>），电路将闭合，LED 将发光。如果引脚关闭（<strong>0V</strong>），电路断开，LED 不会发光。</p><p>让我们编写一个程序，实现以编程方式打开 BCM 4 引脚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 4 pin as &#x27;output&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ledOut = <span class="keyword">new</span> Gpio( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;out&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// current LED state</span></span><br><span class="line"><span class="keyword">let</span> isLedOn = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run a infinite interval</span></span><br><span class="line"><span class="built_in">setInterval</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ledOut.writeSync( isLedOn ? <span class="number">0</span> : <span class="number">1</span> ); <span class="comment">// provide 1 or 0 </span></span><br><span class="line">  isLedOn = !isLedOn; <span class="comment">// toggle state</span></span><br><span class="line">&#125;, <span class="number">3000</span> ); <span class="comment">// 3s</span></span><br></pre></td></tr></table></figure><p>在上述程序中， 我们导入 <code>onoff</code> 包并引入 <code>Gpio</code> 构造函数。用设定好的配置创建 <code>Gpio</code> 类来配置一个 GPIO。上面的例子中，我们将 <strong>BCM 4</strong> 设置成了<strong>输出模式</strong>。</p><blockquote><p>你可以参考该 <code>onoff</code> 模块的 <a href="https://github.com/fivdi/onoff#api"><strong>API 文档</strong></a>来了解各种配置选项和 API。</p></blockquote><p><code>Gpio</code> 类创建的实例提供了与该引脚交互的高阶 API。<code>writeSync</code> 方法会将 <strong>1</strong> 或 <strong>0</strong> 写入引脚，以实现开启或关闭引脚。当引脚设为 <strong>1</strong> 时，引脚<strong>开启</strong>并输入 <strong>3.3V</strong> 电源。当它设为 <strong>0</strong> 时，引脚会<strong>关闭</strong>且不再提供任何电源电压（<strong>0V</strong>）。</p><p>使用 <code>setInterval</code> 时，我们就是在运行一个无限循环，不断地调用 <code>ledOut.writeSync(val)</code> 方法在 <code>ledOut</code> 引脚中写入 0 或 1。让我们使用 Node.js 来运行这个程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node rpi-led-out.js</span><br></pre></td></tr></table></figure><p>由于这是一个无限循环的程序，一旦启动，它就不会终止，除非我们使用 <code>ctrl + c</code> 强制终止程序。在该程序的生命周期内，它将每隔 <strong>3 秒</strong>切换一次 <strong>BCM 4</strong> 引脚的状态。</p><p>树莓派 GPIO 有意思的一点是，一旦 GPIO 引脚被设为 <strong>1</strong> 或 <strong>0</strong>，它将一直保持不变， 除非我们覆盖该值或关闭树莓派的电源。比如，当你启动程序时，LED 处于熄灭状态，但当你终止程序时，LED 可能会保持亮起状态。</p><h2 id="开关输入示例"><a href="#开关输入示例" class="headerlink" title="开关输入示例"></a>开关输入示例</h2><p>众所周知，当把 GPIO 用作输入时，我们需要提供接近 <strong>3.3V</strong> 的电压。我们可以连接一个开关（<strong>按钮</strong>）直接从 <strong>3.3V</strong> 引脚提供电压，如下图所示：</p><p><img src="/images/15993016750320.jpg" alt=""></p><p>在输入开关之前，我们已经在电路中使用了一个 <strong>1K ohm</strong> 的电阻。它能防止 <strong>3.3V</strong> 电源产生过大的电流，避免开关熔断。</p><p>我们还连接了一个 <strong>10K ohm</strong> 电阻，该电阻也从按钮的输出端汲取电流并接地。这类电阻被称为<strong>下拉</strong>电阻（<strong>因为它们在电路中的位置</strong>），它们会将电流（<strong>或大气中电荷聚集产生的电流</strong>）导向地面。</p><blockquote><p>我们也可以增加一个<strong>上拉电阻</strong>，从 <strong>3.3V</strong> 引脚导出电流，供给给 GPIO 的输入引脚。在这种配置下，输入引脚会始终读取 <strong>高</strong> 或 <strong>1</strong>。按下按钮时，开关在电阻和地面之间产生短路，将所有电流导向地面，并且没有电流通过开关到达输入引脚，读数为 <strong>0</strong>。<a href="https://www.youtube.com/watch?v=5vnW4U5Vj0k"><strong>此处有一段很棒的视频</strong></a>演示了上拉和下拉电阻。</p></blockquote><p>开关的输出连接到 <strong>BCM 17</strong> 引脚。当按下按钮（<strong>开关</strong>）时，电流将通过开关流入 BCM 17 引脚。然而，由于 10K ohm 电阻给电流提供了更大的障碍，大多数电流会流向由<strong>红色虚线</strong>表示的回路。</p><p>未按下按钮时，由红色虚线表示的回路闭合，没有电流流过。然而，由<strong>灰色虚线</strong>表示的环路是闭合的，BCM 17 引脚接地（<strong>0V</strong>）。</p><blockquote><p>增加一个 10k ohm 电阻是为了让 BCM 17 引脚接地，这样它就不会将任何大气干扰读取为高输入。如果不将输入引脚接地，输入引脚会保持在<strong>浮动状态</strong>。在这种状态下，由于大气干扰，输入引脚可能读取为 0 或 1。</p></blockquote><p>既然电路已经准备好了，让我们编写一个程序来读取输入值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 17 pin as &#x27;input&#x27;</span></span><br><span class="line"><span class="keyword">const</span> switchIn = <span class="keyword">new</span> Gpio( <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;both&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen for pin voltage change</span></span><br><span class="line">switchIn.watch( <span class="function">(<span class="params"> err, value </span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( err ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Error&#x27;</span>, err );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// log pin value (0 or 1)</span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&#x27;Pin value&#x27;</span>, value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上面的程序中，我们将 <strong>BCM 17</strong> 引脚设置为输入模式。<code>Gpio</code> 构造函数的第三个参数配置了我们何时需要引脚输入电压变化的通知。该参数名为 <strong><code>edge</code></strong>，因为我们读取的是电压上升和下降周期的边缘电压值。</p><p><code>edge</code> 参数可以有以下值：</p><p>当使用 <code>rising</code> 值时，如果 GPIO 引脚的输入电压<strong>从 0V 上升</strong>（<strong>至 3.3V</strong>），我们将收到通知。位于此位置时，引脚将读取<strong>逻辑高位</strong>或 <strong>1</strong>，因为该引脚获得了更高的电压。</p><p>当使用 <code>falling</code> 值时，如果输入电压（<strong>从 3.3V</strong>） <strong>降至 0V</strong>，我们将收到通知。位于此位置时，引脚将读取<strong>逻辑低位</strong>或 <strong>0</strong>，因为它正在失去电压。</p><p>当使用 <code>both</code> 值时，我们将收到上述两个事件的通知。当电压从 0V 上升（<strong>至输入高电平或 1</strong>）或从 3.3V 下降（<strong>至输入低电平或 0</strong>）时，我们都会收到到这些事件的通知。</p><blockquote><p>此处不讨论 <code>none</code> 值，请阅读<a href="https://github.com/fivdi/onoff#gpiogpio-direction--edge--options"><strong>文档</strong></a>了解更多信息。</p></blockquote><p>输入模式下 GPIO 引脚上的 <code>watch</code> 方法监视上述事件。这是一个异步方法，因此我们需要传递一个回调函数，该函数接收输入高（1）或输入低（0）值。</p><p>由于我们使用的是 <code>both</code> 值，所以 <code>watch</code> 方法将在输入电压上升时以及输入电压下降时都执行回调。按下按钮，你应该会在控制台中看到下面的值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pin value <span class="number">1</span> (按下按钮)</span><br><span class="line">Pin value <span class="number">0</span> (释放按钮)</span><br><span class="line">Pin value <span class="number">1</span> (按下按钮)</span><br><span class="line">Pin value <span class="number">1</span> (重复值)</span><br><span class="line">Pin value <span class="number">0</span> (按下按钮)</span><br></pre></td></tr></table></figure><p>如果仔细检查以上输出就能发现，我们有时会在按下或释放按钮时得到重复的值。由于开关机制的两个连接器之间的物理连接并不总那么顺畅，所以，不小心按下开关时，它可以多次连接和断开。</p><p>为了避免这种情况，我们可以在开关电路中增加电容，在实际电流流入 GPIO 引脚之前充电，并在按钮释放时平稳放电。这种方法非常简单，你可以试一试。</p><h2 id="组合-I-O-示例"><a href="#组合-I-O-示例" class="headerlink" title="组合 I/O 示例"></a>组合 I/O 示例</h2><p>现在我们已经充分理解了 GPIO 引脚的工作原理以及配置方法，让我们结合最后两个例子进行讲解。更重要的是，按下按钮时，打开 LED 而释放按钮时关闭 LED。让我们先看看电路图：</p><p><img src="/images/15993016891138.jpg" alt=""></p><p>从以上例子可以看出，我们没有从上面的两个例子中改变任何东西。另外，LED 和开关电路都是独立的。这意味着我们之前的程序在这条线路上应该可以正常工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Gpio &#125; = <span class="built_in">require</span>( <span class="string">&#x27;onoff&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 4 pin as &#x27;output&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ledOut = <span class="keyword">new</span> Gpio( <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;out&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// set BCM 17 pin as &#x27;input&#x27;</span></span><br><span class="line"><span class="keyword">const</span> switchIn = <span class="keyword">new</span> Gpio( <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;both&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen for pin voltage change</span></span><br><span class="line">switchIn.watch( <span class="function">(<span class="params"> err, value </span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>( err ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Error&#x27;</span>, err );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the input value (0 or 1) &#x27;ledOut&#x27; pin</span></span><br><span class="line">  ledOut.writeSync( value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>在上述程序中，我们将 GPIO 引脚分别配置为输入和输出模式。由于输入引脚上的 <code>watch</code> 方法提供的值是 <strong>0</strong> 或 <strong>1</strong>，因此，我们直接把这些值写入输出引脚。</p><p>因为我们在 <code>both</code> 模式下用 <code>watch</code> 方法监视输入引脚，当按下按钮发送 <strong>1</strong> 或者释放按钮发送 <strong>0</strong> 时，<code>watch</code> 方法的回调将被触发。</p><p>我们可以直接使用该值写入 <code>ledOut</code> 引脚。因此，按下按钮时，<code>value</code> 为 <code>1</code> 并执行 <code>ledOut.writeSync(1)</code>，会打开 LED。松开按钮时则反之。</p><hr><p><img src="/images/1_a35VFbnt_AUM0ch8ftCxMA.gif" alt="1_a35VFbnt_AUM0ch8ftCxMA"></p><p>以上是我们刚才创建的完整输入/输出电路的演示。为了你本人和树莓派的安全，建议买一个好的外壳和 40 针 GPIO 扩展带状电缆。</p><p>希望你今天能学到一点东西。在接下来的教程中，我们将构建一些复杂的电路并学习连接一些有意思的设备，如字符 LCD 显示屏和数字输入板。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/6868946182325043207">https://juejin.im/post/6868946182325043207</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567.jpeg&quot; alt=&quot;68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f31323030302f312a742d64725f3543724b663435524530557577773273672e6a706567&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过本文，我们将熟悉树莓派 GPIO 及其技术规范。并且，我们将通过了一个简单例子，说明如何使用树莓派的 I/O 控制 LED 和开关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可能见过 “&lt;strong&gt;IoT&lt;/strong&gt;” 这个术语，它是 &lt;strong&gt;Internet of Things（物联网）&lt;/strong&gt; 的缩写。意思是，人们可以通过互联网控制一台设备（即“物” &lt;strong&gt;thing&lt;/strong&gt;）。比如，用手机控制你房间内的智能电灯泡就是一种物联网的应用。&lt;/p&gt;
&lt;p&gt;由于物联网设备可通过互联网控制，所以 IoT 设备需要始终与互联网相连。我们主要有两种方式将设备连接至互联网：以太网网线和 WiFi。&lt;/p&gt;
&lt;p&gt;物联网设备可被用于各种目的。例如，你可以使用物联网来控制你家的室内温度、照明或者在回家前打开某些设备，所有这些操作都只需要通过你的手机便能实现。&lt;/p&gt;
&lt;p&gt;那么，物联网设备的技术规范有哪些？简言之，它应该包含连接到互联网的工具，有一些输入和输出接口来读写设备的模拟或数字信号，并且使用最少的硬件来读取和执行程序指令。&lt;/p&gt;
&lt;p&gt;一个物联网设备配有一个硬件组件，为外部设备读取数字数据和取电提供接口。该接口就是 &lt;strong&gt;GPIO&lt;/strong&gt; 或称作 &lt;strong&gt;General Purpose Input Output（通用输入输出接口）&lt;/strong&gt; 。这种硬件组件基本上都是由一系列可以连接到外部设备的引脚（或管脚，pin）构成。&lt;/p&gt;
&lt;p&gt;这些 GPIO 引脚可以被程序控制。比如，在满足一些条件的情况下，我们可以给一个 GPIO 引脚施以 5V 的电压，任何连接到该引脚的设备都会被开启。程序也能够监听来自互联网的信号，并根据该信号对 GPIO 引脚进行控制。这就是物联网。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Node.js" scheme="https://lsvih.com/tags/Node-js/"/>
    
      <category term="IoT" scheme="https://lsvih.com/tags/IoT/"/>
    
      <category term="GPIO" scheme="https://lsvih.com/tags/GPIO/"/>
    
      <category term="Raspberry Pi" scheme="https://lsvih.com/tags/Raspberry-Pi/"/>
    
      <category term="Hardware" scheme="https://lsvih.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 应用中引入 CSS 的几种方式</title>
    <link href="https://lsvih.com/2020/08/31/the-many-ways-to-include-css-in-javascript-applications.md/"/>
    <id>https://lsvih.com/2020/08/31/the-many-ways-to-include-css-in-javascript-applications.md/</id>
    <published>2020-08-31T08:37:00.000Z</published>
    <updated>2020-08-31T08:38:01.981Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/css-vs-js.png" alt="css-vs-js"></p><p>欢迎你踏上了一条在前端世界中饱含争议的道路！相信大部分读者会在关于如何<a href="https://css-tricks.com/tag/css-in-js/">在 JavaScript 应用中处理 CSS</a> 这一话题上产生共鸣。</p><p>文章伊始，先声明一句：<strong>无论是在基于 Vue、Angular 还是 React 构建的应用，针对如何处理 CSS，世界上并没有任何放之四海而皆准的方法。</strong>各个项目皆有不同，每种方式也有可取之处！可能这么说显得含糊其辞，但就我所知，在我们的开发社区内，那些追寻新知识，推动网页开发向前发展的人举目皆是。</p><p>让我们放下对本文话题的感性认知，先领会下 CSS 世界架构的奇妙之处。</p><a id="more"></a><h3 id="让我们盘点一番引入-CSS-的方式"><a href="#让我们盘点一番引入-CSS-的方式" class="headerlink" title="让我们盘点一番引入 CSS 的方式"></a>让我们盘点一番引入 CSS 的方式</h3><p>单单谷歌一下“如何在框架内加入 CSS”，各种言辞凿凿的关于如何在项目中应用样式的观点和看法便映入眼帘。排除一些无关紧要的信息，我们可以先宏观上挑选出更通用的方法和目的检验一番。</p><h4 id="选项-1：-传统样式表"><a href="#选项-1：-传统样式表" class="headerlink" title="选项 1： 传统样式表"></a>选项 1： 传统样式表</h4><p>先从我们最熟悉的方式开始：老掉牙的样式表。我们自然可以在应用中 <code>&lt;link&gt;</code> 一个外部样式表，活儿就完了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以一如往常地写熟悉的 CSS。这样做在一般情况下倒没什么问题，然而，当应用逐渐臃肿、越来越复杂时，维护一个样式表就变成了难题。上千行的 CSS 对应整个应用的样式，开发者要维护这样的样式表将痛苦不堪。样式级联看着很美好，但控制样式也同样困难，比如某个开发改动了一部分样式，会导致其它部分也因此需要跑回归测试。这些问题似曾相识，也因此 <a href="https://sass-lang.com/">Sass</a>（和更新的 <a href="https://github.com/postcss/postcss">PostCSS</a>）悉数登出救场。</p><p>顺着这个思路，我们用 PostCSS 来攥写模块化的 CSS 片段，并通过 <code>@import</code> 将这些模块组合起来。虽然这需要花点精力配置 webpack，但这对你来说不成问题！</p><p>无论你最终选择了哪种编译器，它们最终都会通过一个头部的 <code>&lt;link&gt;</code> 标签，把所有的样式扔在一个 CSS 文件内。随着应用日益复杂，这个文件将更加臃肿，异步加载将变得缓慢，从而阻塞了应用的其余部分的渲染（当然，阻塞渲染不<strong>总是</strong>是件坏事，但总体来说，我们还是会尽量避免使用会阻塞渲染的样式和脚本）。</p><p>我并不是说这种方式毫无可取之处。对于小应用来说，抑或对前端开发并不重视的团队们来讲，一张样式表足以满足需求了。它清晰地分离了业务逻辑和样式，而且它不是生成的，对开发者而言所写即所得，随心所欲。此外，浏览器也可以轻松缓存这张样式表，所以那些回头客们也就不用重新下载了。</p><p>而我们现在所寻找的，是一种能够完全发挥工具优势、稳健的 CSS 架构。这种架构需要能通过一种精细的方式，管理整个应用：CSS 模块化呼之欲出。</p><h4 id="选项-2：CSS-模块化"><a href="#选项-2：CSS-模块化" class="headerlink" title="选项 2：CSS 模块化"></a>选项 2：CSS 模块化</h4><p>单张样式表一个严峻的问题是回归的风险。样式表内写一个模糊选择器样式可能会改动到另一个无关组件的样式。带作用域的样式此刻就发挥了其作用。</p><p>带作用域的样式可以程序化的生成对应组件的明确类名，以确保它们的类名唯一。自动生成的类名例如 <code>header__2lexd</code>，后面那小部分是选择器唯一的哈希值。当一个组件叫 header 时，你可以给它的类名取名为 header，程序将自动生成类似 <code>header__15qy_</code> 的新哈希后缀。</p><p>基于不同的实现方式，CSS 模块生成类名的方式不尽相同，这部分我就不赘述了，请参考 <a href="https://github.com/css-modules/css-modules/tree/master/docs">CSS 模块化文档</a>。</p><p><strong>到头来，在浏览器内我们仍然是用头部的 <code>&lt;link&gt;</code> 标签来加载使用生成的单个 CSS 文件。</strong>伴随而来的有潜在问题（诸如阻塞渲染、文件大小膨胀等），和上文提到的些许好处（缓存是主要优势）。一个需要注意的点是：这种方法移除了全局作用域 —— 起码一开始没有，而这正是其样式作用域所致。</p><p>比如在一个应用内，你想将一个全局的类名 <code>.screen-reader-text</code> 应用在任何一个组件上，当你使用 CSS 模块化时，你得在 <code>:global</code> 伪选择器内定义样式，才能使得这个类样式能被其它组件引用到；接着你需要把这个带有全局选择器的文件导入到各个组件的样式表内，才能生效。这样做虽然不算麻烦，但还是得花点力气习惯这种做法。</p><p>这是一个使用 <code>:global</code> 伪选择器的范例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// typography.css</span><br><span class="line"><span class="selector-pseudo">:global</span> &#123;</span><br><span class="line">  .aligncenter &#123;</span><br><span class="line">    <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.alignright</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.alignleft</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能得冒险把一大摞的字体、表格和大部分页面都有的通用元素样式扔进这一个 <code>:global</code> 选择器。幸好 <a href="https://github.com/postcss/postcss-nested">PostCSS Nested</a> 或者 Sass 可以帮你导入样式表，让代码看着更加清爽。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.scss</span></span><br><span class="line">:global &#123;</span><br><span class="line">  @import <span class="string">&quot;typography&quot;</span>;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&quot;forms&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样，把部分样式抽离出来，不再需要用 <code>:global</code> 伪选择器包装，只需要在主样式表中导入即可。</p><p>还有一点需要适应的是，在 DOM 节点中引用类名的方式。这点 <a href="https://vue-loader.vuejs.org/guide/css-modules.html#usage">Vue</a>、<a href="https://github.com/css-modules/css-modules/blob/master/docs/css-modules-with-react.md">React</a> 和 <a href="https://github.com/css-modules/css-modules/blob/master/docs/css-modules-with-angular.js.md">Angular</a> 在它们的文档中都有说明。我这里也有一些例子，可以说明在 React 组件内，这些类是如何被引用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./css/Button.css</span></span><br><span class="line"></span><br><span class="line">.btn &#123;</span><br><span class="line">  background-color: blanchedalmond;</span><br><span class="line">  font-size: <span class="number">1.4</span>rem;</span><br><span class="line">  padding: <span class="number">1</span>rem <span class="number">2</span>rem;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  transition: background-color ease <span class="number">300</span>ms, border-color ease <span class="number">300</span>ms;</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./Button.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./css/Button.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;button className=&#123;styles.btn&#125;&gt;</span><br><span class="line">    Click me!</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button;</span><br></pre></td></tr></table></figure><p>CSS 模块化有诸多精彩的用例。如果你在寻找一种带作用域的样式，又希望保留静态样式的优势，那么 CSS 模块化正适合你。</p><p>同样值得注意的是，CSS 模块化可以和你喜爱的 CSS 预处理器相结合。通过 CSS 模块化，诸如 Sass、Less、PostCSS 等 CSS 预处理工具与插件都可以结合进项目构建过程中。</p><p>但是，假如你的应用程序是基于 JavaScript 开发的，那么如果 CSS 样式也可以访问组件的各种状态，并根据状态的变化做出反应，也会是不错的路子。假设你希望轻松地将关键 CSS 加入到应用程序中，有请 CSS-in-JS！</p><h4 id="选项-3：CSS-in-JS"><a href="#选项-3：CSS-in-JS" class="headerlink" title="选项 3：CSS-in-JS"></a>选项 3：CSS-in-JS</h4><p>CSS-in-JS 这个话题颇为宽泛。也有一些库致力于轻松书写 CSS-in-JS。像 <a href="https://cssinjs.org/?v=v10.0.0-alpha.16">JSS</a>、<a href="https://emotion.sh/docs/introduction">Emotion</a> 和 <a href="https://www.styled-components.com/">Styled Components</a> 这类框架扛起了 CSS-in-JS 的大旗。</p><p>总体而言，这些框架大部分的实现方式是相通的。它们都会给单个组件写样式，并在构建过程中<strong>只编译页面上即将渲染的组件</strong>的 CSS。CSS-in-JS 框架通过 <code>&lt;head&gt;</code> 内的 <code>&lt;style&gt;</code> 标签输出 CSS，这种关键 CSS 加载策略开箱即用，并且像 CSS 模块化一样包含作用域，类名也经过了哈希。</p><p>当你在应用内跳转时，卸载的组件会把对应的样式从 <code>&lt;head&gt;</code> 内移除，加载的组件会加上对应的样式，因此性能得到了提升。不再有 HTTP 请求，也不会阻塞渲染，还确保了浏览器只会下载用户需要看到的样式。</p><p>有趣的是，CSS-in-JS 可以获取不同组件的状态和方法，借此渲染不同的 CSS。它可以像基于状态改变而重复加减类名那样简单，也可以像制作一套主题那样复杂。</p><p>因为 CSS-in-JS 着实是热门话题，我知道许多人也有不同的实践。我对 CSS-in-JS 的第一反应是十分负面的，我不喜欢 CSS 和 JS 两者这个理念在一起交叉污染，但我还是想保持开放的心态，因此需要从前端开发者的角度来评估哪些功能是我们<strong>需要</strong>的。现在我将分享一些其他人的感受，这群人非常重视 CSS，尤其是用 JS 写 CSS：</p><ul><li>如果我们采用 CSS-in-JS，我们就得编写<strong>纯正</strong>的 CSS。有些包提供了编写 CSS-in-JS 的模板，但你得使用驼峰式命名 - 即 <code>padding-left</code> 变成 <code>paddingLeft</code>。这不是我个人想放弃的习惯。</li><li>一些 CSS-in-JS 方案要求你在需要样式的元素上编写内联样式。特别是在复杂的组件中，它的语法，开始变得非常冗繁，同样我也不想妥协。</li><li>要想让我使用 CSS-in-JS，它必须得有强大的工具，需要能解决 CSS 模块化或传统的样式表难以解决的痛点。</li><li>我们必须能够利用具有前瞻性思维的 CSS，如嵌套和变量。为了增强开发人员体验，我们还必须能够结合诸如 <a href="https://css-tricks.com/autoprefixer/">Autoprefixer</a> 和其它的附加组件。</li></ul><p>此外针对框架还有很多问题。但对于我们这些人来说，一生中大部分时间都在研究和实施我们喜爱语言的解决方案，我们要确保尽最大的可能把同样的语言写到最好。</p><p>下面是使用 Styled Components 的 React 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./Button.js</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StyledButton = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blanchedalmond;</span></span><br><span class="line"><span class="string">  font-size: 1.4rem;</span></span><br><span class="line"><span class="string">  padding: 1rem 2rem;</span></span><br><span class="line"><span class="string">  text-transform: uppercase;</span></span><br><span class="line"><span class="string">  transition: background-color ease 300ms, border-color ease 300ms;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: #000;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">StyledButton</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">StyledButton</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Button;</span><br></pre></td></tr></table></figure><p>我们还需要探索 CSS-in-JS 解决方案的潜在缺点 —— 绝对不是我加戏。使用 CSS-in-JS，我们很容易落入另一个陷阱，日积月累写出一个组件里有几百行 CSS 的臃肿的 JavaScript 文件，让开发者难以辨别组件的方法和结构。但同时，我们可以非常仔细地检查我们如何以及为什么要如此构建组件。在更深入地思考这个问题时，我们可以利用它并编写更精简的代码和更多可重用的组件。</p><p>此外，此方法完全模糊了业务逻辑和应用程序样式之间的界限。但只要架构的文档完备且经过深思熟虑，项目中的其他开发人员便可以放心遵从这个想法而不会不知所措。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在有各种各样的框架和方法可以在任何项目中解决 CSS 架构问题。我们作为开发者，有<strong>如此之多的选择</strong>，是让人无比兴奋的。然而我们仍会在碎片化社交媒体中产生选择困难症，因为每个解决方案都有其优点和不足的缺点。归根结底，我们是在讨论如何仔细而周密地实现系统在未来可控，让未来的我们和开发人员们感谢自己曾花时间建立这个架构。</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/6867054761741549576">https://juejin.im/post/6867054761741549576</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/css-vs-js.png&quot; alt=&quot;css-vs-js&quot;&gt;&lt;/p&gt;
&lt;p&gt;欢迎你踏上了一条在前端世界中饱含争议的道路！相信大部分读者会在关于如何&lt;a href=&quot;https://css-tricks.com/tag/css-in-js/&quot;&gt;在 JavaScript 应用中处理 CSS&lt;/a&gt; 这一话题上产生共鸣。&lt;/p&gt;
&lt;p&gt;文章伊始，先声明一句：&lt;strong&gt;无论是在基于 Vue、Angular 还是 React 构建的应用，针对如何处理 CSS，世界上并没有任何放之四海而皆准的方法。&lt;/strong&gt;各个项目皆有不同，每种方式也有可取之处！可能这么说显得含糊其辞，但就我所知，在我们的开发社区内，那些追寻新知识，推动网页开发向前发展的人举目皆是。&lt;/p&gt;
&lt;p&gt;让我们放下对本文话题的感性认知，先领会下 CSS 世界架构的奇妙之处。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="Javascript" scheme="https://lsvih.com/tags/Javascript/"/>
    
      <category term="CSS" scheme="https://lsvih.com/tags/CSS/"/>
    
      <category term="CSS-in-JS" scheme="https://lsvih.com/tags/CSS-in-JS/"/>
    
  </entry>
  
  <entry>
    <title>Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 论文笔记</title>
    <link href="https://lsvih.com/2020/07/15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2020/07/15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-15T12:20:00.000Z</published>
    <updated>2020-08-23T09:34:34.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 一文是我和组内同学、师兄的合作工作，作为短文录用于 ACL 2020。</p></blockquote><p>说起来很奇妙，这个工作最开始是为了做 Aspect-extraction 相关工作而开始的，效果很一般。但是在调参的时候发现单纯作为序列标注任务的一个额外的特征输入，居然得到了一丁点提升。也就是这一点点提升，我决定把它应用在预训练语言模型中做一做实验。在经过大量的试错、调整和调参后，最终得到了这么一种新奇的方法，可以让预训练语言模型额外获得一些 word-level 的信息，在各个需要词信息的任务中都有那么一点提升。但这个方法相当的实验化且缺乏理论支撑，并且还有一些别的致命问题（如果没有这些问题谁会去投短文…），会在后面一一说明。下文将结合在会上做远程汇报的 slide，简单描述这个工作。</p><blockquote><p>ppt 已经放在<a href="https://lsvih.com/2020/07/15/Slide-of-MWA/">这里</a>了</p><p>反正就是想写个笔记给自己看，又不是写论文，就不用玩啥避重就轻之类的套路了，<strong>吐槽为主</strong>（反正没人看）。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/15949186123616.jpg" alt="-w591"></p><p>首先是预训练语言模型在最近有了很大的发展，上面那个图是 thunlp 组同学整理的。现在预训练语言模型发展方向就是在不断改进预训练任务和模型结构，让其能适配更大量的数据的数据，方便刷榜，看看 GPT-3 那 1700 亿个参数就心酸。当然也有许多做压缩模型、蒸馏的工作，这些现在应用起来反而更实用一些。还有一些工作在尝试融入额外信息，比如：清华 nlp 提出的 ERNIE 在 BERT 中融入知识图谱；百度的 ERNIE 1.0 融入实体信息，ERNIE 2.0 花式训练；香侬科技魔幻的 Glyce 融合字形；创新工场的 ZEN 用 n-gram 去融合分词信息。</p><p><img src="/images/15949229491682.jpg" alt="-w399"></p><p>但是不管怎样边，主流的预训练语言模型都和上图一样，分预训练和微调两个阶段（GPT-3 那种号称不用微调的除外），现在大家的主要工作也是集中在预训练阶段去做的。近些年这块最经典的工作当然非 BERT 莫属了，所以我后面都是在 BERT 上跑实验。</p><p>不管啥模型，第一件事都是 tokenizer。对于 BERT 来说，英文的 token 是 word-piece，中文的是字（这也对后面的实验造成了很大的麻烦，因为要对齐）。而且已经有相当多的工作证明了，对于中文在 character-level 建模会比较合适（香侬在 ACL2019 的那篇《Is Word Segmentation Necessary for Deep Learning of Chinese Representations》很是经典）。不过在实际应用中，包括很多 Application of NLP 领域的文章，还有我自己的文章，都发现将词信息融入到文本表示中会对应用有效果。</p><p>所以，这篇论文实质上就是在实验看有什么办法去各种拐着弯儿向 character-level 的表示模型融入词信息。</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>至于动机也很简单。玄一些就是把一些眼动追踪的研究挪过来建模：</p><p><img src="/images/15949238058792.jpg" alt=""></p><p>[1] Reading spaced and unspaced chinese text: Evidence from eye movements<br>[2] Parafoveal load of word N+1 modulates preprocessing effectiveness of word N+2 in Chinese reading<br>[3] Cognitive mechanisms in reading ancient Chinese poetry: evidence from eye movements</p><p>上图就是上面几篇论文的部分结论，总结起来就是人阅读中文的时候对每个词付出的“注意度”类似。</p><p>实在一些就是想找一些方法来改变 transformer 的 attention 分布，或者找一种可以折中 soft-attention 与 hard-attention 的方法，在维持原 attention 机制的情况下，用比较 soft 的方法来实现比较 hard 的效果，来方便某些任务（后记中有写）。</p><p>总之，我就是根据这些动机进行了实验。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="单个分词器下的情况"><a href="#单个分词器下的情况" class="headerlink" title="单个分词器下的情况"></a>单个分词器下的情况</h4><p><img src="/images/15949243105852.jpg" alt=""></p><p>（在师兄指导下画的图，还挺好看的）</p><p>模型很简单，就是在预训练语言模型对下游任务进行微调时，中间插上一层 multi-head attention 的变体。</p><p>首先，可以使用分词工具将输入的文本进行分词，具体来说就是讲由字构成的序进行划分（parition），我们把这种划分策略称为 $\pi$。</p><p>得到划分 $\pi$ 后，将其应用于正常得到的 attention 权重矩阵上，可以得到按词划分的（word-based）字级别（character-level）的 attention 权重组合。</p><p>为了同时考虑：1. 句子中所有词的语义表示；2. 句子中最重要的词的语义表示 这两种情况，我们使用 mix-pooling 来对 mean-pooling 和 max-pooling 进行混合：</p><script type="math/tex; mode=display">MixPooling = \lambda MeanPooling + (1 - \lambda MaxPooling)</script><p>其中 $\lambda$ 为参数（后面做实验观察 $\lambda$ 发现，还是 MeanPooling 更重要一些）。</p><p><img src="/images/15949249830517.jpg" alt=""></p><p>比如上图就是这种 attention 权重矩阵的可视化效果图。这个例子是从情感分类任务模型中拿出来试的，可以看到 attention 权重矩阵被转化为了 character-level to word-level 的形式，而实际上还是 character-level 的模型，保留了字建模的优秀表示，同时也做到了前面动机所说的接近 hard-attention 的效果。</p><p>把这样的 attention 权重再拿回 character-level 表示去调整它，就能得到最终的字表示，送往后续的下游任务。</p><h4 id="多个分词器下的情况"><a href="#多个分词器下的情况" class="headerlink" title="多个分词器下的情况"></a>多个分词器下的情况</h4><p>然而，众所周知，分词器经常会出现问题。</p><p><img src="/images/15949252629966.jpg" alt=""></p><p>上图是论文里的图（为了和平特意找了个都没分错的例子），这几个分词器得到的结果都是对的，但是其粒度不同。</p><p>为了减少分词错误，以及用上不同粒度级别的特征，我们找了一种简单的方法，同时用上多个分词工具的分词结果。</p><script type="math/tex; mode=display">\textbf{H'} = \sum_{m=1}^{M} \tanh( {\textbf{H}}^m\textbf{W})</script><p>真的很简单，就是几个分词器的结果，分别得到下游表示之后过个线性层结合在一起而已。</p><p>实验证明这样是有一定效果的。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>都在原文里有，没啥槽点，就是做实验耗的时间太多了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下这个工作的优缺点：</p><p>优点：</p><ul><li>提出了这么一种有意思的结构</li><li>这么一种有意思的结构可以融入一些分词信息，并且对预训练语言模型的下游任务有一些帮助</li><li>单纯融入一种分词信息不够，就多加几种分词信息</li></ul><p>缺点：</p><ul><li>实在缺乏理论支撑</li><li>预处理的真的特别特别慢（尤其是要用几种分词器来分词），并且数据预处理无比复杂（因为各个分词器的处理逻辑都不一样，各种特殊符号、数字、英语、日语、繁体啥的全部都要单独处理，尤其是 BERT 会将英语单词 tokenize 成 word-piece，导致 token 对不上，前期实验有 80% 以上的时间都是在搞这些预处理）</li><li>在 forward 的时候把 transformer 的时间复杂度 $O(n^2)$ 变成了 $O(d n^2)$（这还好是常数级），但是要命的是，在这个方法中，每一条训练数据都会有各自不同的分词方式，都只能各自去分段计算 mix-pooling，这导致完全无法应用 cudnn 原语加速，也完全没可能写成矩阵运算来利用 GPU batch 加速，即使直接用 cuda 编程也没法改善。连 forward 都这么慢，backward 更不用说了……这点是致命的，让我的实验时间变得特别特别长，跑个 CMRC 数据集硬生生把 6 个小时的训练时间搞成了 28 个小时，心态都炸了。</li></ul><p>总结下来，这个工作其实缺点其实挺明显的，主要集中在预处理和速度极慢这两块上。吐槽：<strong>但投稿时 call for short paper 写明白了就是欢迎分享这些不是很完善的 idea 呀，不懂为啥要使劲冲着缺陷打，没这些问题投长文不香吗？</strong></p><p>优点主要还是这个结构足够新颖。由于这种东西的预处理实在太 <strong>dirty</strong> 了，跑起来也慢的<strong>令人抓狂</strong>，我是不打算 follow 这个工作继续做下去了。但是，这种有意思的结构可以用在其它一些 NLP 应用里面，还是可以做一做的。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在郁博文师兄的帮助下第一次写这种实验性质的短文也是挺有意思的。我受到的指导，和我写的文章，一般都是<code>发现问题-&gt;分析问题-&gt;分析方案-&gt;理论支撑方案-&gt;实验支撑理论</code>这么个范式；而这篇文章是<code>发现问题-&gt;分析问题-&gt;哇，有灵感了-&gt;实验结果还不错</code>这么个流程，还是蛮奇妙的。但说到底还是缺乏理论支撑，我去年曾尝试用离散数学去建模分词和这个模型的过程（有图为证），还试图用<code>正则化</code>或者<code>标准化</code>等深度学习术语来解释这种模型，但都成功地浪费了大量的时间，在没有理论支撑的情况下，也只能这样了。</p><p><img src="/images/15949218669058.jpg" alt="-w202"></p><p>这篇文章的录用还是很侥幸的。在审稿 rebuttal 的时候，审稿人给的分和评价都很一般。正如前文所说，文本的确有很多问题，但几位审稿人最主要的关注点居然都主要集中在空间复杂度和训练参数数量上面，没有抓主要矛盾而是重点抓次要矛盾去了。所以简单回答这些关于参数、空间占用之类的问题值后，有位审稿人改了分，这才被录用。</p><blockquote><p>最后这篇论文出来的时候真是命运多舛，赶上了 2020 年的疫情，不让回实验室，资料、代码啥的全在工位台式机上，又赶上组里的大工程和自己的毕设，只能抽空远程一点一点扒代码，扒到开会都没扒完；后来都有好几位老师同学发邮件索取了，都没办法直接发给人家可以直接跑的模型，只给一个老师发了最主要的那个 <code>attention align</code> 模块，也不知道有没有帮上他的忙；好在后来找了点办法能远程直连了，不然更难受。</p><p>最近申博士也很难受，因为特总美国学校鸽了、欧洲学校因为疫情考不了雅思并且因为经济下滑很多组都没有 fund、国内那两所学校又卷到没有坑留、找工作还没来得及刷题，整个人都不好了。。<br>真希望以后不要再有这样的日子了，赶紧刷题复习去:(</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention 一文是我和组内同学、师兄的合作工作，作为短文录用于 ACL 2020。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
      <category term="NLP" scheme="https://lsvih.com/tags/NLP/"/>
    
      <category term="Natural Language Processing" scheme="https://lsvih.com/tags/Natural-Language-Processing/"/>
    
      <category term="ACL" scheme="https://lsvih.com/tags/ACL/"/>
    
  </entry>
  
  <entry>
    <title>Slide of &#39;Enhancing Pre-trained Chinese Character Representation with Word-aligned Attention&#39; used in ACL conference.</title>
    <link href="https://lsvih.com/2020/07/13/Slide-of-MWA/"/>
    <id>https://lsvih.com/2020/07/13/Slide-of-MWA/</id>
    <published>2020-07-13T03:06:00.000Z</published>
    <updated>2020-07-16T17:17:35.470Z</updated>
    
    <content type="html"><![CDATA[<p><iframe src="https://lsvih.github.io/workshop/20-07-15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-aligned%20Attention.html" scrolling="no" frameborder="0" align="" height="600px" width="100%"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;iframe src=&quot;https://lsvih.github.io/workshop/20-07-15/Enhancing%20Pre-trained%20Chinese%20Character%20Representation%20with%20Word-align
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="paper" scheme="https://lsvih.com/tags/paper/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Slide" scheme="https://lsvih.com/tags/Slide/"/>
    
      <category term="conference" scheme="https://lsvih.com/tags/conference/"/>
    
      <category term="language model" scheme="https://lsvih.com/tags/language-model/"/>
    
  </entry>
  
  <entry>
    <title>获取 Git 全部远程分支</title>
    <link href="https://lsvih.com/2020/06/05/fetch-all-git-remote-branch/"/>
    <id>https://lsvih.com/2020/06/05/fetch-all-git-remote-branch/</id>
    <published>2020-06-05T08:13:59.000Z</published>
    <updated>2020-06-05T08:23:51.327Z</updated>
    
    <content type="html"><![CDATA[<p>因为图省硬盘，直接用了 <code>--depth=1</code> 命令 clone，导致在本地追踪不到远程的分支，并且用 <code>git branch -a</code> 看不到远程分支，当然也不能 checkout 到 origin/remote 上去。<code>git fetch all</code>、<code>git fetch origin</code> 也都拿不到内容。</p><p>因为有 slash 的内容和已经准备好的 commit，又不想重新去 clone，想起来 git 使用 fetch 时就是去找 <code>.git/config</code> 文件里的 remote origin 字段，因此直接改了这个文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .git/config</span><br></pre></td></tr></table></figure><p>找到  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx</span><br><span class="line">        fetch = +refs<span class="regexp">/heads/m</span>aster:refs<span class="regexp">/remotes/</span>origin/master</span><br></pre></td></tr></table></figure><p>果然 head 和 remote origin 都指向 master，把 master 改成 *：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">        url = https:<span class="regexp">//gi</span>thub.com<span class="regexp">/xxx/</span>xxx</span><br><span class="line">        fetch = +refs<span class="regexp">/heads/</span>*:refs<span class="regexp">/remotes/</span>origin/*</span><br></pre></td></tr></table></figure><p>接着 <code>git fetch --all</code>，就拿到了全部的分支，现在就可以直接去 checkout 了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为图省硬盘，直接用了 &lt;code&gt;--depth=1&lt;/code&gt; 命令 clone，导致在本地追踪不到远程的分支，并且用 &lt;code&gt;git branch -a&lt;/code&gt; 看不到远程分支，当然也不能 checkout 到 origin/remote 上去。&lt;code
      
    
    </summary>
    
    
      <category term="Note" scheme="https://lsvih.com/categories/Note/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="tool" scheme="https://lsvih.com/tags/tool/"/>
    
      <category term="bash" scheme="https://lsvih.com/tags/bash/"/>
    
      <category term="git" scheme="https://lsvih.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 进行边缘检测</title>
    <link href="https://lsvih.com/2020/02/07/edge-detection-in-python/"/>
    <id>https://lsvih.com/2020/02/07/edge-detection-in-python/</id>
    <published>2020-02-07T11:50:00.000Z</published>
    <updated>2020-02-07T11:50:31.380Z</updated>
    
    <content type="html"><![CDATA[<p>上季度，我在学校辅助一门 Python 课程的教学，在此过程中学到了很多图像处理的知识。我希望通过本文分享一些关于边缘检测的知识，包括边缘检测的<strong>理论</strong>以及如何使用 Python <strong>实现</strong>边缘检测。</p><hr><h3 id="为何检测边缘？"><a href="#为何检测边缘？" class="headerlink" title="为何检测边缘？"></a>为何检测边缘？</h3><p>我们首先应该了解的问题是：<strong>“为什么要费尽心思去做边缘检测？”</strong>除了它的效果很酷外，为什么边缘检测还是一种实用的技术？为了更好地解答这个问题，请仔细思考并对比下面的风车图片和它的“仅含边缘的图”：</p><p><img src="/images/1-2.png" alt="Image of pinwheel (left) and its edges (right)"></p><p>可以看到，左边的原始图像有着各种各样的色彩、阴影，而右边的“仅含边缘的图”是黑白的。如果有人问，哪一张图片需要更多的存储空间，你肯定会告诉他原始图像会占用更多空间。这就是边缘检测的意义：通过对图片进行边缘检测，丢弃大多数的细节，从而得到“更轻量化”的图片。</p><p>因此，在无须保存图像的所有复杂细节，而 <strong>“只关心图像的整体形状”</strong> 的情况下，边缘检测会非常有用。</p><hr><h3 id="如何进行边缘检测-——-数学"><a href="#如何进行边缘检测-——-数学" class="headerlink" title="如何进行边缘检测 —— 数学"></a>如何进行边缘检测 —— 数学</h3><p>在讨论代码实现前，让我们先快速浏览一下边缘检测背后的数学原理。作为人类，我们非常擅长识别图像中的“边”，那如何让计算机做到同样的事呢？</p><p>首先，假设有一张很简单的图片，在白色背景上有一个黑色的正方形：</p><p><img src="/images/2-1.png" alt="Our working image"></p><p>在这个例子中，由于处理的是黑白图片，因此我们可以考虑将图中的每个像素的值都用 <strong>0（黑色）</strong> 或 <strong>1（白色）</strong> 来表示。除了黑白图片，同样的理论也完全适用于彩色图像。</p><p>现在，我们需要判断上图中绿色高亮的像素是不是这个图像边缘的一部分。作为人类，我们当然可以认出它<strong>是</strong>图像的边缘；但如何让计算机利用相邻的像素来得到同样的结果呢？</p><p>我们以绿色高亮的像素为中心，设定一个 3 x 3 像素大小的小框，在图中以红色示意。接着，对这个小方框“应用”一个过滤器（filter）：</p><p><img src="/images/3.png" alt="对局部像素框应用纵向过滤器"></p><p>上图展示了我们将要“应用”的过滤器。乍一看上去很神秘，让我们仔细研究它做的事情：当我们说 <strong>“将过滤器应用于一小块局部像素块”</strong> 时，具体是指红色框中的每个像素与过滤器中与之位置对应的像素进行相乘。因此，红色框中左上角像素值为 1，而过滤器中左上角像素值为 -1，它们相乘得到 -1，这也就是结果图中左上角像素显示的值。结果图中的每个像素都是用这种方式得到的。</p><p>下一步是对过滤结果中的所有像素值求和，得到 -4。请注意，-4 其实是我们应用这个过滤器可获得的“最小”值（因为原始图片中的像素值只能在 0 到 1 之间）。因此，当获得 -4 这个最小值的时候，我们就能知道，对应的像素点是图像中正方形<strong>顶部竖直方向边缘</strong>的一部分。</p><p>为了更好地掌握这种变换，我们可以看看将此过滤器应用于图中正方形底边上的一个像素会发生什么：</p><p><img src="/images/4-1.png" alt=""></p><p>可以看到，我们得到了与前文相似的结果，相加之后得到的结果是 4，这是应用此过滤器能得到的<strong>最大值</strong>。因此，由于我们得到了 4 这一最大值，可以知道这个像素是图像中正方形<strong>底部竖直方向边缘</strong>的一部分。</p><p>为了把这些值映射到 0-1 的范围内，我们可以简单地给其加上 4 再除以 8，这样就能把 -4 映射成 0（<strong>黑色</strong>），把 4 映射成 1（<strong>白色</strong>）。因此，我们将这种过滤器称为<strong>纵向 Sobel 过滤器</strong>，可以用它轻松检测图像中垂直方向的边缘。</p><p>那如何检测水平方向的边缘呢？只需简单地将<strong>纵向过滤器</strong>进行转置（按照其数值矩阵的对角线进行翻转）就能得到一个新的过滤器，可以用于检测水平方向的边缘。</p><p>如果需要同时检测水平方向、垂直方向以及介于两者之间的边缘，我们可以把<strong>纵向过滤器得分和横向过滤器得分进行结合</strong>，这个步骤在后面的代码中将有所体现。</p><p>希望上文已经讲清楚了这些理论！下面看一看代码是如何实现的。</p><hr><h3 id="如何进行边缘检测-——-代码"><a href="#如何进行边缘检测-——-代码" class="headerlink" title="如何进行边缘检测 —— 代码"></a>如何进行边缘检测 —— 代码</h3><p>首先进行一些设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义纵向过滤器</span></span><br><span class="line">vertical_filter = [[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义横向过滤器</span></span><br><span class="line">horizontal_filter = [[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>], [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">2</span>], [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取纸风车的示例图片“pinwheel.jpg”</span></span><br><span class="line">img = plt.imread(<span class="string">&#x27;pinwheel.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到图片的维数</span></span><br><span class="line">n,m,d = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化边缘图像</span></span><br><span class="line">edges_img = img.copy()</span><br></pre></td></tr></table></figure><ul><li>你可以把代码中的“pinwheel.jpg”替换成其它你想要找出边缘的图片文件！需要确保此文件和代码在同一工作目录中。</li></ul><p>接着编写边缘检测代码本身：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义纵向过滤器</span></span><br><span class="line">vertical_filter = [[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>], [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义横向过滤器</span></span><br><span class="line">horizontal_filter = [[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>], [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">2</span>], [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取纸风车的示例图片“pinwheel.jpg”</span></span><br><span class="line">img = plt.imread(<span class="string">&#x27;pinwheel.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到图片的维数</span></span><br><span class="line">n,m,d = img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化边缘图像</span></span><br><span class="line">edges_img = img.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环遍历图片的全部像素</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">3</span>, n<span class="number">-2</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">3</span>, m<span class="number">-2</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在当前位置创建一个 3x3 的小方框</span></span><br><span class="line">        local_pixels = img[row<span class="number">-1</span>:row+<span class="number">2</span>, col<span class="number">-1</span>:col+<span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用纵向过滤器</span></span><br><span class="line">        vertical_transformed_pixels = vertical_filter*local_pixels</span><br><span class="line">        <span class="comment"># 计算纵向边缘得分</span></span><br><span class="line">        vertical_score = vertical_transformed_pixels.sum()/<span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用横向过滤器</span></span><br><span class="line">        horizontal_transformed_pixels = horizontal_filter*local_pixels</span><br><span class="line">        <span class="comment"># 计算横向边缘得分</span></span><br><span class="line">        horizontal_score = horizontal_transformed_pixels.sum()/<span class="number">4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将纵向得分与横向得分结合，得到此像素总的边缘得分</span></span><br><span class="line">        edge_score = (vertical_score**<span class="number">2</span> + horizontal_score**<span class="number">2</span>)**<span class="number">.5</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将边缘得分插入边缘图像中</span></span><br><span class="line">        edges_img[row, col] = [edge_score]*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对边缘图像中的得分值归一化，防止得分超出 0-1 的范围</span></span><br><span class="line">edges_img = edges_img/edges_img.max()</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>在图片的边界像素上，我们无法创建完整的 3 x 3 小方框，因此在图片的四周会有一个细边框。</li><li>既然是同时检测水平方向和垂直方向的边缘，我们可以直接将原始的纵向得分与横向得分分别除以 4（而不像前文描述的分别加 4 再除以 8）。这个改动无伤大雅，反而可以更好地突出图像的边缘。</li><li>将纵向得分与横向得分结合起来时，有可能会导致最终的边缘得分超出 0-1 的范围，因此最后还需要重新对最终得分进行标准化。</li></ul><p>在更复杂的图片上运行上述代码：</p><p><img src="/images/5-1.png" alt=""></p><p>得到边缘检测的结果：</p><p><img src="/images/6-1.png" alt=""></p><hr><p>以上就是本文的全部内容了！希望你了解到了一点新知识，并继续关注更多数据科学方面的文章〜</p><blockquote><p>掘金链接：<a href="https://juejin.im/post/5e3d4b53e51d4526c26fadd4">https://juejin.im/post/5e3d4b53e51d4526c26fadd4</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上季度，我在学校辅助一门 Python 课程的教学，在此过程中学到了很多图像处理的知识。我希望通过本文分享一些关于边缘检测的知识，包括边缘检测的&lt;strong&gt;理论&lt;/strong&gt;以及如何使用 Python &lt;strong&gt;实现&lt;/strong&gt;边缘检测。&lt;/p&gt;
&lt;hr
      
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
      <category term="Computer Vision" scheme="https://lsvih.com/tags/Computer-Vision/"/>
    
      <category term="Tutorial" scheme="https://lsvih.com/tags/Tutorial/"/>
    
      <category term="Edge Detection" scheme="https://lsvih.com/tags/Edge-Detection/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost 算法万岁！</title>
    <link href="https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/"/>
    <id>https://lsvih.com/2019/08/05/xgboost-algorithm-long-may-she-reign/</id>
    <published>2019-08-05T14:50:00.000Z</published>
    <updated>2019-08-05T14:54:58.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15650167189931.jpg" alt="Photo By Jared Subia"></p><a id="more"></a><blockquote><p>机器学习算法的新女王将接管整个世界……</p></blockquote><p>（本文与 <a href="https://towardsdatascience.com/u/e15e82916c90">Venkat Anurag Setty</a> 共同完成）</p><p>我还记得 15 年前我的第一份工作。那时，我刚完成研究生课程，作为一名分析师加入了一家国际投行。在入职的第一天，我小心翼翼地工作，不断回想学过的知识，心里想着自己是否能胜任这个企业的工作。老板感受到了我的焦虑，笑着对我说：</p><p><strong>“别担心！你只要了解回归模型就行了！”</strong></p><p>我仔细想了想，“明白了！” —— 无论是线性回归还是逻辑回归我都了解。老板是对的，在我的任期内，专门构建基于回归的统计学模型。我并不是孤身一人，因为在那时，回归模型是无可争议的预测分析女王。15 年后，回归模型的时代结束了，这位老女王已经退位。新上任的女王有着时髦的名字：XGBoost 或 Extreme Gradient Boosting。</p><hr><h2 id="什么是-XGBoost？"><a href="#什么是-XGBoost？" class="headerlink" title="什么是 XGBoost？"></a>什么是 XGBoost？</h2><p><a href="https://xgboost.ai/">XGBoost</a> 是一种基于决策树的集成（ensemble）机器学习算法，使用了<a href="https://en.wikipedia.org/wiki/Gradient_boosting">梯度提升（gradient boosting）</a>框架。在非结构化数据（如图像、文本等）的预测问题中，人工神经网络效果好于其它所有算法和框架；然而，在解决中小型的结构化、扁平化数据时，基于决策树的算法才是最好的。下面的图表展示了近年来基于树的算法的演变过程：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*QJZ6W-Pck_W7RlIDwUIN9Q.jpeg" alt="Evolution of XGBoost Algorithm from Decision Trees"></p><p>XGBoost 算法是华盛顿大学在科研工程中开发的。<a href="https://arxiv.org/pdf/1603.02754.pdf">陈天奇与 Carlos Guestrin</a> 在 SIGKDD 2016 上发表了他们的论文，迅速吸引了机器学习界的注意。自从 XGBoost 推出以来，它不仅在许多 Kaggle 竞赛中获得了胜利，还为一些顶尖的业界应用提供了动力。因此，形成了一个强大的数据科学家社区为 XGBoost 做贡献，目前 <a href="https://github.com/dmlc/xgboost/">GitHub</a> 上的 XGBoost 项目有 350 余名贡献者，3600 余条 commit 记录。XGBoost 算法还在下面几个方面极为出众：</p><ol><li>应用广泛：可以用于解决回归、分类、排序和其它用户自定义的预测问题；</li><li>可移植性：在 Windows、Linux 和 OS X 系统中都能顺畅运行；</li><li>语言：支持包括 C++、Python、R、Java、Scala 和 Julia 等全部主流编程语言；</li><li>云端集成：支持 AWS、Azure、Yarn 集群，并与 Flink、Spark 等生态系统配合无间。</li></ol><hr><h2 id="如何直观地理解-XGBoost？"><a href="#如何直观地理解-XGBoost？" class="headerlink" title="如何直观地理解 XGBoost？"></a>如何直观地理解 XGBoost？</h2><p>决策树在最简单的形式下，是最易于可视化以及最具可解释性的算法，但想要直观的理解新一代的基于树的算法可能会有些困难。可以用下面的类比来更好地了解基于树的算法的演变。</p><p><img src="https://cdn-images-1.medium.com/max/11030/1*Uwbv9Nzv7uoZV_hJwrsPGQ.jpeg" alt="[rawpixel](https://unsplash.com/photos/cnseVhmbA7k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) 供图[Unsplash](https://unsplash.com/search/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"></p><p>设想你是一名 HR，要对几名优秀的候选人进行面试。而基于树的算法的演变过程的每一步，都可以视为是面试过程的一个版本。</p><ol><li><p><strong>决策树（Decision Tree）</strong>：每个 HR 都有一系列标准，比如学历、工作年份、面试表现等。一个决策树就类似于一个 HR 基于他的这些标准来筛选候选人。</p></li><li><p><strong>Bagging</strong>：假设现在不只有一个面试官，而是有一个面试小组，组中每个面试官都有投票权。Bagging 和 Bootstrap 就是通过一个民主投票的过程，将所有面试官的输入聚合起来，得到一个最终的决定。</p></li><li><p><strong>随机森林（Random Forest）</strong>：它是一种基于 Bagging 的算法，关键点在于随机森林会随机使用特征的子集。换句话说，就是每个面试官都只会用一些随机选择的标准来考验候选人的任职资格（比如，技术面值考察编程技能，行为面只考察非技术相关的技能）。</p></li><li><p><strong>Boosting</strong>：这是一种替代方法，每个面试官都会根据上一个面试官的面试结果来改变自己的评价标准。通过利用更加动态的评估过程，可以提升（boost）面试过程的效率。</p></li><li><p><strong>梯度提升（Gradient Boosting）</strong>：Boosting 的特例，用梯度下降算法来将误差最小化。比如，咨询公司用案例面试来剔除不太合格的候选人。</p></li><li><p><strong>XGBoost</strong>：可以认为 XGBoost 就是“打了兴奋剂”的梯度提升（因此它全称是“Extreme Gradient Boosting” —— 极端梯度提升）。它是软件和硬件优化技术的完美结合，可以在最短的时间内用较少的计算资源得到出色的结果。</p></li></ol><hr><h2 id="为什么-XGBoost-效果这么好？"><a href="#为什么-XGBoost-效果这么好？" class="headerlink" title="为什么 XGBoost 效果这么好？"></a>为什么 XGBoost 效果这么好？</h2><p>XGBoost 和梯度提升机（Gradient Boosting Machines，GBM）都是集成（ensemble）树方法，原理都是用梯度下降架构来对多个弱分类器（通常是 <a href="https://www.datasciencecentral.com/profiles/blogs/introduction-to-classification-regression-trees-cart">CARTs</a>）进行提升（boosting）。不过，XGBoost 通过系统优化与算法强化在 GBM 框架上进行了改进。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*FLshv-wVDfu-i54OqvZdHg.png" alt="XGBoost 是如何优化标准 GBM 算法的"></p><p><strong>系统优化：</strong></p><ol><li><p><strong>并行化</strong>：XGBoost 通过<a href="http://zhanpengfang.github.io/418home.html">并行化</a>方法来实现顺序的建树过程。由于基础学习器循环内部（包括用于枚举树的叶子节点的外部循环，以及用于计算特征的内部循环）的可互换性，因此才能这么做；循环的嵌套会限制并行化，因为如果没有完成两个开销更大的内部循环，就不能开始新的外部循环。XGBoost 算法通过使用并行线程对所有实例进行全局扫描和排序来进行初始化，使得循环的顺序变得可交换，从而减少了运行的时间。这样做，可以抵消并行化开销而提升算法性能。</p></li><li><p><strong>树剪枝</strong>：在 GBM 框架中，树停止分裂的标准本质上是贪婪的，取决于分裂点的 loss 值。而 XGBoost 用 <code>max_depth</code> 这一参数而非某个指标来停止分裂，然后开始反过来对树进行剪枝。这种“深度优先”的方法显著提高了计算性能。</p></li><li><p><strong>硬件优化</strong>：XGBoost 算法就是为了高效利用硬件资源而设计的。它为每个线程都分配了内部缓存区，用于存储梯度统计信息。另外，利用“核外计算”方法，在处理不适合放在内存中的大数据切片时，进一步优化磁盘可用空间。</p></li></ol><p><strong>算法强化：</strong></p><ol><li><p><strong>正则化（Regularization）</strong>：XGBoost 同时通过 LASSO（L1）与 Ridge（L2）<a href="https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c">正则化</a>惩罚过于复杂的模型，从而避免过拟合。</p></li><li><p><strong>稀疏意识（Sparsity Awareness）</strong>：XGBoost 会根据训练 loss 自动“学习”输入中的缺失值，从而自然地接收稀疏特征，并更高效地处理各种<a href="https://www.kdnuggets.com/2017/10/xgboost-concise-technical-overview.html">稀疏模式（sparsity patterns）</a>的数据。</p></li><li><p><strong>Weighted Quantile Sketch</strong>：XGBoost 使用分布式 <a href="https://arxiv.org/pdf/1603.02754.pdf">weighted Quantile Sketch 算法</a>，可以有效地找到大多数带权数据集的最佳分割点。 </p></li><li><p><strong>交叉验证（Cross-validation）</strong>：算法内置了在每次迭代时进行<a href="https://towardsdatascience.com/cross-validation-in-machine-learning-72924a69872f">交叉验证</a>的方法，不再需要显式地去搜索与指定一轮训练中所需的 boosting 迭代次数。</p></li></ol><hr><h2 id="Where-is-the-proof"><a href="#Where-is-the-proof" class="headerlink" title="Where is the proof?"></a>Where is the proof?</h2><p>我们使用 Scikit-learn 的 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html"><code>Make_Classification</code></a> 数据包，创建了一个包含 100 万个数据点、20 个特征（其中包括 2 个信息性特征与 2 个冗余特征）的随机样本集，并用它测试几种算法：逻辑回归、随机森林、标准梯度提升和 XGBoost。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*U72CpSTnJ-XTjCisJqCqLg.jpeg" alt="XGBoost vs. Other ML Algorithms using SKLearn’s Make_Classification Dataset"></p><p>如上图所示，与其它算法相比，XGBoost 模型得到了最好的预测性能与最短的处理时间。研究发现，在其它严格的<a href="https://github.com/szilard/benchm-ml">基准测试</a>中，也能得到类似的结果。因此，XGBoost 在最近的数据科学比赛中被广泛采用，也是意料之中的事。</p><blockquote><p>“当你举棋不定的时候，用 XGBoost 就对了” —— <a href="http://blog.kaggle.com/2015/08/26/avito-winners-interview-1st-place-owen-zhang/">Avito</a> Kaggle 上下文广告点击预测大赛冠军 Owen Zhang 如是说。</p></blockquote><hr><h2 id="我们是否可以在任何情况都用-XGBoost？"><a href="#我们是否可以在任何情况都用-XGBoost？" class="headerlink" title="我们是否可以在任何情况都用 XGBoost？"></a>我们是否可以在任何情况都用 XGBoost？</h2><p>在机器学习中（或者说在生命中），没有免费的午餐。作为数据科学家，必须为手头数据测试所有算法，以找到效果最好的算法。但是，选出正确算法还不够，还必须要为数据集正确地配置算法的<a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/">超参数</a>。此外，在选择最优算法时，除了效果还要考虑其它的因素，比如计算复杂度、可解释性、易用性等等。这正是机器学习从科学转向艺术的部分，同时，也是魔法发生的地方！</p><hr><h2 id="未来会如何？"><a href="#未来会如何？" class="headerlink" title="未来会如何？"></a>未来会如何？</h2><p>机器学习是一个非常活跃的研究领域，目前已经出现了各种各样的 XGBoost 的变体。微软研究院最近提出了 <a href="https://www.microsoft.com/en-us/research/project/lightgbm/">LightGBM</a> 梯度提升框架，体现出了巨大的潜力。Yandex 科技开发了 <a href="https://catboost.ai/">CatBoost</a>，得到了令人印象深刻的基准测试结果。出现一个在预测性能、灵活性、可解释性和实用型都优于 XGBoost 的框架只是时间上的问题。然而，在这个更强的挑战者到来之前，XGBoost 将继续统治机器学习的世界！</p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5d484040e51d4561f95ee9de">https://juejin.im/post/5d484040e51d4561f95ee9de</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/15650167189931.jpg&quot; alt=&quot;Photo By Jared Subia&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Algorithm" scheme="https://lsvih.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
      <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
      <category term="XGBoost" scheme="https://lsvih.com/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>在机器学习中为什么要进行 One-Hot 编码？</title>
    <link href="https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/"/>
    <id>https://lsvih.com/2019/06/28/why-one-hot-encode-data-in-machine-learning/</id>
    <published>2019-06-28T03:10:00.000Z</published>
    <updated>2019-06-28T03:12:13.010Z</updated>
    
    <content type="html"><![CDATA[<p>入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。</p><p>一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。</p><p>其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。</p><ul><li>为什么 One-Hot 编码是必要的？</li><li>为什么你不能直接使用数据来拟合模型？</li></ul><p>在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。</p><a id="more"></a><p>让我们开始吧！</p><p><img src="/images/Why-One-Hot-Encode-Data-in-Machine-Learning.jpg" alt=""></p><p><a href="https://www.flickr.com/photos/jiangkeren/8263176332/">题图 by Karan Jain，保留部分权利</a></p><h2 id="什么是类别数据？"><a href="#什么是类别数据？" class="headerlink" title="什么是类别数据？"></a>什么是类别数据？</h2><p>类别数据是一种只有标签值而没有数值的变量。</p><p>它的值通常属于一个大小固定且有限的集合。</p><p>类别变量也常被称为<a href="https://en.wikipedia.org/wiki/Nominal_category">标称值（nominal）</a>。</p><p>下面举例说明：</p><ul><li>宠物（pet）变量包含以下几种值：狗（dog）、猫（cat）。</li><li>颜色（color）变量包含以下几种值：红（red）、绿（green）、蓝（blue）。</li><li>位次（place）变量包含以下几种值：第一（first）、第二（second）和第三（third）。</li></ul><p>以上例子中的每个值都代表着一个不同的类别。</p><p>有些类别彼此间存在一定的自然关系，比如自然的排序关系。</p><p>上述例子中，位次（place）变量的值就有这种自然的排序关系。这种变量被称为序数变量（ordinal variable）。</p><h2 id="类别数据有什么问题？"><a href="#类别数据有什么问题？" class="headerlink" title="类别数据有什么问题？"></a>类别数据有什么问题？</h2><p>有些算法可以直接应用于类别数据。</p><p>比如，你可以不进行任何数据转换，将决策树算法直接应用于类别数据上（取决于具体实现方式）。</p><p>但还有许多机器学习算法并不能直接操作标签数据。这些算法要求所有的输入输出变量都是数值（numeric）。</p><p>通常来说，这种限制主要是因为这些机器学习算法的高效实现造成的，而不是算法本身的限制。</p><p>但这也意味着我们需要把类别数据转换成数值形式。如果输出变量是类别变量，那你可能还得将模型的预测值转换回类别形式，以便在一些应用中展示或使用它们。</p><h2 id="如何将类别数据转换成数值数据？"><a href="#如何将类别数据转换成数值数据？" class="headerlink" title="如何将类别数据转换成数值数据？"></a>如何将类别数据转换成数值数据？</h2><p>这包含两个步骤：</p><ol><li>整数编码</li><li>One-Hot 编码</li></ol><h3 id="1-整数编码"><a href="#1-整数编码" class="headerlink" title="1. 整数编码"></a>1. 整数编码</h3><p>第一步，先要给每个类别值都分配一个整数值。</p><p>比如，用 1 表示红色（red），2 表示绿色（green），3 表示蓝色（blue）。</p><p>这种方式被称为标签编码或者整数编码，可以很轻松地将它还原回类别值。</p><p>对于某些变量来说，这种编码就足够了。</p><p>整数之间存在自然的排序关系，机器学习算法也许可以理解并利用这种关系。</p><p>比如，前面的位次（place）例子中的序数变量就是一个很好的例子。对于它我们只需要进行标签编码就够了。</p><h3 id="2-One-Hot-编码"><a href="#2-One-Hot-编码" class="headerlink" title="2. One-Hot 编码"></a>2. One-Hot 编码</h3><p>但对于不存在次序关系的类别变量，仅使用上述的整数编码是不够的。</p><p>实际上，使用整数编码会让模型假设类别间存在自然的次序关系，从而导致结果不佳或得到意外的结果（预测值落在两个类别的中间）。</p><p>这种情况下，就要对整数表示使用 One-Hot 编码了。One-Hot 编码会去除整数编码，并为每个整数值都创建一个二值变量。</p><p>在颜色（color）的示例中，有 3 种类别，因此需要 3 个二值变量进行编码。对应的颜色位置上将被标为“1”，其它颜色位置上会被标为“0”。</p><p>比如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">red, green, blue</span><br><span class="line"><span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在统计学等领域中，这种二值变量通常被称为“虚拟变量”或“哑变量”（dummy variable）。</p><h2 id="One-Hot-编码教程"><a href="#One-Hot-编码教程" class="headerlink" title="One-Hot 编码教程"></a>One-Hot 编码教程</h2><p>如果你想了解如何在 Python 对你的数据进行 One-Hot 编码，请参阅：</p><ul><li><a href="https://machinelearningmastery.com/data-preparation-gradient-boosting-xgboost-python/">Data Preparation for Gradient Boosting with XGBoost in Python</a> — 在 Python 中使用 XGBoost 梯度提升法前的数据准备</li><li><a href="https://machinelearningmastery.com/how-to-one-hot-encode-sequence-data-in-python/">How to One Hot Encode Sequence Data in Python</a> — 如何使用 Python 对序列数据进行 One-Hot 编码</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Categorical_variable">类别变量（Categorical variable）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Nominal_category">标称分类（Nominal category）</a>，Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Dummy_variable_(statistics">虚拟变量，哑变量（Dummy variable）</a>)，Wikipedia</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，你应该了解了为什么在使用机器学习算法时通常要对类别数据进行编码。</p><p>特别要注意：</p><ul><li>类别数据的定义是由一组有限集合中的值构成的变量。</li><li>大多数机器学习算法都需要输入数值变量，并会输出数值变量。</li><li>通过整数编码与 One-Hot 编码可以将类别数据转换为整型数据。</li></ul><p>文章首发于掘金：<a href="https://juejin.im/post/5d15840e5188255c23553204">https://juejin.im/post/5d15840e5188255c23553204</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入门机器学习应用，尤其是需要对实际数据进行处理时，是很困难的。&lt;/p&gt;
&lt;p&gt;一般来说，机器学习教程会推荐你或要求你，在开始拟合模型之前，先以特定的方式准备好数据。&lt;/p&gt;
&lt;p&gt;其中，一个很好的例子就是对类别数据（Categorical data）进行 One-Hot 编码（又称独热编码）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 One-Hot 编码是必要的？&lt;/li&gt;
&lt;li&gt;为什么你不能直接使用数据来拟合模型？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，你将得到上述重要问题的答案，并能更好地理解机器学习应用中的数据准备工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Machine Learning" scheme="https://lsvih.com/tags/Machine-Learning/"/>
    
      <category term="Tutorial" scheme="https://lsvih.com/tags/Tutorial/"/>
    
      <category term="One Hot" scheme="https://lsvih.com/tags/One-Hot/"/>
    
      <category term="Deep Learning" scheme="https://lsvih.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Graph Convolutional Networks for Text Classification 论文笔记</title>
    <link href="https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/"/>
    <id>https://lsvih.com/2019/06/27/Graph%20Convolutional%20Networks%20for%20Text%20Classification/</id>
    <published>2019-06-27T04:04:00.000Z</published>
    <updated>2019-06-27T04:06:42.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：<a href="https://github.com/yao8839836/text_gcn">https://github.com/yao8839836/text_gcn</a> </p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文解决的是自然语言处理中最基础的任务 - 文本分类任务。利用近年大火的图神经网络，作者通过词与文章的共现信息和 TF-IDF 权重和互信息权重将无结构数据文本进行了构图，并利用 Graph Convolutional Network（GCN）捕获图中的文档-词、词-词、文档-文档关系，从而进行文本分类。</p><p>具体来说，本文主要有以下两个贡献点：</p><ol><li>提出了使用图神经网络来解决文本分类问题，有效利用了文档、词等的异构信息</li><li>在 benchmark 上达到了 state-of-the-art 的效果</li></ol><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><p>传统的文本分类方法主要依靠特征工程，在深度学习兴起后，各种深度学习框架代替了这个步骤。人们利用文本的分布式表示（embedding），使用各种 CNN、RNN、LSTM 等神经网络来捕获 embedding 中的语义信息，进行分类。本文就是在此基础之上，用 GCN 来捕获 Graph 中的 语义信息从而实现准确分类。</p><h3 id="图网络"><a href="#图网络" class="headerlink" title="图网络"></a>图网络</h3><p>近些年为了突破传统神经网络只能应用于对齐的 grid 数据的限制，出现了可以应用于 Graph 的图神经网络。其中，GCN 方法简单有效，在图的各个节点上计算其邻居的聚合信息表示。因此，作者 employ 了 GCN 方法，将其用于图结构的学习。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>作者在 5 个常用的公开数据集上进行了实验。这 5 个数据集的基本信息如下：</p><p><img src="/images/15616083187154.jpg" alt="-w692"></p><p>在实验前，作者利用 NLTK 去除了前 4 个数据集的停用词，并去除了频次小于 5 的低频次。MR 数据集因为句子太短了，没有必要再删。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h3><p>作者最终构成的图结构如下图所示：</p><p><img src="/images/15616083306904.jpg" alt="-w922"></p><p>在图中，左边是文本构成的图，右边是经过 GCN 得到的图表示。在左图中，以“O”开头的节点是文档节点，白色圈里有单词的节点是单词节点，黑色的线是文档-单词关系，灰色的线是单词-单词关系。右图中的$R(x)$表示文档或单词$x$的表示。</p><p>具体来说，在这个情景中，构图主要在于如何对文档-单词和单词-单词的边赋权。作者使用了下面公式所示的构图方式：</p><script type="math/tex; mode=display">A _ { i j } = \left\{ \begin{array} { c } { \operatorname { PMI } ( i , j ) } \space \text{i,j 是单词，且 PMI(i,j)>0} \\ { \mathrm { TF } - \mathrm { IDF } _ { i j } } \space \text{i是单词，j是文档} \\ { 1 } \space i =j \\ { 0 } \space otherwise \end{array} \right.</script><p>$A_{ij}$表示从节点 i 连到节点 j 的边的权重。简单来说，就是对文档-单词的边算 TF-IDF 作为权重，对单词-单词的边使用 PMI 做权重。PMI 是单词与单词的互信息，具体计算方式是：</p><script type="math/tex; mode=display">\begin{aligned} \operatorname { PMI } ( i , j ) = & \log \frac { p ( i , j ) } { p ( i ) p ( j ) } \\ p ( i , j ) = & \frac { \# W ( i , j ) } { \# W } \\ p ( i ) = & \frac { \# W ( i ) } { \# W } \end{aligned}</script><p>其中，#W 是滑动窗口，具体来说，PMI 就是算单词 i 和单词 j 同时出现的概率比上单词 i 和单词 j 单独出现的概率。</p><h3 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h3><p>在 GCN 框架内，使用 BP 算法来优化节点表示，并在 GCN 后加一层 Dense 层和激活层，利用 softmax 来进行分类。作者将其表示如下：</p><script type="math/tex; mode=display">Z = \operatorname { softmax } \left( \tilde { A } \operatorname { ReL } \mathbf { U } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 } \right)</script><p>其中，$ \tilde { A } X W _ { 0 } $ 和前面的公式 $L ^ { ( 1 ) } = \rho \left( \tilde { A } X W _ { 0 } \right)$ 一致，都是通过对 W 的优化来进行节点的表示。对上面的公式进一步拆解，可以记为：</p><script type="math/tex; mode=display">E _ { 1 } = \tilde { A } X W _ { 0 }</script><p>$E_1$ 就是对单词和文档节点的表示。</p><script type="math/tex; mode=display">E _ { 2 } = \tilde { A } \operatorname { ReLU } \left( \tilde { A } X W _ { 0 } \right) W _ { 1 }</script><p>$E_2$ 就是对节点的第二层级表示。因此，本文相当于用了 2 层 GCN 进行图表示，然后用 softmax 进行分类。在分类优化时，采用了交叉熵损失函数：</p><script type="math/tex; mode=display">\mathcal { L } = - \sum _ { d \in \mathcal { Y } _ { D } } \sum _ { f = 1 } ^ { F } Y _ { d f } \ln Z _ { d f }</script><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="baseline-设置"><a href="#baseline-设置" class="headerlink" title="baseline 设置"></a>baseline 设置</h3><p>作者设置了多种 baseline，包括：</p><ul><li>TF-IDF + 线性分类器</li><li>CNN 文本分类（Convolutional neural networks for sentence classification，EMNLP）</li><li>LSTM 文本分类（Recurrent neural network for text classiﬁcation with multi-task learning，IJCAI）</li><li>Bi-LSTM</li><li>PV-DBOW（Distributed representations of sentences and documents，ICML）</li><li>PV-DM（同上）</li><li>PTE（Automatic lymphoma classiﬁcation with sentence subgraph mining from pathology reports）</li><li>FastText（Bag of tricks for efﬁcient text classiﬁcation，EACL）</li><li>SWEM（Baseline needs more love: On simple wordembedding-based models and associated pooling mechanisms，ACL）</li><li>LEAM（Joint embedding of words and labels for text classiﬁcation，ACL）</li><li>Graph-CNN-C（Convolutional neural networks on graphs with fast localized spectral ﬁltering，NIPS）</li><li>Graph-CNN-S（Spectral networks and locally connected networks on graphs，ICLR）</li><li>Graph-CNN-F（Deep convolutional networks on graphstructured data）</li></ul><p>可以看到，作者的实验非常完善且置信，应用了当时几乎全部的文本分类方法来进行对比。</p><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>作者用了 200 维作为 embedding 维数，20 作为滑动窗口大小，学习率设为 0.02，Dorpout 设为 0.5，分别随机采样 10 % 数据作为验证集和测试集。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>最终，得到了如下表所示的实验结果：</p><p><img src="/images/15616083449147.jpg" alt="-w1067"></p><p>该表有两个维度，数据集和模型。从此也可以看出，作者实验做的非常充分。</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>从上表可以看到，除了 MR 数据集外，作者提出的 Text GCN 方法在其余全部数据集上都得到了最好的结果。猜测可能是由于 MR 数据集中数据过于短，构图效果不佳造成的。</p><p>此外，作者利用 t-SNE 方法（Visualizing data using t-sne，JMLR）对结果进行了可视化，用于分析训练得到的 embedding 的效果。结果如下：</p><p><img src="/images/15616083604339.jpg" alt="-w513"></p><p>可以看到，作者提出的 Text GCN 方法得到的文档表示在 t-SNE 表现是可分的，类间距离较大，优于用来对比的其余两种方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者提出的 Text GCN 方法在文本分类任务中，在多个数据集上得到了最好的结果。我认为其最大创新点在于：1、引入了 GCN 来做文本分类 2、提出了这种构建带权边图的方式。整个工作非常完备，应该要做的实验基本都做了，令人信服，我们做文本分类应当也要学习本文的实验方式。此外，文章最后的节点表示可视化也很有说服力。</p><p>对于后续工作，我觉得一个是可以 follow 一些新的构图方式和 GNN 框架，再有就是在 loss 方面进行改进，优化表示的空间分布。此外，可以考虑结合一些最新的语言模型方法（BERT、XLNET 等）改善结果。以及，可以对分类器那块进行一些改进，比如引入 Attention 等方法可能可以提升效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文作于 2018 年，被 AAAI 2019 接收。作者是浙大博士，在 Northwestern University 做博后期间做出了此工作。文章中开源了实现代码：&lt;a href=&quot;https://github.com/yao8839836/t
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="NLP" scheme="https://lsvih.com/tags/NLP/"/>
    
      <category term="GNN" scheme="https://lsvih.com/tags/GNN/"/>
    
      <category term="GCN" scheme="https://lsvih.com/tags/GCN/"/>
    
      <category term="Text classification" scheme="https://lsvih.com/tags/Text-classification/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 线性代数系列</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra/</id>
    <published>2019-06-26T02:00:00.000Z</published>
    <updated>2019-06-26T02:08:51.880Z</updated>
    
    <content type="html"><![CDATA[<p>本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 <a href="https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0">Linear Algebra with Javascript</a>，旨在帮助复习线性代数的基本概念与运算，并了解如何使用 React、SVG、ThreeJS 等技术栈对线性代数的二维、三维向量、矩阵、线性变换进行可视化。</p><p>本系列共包含 5 篇文章：</p><ol><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/">用 React 制作线性代数教程示例：网格与箭头</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/">JavaScript 线性代数：向量</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/">JavaScript 线性代数：线性变换与矩阵</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/">JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</a></li><li><a href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/">线性代数：矩阵基本运算</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列翻译自 Rodion Chachura 发布于 Medium 的系列文章 &lt;a href=&quot;https://medium.com/@geekrodion/linear-algebra-with-javascript-46c289178c0&quot;&gt;Linear Algebr
      
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线性代数：矩阵基本运算</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-basic-matrix-operations/</id>
    <published>2019-06-26T01:05:00.000Z</published>
    <updated>2019-06-26T02:07:56.440Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。</p><h2 id="矩阵的加减法"><a href="#矩阵的加减法" class="headerlink" title="矩阵的加减法"></a>矩阵的加减法</h2><p>矩阵的<strong>加法</strong>与<strong>减法</strong>运算将接收两个矩阵作为输入，并输出一个新的矩阵。矩阵的加法和减法都是在分量级别上进行的，因此要进行加减的矩阵必须有着相同的维数。</p><p>为了避免重复编写加减法的代码，我们先创建一个可以接收运算函数的方法，这个方法将对两个矩阵的分量分别执行传入的某种运算。然后在加法、减法或者其它运算中直接调用它就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  componentWiseOperation(func, &#123; rows &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = rows.map(<span class="function">(<span class="params">row, i</span>) =&gt;</span></span><br><span class="line">      row.map(<span class="function">(<span class="params">element, j</span>) =&gt;</span> func(<span class="built_in">this</span>.rows[i][j], element))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">  add(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, other)</span><br><span class="line">  &#125;</span><br><span class="line">  subtract(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentWiseOperation(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b, other)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 6, 8 ], [ 10, 12 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.subtract(one))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 4 ], [ 4, 4 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵的标量乘法"><a href="#矩阵的标量乘法" class="headerlink" title="矩阵的标量乘法"></a>矩阵的标量乘法</h2><p>矩阵的标量乘法与向量的缩放类似，就是将矩阵中的每个元素都乘上标量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scaleBy(number) &#123;</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span></span><br><span class="line">      row.map(<span class="function"><span class="params">element</span> =&gt;</span> element * number)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 4, 6 ], [ 8, 10 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>当 <strong>A</strong>、<strong>B</strong> 两个矩阵的维数是<strong>兼容</strong>的时候，就能对这两个矩阵进行矩阵乘法。所谓维数兼容，指的是 <strong>A</strong> 的列数与 <strong>B</strong> 的行数相同。矩阵乘法 <strong>AB</strong> 就是对举证 <strong>A</strong> 的每一行行与矩阵 <strong>B</strong> 的每一列分别进行点积运算：</p><p><img src="/images/15615137842832.jpg" alt="matrix-matrix multiplication"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  multiply(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows[<span class="number">0</span>].length !== other.rows.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;The number of columns of this matrix is not equal to the number of rows of the given matrix.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> columns = other.columns()</span><br><span class="line">    <span class="keyword">const</span> newRows = <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">row</span> =&gt;</span> </span><br><span class="line">      columns.map(<span class="function"><span class="params">column</span> =&gt;</span> sum(row.map(<span class="function">(<span class="params">element, i</span>) =&gt;</span> element * column[i])))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...newRows)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, <span class="number">-4</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">-3</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">-2</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">2</span>, <span class="number">-4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">-3</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(one.multiply(other))</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows:</span></span><br><span class="line"><span class="comment">//    [ [ -7, 18, -32 ],</span></span><br><span class="line"><span class="comment">//      [ -12, 9, -15 ],</span></span><br><span class="line"><span class="comment">//      [ 10, 18, -34 ],</span></span><br><span class="line"><span class="comment">//      [ 1, -5, 9 ] ]&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以把矩阵乘法 <strong>AB</strong> 视为先后应用 <strong>A</strong> 和 <strong>B</strong> 两个线性变换矩阵。为了更好地理解这种概念，可以看一看我们的 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a>。</p><p>下图中黄色的部分就是对红色方块应用线性变换 <strong>C</strong> 的结果。而线性变换 <strong>C</strong> 就是矩阵乘法 <strong>AB</strong> 的结果，其中 <strong>A</strong> 是做相对于 y 轴进行反射的变换矩阵，<strong>B</strong> 是做剪切变换的矩阵。</p><p><img src="/images/15615138080956.jpg" alt="先旋转再剪切变换"></p><p>如果在矩阵乘法中调换 <strong>A</strong> 和 <strong>B</strong> 的顺序，我们会得到一个不同的结果，因为相当于先应用了 <strong>B</strong> 的剪切变换，再应用 <strong>A</strong> 的反射变换：</p><p><img src="/images/15615138231502.jpg" alt="shear than rotate"></p><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><p><strong>转置</strong>矩阵 $A^T$ 由公式 $a^T_{ij}=a_{ji}$ 定义。换句话说，我们通过关于矩阵的对角线对其进行翻转来得到转置矩阵。需要注意的是，矩阵对角线上的元素不受转置运算影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  transpose() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...this.columns())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.transpose())</span><br><span class="line"><span class="comment">// Matrix &#123;</span></span><br><span class="line"><span class="comment">//   rows: [</span></span><br><span class="line"><span class="comment">//     [ 0, 3, 6, 9 ],</span></span><br><span class="line"><span class="comment">//     [ 1, 4, 7, 10 ],</span></span><br><span class="line"><span class="comment">//     [ 2, 5, 8, 11 ]</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="行列式运算"><a href="#行列式运算" class="headerlink" title="行列式运算"></a>行列式运算</h2><p>矩阵的<strong>行列式</strong>运算将计算矩阵中的所有系数，最后输出一个数字。准确地说，行列式可以描述一个由矩阵行构成的向量的相对几何指标（比如在欧式空间中的有向面积、体积等空间概念）。更准确地说，矩阵 <strong>A</strong> 的行列式相当于告诉你由 <strong>A</strong> 的行定义的方块的体积。$2\times 2$ 矩阵的行列式运算如下所示：</p><p><img src="/images/15615138461810.jpg" alt="det(2×2 matrix)"></p><p>$3\times 3$ 矩阵的行列式运算如下所示：</p><p><img src="/images/15615138625927.jpg" alt="det(3×3 matrix)"></p><p>我们的方法可以计算任意大小矩阵（只要其行列的数量相同）的行列式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  determinant() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows.length !== <span class="built_in">this</span>.rows[<span class="number">0</span>].length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Only matrices with the same number of rows and columns are supported.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rows.length === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.rows[<span class="number">0</span>][<span class="number">0</span>] * <span class="built_in">this</span>.rows[<span class="number">1</span>][<span class="number">1</span>] - <span class="built_in">this</span>.rows[<span class="number">0</span>][<span class="number">1</span>] * <span class="built_in">this</span>.rows[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parts = <span class="built_in">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">coef, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matrixRows = <span class="built_in">this</span>.rows.slice(<span class="number">1</span>).map(<span class="function"><span class="params">row</span> =&gt;</span> [ ...row.slice(<span class="number">0</span>, index), ...row.slice(index + <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(...matrixRows)</span><br><span class="line">      <span class="keyword">const</span> result = coef * matrix.determinant()</span><br><span class="line">      <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span> ? result : -result</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(parts)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix2 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [ <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix2.determinant())</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">const</span> matrix3 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">2</span>, <span class="number">-3</span>,  <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,  <span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">  [<span class="number">1</span>,  <span class="number">4</span>,  <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix3.determinant())</span><br><span class="line"><span class="comment">// 49</span></span><br><span class="line"><span class="keyword">const</span> matrix4 = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-2</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-3</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>,  <span class="number">0</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix4.determinant())</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>行列式可以告诉我们变换时对象被拉伸的程度。因此我们可以将其视为一个线性变换对区域改变的一个因素。为了更好地理解这个概念，请参考 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a>：</p><p>在下图中，我们可以看到对红色的 <strong>1×1</strong> 方形进行线性变换后得到了一个 <strong>3×2</strong> 的长方形，面积从 <strong>1</strong> 变为了 <strong>6</strong>，这个数字与线性变换矩阵的行列式值相同。</p><p><img src="/images/15615138875261.jpg" alt="det(scale transformation)"></p><p>如果我们应用一个剪切变换，可以看到方形会变成一个面积不变的平行四边形。因此，剪切变换矩阵的行列式值等于 1：</p><p><img src="/images/15615139063445.jpg" alt="det(shear transformation)"></p><p>如果行列式的值是<strong>负数</strong>，则说明应用线性变换后，空间被反转了。比如在下图中，我们可以看到变换前 $\hat{\jmath}$ 在 $\hat{\imath}$ 的左边，而变换后 $\hat{\jmath}$ 在 $\hat{\imath}$ 的右边。</p><p><img src="/images/15615139284033.jpg" alt="negative determinant"></p><p>如果变换的行列式为 <strong>0</strong>，则表示它会将所有空间都压缩到一条线或一个点上。也就是说，计算一个给定矩阵的行列式是否为 0，可以判断这个矩阵对应的线性变换是否会将对象压缩到更小的维度去。</p><p><img src="/images/15615139536351.jpg" alt="2D 中的 0 行列式"></p><p>在三维空间里，行列式可以告诉你体积缩放了多少：</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a7937595f61716c476f2d4a31356877776c374e6766512e676966.gif" alt="det(scale transformation) in 3D"></p><p>变换行列式等于 0，意味着原来的空间会被完全压缩成体积为 0 的空间。如前文所说，如果在 2 维空间中变换的行列式为 0，则意味着变换的结果将空间压缩成了一条线或一个点；而在 3 维空间中变换的行列式为 0 意味着一个物体会被压扁成一个平面，如下图所示：</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323330302f312a4b396f324f7268746671574f324e4e6f34684b354e412e676966.gif" alt="3D 中的 0 行列式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
      <category term="Matrix" scheme="https://lsvih.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：使用 ThreeJS 制作线性变换动画</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-animating-linear-transformations-with-threejs/</id>
    <published>2019-06-26T01:04:00.000Z</published>
    <updated>2019-06-26T02:07:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我完成了一篇关于使用 JavaScript 进行线性变换的文章，并用 <strong>SVG</strong> 网格实现了 2D 的示例。你可以在<a href="https://juejin.im/post/5cefbc37f265da1bd260d129">此处</a>查看之前的文章。但是，那篇文章没有三维空间的示例，因此本文将补全那篇文章的缺失。你可以在<a href="https://github.com/RodionChachura/linear-algebra">此处</a>查看本系列文章的 GitHub 仓库，与本文相关的 commit 可以在<a href="https://github.com/RodionChachura/linear-algebra/tree/6e9b5fe7f037ec12b115c915f33b58ce5e2e9c1f">此处</a>查看。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本文中，我们将制作一个组件，用于对三维空间的对象的线性变换进行可视化。最终效果如下面的动图所示，或者你也可以在<a href="https://rodionchachura.github.io/linear-algebra/">此网页</a>体验。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323533322f312a42415a757839676e656956795a2d456a676b714565672e676966.gif" alt="applying different linear transformations on cube"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>当我们要在浏览器中制作 3D 动画时，第一个想到的当然就是 <a href="https://threejs.org/">three.js</a> 库啦。所以让我们来安装它以及另一个可以让用户移动摄像机的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save three three-orbitcontrols</span><br></pre></td></tr></table></figure><p>下面构建一个组件，它可以由父组件的属性中接收矩阵，并且渲染一个立方体的转换动画。下面代码展示了这个组件的结构。我们用 <strong>styled-components</strong> 和 <strong>react-sizeme</strong> 库中的函数对这个组件进行了包装，以访问颜色主题和检测组件尺寸的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">&#x27;react-sizeme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;&#125;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  animate = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedScene = withTheme(withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(ThreeScene))</span><br></pre></td></tr></table></figure><p>在<strong>构造函数</strong>中，我们对状态进行了初始化，其中包括了视图的大小。因此，我们当接收新的状态值时，可以在 <strong>componentWillReceiveProps</strong> 方法中与初始状态进行对比。由于需要访问实际的 <strong>DOM</strong> 元素以注入 <strong>ThreeJS</strong> 的 <strong>renderer</strong>，因此需要在 <strong>render</strong> 方法中用到 <strong>ref</strong> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> View = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      width: <span class="number">0</span>,</span><br><span class="line">      height: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">ref</span>=<span class="string">&#123;el</span> =&gt;</span> (this.view = el)&#125; /&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>componentDidMount</strong> 方法中，我们对方块变换动画所需要的所有东西都进行了初始化。首先，我们创建了 ThreeJS 的场景（scene）并确定好摄像机（camera）的位置，然后我们创建了 ThreeJS 的 <strong>renderer</strong>，为它设置好了颜色及大小，最后将 <strong>renderer</strong> 加入到 <strong>View</strong> 组件中。</p><p>接下来创建需要进行渲染的对象：坐标轴、方块以及方块的边。由于我们需要手动改变矩阵，因此将方块和边的 <strong>matrixAutoUpdate</strong> 属性设为 false。创建好这些对象后，将它们加入场景（scene）中。为了让用户可以通过鼠标来移动摄像机位置，我们还用到了 <strong>OrbitControls</strong>。</p><p>最后要做的，就是将我们的库输出的矩阵转换成 <strong>ThreeJS</strong> 的格式，然后获取根据时间返回颜色和转换矩阵的函数。在 <strong>componentWillUnmount</strong>，取消动画（即停止 anime frame）并从 <strong>DOM</strong> 移除 <strong>renderer</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      size: &#123; width, height &#125;,</span><br><span class="line">      matrix,</span><br><span class="line">      theme</span><br><span class="line">    &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">    <span class="built_in">this</span>.scene = <span class="keyword">new</span> THREE.Scene()</span><br><span class="line">    <span class="built_in">this</span>.camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">100</span>, width / height)</span><br><span class="line">    <span class="built_in">this</span>.camera.position.set(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123; <span class="attr">antialias</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="built_in">this</span>.renderer.setClearColor(theme.color.background)</span><br><span class="line">    <span class="built_in">this</span>.renderer.setSize(width, height)</span><br><span class="line">    <span class="built_in">this</span>.view.appendChild(<span class="built_in">this</span>.renderer.domElement)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> initialColor = theme.color.red</span><br><span class="line">    <span class="keyword">const</span> axes = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">this</span>.segments = <span class="keyword">new</span> THREE.LineSegments(</span><br><span class="line">      <span class="keyword">new</span> THREE.EdgesGeometry(geometry),</span><br><span class="line">      <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: theme.color.mainText &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.cube = <span class="keyword">new</span> THREE.Mesh(</span><br><span class="line">      geometry,</span><br><span class="line">      <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: initialColor &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.objects = [<span class="built_in">this</span>.cube, <span class="built_in">this</span>.segments]</span><br><span class="line">    <span class="built_in">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> (obj.matrixAutoUpdate = <span class="literal">false</span>))</span><br><span class="line">    <span class="built_in">this</span>.scene.add(<span class="built_in">this</span>.cube, axes, <span class="built_in">this</span>.segments)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.controls = <span class="keyword">new</span> OrbitControls(<span class="built_in">this</span>.camera)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.getAnimatedColor = getGetAnimatedColor(</span><br><span class="line">      initialColor,</span><br><span class="line">      theme.color.blue,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> fromMatrix = fromMatrix4(<span class="built_in">this</span>.cube.matrix)</span><br><span class="line">    <span class="keyword">const</span> toMatrix = matrix.toDimension(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">this</span>.getAnimatedTransformation = getGetAnimatedTransformation(</span><br><span class="line">      fromMatrix,</span><br><span class="line">      toMatrix,</span><br><span class="line">      PERIOD</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">this</span>.frameId = requestAnimationFrame(<span class="built_in">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    cancelAnimationFrame(<span class="built_in">this</span>.frameId)</span><br><span class="line">    <span class="built_in">this</span>.view.removeChild(<span class="built_in">this</span>.renderer.domElement)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过此时我们还没有定义 <strong>animate</strong> 函数，因此什么也不会渲染。首先，我们更新立方体及其边缘的转换矩阵，并且更新立方体的颜色，然后进行渲染并且调用 <code>window.requestAnimationFrame</code>。</p><p><strong>componentWillReceiveProps</strong> 方法将接收当前组件的大小，当它检测到组件尺寸发生了变化时，会更新状态，改变 renderer 的尺寸，并调整 camera 的方位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeScene</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  animate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transformation = <span class="built_in">this</span>.getAnimatedTransformation()</span><br><span class="line">    <span class="keyword">const</span> matrix4 = toMatrix4(transformation)</span><br><span class="line">    <span class="built_in">this</span>.cube.material.color.set(<span class="built_in">this</span>.getAnimatedColor())</span><br><span class="line">    <span class="built_in">this</span>.objects.forEach(<span class="function"><span class="params">obj</span> =&gt;</span> obj.matrix.set(...matrix4.toArray()))</span><br><span class="line">    <span class="built_in">this</span>.renderer.render(<span class="built_in">this</span>.scene, <span class="built_in">this</span>.camera)</span><br><span class="line">    <span class="built_in">this</span>.frameId = <span class="built_in">window</span>.requestAnimationFrame(<span class="built_in">this</span>.animate)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; <span class="attr">size</span>: &#123; width, height &#125; &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.width !== width || <span class="built_in">this</span>.state.height !== height) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; width, height &#125;)</span><br><span class="line">      <span class="built_in">this</span>.renderer.setSize(width, height)</span><br><span class="line">      <span class="built_in">this</span>.camera.aspect = width / height</span><br><span class="line">      <span class="built_in">this</span>.camera.updateProjectionMatrix()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>为了将颜色变化以及矩阵变换做成动画，需要写个函数来返回动画函数。在写这块函数前，我们先要完成以下两种转换器：将我们库的矩阵转换为 <strong>ThreeJS</strong> 格式矩阵的函数，以及参考 StackOverflow 上代码的将 RGB 转换为 hex 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/matrix&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Matrix &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/matrix&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toMatrix4 = <span class="function"><span class="params">matrix</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matrix4 = <span class="keyword">new</span> THREE.Matrix4()</span><br><span class="line">  matrix4.set(...matrix.components())</span><br><span class="line">  <span class="keyword">return</span> matrix4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fromMatrix4 = <span class="function"><span class="params">matrix4</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> components = matrix4.toArray()</span><br><span class="line">  <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> components.slice(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Matrix(...rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>首先，需要计算每种原色（RGB）变化的幅度。第一次调用 <strong>getGetAnimatedColor</strong> 时会返回新的色彩与时间戳的集合；并在后续被调用时，通过颜色变化的距离以及时间的耗费，可以计算出当前时刻新的 <strong>RGB</strong> 颜色：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hexToRgb, rgbToHex &#125; <span class="keyword">from</span> <span class="string">&#x27;./generic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedColor = <span class="function">(<span class="params">fromColor, toColor, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fromRgb = hexToRgb(fromColor)</span><br><span class="line">  <span class="keyword">const</span> toRgb = hexToRgb(toColor)</span><br><span class="line">  <span class="keyword">const</span> distances = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toPart = toRgb[index]</span><br><span class="line">    <span class="keyword">return</span> fromPart &lt;= toPart ? toPart - fromPart : <span class="number">255</span> - fromPart + toPart</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toColor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> rgb = fromRgb.map(<span class="function">(<span class="params">fromPart, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances[index]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round((fromPart + step) % <span class="number">255</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> rgbToHex(...rgb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>为了给线性变换做出动画效果，同样要进行上节的操作。我们首先找到矩阵变换前后的区别，然后在动画函数中，根据第一次调用 <strong>getGetAnimatedTransformation</strong> 时的状态，根据时间来更新各个组件的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getGetAnimatedTransformation = <span class="function">(<span class="params">fromMatrix, toMatrix, period</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> distances = toMatrix.subtract(fromMatrix)</span><br><span class="line">  <span class="keyword">let</span> start</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">      start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> timePassed = now - start</span><br><span class="line">    <span class="keyword">if</span> (timePassed &gt; period) <span class="keyword">return</span> toMatrix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> animatedDistance = timePassed / period</span><br><span class="line">    <span class="keyword">const</span> newMatrix = fromMatrix.map(<span class="function">(<span class="params">fromComponent, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> distance = distances.rows[i][j]</span><br><span class="line">      <span class="keyword">const</span> step = distance * animatedDistance</span><br><span class="line">      <span class="keyword">return</span> fromComponent + step</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newMatrix</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="ThreeJS" scheme="https://lsvih.com/tags/ThreeJS/"/>
    
      <category term="Animate" scheme="https://lsvih.com/tags/Animate/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：线性变换与矩阵</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-linear-transformation/</id>
    <published>2019-06-26T01:03:00.000Z</published>
    <updated>2019-06-26T02:08:06.140Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>矩阵</strong>是一种由 <strong>m</strong> 行 <strong>n</strong> 列实数组成的“矩形”数组。比如，一个 <strong>3x2</strong> 的矩阵如下所示：</p><p><img src="/images/15615130636391.jpg" alt="**3×2** 矩阵"></p><p><strong>Matrix</strong> 类的构造器（constructor）接收若干行元素作为参数。我们可以通过指定行号取出矩阵中的一行，然后再通过指定列号取出一个特定的元素。下面直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span><br><span class="line">    <span class="built_in">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix)</span><br><span class="line"><span class="comment">// Matrix &#123; rows: [ [ 0, 1 ], [ 2, 3 ], [ 4, 5 ] ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// [ 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(matrix.rows[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="矩阵与向量的乘积"><a href="#矩阵与向量的乘积" class="headerlink" title="矩阵与向量的乘积"></a>矩阵与向量的乘积</h2><p><strong>矩阵与向量的乘法</strong> —— $A\vec{x}$ 会将矩阵 $A$ 的列进行系数为 $\vec{x}$ 的线性组合。比如，一个 $3\times 2$ 的矩阵 A 与一个 <strong>2D</strong> 向量 <strong>x⃗</strong> 的乘积将得到一个 <strong>3D</strong> 向量，这个计算记为：$\vec{y} : \vec{y} = A\vec{x}$。</p><p><img src="/images/15615131095284.jpg" alt=""></p><p>假设有一组向量 $\{\vec{e}_1,\vec{e}_2\}$，另一个向量 $\vec{y}$ 是 $\vec{e}_1$ 和 $\vec{e}_2$ 的<strong>线性组合</strong>：$\vec{y} = \alpha\vec{e}_1 + \beta \vec{e}_2$。其中，$\alpha, \beta \in \mathbb{R}$ 就是这个线性组合的系数。</p><p>为了更好地学习线性组合，我们特地为此定义了矩阵向量乘法。我们可以将前面所说的线性组合记为以下矩阵向量乘法的形式：$\vec{y} = E \vec{x}$。矩阵 $E$ 有 $\vec{e}_1$、$\vec{e}_2$ 两列。矩阵的维数是 $n \times 2$，其中 $n$ 是向量 $\vec{e}_1$、$\vec{e}_2$ 与 $\vec{y}$ 的维数。</p><p>下图展示了将向量 $\vec{v}$ 表示为向量 $\vec{\imath}$ 和向量 $\vec{\jmath}$ 的线性组合：</p><p><img src="/images/15615131638823.jpg" alt="线性组合"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> j = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> firstCoeff = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> secondCoeff = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> linearCombination = i.scaleBy(firstCoeff).add(j.scaleBy(secondCoeff))</span><br><span class="line"><span class="built_in">console</span>.log(linearCombination)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 5 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>矩阵与向量的乘法是<strong>线性变换</strong>的抽象概念，这是学习线性代数中的关键概念之一。向量与矩阵的乘法可以视为对向量进行线性变换：将 n 维向量作为输入，并输出 m 维向量。也可以说，矩阵是定义好的某种空间变换。</p><p>我们可以通过一个示例来更清楚地理解线性变换。首先需要给 Matrix 类加上一个方法，用于返回矩阵的列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...rows) &#123;</span><br><span class="line">    <span class="built_in">this</span>.rows = rows</span><br><span class="line">  &#125;</span><br><span class="line">  columns() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.rows[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="built_in">this</span>.rows.map(<span class="function"><span class="params">r</span> =&gt;</span> r[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(matrix.columns())</span><br><span class="line"><span class="comment">// [ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]</span></span><br></pre></td></tr></table></figure><p>乘法得到的向量的维数将与矩阵的行数相同。如果我们将一个 <strong>2D</strong> 向量和一个 <strong>3x2</strong> 矩阵相乘，将得到一个 <strong>3D</strong> 的向量；如果将一个 <strong>3D</strong> 向量和一个 <strong>2x3</strong> 矩阵相乘，将得到一个 <strong>2D</strong> 的向量；如果在做乘法时，矩阵的列数和向量的维数不相同，将报错。在下面的代码中，你可以看到几种不同的向量与矩阵相乘的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, value</span>) =&gt;</span> acc + value, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  transform(matrix) &#123;</span><br><span class="line">    <span class="keyword">const</span> columns = matrix.columns()</span><br><span class="line">    <span class="keyword">if</span>(columns.length !== <span class="built_in">this</span>.components.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Matrix columns length should be equal to vector components length.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> multiplied = columns</span><br><span class="line">      .map(<span class="function">(<span class="params">column, i</span>) =&gt;</span> column.map(<span class="function"><span class="params">c</span> =&gt;</span> c * <span class="built_in">this</span>.components[i]))</span><br><span class="line">    <span class="keyword">const</span> newComponents = multiplied[<span class="number">0</span>].map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> sum(multiplied.map(<span class="function"><span class="params">column</span> =&gt;</span> column[i])))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(...newComponents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector2D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> vector3D = <span class="keyword">new</span> Vector(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> matrix2x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix2x3D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> matrix3x2D = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3D =&gt; 2D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector3D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 19, 49 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2D =&gt; 3D</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix3x2D))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 13, 29, 45 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector2D.transform(matrix2x3D))</span><br><span class="line"><span class="comment">// Error: Matrix columns length should be equal to vector components length.</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在，我们将尝试对二维的对象应用线性变换。首先，需要创建一个新的 <strong>Contour</strong>（轮廓）类，它在 constructor 中接收一系列的向量（在 2D 平面中形成一个轮廓），然后用唯一的方法 —— <strong>transform</strong> 对轮廓中的所有向量坐标进行变换，最后返回一个新的轮廓。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contour</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vectors) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vectors = vectors</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transform(matrix) &#123;</span><br><span class="line">    <span class="keyword">const</span> newVectors = <span class="built_in">this</span>.vectors.map(<span class="function"><span class="params">v</span> =&gt;</span> v.transform(matrix))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contour(newVectors)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contour = <span class="keyword">new</span> Contour([</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>现在，请在 <a href="https://rodionchachura.github.io/linear-algebra/">linear-algebra-demo</a> 项目中试试各种转换矩阵。红色方块是初始化的轮廓，蓝色形状是应用变换矩阵后的轮廓。</p><p><img src="/images/15615132290264.jpg" alt="镜像"></p><p><img src="/images/15615132414178.jpg" alt="缩放"></p><p>通过下面的方式，我们可以构建一个矩阵，用于将给定的向量旋转指定的角度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> angle = toRadians(<span class="number">45</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = <span class="keyword">new</span> Matrix(</span><br><span class="line">  [<span class="built_in">Math</span>.cos(angle), -<span class="built_in">Math</span>.sin(angle)],</span><br><span class="line">  [<span class="built_in">Math</span>.sin(angle), <span class="built_in">Math</span>.cos(angle)]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/15615132769006.jpg" alt="旋转"></p><p><img src="/images/15615133004176.jpg" alt="剪切变换"></p><p>对 3D 空间内的对象进行变换也与此类似。你可以在下图中看到一个红色方块变换成一个蓝色的平行六边形的动画。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323433322f312a7a6f5472705f6c6d3170324851436c6b614f644d4f512e676966.gif" alt="3D 剪切变换"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 线性代数：向量</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-vectors/</id>
    <published>2019-06-26T01:01:00.000Z</published>
    <updated>2019-06-26T02:08:28.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p><strong>向量</strong>是用于精确表示空间中方向的方法。向量由一系列数值构成，每维数值都是向量的一个<strong>分量</strong>。在下图中，你可以看到一个由两个分量组成的、在 2 维空间内的向量。在 3 维空间内，向量会由 3 个分量组成。</p><p><img src="/images/15615124754701.jpg" alt="the vector in 2D space"></p><p>我们可以为 2 维空间的向量创建一个 <strong>Vector2D</strong> 类，然后为 3 维空间的向量创建一个 <strong>Vector3D</strong> 类。但是这么做有一个问题：向量并不仅用于表示物理空间中的方向。比如，我们可能需要将颜色（RGBA）表示为向量，那么它会有 4 个分量：红色、绿色、蓝色和 alpha 通道。或者，我们要用向量来表示有不同占比的 <strong>n</strong> 种选择（比如表示 5 匹马赛马，每匹马赢得比赛的概率的向量）。因此，我们会创建一个不指定维度的类，并像这样使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> direction2d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> direction3d = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> Vector(<span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="keyword">const</span> probabilities = <span class="keyword">new</span> Vector(<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>考虑有两个向量的情况，可以对它们定义以下运算：</p><p><img src="/images/15615124998598.jpg" alt="basic vector operations"></p><p>其中，<strong>α ∈ R</strong> 为任意常数。</p><p>我们对除了叉积之外的运算进行了可视化，你可以在<a href="https://rodionchachura.github.io/linear-algebra/">此处</a>找到相关示例。<a href="https://github.com/RodionChachura/linear-algebra">此 GitHub 仓库</a>里有用来创建这些可视化示例的 React 项目和相关的库。如果你想知道如何使用 React 和 SVG 来制作这些二维可视化示例，请参考<a href="https://juejin.im/post/5cefbc37f265da1bd260d129">本文</a>。</p><h3 id="加法与减法"><a href="#加法与减法" class="headerlink" title="加法与减法"></a>加法与减法</h3><p>与数值运算类似，你可以对向量进行加法与减法运算。对向量进行算术运算时，可以直接对向量各自的分量进行数值运算得到结果：</p><p><img src="/images/15615125322484.jpg" alt="vectors addition"></p><p><img src="/images/15615125380537.jpg" alt="vectors subtraction"></p><p>加法函数接收另一个向量作为参数，并将对应的向量分量相加，返回得出的新向量。减法函数与之类似，不过会将加法换成减法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="built_in">this</span>.components[index] + component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  subtract(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...components.map(<span class="function">(<span class="params">component, index</span>) =&gt;</span> <span class="built_in">this</span>.components[index] - component)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.add(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 4, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(one.subtract(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>我们可以对一个向量进行缩放，缩放比例可为任意数值 <strong>α ∈ R</strong>。缩放时，对所有向量分量都乘以缩放因子 <strong>α</strong>。当 <strong>α &gt; 1</strong> 时，向量会变得更长；当 <strong>0 ≤ α \&lt; 1</strong> 时，向量会变得更短。如果 <strong>α</strong> 是负数，缩放后的向量将会指向原向量的反方向。</p><p><img src="/images/15615125690651.jpg" alt="scaling vector"></p><p>在 <strong>scaleBy</strong> 方法中，我们对所有的向量分量都乘上传入参数的数值，得到新的向量并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  scaleBy(number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      ...this.components.map(<span class="function"><span class="params">component</span> =&gt;</span> component * number)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">2</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 2, 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.5, 1 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vector.scaleBy(<span class="number">-1</span>))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -1, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>向量长度可由勾股定理导出：</p><p><img src="/images/15615125935367.jpg" alt="vectors length"></p><p>由于在 JavaScript 内置的 Math 对象中有现成的函数，因此计算长度的方法非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  length() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(...this.components)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br></pre></td></tr></table></figure><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><p>点积可以计算出两个向量的相似程度。点积方法接收两个向量作为输入，并输出一个数值。两个向量的点积等于它们各自对应分量的乘积之和。</p><p><img src="/images/15615126207640.jpg" alt="dot product"></p><p>在 <strong>dotProduct</strong> 方法中，接收另一个向量作为参数，通过 reduce 方法来计算对应分量的乘积之和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  dotProduct(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.reduce(<span class="function">(<span class="params">acc, component, index</span>) =&gt;</span> acc + component * <span class="built_in">this</span>.components[index], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.dotProduct(other))</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>在我们观察几个向量间的方向关系前，需要先实现一种将向量长度归一化为 1 的方法。这种归一化后的向量在许多情景中都会用到。比如说当我们需要在空间中指定一个方向时，就需要用一个归一化后的向量来表示这个方向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  normalize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scaleBy(<span class="number">1</span> / <span class="built_in">this</span>.length())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> normalized = vector.normalize()</span><br><span class="line"><span class="built_in">console</span>.log(normalized)</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0.4472135954999579, 0.8944271909999159 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(normalized.length())</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><img src="/images/15615126527250.jpg" alt="using dot product"></p><p>如果两个归一化后的向量的点积结果等于 1，则意味着这两个向量的方向相同。我们创建了 <strong>areEqual</strong> 函数用来比较两个浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EPSILON = <span class="number">0.00000001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> areEqual = <span class="function">(<span class="params">one, other, epsilon = EPSILON</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Math</span>.abs(one - other) &lt; epsilon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  haveSameDirectionWith(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveSameDirectionWith(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量点积结果等于 -1，则表示它们的方向完全相反：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  haveOppositeDirectionTo(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">-4</span>, <span class="number">-8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.haveOppositeDirectionTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果两个归一化后的向量的点积结果为 0，则表示这两个向量是相互垂直的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  isPerpendicularTo(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> dotProduct = <span class="built_in">this</span>.normalize().dotProduct(other.normalize())</span><br><span class="line">    <span class="keyword">return</span> areEqual(dotProduct, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">-2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.isPerpendicularTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><p>叉积仅对三维向量适用，它会产生垂直于两个输入向量的向量：</p><p><img src="/images/15615126731739.jpg" alt=""></p><p>我们实现叉积时，假定它只用于计算三维空间内的向量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只适用于 3 维向量</span></span><br><span class="line">  crossProduct(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">1</span>] * components[<span class="number">2</span>] - <span class="built_in">this</span>.components[<span class="number">2</span>] * components[<span class="number">1</span>],</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">2</span>] * components[<span class="number">0</span>] - <span class="built_in">this</span>.components[<span class="number">0</span>] * components[<span class="number">2</span>],</span><br><span class="line">      <span class="built_in">this</span>.components[<span class="number">0</span>] * components[<span class="number">1</span>] - <span class="built_in">this</span>.components[<span class="number">1</span>] * components[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.crossProduct(other))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, -3, 3 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(other.crossProduct(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 0, 3, -3 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h2><p>在现实生活的应用中，上述方法是远远不够的。比如说，我们有时需要找到两个向量的夹角、将一个向量反向，或者计算一个向量在另一个向量上的投影等。</p><p>在开始编写上面说的方法前，需要先写下面两个函数，用于在角度与弧度间相互转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toDegrees = <span class="function"><span class="params">radians</span> =&gt;</span> (radians * <span class="number">180</span>) / <span class="built_in">Math</span>.PI</span><br><span class="line"><span class="keyword">const</span> toRadians = <span class="function"><span class="params">degrees</span> =&gt;</span> (degrees * <span class="built_in">Math</span>.PI) / <span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="夹角"><a href="#夹角" class="headerlink" title="夹角"></a>夹角</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  angleBetween(other) &#123;</span><br><span class="line">    <span class="keyword">return</span> toDegrees(</span><br><span class="line">      <span class="built_in">Math</span>.acos(</span><br><span class="line">        <span class="built_in">this</span>.dotProduct(other) /</span><br><span class="line">        (<span class="built_in">this</span>.length() * other.length())</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.angleBetween(other))</span><br><span class="line"><span class="comment">// 45.00000000000001</span></span><br></pre></td></tr></table></figure><h3 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h3><p>当需要将一个向量的方向指向反向时，我们可以对这个向量进行 -1 缩放：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  negate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.scaleBy(<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(vector.negate())</span><br><span class="line"><span class="comment">// Vector &#123; components: [ -2, -2 ] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p><img src="/images/15615126897492.jpg" alt="project v on d"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  projectOn(other) &#123;</span><br><span class="line">    <span class="keyword">const</span> normalized = other.normalize()</span><br><span class="line">    <span class="keyword">return</span> normalized.scaleBy(<span class="built_in">this</span>.dotProduct(normalized))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(other.projectOn(one))</span><br><span class="line"><span class="comment">// Vector &#123; components: [ 6, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="设定长度"><a href="#设定长度" class="headerlink" title="设定长度"></a>设定长度</h3><p>当需要给向量指定一个长度时，可以使用如下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  withLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.normalize().scaleBy(newLength)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.length())</span><br><span class="line"><span class="comment">// 3.6055512754639896</span></span><br><span class="line"><span class="keyword">const</span> modified = one.withLength(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(modified.length())</span><br></pre></td></tr></table></figure><h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p>为了判断两个向量是否相等，可以对它们对应的分量使用  <strong>areEqual</strong> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...components) &#123;</span><br><span class="line">    <span class="built_in">this</span>.components = components</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  equalTo(&#123; components &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.every(<span class="function">(<span class="params">component, index</span>) =&gt;</span> areEqual(component, <span class="built_in">this</span>.components[index]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(other))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(one.equalTo(another))</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="单位向量与基底"><a href="#单位向量与基底" class="headerlink" title="单位向量与基底"></a>单位向量与基底</h2><p>我们可以将一个向量看做是“在 x 轴上走 $v_x$ 的距离、在 y 轴上走 $v_y$ 的距离、在 z 轴上走 $v_z$ 的距离”。我们可以使用 $\hat { \imath }$ 、$\hat { \jmath }$ 和 $\hat { k }$ 分别乘上一个值更清晰地表示上述内容。下图分别是 $x$、$y$、$z$ 轴上的<strong>单位向量</strong>：</p><script type="math/tex; mode=display">\hat { \imath } = ( 1,0,0 ) \quad \hat { \jmath } = ( 0,1,0 ) \quad \hat { k } = ( 0,0,1 )</script><p>任何数值乘以 $\hat { \imath }$ 向量，都可以得到一个第一维分量等于该数值的向量。例如：</p><script type="math/tex; mode=display">2 \hat { \imath } = ( 2,0,0 ) \quad 3 \hat { \jmath } = ( 0,3,0 ) \quad 5 \hat { K } = ( 0,0,5 )</script><p>向量中最重要的一个概念是<strong>基底</strong>。设有一个 3 维向量 $\mathbb{R}^3$，它的基底是一组向量：$\{\hat{e}_1,\hat{e}_2,\hat{e}_3\}$，这组向量也可以作为 $\mathbb{R}^3$ 的坐标系统。如果 $\{\hat{e}_1,\hat{e}_2,\hat{e}_3\}$ 是一组基底，则可以将任何向量 $\vec{v} \in \mathbb{R}^3$ 表示为该基底的系数 $(v_1,v_2,v_3)$：</p><script type="math/tex; mode=display">\vec{v} = v_1 \hat{e}_1 + v_2 \hat{e}_2 + v_3 \hat{e}_3</script><p>向量 $\vec{v}$ 是通过在 $\hat{e}_1$ 方向上测量 $v_2$ 的距离、在 $\hat{e}_2$ 方向上测量 $v_1$ 的距离、在 $\hat{e}_3$ 方向上测量 $v_3$ 的距离得出的。</p><p>在不知道一个向量的基底前，向量的系数三元组并没有什么意义。只有知道向量的基底，才能将类似于 $(a,b,c)$ 三元组的数学对象转化为现实世界中的概念（比如颜色、概率、位置等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="SVG" scheme="https://lsvih.com/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>用 React 制作线性代数教程示例：网格与箭头</title>
    <link href="https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/"/>
    <id>https://lsvih.com/2019/06/26/javascript-linear-algebra-react-example/</id>
    <published>2019-06-26T01:00:00.000Z</published>
    <updated>2019-06-26T02:08:16.940Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“<a href="https://lsvih.com/2019/06/26/javascript-linear-algebra/">JavaScript 线性代数</a>”教程的一部分。</p><a id="more"></a><p>最近我撰写了这个线性代数系列的<a href="https://medium.com/@geekrodion/linear-algebra-vectors-f7610e9a0f23">开篇之作</a>。在新篇开始动笔前，我有了一个想法：使用 React 开发一个项目，来为这个系列的所有示例提供可视化功能一定很好玩！本系列的所有代码都存放于<a href="https://github.com/RodionChachura/linear-algebra">此 GitHub 仓库</a>，本文相关代码的提交记录位于<a href="https://github.com/RodionChachura/linear-algebra/tree/813cfecfda70cb3a9415c21ead97e09242e08f49">此处</a>。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本系列刚开始写作时，只有一个章节涉及了向量的基本运算。所以，目前实现一个能渲染二维坐标网格以及能将向量可视化为箭头的组件就够用了。本文最后做出的效果如下图所示，你也可以在<a href="https://rodionchachura.github.io/linear-algebra/">此处</a>进行体验。</p><p><img src="/images/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f333833302f312a3338743653416c5363676d42476a58516e39635475412e676966.gif" alt="二维空间中的基本向量运算"></p><h2 id="创建-React-项目"><a href="#创建-React-项目" class="headerlink" title="创建 React 项目"></a>创建 React 项目</h2><p>其实已经有关于创建 React 项目的最佳实践指南文章可供参考，不过在本文中，我们将尽可能减少依赖的库，并简化对项目的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-react-app linear-algebra-demo</span><br><span class="line"><span class="built_in">cd</span> linear-algebra-demo</span><br><span class="line">npm install --save react-sizeme styled-components</span><br></pre></td></tr></table></figure><p>上面的脚本安装了两个库。第一个库 <code>react-sizeme</code> 可以实现当窗体大小发生变化时，重新渲染网格组件。第二个库 <code>styled-components</code> 则能让我们更轻松地编写组件的样式。此外，要用到我们正在开发的 <strong>linear-algebra</strong> 库，需要在 <strong>package.json</strong> 中进行如下引用：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;linear-algebra&quot;</span>: <span class="string">&quot;file:../library&quot;</span>,</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/images/15615123069092.jpg" alt="项目结构"></p><p>本系列为每个示例都在 <code>views</code> 目录中创建了各自的组件。我们在 <strong>index.js</strong> 中导出一个以示例名称为键、以对应组件为值的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorLength &#125; <span class="keyword">from</span> <span class="string">&#x27;./vector-length&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorScale &#125; <span class="keyword">from</span> <span class="string">&#x27;./vector-scale&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsAddition &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-addition&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsSubtraction &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-subtraction&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> VectorsDotProduct &#125; <span class="keyword">from</span> <span class="string">&#x27;./vectors-dot-product&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">&#x27;vectors: addition&#x27;</span>: VectorsAddition,</span><br><span class="line">  <span class="string">&#x27;vectors: subtraction&#x27;</span>: VectorsSubtraction,</span><br><span class="line">  <span class="string">&#x27;vectors: length&#x27;</span>: VectorLength,</span><br><span class="line">  <span class="string">&#x27;vectors: scale&#x27;</span>: VectorScale,</span><br><span class="line">  <span class="string">&#x27;vectors: dot product&#x27;</span>: VectorsDotProduct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>Main</code> 组件中导入该对象，并在菜单中展示出所有的键。当用户通过菜单选择示例后，更新组件状态，并渲染新的 <code>view</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> views <span class="keyword">from</span> <span class="string">&#x27;./views&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MenuItem <span class="keyword">from</span> <span class="string">&#x27;./menu-item&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Menu = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      view: <span class="built_in">Object</span>.keys(views)[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; view &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> View = views[view]</span><br><span class="line">    <span class="keyword">const</span> viewsNames = <span class="built_in">Object</span>.keys(views)</span><br><span class="line">    <span class="keyword">const</span> MenuItems = <span class="function">() =&gt;</span></span><br><span class="line">      viewsNames.map(<span class="function"><span class="params">name</span> =&gt;</span> (</span><br><span class="line">        &lt;MenuItem</span><br><span class="line">          key=&#123;name&#125;</span><br><span class="line">          selected=&#123;name === view&#125;</span><br><span class="line">          text=&#123;name&#125;</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">view</span>: name &#125;)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;View /&gt;</span><br><span class="line">        &lt;Menu&gt;</span><br><span class="line">          &lt;MenuItems /&gt;</span><br><span class="line">        &lt;/Menu&gt;</span><br><span class="line">      &lt;/Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><h2 id="网格组件"><a href="#网格组件" class="headerlink" title="网格组件"></a>网格组件</h2><p>为了在之后的示例中渲染向量和其它内容，我们设计了一个功能强大的组件，这个组件需要有这么一种投影功能：将我们熟知的直角坐标系（原点在中间，y 轴正向朝上）投影到 <strong>SVG</strong> 坐标系（原点在左上角，y 轴正向朝下）中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.updateProject(<span class="function"><span class="params">vector</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 vector 类中没有任何用于缩放的方法，因此在这里进行计算：</span></span><br><span class="line">  <span class="keyword">const</span> scaled = vector.scaleBy(step)</span><br><span class="line">  <span class="keyword">const</span> withNegatedY = <span class="keyword">new</span> Vector(</span><br><span class="line">    scaled.components[<span class="number">0</span>],</span><br><span class="line">    -scaled.components[<span class="number">1</span>]</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> middle = getSide(size) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> withNegatedY.add(<span class="keyword">new</span> Vector(middle, middle))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了捕获到网格组件容器的大小变动，我们使用 <strong>react-size</strong> 库提供的函数将这个组件包装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123; withSize &#125; <span class="keyword">from</span> <span class="string">&#x27;react-sizeme&#x27;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  updateProject = <span class="function">(<span class="params">size, cells</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> step = getStepLen(size, cells)</span><br><span class="line">    <span class="built_in">this</span>.props.updateProject(<span class="function">() =&gt;</span> /...)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(&#123; size, cells &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="keyword">const</span> newStepLen = getStepLen(size, cells)</span><br><span class="line">      <span class="keyword">const</span> oldStepLen = getStepLen(<span class="built_in">this</span>.props.size, cells)</span><br><span class="line">      <span class="keyword">if</span> (newStepLen !== oldStepLen) &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateProject(size, cells)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.updateProject) &#123;</span><br><span class="line">      <span class="built_in">this</span>.updateProject(<span class="built_in">this</span>.props.size, <span class="built_in">this</span>.props.cells)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withSize(&#123; <span class="attr">monitorHeight</span>: <span class="literal">true</span> &#125;)(Grid)</span><br></pre></td></tr></table></figure><p>为了便于在不同的示例中使用这个网格组件，我们编写了一个 <strong>GridExample</strong> 组件，它可以接收两个参数：一个用于渲染信息（例如向量的名称）的函数 <code>renderInformation</code>，以及一个用于在网格上呈现内容（如后面的箭头组件）的函数 <code>renderGridContent</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> Grid <span class="keyword">from</span> <span class="string">&#x27;./grid&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      project: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; project &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123; renderInformation, renderGridContent &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> Content = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (project &amp;&amp; renderGridContent) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderGridContent(&#123; project &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Information = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (renderInformation) &#123;</span><br><span class="line">        <span class="keyword">return</span> renderInformation()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container&gt;</span><br><span class="line">        &lt;Grid cells=&#123;<span class="number">10</span>&#125; updateProject=&#123;<span class="function"><span class="params">project</span> =&gt;</span> <span class="built_in">this</span>.setState(&#123; project &#125;)&#125;&gt;</span><br><span class="line">          &lt;Content /&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">        &lt;InfoContainer&gt;</span><br><span class="line">          &lt;Information /&gt;</span><br><span class="line">        &lt;/InfoContainer&gt;</span><br><span class="line">      &lt;/Container&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main</span><br></pre></td></tr></table></figure><p>这样就能在 view 中使用这个组件了。下面以向量的加法为例测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> GridExample <span class="keyword">from</span> <span class="string">&#x27;../grid-example&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Arrow <span class="keyword">from</span> <span class="string">&#x27;../arrow&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VectorView <span class="keyword">from</span> <span class="string">&#x27;../vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VectorsAddition = <span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">const</span> other = <span class="keyword">new</span> Vector(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> oneName = <span class="string">&#x27;v⃗&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> otherName = <span class="string">&#x27;w⃗&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> oneColor = theme.color.green</span><br><span class="line">  <span class="keyword">const</span> otherColor = theme.color.red</span><br><span class="line">  <span class="keyword">const</span> sum = one.add(other)</span><br><span class="line">  <span class="keyword">const</span> sumColor = theme.color.blue</span><br><span class="line">  <span class="keyword">const</span> sumText = <span class="string">`<span class="subst">$&#123;oneName&#125;</span> + <span class="subst">$&#123;otherName&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> renderInformation = <span class="function">() =&gt;</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;VectorView components=&#123;one.components&#125; name=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span><br><span class="line">      &lt;VectorView</span><br><span class="line">        components=&#123;other.components&#125;</span><br><span class="line">        name=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;VectorView components=&#123;sum.components&#125; name=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> renderGridContent = <span class="function">(<span class="params">&#123; project &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;one&#125; text=&#123;oneName&#125; color=&#123;oneColor&#125; /&gt;</span><br><span class="line">      &lt;Arrow</span><br><span class="line">        project=&#123;project&#125;</span><br><span class="line">        vector=&#123;other&#125;</span><br><span class="line">        text=&#123;otherName&#125;</span><br><span class="line">        color=&#123;otherColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Arrow project=&#123;project&#125; vector=&#123;sum&#125; text=&#123;sumText&#125; color=&#123;sumColor&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> props = &#123; renderInformation, renderGridContent &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GridExample</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTheme(VectorsAddition)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头组件"><a href="#箭头组件" class="headerlink" title="箭头组件"></a>箭头组件</h2><p>箭头组件由 3 个 <strong>SVG</strong> 元素组成：<strong>line</strong> 用于显示箭头的线、<strong>polygon</strong> 用于显示箭头的头、<strong>text</strong> 用于显示向量名称。此外，我们需要接收 <strong>project</strong> 函数，用于将箭头放在网格中正确的位置上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vector &#125; <span class="keyword">from</span> <span class="string">&#x27;linear-algebra/vector&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Arrow = styled.line<span class="string">`</span></span><br><span class="line"><span class="string">  stroke-width: 2px;</span></span><br><span class="line"><span class="string">  stroke: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Head = styled.polygon<span class="string">`</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Text = styled.text<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 24px;</span></span><br><span class="line"><span class="string">  fill: <span class="subst">$&#123;p =&gt; p.color&#125;</span>;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; vector, text, color, project &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> direction = vector.normalize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> headStart = direction.scaleBy(vector.length() - <span class="number">0.6</span>)</span><br><span class="line">  <span class="keyword">const</span> headSide = <span class="keyword">new</span> Vector(</span><br><span class="line">    direction.components[<span class="number">1</span>],</span><br><span class="line">    -direction.components[<span class="number">0</span>]</span><br><span class="line">  ).scaleBy(<span class="number">0.2</span>)</span><br><span class="line">  <span class="keyword">const</span> headPoints = [</span><br><span class="line">    headStart.add(headSide),</span><br><span class="line">    headStart.subtract(headSide),</span><br><span class="line">    vector</span><br><span class="line">  ]</span><br><span class="line">    .map(project)</span><br><span class="line">    .map(<span class="function"><span class="params">v</span> =&gt;</span> v.components)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> projectedStart = project(<span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">const</span> projectedEnd = project(vector)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PositionedText = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!text) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> &#123; components &#125; = project(vector.withLength(vector.length() + <span class="number">0.2</span>))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text color=&#123;color&#125; x=&#123;components[<span class="number">0</span>]&#125; y=&#123;components[<span class="number">1</span>]&#125;&gt;</span><br><span class="line">        &#123;text&#125;</span><br><span class="line">      &lt;/Text&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;g&gt;</span><br><span class="line">      &lt;Arrow</span><br><span class="line">        color=&#123;color&#125;</span><br><span class="line">        x1=&#123;projectedStart.components[<span class="number">0</span>]&#125;</span><br><span class="line">        y1=&#123;projectedStart.components[<span class="number">1</span>]&#125;</span><br><span class="line">        x2=&#123;projectedEnd.components[<span class="number">0</span>]&#125;</span><br><span class="line">        y2=&#123;projectedEnd.components[<span class="number">1</span>]&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Head color=&#123;color&#125; points=&#123;headPoints&#125; /&gt;</span><br><span class="line">      &lt;PositionedText /&gt;</span><br><span class="line">    &lt;/g&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>通过结合 <strong>React</strong> 与 <strong>SVG</strong> 可以做更多有意思的事。在本系列的后面章节中，我们会给这个可视化示例添加更多的功能。最后推荐另一篇类似的文章：<a href="https://medium.com/@geekrodion/bar-chart-with-react-3b20b7907633">使用 <strong>React</strong> 与 <strong>SVG</strong> 制作复杂的条形图</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“&lt;a href=&quot;https://lsvih.com/2019/06/26/javascript-linear-algebra/&quot;&gt;JavaScript 线性代数&lt;/a&gt;”教程的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Linear Algebra" scheme="https://lsvih.com/tags/Linear-Algebra/"/>
    
      <category term="React" scheme="https://lsvih.com/tags/React/"/>
    
      <category term="线性代数" scheme="https://lsvih.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数据可视化" scheme="https://lsvih.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>An Online Social Network-based Recommendation System 论文笔记</title>
    <link href="https://lsvih.com/2019/05/23/An%20Online%20Social%20Network-based%20Recommendation%20System/"/>
    <id>https://lsvih.com/2019/05/23/An%20Online%20Social%20Network-based%20Recommendation%20System/</id>
    <published>2019-05-23T14:48:00.000Z</published>
    <updated>2019-05-23T14:48:31.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作者提出了一种基于社会网络的推荐系统，这种推荐系统利用用户资料以及用户与用户之间的连接进行推荐（具体来说是通过用户的打分矩阵和对应的朋友关系来推荐）。</p><blockquote><p>本文的数据来源于一个名为 BoardGameGeek（BGG）的网站，在数据一节详细描述</p></blockquote><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p>所谓推荐系统，是一种基于用户以往数据、通过某些算法计算，向用户推送新内容的一种机制，在 20 世纪互联网经济发展中被广泛使用。最早利用推荐系统扩大利润的是电商 Amazon，他们利用用户曾经购买或评分的商品来预测用户之后可能会购买的商品并进行推送，从而促使用户购买更多的商品。</p><p>推荐系统最常用的方式就是基于内容的<strong>协同过滤</strong>方法（这种方式在今天也被广泛使用，好处是推荐较为准确，坏处是计算量极大），具体来说就是通过计算多个用户喜好的相似，来推荐对应的对象。</p><p>推荐系统研究的一个难点就是数据的获取，使用用户数据容易触及隐私问题，因此各个公司都是在利用用户的公开数据来进行推荐系统的研究。这又有另一个问题：很多用户的公开数据并不完全（比如获取不到用户间的联系），导致困难重重。此外，传统的算法的前提假设为用户是独立的存在，因此无法利用用户的结构信息来进行推荐。</p><p>作者通过对社会学和机器学习的研究，为 boardgaming 开发了一种 Online Social Network-based（OSN）推荐系统，实现了较好的推荐效果。</p><p>最后作者还对数据的隐私问题和算法的应用进行了讨论。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>BoardGameGeek（BGG）是一个知名的游戏站点，人们在其中讨论各种游戏机和卡带，并且会对各个游戏、主机等产品进行评价、打分。比较特殊的是，这个网站包含了大量的公开社交信息（玩家会公开加好友，并进行讨论），因此适合用来使用社会网络来构建推荐系统。</p><p>最终，作者使用的数据包括：</p><ul><li>大约 3 万条被用户评价过的游戏数据</li><li>大约 4 万条曾经评价过游戏的用户数据</li><li>所有的任意用户对任意游戏的评价数据</li><li>各个用户“愿望清单”的游戏列表</li><li>用户与用户之间的好友关系</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>作者使用了概率矩阵分解算法（probabilistic matrix factorization，简称 PMF 算法）。在此简单描述一下这个算法：</p><p>给定一个维数为 $M \times N$ 的评价矩阵 $R$，其中 $R_{ij}$ 可以表示用户 $i$ 对游戏 $j$ 的评价分数。而 PMF 算法的目的就是对评价矩阵 $R$ 进行矩阵分解，找到评价矩阵的因子：</p><script type="math/tex; mode=display">R \approx U G</script><p>其中 $U \in \mathcal { R } ^ { M \times D } $, $G \in \mathcal { R } ^ { D \times N }$。作者假设有一些“原型用户”（prototype user），这种用户具有评分和喜好的代表性。上式中的$D$就是这种“原型用户”的数量。因此上面的矩阵分解就能得出原型用户的评分矩阵。作者直接利用 FA、PCA 之类的矩阵分解算法，使用方差 $\left( \sum _ { i , j } R _ { i j } - U _ { i } ^ { T } G _ { j } \right) ^ { 2 }$ 作为损失函数，对矩阵分解算法进行优化。（注，这应该是非常稀疏的矩阵分析）</p><p>为了把社会网络的信息加入模型中，作者将社交信息定义为矩阵 $F$，其维数是 $M \times M$。在 $F$ 中，如果用户 $i$ 和 $j$ 是好友关系，则 $F_{ij} = 1$，否则为 0。由此，作者将前面的矩阵分析式子改写为：</p><script type="math/tex; mode=display">R \approx F U G</script><p>转换问题，写作：</p><script type="math/tex; mode=display">F^{-1} R \approx U G</script><p>这样就可以继续用前文的方法求出原型用户的评分了。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者使用 SE（方差）loss 对矩阵分解进行优化，在训练迭代过程中 loss 下降情况如下图所示：</p><p><img src="/images/15586229007735.jpg" alt="-w445"></p><p>可以看到算法确实收敛了。（个人觉得可能过拟合了）</p><p>这个实验因为没有标注数据，所以也不好进行评价。因此作者用少数的数据作为测试集来验证效果，发现结果不错，最后直接将这个 baseline 做成了一款 Web 应用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种同时利用社会网络信息和用户评分信息的推荐算法，改善了推荐系统的效果。其意义是找了一种方法来把简单的社会网络信息给整合进传统的评分矩阵分解法中。总体来说整个文章的方法非常简单，而且实验不够置信，但可以用来参考了解“基于社会网络的推荐系统”这一课题。</p><p>此外，这篇文献的年代其实比较久远，目前已经有各种各样利用 Network Embedding 的方法，利用各种异构网络信息去做推荐系统，但其实主要的方法还是这篇文章中的方法：将评分矩阵与网络表示矩阵进行合并，然后再做矩阵分析。区别是本文的 Social Network 的表示实质上就是最简单的 one-hot Network Embedding，如果换成现代先进的 node2vec、deep walk 之类的方法应该会有所提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文发表于2007年，作者是来自多伦多大学计算机系的几位师生。虽然本文在领域内影响并不大，但我认为它的撰写非常清晰，有利于对“基于社会网络的推荐系统”这一课题的了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="recommendation system" scheme="https://lsvih.com/tags/recommendation-system/"/>
    
      <category term="social network" scheme="https://lsvih.com/tags/social-network/"/>
    
  </entry>
  
  <entry>
    <title>使用 PyTorch 在 MNIST 数据集上进行逻辑回归</title>
    <link href="https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/"/>
    <id>https://lsvih.com/2019/04/29/logistic-regression-on-mnist-with-pytorch/</id>
    <published>2019-04-29T04:02:00.000Z</published>
    <updated>2019-06-30T04:16:29.630Z</updated>
    
    <content type="html"><![CDATA[<p><strong>逻辑回归（Logistic Regression）</strong>既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了<strong>逻辑回归</strong>与<strong>线性回归</strong>的区别。</p><p><img src="/images/15618681795750.jpg" alt=""></p><p>本文将展示如何使用 PyTorch 编写逻辑回归模型。<br><a id="more"></a><br>我们将尝试在 MNIST 数据集上解决分类问题。首先，导入我们所需要的所有库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dsets</span><br></pre></td></tr></table></figure><p>在创建模型前，我喜欢列一个如下的步骤表。PyTorch 官网[2]上也有这个步骤列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：加载数据集</span></span><br><span class="line"><span class="comment"># 第二步：使数据集可迭代</span></span><br><span class="line"><span class="comment"># 第三步：创建模型类</span></span><br><span class="line"><span class="comment"># 第四步：将模型类实例化</span></span><br><span class="line"><span class="comment"># 第五步：实例化 Loss 类</span></span><br><span class="line"><span class="comment"># 第六步：实例化优化器类</span></span><br><span class="line"><span class="comment"># 第七步：训练模型</span></span><br></pre></td></tr></table></figure><p>下面我们将一步步完成上述的步骤。</p><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>我们使用 <strong>torchvision.datasets</strong> 来加载数据集。这个库中包含了几乎全部的用于机器学习的流行数据集。在[3]中可以看到完整的数据集列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = dsets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transforms.ToTensor(), download=<span class="literal">False</span>)</span><br><span class="line">test_dataset = dsets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><h3 id="使数据集可迭代"><a href="#使数据集可迭代" class="headerlink" title="使数据集可迭代"></a>使数据集可迭代</h3><p>我们利用 DataLoader 类，使用以下代码来让我们的数据集可被迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="创建模型类"><a href="#创建模型类" class="headerlink" title="创建模型类"></a>创建模型类</h3><p>现在，我们将创建一个用来定义逻辑回归模型结构的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_dim, output_dim</span>):</span></span><br><span class="line">        super(LogisticRegression, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(input_dim, output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        outputs = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h3 id="将模型类实例化"><a href="#将模型类实例化" class="headerlink" title="将模型类实例化"></a>将模型类实例化</h3><p>在将模型类实例化之前，我们先初始化如下所示的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">n_iters = <span class="number">3000</span></span><br><span class="line">epochs = n_iters / (len(train_dataset) / batch_size)</span><br><span class="line">input_dim = <span class="number">784</span></span><br><span class="line">output_dim = <span class="number">10</span></span><br><span class="line">lr_rate = <span class="number">0.001</span></span><br></pre></td></tr></table></figure><p>然后，就能初始化我们的逻辑回归模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = LogisticRegression(input_dim, output_dim)</span><br></pre></td></tr></table></figure><h3 id="实例化-Loss-类"><a href="#实例化-Loss-类" class="headerlink" title="实例化 Loss 类"></a>实例化 Loss 类</h3><p>我们使用交叉熵损失来计算 loss：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.CrossEntropyLoss() <span class="comment"># 计算 softmax 分布之上的交叉熵损失</span></span><br></pre></td></tr></table></figure><h3 id="实例化优化器类"><a href="#实例化优化器类" class="headerlink" title="实例化优化器类"></a>实例化优化器类</h3><p>优化器（optimizer）就是我们即将使用的学习算法。在本例中，我们将使用随机梯度下降（SGD）作为优化器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=lr_rate)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>这就是最后一步了。我们将用以下的代码来训练模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">iter = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(int(epochs)):</span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line">        labels = Variable(labels)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        iter+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> iter%<span class="number">500</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 计算准确率</span></span><br><span class="line">            correct = <span class="number">0</span></span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">                images = Variable(images.view(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line">                outputs = model(images)</span><br><span class="line">                _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">                total+= labels.size(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 如果用的是 GPU，则要把预测值和标签都取回 CPU，才能用 Python 来计算</span></span><br><span class="line">                correct+= (predicted == labels).sum()</span><br><span class="line">            accuracy = <span class="number">100</span> * correct/total</span><br><span class="line">            print(<span class="string">&quot;Iteration: &#123;&#125;. Loss: &#123;&#125;. Accuracy: &#123;&#125;.&quot;</span>.format(iter, loss.item(), accuracy))</span><br></pre></td></tr></table></figure><p>在训练时，这个模型只需要进行 3000 次迭代就能达到 <strong>82%</strong> 的准确率。你可以试着继续调整一下参数，看看还能不能把准确率再调高一点。</p><p>如果你想加深对在 PyTorch 中实现逻辑回归的理解，可以把上面的模型应用于任何分类问题。比如，你可以训练一个逻辑回归模型来对你最喜爱的<strong>漫威英雄</strong>的图像做个分类（有一半已经化灰了，所以做分类应该不是很难）:)</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] <a href="https://www.statisticssolutions.com/what-is-logistic-regression/">https://www.statisticssolutions.com/what-is-logistic-regression/</a></p><p>[2] <a href="https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py">https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html#sphx-glr-beginner-blitz-neural-networks-tutorial-py</a></p><p>[3] <a href="https://pytorch.org/docs/stable/torchvision/datasets.html">https://pytorch.org/docs/stable/torchvision/datasets.html</a></p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5cc66d946fb9a032286173a7">https://juejin.im/post/5cc66d946fb9a032286173a7</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;逻辑回归（Logistic Regression）&lt;/strong&gt;既可以用来描述数据，也可以用来解释数据中各个二值变量、类别变量、顺序变量、距离变量、比率变量之间的关系[1]。下图展示了&lt;strong&gt;逻辑回归&lt;/strong&gt;与&lt;strong&gt;线性回归&lt;/strong&gt;的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/15618681795750.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文将展示如何使用 PyTorch 编写逻辑回归模型。&lt;br&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="pytorch" scheme="https://lsvih.com/tags/pytorch/"/>
    
      <category term="MNIST" scheme="https://lsvih.com/tags/MNIST/"/>
    
  </entry>
  
  <entry>
    <title>Robust Classification with Convolutional Prototype Learning 论文笔记</title>
    <link href="https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://lsvih.com/2019/04/07/Robust-Classification-with-Convolutional-Prototype-Learning-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-07T10:48:00.000Z</published>
    <updated>2019-04-08T01:36:59.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。<br>论文地址：<a href="https://arxiv.org/abs/1805.03438v1">https://arxiv.org/abs/1805.03438v1</a><br>论文代码：<a href="https://github.com/YangHM/Convolutional-Prototype-Learning">https://github.com/YangHM/Convolutional-Prototype-Learning</a></p></blockquote><p>这篇文章在原型学习（prototype learning）与 CNN 的基础之上，提出了一种有效的学习方式，并设计了几种不同的 loss 函数，这些损失函数均能从直观上理解其效果并在实验中证明它们的有效性。通过学习这篇文章，可以更好地了解原型学习以及 loss 的设计，同时可以直接将文中的方法用于一些下游应用。</p><p><strong>此外需要注意的是</strong>，这篇文章的“Robust classification”和 Goodfellow 提出的对抗样本型“Robust model”是两码事。这篇文章没有对模型对于对抗样本的 Robust 进行分析，但本文提出的方法学习到的分类器对于任务来说是 Robust 的。从文章的实验结果来看，将这篇文章提出的方法称为“Robust”一点也不为过，毕竟“Robust”又不是 Goodfellow 发明的，各人可以有自己的理解。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章主要按以下的框架描述了作者提出的方法：</p><ul><li>背景与相关工作</li><li>卷积原型学习（Convolutional prototype learning）</li><li>设计的各种 loss 函数</li><li>实验结果与分析</li></ul><p>因此，这篇笔记也按照论文作者的写作顺序记录。</p><h2 id="背景与相关工作"><a href="#背景与相关工作" class="headerlink" title="背景与相关工作"></a>背景与相关工作</h2><p><img src="/images/15546341569411.jpg" alt=""></p><p>文章开头就给了这张图，描述了传统的 CNN 模型 + cross entropy loss 在 MNIST 上训练出来的特征的二维表示。作者用此图片说明了传统 CNN 模型的问题：学习出来的分类特征在特征空间内非常集中，甚至有很多类内距离（intra-class）小于类间距离（inter-class）的情况。这种情况也就会导致最终的分类效果变差，并且分类模型不易拓展等不够“Robust”的问题。</p><blockquote><p>这个图片的具体作图方法，是把模型输出层前的最后隐层（bottleneck layer）设定为两个神经元，训练完成后，将样本送入神经网络，取出这两个神经元的输出，将输出分别设为 X 与 Y 轴，即得到了这张图。（这个方法可以用在别的需要可视化特征的场景中，可以免去 PCA 等降维步骤。不过在一些比较复杂的任务里貌似这么训练会很难收敛）</p></blockquote><p>尽管后来还有人为此做了各种改进，比如 triple loss、centre loss 等，来改善这种情况，但这些方法都没有离开 softmax + cross entropy 的范畴，也没有根本解决问题。因此作者基于原型学习的思想，利用 CNN 作为特征提取的工具，提出了一种原型学习框架 Convolutional prototype learning（后文直接记为 CPL），同时为它设计了几种模式的 loss 函数，在实验上取得了良好的效果。</p><blockquote><p>关于什么是原型学习，可以了解一下 LVQ 算法。</p></blockquote><h2 id="卷积原型学习"><a href="#卷积原型学习" class="headerlink" title="卷积原型学习"></a>卷积原型学习</h2><p><img src="/images/15546341698125.jpg" alt=""></p><p>如图所示。这个框架其实思路很简单：</p><ol><li>利用 CNN 进行特征提取：直接将 CNN 看做是一个 $f(x,\theta)$ 的函数，输入的 x 是数据，$\theta$ 是 CNN 的参数；输出的是特征。</li><li>用一个或多个原型来对应每一个分类（文章后来用实验证明了一个分类对应一个原型就可以有足够好的效果）。</li><li>在训练时，让原型与原型间的欧式距离尽量远，让特征与对应类别原型的欧式距离尽量近：</li></ol><script type="math/tex; mode=display">\begin{array} { l } { x \in \text { class arg } \max _ { i = 1 } ^ { C } g _ { i } ( x ) } \\ { g _ { i } ( x ) = - \min _ { j = 1 } \left\| f ( x ; \theta ) - m _ { i j } \right\| _ { 2 } ^ { 2 } } \end{array}</script><p>（上式中各符号代表的含义请参考原论文 3.1 与 3.2）</p><h2 id="loss-函数"><a href="#loss-函数" class="headerlink" title="loss 函数"></a>loss 函数</h2><p>这部分是文章的核心。为了实现上面一节说的 CPL，必须要有合适的 loss 函数，这种 loss 函数需要满足以下几个条件：</p><ol><li>符合 CPL 的思路，及让原型与原型间距离尽量远，让特征与对应原型的距离尽量近。</li><li>需要对 CNN 可导（这样才能通过 BP 算法去优化 CNN 的参数 $\theta$，也就才能让 CNN 提取出正确的特征）</li><li>需要对原型可导（这样才符合原型学习的思想，才能去不断调整原型在特征空间中的位置）</li></ol><p>因此，这篇文章设计的几个 loss 函数都会去证明 $\frac { \partial l } { \partial f }$ 与 $\frac { \partial l } { \partial M }$ 的可导性。（l 是 loss 函数，f 是 CNN 特征提取器，M 是原型集），笔记中就不再赘述。</p><p>下文将逐个说明论文提出的 loss 函数。</p><h3 id="Minimum-classification-error-loss-MCE"><a href="#Minimum-classification-error-loss-MCE" class="headerlink" title="Minimum classification error loss(MCE)"></a>Minimum classification error loss(MCE)</h3><p>MCE 即“最小分类误差”，是《Discriminative learning for minimum error classification》提出的一种经典的测量指标，主要公式如下：</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + \left[ \frac { 1 } { C - 1 } \sum _ { j \neq y } g _ { j } ( x ) ^ { \eta } \right] ^ { 1 / \eta }</script><p>作者在列这个公式的时候貌似忘了解释 $\eta$ 的作用了。查阅原文发现，这个指标可以用来控制考虑误分类的程度多少。当 $\eta$ 为正无穷的时候，上式等于</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = - g _ { y } ( x ) + g _ { r } ( x )</script><p>其中 $g _ { r } ( x ) = \max _ { k \neq y } g _ { k } ( x )$，是“错的最离谱”的错分距离。因此可以将 MCE 记为</p><script type="math/tex; mode=display">\mu _ { y } ( x ) = \left\| f ( x ) - m _ { y i } \right\| _ { 2 } ^ { 2 } - \left\| f ( x ) - m _ { r j } \right\| _ { 2 } ^ { 2 }</script><p>作者按照《Discriminative learning for minimum error classification》中的 Translated sigmoid 公式定义了这个方法最终的 loss 函数计算公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \frac { 1 } { 1 + e ^ { - \xi \mu _ { y } } }</script><p>综上，这个 loss 方法其实优化的是 MCE 指标，重点是作者将 $\mu_y$ 转换为了原型的形式，换句话就是说这个 loss 在优化时，除了会让 CNN 提取出正确的特征外，还会尽量让原型靠近正确的类的特征分布密集区域，远离错误的类的特征分布区域。通过这种方式，可以实现笔记最开头提到的目标。</p><h3 id="Margin-based-classification-loss-MCL"><a href="#Margin-based-classification-loss-MCL" class="headerlink" title="Margin based classification loss(MCL)"></a>Margin based classification loss(MCL)</h3><p>顾名思义，这个 loss 是“基于边距的分类 loss”。这个“margin”在 triple loss 等方法中其实都有用到。作者提出这个方法的思想就是“让一个样本的特征和对应分类的原型在特征空间中的距离，要小于和其它原型在特征空间内的距离”，通过这种思路，就能使得样本尽量不被误分类。按照这个思路，作者提出了公式：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) \right] _ { + }</script><p>这个公式中的 d 函数就是求样本和原型在特征空间中的欧式距离。整个 loss 用 $\left[ \right] _+$ 包含着，表示只取正值。因为如果样本距离正确分类的原型的距离已经满足要求时，loss 值应该为 0。</p><p>根据上式，作者进一步对这个 loss 进行完善，为它添加了 margin（作用和 triple loss、centre loss 的 margin 是一致的），让“样本离本类原型”的距离要比“样本离其它类原型”距离+margin要更小：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) + m \right] _ { + }</script><p>这样就能达成前文所说的目的。</p><p>作者在此基础上，又为 margin 的值做了进一步的改进。因为在上述 loss 中，margin 的值必须和“样本与原型的距离”值在同一个数量级上才能顺利进行优化。为此，作者稍作转换：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = \left[ \frac { d \left( f ( x ) , m _ { y i } \right) - d \left( f ( x ) , m _ { r j } \right) } { d \left( f ( x ) , m _ { y i } \right) + d \left( f ( x ) , m _ { r j } \right) } + m \right] _ { + }</script><p>这样，m 在 (0,1) 的范围内取值即可保证数量级的一致性。</p><h3 id="Distance-based-cross-entropy-loss-DCE"><a href="#Distance-based-cross-entropy-loss-DCE" class="headerlink" title="Distance based cross entropy loss(DCE)"></a>Distance based cross entropy loss(DCE)</h3><p> 这个 loss 函数是基于一个约等式：</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) \propto - \left\| f ( x ) - m _ { i j } \right\| _ { 2 } ^ { 2 }</script><p> 这个式子的意义是，可以用“样本距离原型的距离”来测度“样本属于一个原型类别的概率”。这样就能用 cross entropy 之类的方法对概率进行优化了。因此，需要用一个确切的值来把上式给写出来，同时满足：</p><ol><li>概率值是正数</li><li><p>所有概率（即一个样本属于各个原型的概率）的和需要为 1</p><p>为此，作者定义</p><script type="math/tex; mode=display">p \left( x \in m _ { i j } | x \right) = \frac { e ^ { - \gamma d \left( f ( x ) , m _ { i j } \right) } } { \sum _ { k = 1 } ^ { C } \sum _ { l = 1 } ^ { K } e ^ { - \gamma d \left( f ( x ) , m _ { k l } \right) } }</script><p>此时，样本属于一个分类的概率即为样本属于这个分类的各个原型的概率之和，即为：</p><script type="math/tex; mode=display">p ( y | x ) = \sum _ { j = 1 } ^ { K } p \left( x \in m _ { y j } | x \right)</script><p>应用 cross entropy，可以将最终的 loss 函数写出来：</p><script type="math/tex; mode=display">l ( ( x , y ) ; \theta , M ) = - \log p ( y | x )</script><p>这个 loss 相当于换了一个角度考虑，把距离换成了概率然后代入 cross entropy。</p></li></ol><h3 id="Generalized-CPL-with-prototype-loss-GCPL"><a href="#Generalized-CPL-with-prototype-loss-GCPL" class="headerlink" title="Generalized CPL with prototype loss(GCPL)"></a>Generalized CPL with prototype loss(GCPL)</h3><p>除了上述的 loss 之外，作者还提出了一种可以加入上述 loss 中的约束方法。作者给的理由是，由于 CPL 中的参数比较少（因为 CNN 的参数本来就不多），很容易过拟合，因此需要这么一个约束来防止 overfit 情况的发生：</p><script type="math/tex; mode=display">p l ( ( x , y ) ; \theta , M ) = \left\| f ( x ) - m _ { y j } \right\| _ { 2 } ^ { 2 }</script><p>这个式子的意义是，计算在特征空间内样本的位置与对应分类的原型（且为距离最近的一个原型）位置的距离。利用这个约束，可以将前文提到的几种 loss 记为：</p><script type="math/tex; mode=display">\operatorname { loss } ( ( x , y ) ; \theta , M ) = l ( ( x , y ) ; \theta , M ) + \lambda p l ( ( x , y ) ; \theta , M )</script><p>上式中的 $\lambda$ 作用是控制此约束的强硬程度。通过这个约束，可以让同类的原型间的距离更近，不同类的原型间的距离更远。与此同时，就能保证样本在特征空间中的类内距离更近，类间距离更远。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>基于以上方法，作者在 MNIST、CIFAR-10、OLHWDB 数据集上进行了实验。其中，OLHWDB 数据集是一个大规模的中文手写文字数据集，甚至比 ImageNet 还要大。（不过我觉得作者还是应该在 ImageNet 上进行实验，不然整个实验还是不够完整。另外，作者的实验虽然都很置信且完善，但是对比实验选择的 baseline 不够 solid，只用了最基本的 softmax 作为对比，没有考虑最近几年涌现出的各种 softmax 的进阶版。）</p><h3 id="基本分类实验结果"><a href="#基本分类实验结果" class="headerlink" title="基本分类实验结果"></a>基本分类实验结果</h3><ul><li><p>MNIST:<br><img src="/images/15546341823585.jpg" alt=""></p></li><li><p>CIFAR-10:<br><img src="/images/15546341912068.jpg" alt=""></p></li><li><p>OLHWDB<br><img src="/images/15546342050566.jpg" alt=""></p></li></ul><p>可以看到，结果还是不错的，至少证明这篇文章提出的方法在最基本的分类效果上不会比 softmax 差。</p><h3 id="拒识实验"><a href="#拒识实验" class="headerlink" title="拒识实验"></a>拒识实验</h3><p><img src="/images/15546342149853.jpg" alt=""></p><p>这个实验结果比较亮眼。最近对模型的“拒识能力”的要求越来越高，所谓拒识，就是在输入 invalid 的测试样本时，模型可以判断出这个是 out-of-domain 的东西，返回拒绝的结果。</p><p>作者的实验方法是，在 MNIST 上进行训练，然后混入 CIFAR 数据集的数据来测试模型的拒识能力。在这种 open-domain 的实验中，我们经常会用某种类似于 min-confidence 的指标来判断送入的数据是不是 out-of-domain，但是像传统的 softmax + cross-entropy 方法中，min-confidence 越大，拒识率虽然会增加，但是准确率却也会明显下降。</p><p>作者提出的方法由于让不同类别的特征分布非常紧密，留出了大量的类间空间，因此在拒识率这块效果很好。</p><p>不过这个实验结果表格还是很微妙，因为每一横行参数啥的都不一样，虽然是为了做 AR 和 RR 的 trade-off 研究，但这样放着还是很奇怪。</p><h3 id="类增量实验"><a href="#类增量实验" class="headerlink" title="类增量实验"></a>类增量实验</h3><p><img src="/images/15546342235530.jpg" alt=""></p><p>这个实验其实还不是很常见，一般在 life-long learning 相关的工作里会有这个实验。目的是，测试一个模型在训练完成后新增一个类别的能力。对于标准的 softmax + cross-entropy 来说，自然不存在这一种能力，原因可以参考这篇笔记的第一个图，本来各个类就离的近了，再加一个类直接就乱套了。</p><p>而本文的方法，可以在“基本分类实验”一章的图中看出，样本按照类原型聚集的非常紧密。这样新增一个类并不是什么很困难的事。</p><p>作者的实验方法是，在 MNIST 训练出的模型中，增加 CIFAR-10 的类。可以看上图，做出来的结果依然很不错。</p><h3 id="小样本训练"><a href="#小样本训练" class="headerlink" title="小样本训练"></a>小样本训练</h3><p><img src="/images/15546342332247.jpg" alt=""></p><p>这个实验其实槽点也是 baseline 太 weak 了。现在做小样本的模型其实不占少数，但作者还是只选了 softmax 做比较。尽管如此，可以看到 GCPL 的效果还是很不错的。</p><h3 id="多原型实验"><a href="#多原型实验" class="headerlink" title="多原型实验"></a>多原型实验</h3><p>前面的所有实验都是在“一个类别对应一个原型”的设定之下完成的，都有不错的效果。作者在文章最后用“一个类别对应多个原型”的假设进行了实验，结果如下表所示：</p><p><img src="/images/15546342428370.jpg" alt=""></p><p>可以观察到，一个类别对应的原型数量其实对结果没有太大的影响。作者给出的解释是，CNN 提取特征的能力已经足够强大，即使初始数据的分布非常复杂，经过 CNN 变换之后，依然可以得到符合单高斯分布的特征分布，也就是一个类别一个原型的分布。</p><p>不过，在更复杂的情景下，一些更复杂的分类状况，多原型可能会发挥它应有的作用。</p><blockquote><p>这块其实也是 trade-off。因为增加一个原型相当于在隐层输出时增加了 Dense Node，会极大地增加空间占用和计算量。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章提出的方法足够新颖，并且取得的结果也非常好。虽然实验部分有些小遗憾（没有和各个任务顶尖的方法对比），但是仍然体现了这篇文章方法的综合性能的优越性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Robust Classification with Convolutional Prototype Learning 一文是自动化所刘成林、殷飞老师组 Hong-Ming Yang 师兄的工作，CVPR 2018 录用。&lt;br&gt;论文地址：&lt;a h
      
    
    </summary>
    
    
      <category term="Paper" scheme="https://lsvih.com/categories/Paper/"/>
    
    
      <category term="note" scheme="https://lsvih.com/tags/note/"/>
    
      <category term="machine learning" scheme="https://lsvih.com/tags/machine-learning/"/>
    
      <category term="Paper" scheme="https://lsvih.com/tags/Paper/"/>
    
      <category term="deep learning" scheme="https://lsvih.com/tags/deep-learning/"/>
    
      <category term="cnn" scheme="https://lsvih.com/tags/cnn/"/>
    
      <category term="prototype learning" scheme="https://lsvih.com/tags/prototype-learning/"/>
    
      <category term="CNN" scheme="https://lsvih.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>Web 开发者需要了解的基础色彩理论</title>
    <link href="https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/"/>
    <id>https://lsvih.com/2019/02/20/basic-color-theory-for-web-developers/</id>
    <published>2019-02-20T01:42:00.000Z</published>
    <updated>2019-02-20T01:55:55.990Z</updated>
    
    <content type="html"><![CDATA[<p>如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。</p><a id="more"></a><p><img src="/images/1-1.png" alt="1"></p><p>在小学美术课上应该讲过<strong>一次色</strong>（primary color，即三原色）与<strong>二次色</strong>（seondary color，间色），如果你在小学之后还上过美术课，应该还了解过<strong>三次色</strong>（tertiary color，副色）。</p><p><img src="/images/2-1.jpeg" alt="2"></p><p>不过如果你在高中或者更高层次的学校中学习过艺术，那你就会发现，色轮是展示<a href="https://en.wikipedia.org/wiki/Color_theory">色彩理论</a>、练习混色以及研究色彩组合的最简单的方法。</p><h2 id="何谓色彩理论？"><a href="#何谓色彩理论？" class="headerlink" title="何谓色彩理论？"></a>何谓色彩理论？</h2><p><strong>色彩理论简史</strong>：爱德华·马奈（Édouard Manet）、埃德加·德加（Edgar Degas）、克洛德·莫奈（Claude Monet）等印象派的画家在抛弃写实，而开始尝试捕捉<strong>光色</strong>时，色彩理论就诞生了。</p><p><img src="/images/3-2.jpeg" alt="3"></p><p>上图为莫奈的 Haystacks 系列画作</p><p><strong>简单来说</strong>：色彩理论研究的是人的眼睛如何将光波转化为颜色。匹配或相似的色彩往往有着相似或互补的波。</p><p>因此可以将色彩理论归结为光波科学，来解释为什么可以看到各种颜色。不过在本文中，我们只专注于两个问题：</p><ul><li>为什么有些颜色可以完美搭配？</li><li>我们该如何选择“正确”的颜色？</li></ul><p>颜色的搭配问题有点像“与生俱来”的东西。不管怎样，在网页或者 App 里用纯绿色的背景是绝对让人无法忍受的！</p><p>下面我列了一个简表，当你遇到与色彩有关的问题时可以参考：</p><h2 id="Level-1：单色"><a href="#Level-1：单色" class="headerlink" title="Level 1：单色"></a>Level 1：单色</h2><p><strong>单色</strong>就是单一的颜色，或者同种颜色的多个色调的组合。</p><blockquote><p><strong>在 Web 开发时</strong>，你可以在<a href="https://www.w3schools.com/colors/colors_picker.asp">这个网页中</a>选择并查询某种颜色的 Hex 代码，并且可以在不影响色调的情况下让颜色更亮或更暗。</p></blockquote><p><img src="/images/4-1.jpeg" alt="4"></p><p>这就是最简单的网页配色方法。诸如 <a href="http://facebook.com">Facebook</a>、<a href="http://twitter.com">Twitter</a> 之类的网站大都是用的这种单色配色方案。黑色、白色、天蓝色组合而成的简单配色，让这些社交 App 更加简洁。</p><p>只有用户的头像、链接、照片有着不同的颜色，这些不同的颜色可以被用户识别，更好地找到他们感兴趣的帖子和账号。</p><p>如果 Twitter 的网页上还有其它的颜色，就会让区分帖子、发帖人变得困难。</p><p>一般来说，即使你需要多种颜色，也得有个主色，所谓背景或者标题的颜色。</p><blockquote><p><strong>专业建议</strong>：如果你的网页要使用单色配色，请确保阴影可以清晰地将各个元素区分开了。否则用户在阅读文本或分离网页元素时将很不方便。</p></blockquote><h2 id="Level-2：互补色"><a href="#Level-2：互补色" class="headerlink" title="Level 2：互补色"></a>Level 2：互补色</h2><p>如果不想在配色中只用各种各样的“橙色”怎么办？如果你想让链接突出，但又不和导航栏或者背景色冲突怎么办？</p><p>如果我们遵循基本色彩理论，解决上述问题的方案就是去寻找<strong>互补色</strong>。</p><p>可以在色轮中一种颜色相对的位置找到它的<strong>互补</strong>色。</p><p><img src="/images/5-1.jpeg" alt="5"></p><p>每种<strong>主色</strong>都与一种<strong>副色</strong>作为互补色相对应。有种方法可以轻松记住颜色如何匹配：如果一种<strong>副色</strong>和一种<strong>主色</strong>匹配，那么<strong>副色</strong>的构成色一定不含<strong>主色</strong>。比如，红色的互补色是绿色，而绿色由蓝色和黄色组成。</p><blockquote><p><strong>专业建议</strong>：一次只增加一种颜色，并保持页面简单。不要为了呈现一个完整的彩虹配色牺牲了你干净、好用的布局。不然，你可能会做出上世纪 90 年代流行的经典网站（比如<a href="https://spacejam.com/">这个</a>）。</p></blockquote><h2 id="继续升级…"><a href="#继续升级…" class="headerlink" title="继续升级…"></a>继续升级…</h2><p>随着你的设计水平的提高，就能自如地挑战自己的极限了。配色并不是什么可怕的工作。你可以多多关注一些配色水平高的开发者（比如<a href="https://www.alispit.tel/#/">他</a> ）和设计师。多问问自己喜欢什么配色、不喜欢什么配色、为什么，这样就能建立自己的品味与品牌。</p><h2 id="Web-开发者的色彩-Hack"><a href="#Web-开发者的色彩-Hack" class="headerlink" title="Web 开发者的色彩 Hack"></a>Web 开发者的色彩 Hack</h2><p>试试自己手写一些 hex 代码、RBG 数字来尝试各种色彩的组合与混合。如果你是 SASS 的粉丝，可以把配好的颜色存储在文件中，日后在项目中导入。如果你的工作是构建页面结构而不是视觉设计（由客户或者产品经理决定），可以把这些颜色当做是占位符，让页面看起来更加明了。</p><p>请确保：</p><ul><li>所有东西都是可读的。</li><li>链接、标题等你想要强调的东西应该与纯文本有所区别。</li><li>用户可以轻松地区分网页的不同部分（比如导航栏、主要内容、文章等）。</li></ul><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><a href="http://paletton.com/">Palleton.com</a></li><li><a href="https://coolors.co/">Coolors.co</a></li></ul><p><a href="https://dev.to/ferkungamaboobo">Doug R. Thomas, Esq.</a> 强烈推荐以下网站：</p><ul><li><a href="https://color.adobe.com/">Color.Adobe.com</a></li><li><a href="https://webaim.org/resources/contrastchecker/">WebAIM — 颜色对比度检查器</a> — 确保文本在背景上的可读性。</li><li><a href="https://www.color-blindness.com/coblis-color-blindness-simulator/">Coblis — 色盲模拟器</a> — 用色盲滤镜来测试你的布局截图，以确保内容对所有受众都是可读的。</li></ul><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>希望在读完这篇文章后，你不再为给网站、网页、app 配色感到犯愁。如果你对这个主题感兴趣，强烈建议去了解<a href="https://www.colormatters.com/color-and-design/basic-color-theory">更多相关知识</a>。本文只是浅显地进行了讲解，你可以读<a href="https://99designs.com/blog/tips/the-7-step-guide-to-understanding-color-theory/">这篇文章</a>了解更多关于色调和阴影的知识。</p><p>最后我想说，在你给自己的项目进行配色时，并不存在”错误答案“。许多人认为品味是天生就有的，正是它帮助你寻找美妙的设计、带来灵感、尝试各种组合，最终为你和你的品牌找到最适合方案。祝你好运！</p><blockquote><p>本文发布于掘金 <a href="https://juejin.im/post/5c6caee26fb9a049df24a4df">https://juejin.im/post/5c6caee26fb9a049df24a4df</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你上过艺术课，一定会发现基本上所有课堂墙上都挂了一个“色轮”。在课堂上，可能需要你混合各种颜色，画出你自己的作品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="juejin" scheme="https://lsvih.com/tags/juejin/"/>
    
      <category term="Front End" scheme="https://lsvih.com/tags/Front-End/"/>
    
      <category term="Color" scheme="https://lsvih.com/tags/Color/"/>
    
      <category term="Design" scheme="https://lsvih.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>十件你不知道的关于 WebPageTest.org 的事(译)</title>
    <link href="https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/"/>
    <id>https://lsvih.com/2019/02/16/ten-things-you-didnt-know-about-webpagetest-org/</id>
    <published>2019-02-16T04:52:00.000Z</published>
    <updated>2019-02-16T05:17:51.300Z</updated>
    
    <content type="html"><![CDATA[<p>够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。</p><p>如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！</p><p>最近我在 Santa Clara 参加了 <a href="http://conferences.oreilly.com/velocity">Velocity Conference</a>，偶遇了 <a href="https://github.com/pmeenan">Pat Meenan</a>（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），<del>希望你还没有用过它们</del>。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。</p><a id="more"></a><h2 id="10-模拟单点失效"><a href="#10-模拟单点失效" class="headerlink" title="10. 模拟单点失效"></a>10. 模拟单点失效</h2><p>你的网站很可能依赖了一些第三方库来提供额外的功能（包括且不仅限于监控脚本、A/B 测试和广告）。问题就有可能出在这些你使用的部署在别人服务器上的库，这就是<a href="https://en.wikipedia.org/wiki/Single_point_of_failure">单点失效</a>（SPOF）风险。如果出于某些原因，导致托管这些库的服务器出现故障或响应缓慢，你的网站也会不幸地收到影响。这种事情可能发生在任何人身上！</p><p>使用 WebPageTest 模拟单点失效与正常测试网站的设置一模一样，不过你需要将第三方库的域名屏蔽。例如，如果你想对 ccn.com 测试单点失效，可以将以下域名复制并粘贴到 SPOF 选项卡中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cdn3</span><span class="selector-class">.optimizely</span><span class="selector-class">.com</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.visualrevenue</span><span class="selector-class">.com</span></span><br><span class="line"><span class="selector-tag">www</span><span class="selector-class">.google-analytics</span><span class="selector-class">.com</span></span><br><span class="line"><span class="selector-tag">pixel</span><span class="selector-class">.quantserve</span><span class="selector-class">.com</span></span><br><span class="line"><span class="selector-tag">budgetedbauer</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>粘贴好后界面应该如下所示：</p><p><img src="/images/1-1.jpeg" alt="1"></p><p>当查看此网站的加载视频时，你会发现 WebPagetest 已经对 SPOF 进行了模拟，导致该网站的加载时间长了不少。在<a href="http://www.webpagetest.org/video/compare.php?tests=160705_CE_HJQ,160705_JS_HJR">上述测试</a>中，网站最终加载完毕共花了 20 多秒！这个功能是测试你的网站在 SPOF 情况下响应情况的好工具。</p><h2 id="9-创建个人-WebPagetest-实例"><a href="#9-创建个人-WebPagetest-实例" class="headerlink" title="9. 创建个人 WebPagetest 实例"></a>9. 创建个人 WebPagetest 实例</h2><p>WebPageTest 公共实例非常方便，你可以免费用它来快速获取需要的信息。不过公共实例有一些限制，比如在某个忙碌的日子里，你可能会需要在排队等待测试结果。如果你将 WebPageTest 用于商业用途，也许需要创建属于自己的私有 WebPageTest 实例。</p><p>Pat Meenan 写了一篇名为 <a href="http://calendar.perfplanet.com/2014/webpagetest-private-instances-in-five-minutes/">5 分钟上手 WebPagetest 私有实例</a>的指南，介绍了在 Amazon EC2 上如何设置自己的实例。代理在所有 EC2 域中以 AMI 的形式提供，如果你需要在公司防火墙内部进行测试，也可以自行配置。</p><p>私有实例用起来很方便，因为你可以控制测试的基础架构，并且 API 请求数量没有限制。</p><h2 id="8-编写登录脚本"><a href="#8-编写登录脚本" class="headerlink" title="8. 编写登录脚本"></a>8. 编写登录脚本</h2><p>WebPageTest 不仅可以用于测试公开的网站，如果有需要，它也可以通过编写登录网站的脚本测试需要登录的网站。WebPageTest 具有脚本功能，可以自动执行多步测试（比如登录网站和发送电子邮件）。</p><p>例如，如果你想为 AOL 网站编写登录步骤的脚本，可以执行类似于以下操作：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logData<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bring up the login screen</span></span><br><span class="line">navigatehttp:<span class="comment">//webmail.aol.com</span></span><br><span class="line"></span><br><span class="line">logData<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// log in</span></span><br><span class="line">setValuename=loginId<span class="symbol">someuser@</span>aol.com</span><br><span class="line">setValuename=passwordsomepassword</span><br><span class="line">submitFormname=AOLLoginForm</span><br></pre></td></tr></table></figure><p>请记住不要将重要的登录凭证放在里面！除非你将它们明确设为私有，否则 webpagetest.org 网站上的测试都是公开的。如果你想了解更多有关编写脚本的信息，请查阅此<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/scripting">链接</a>。</p><h2 id="7-WebPagetest-发明的-Speed-Index-指标"><a href="#7-WebPagetest-发明的-Speed-Index-指标" class="headerlink" title="7.WebPagetest 发明的 Speed Index 指标"></a>7.WebPagetest 发明的 Speed Index 指标</h2><p>WebPagetest 于 2012 年添加了 Speed Index 指标（速度指数），它可以用于标化页面可视内容的填充速度。你可以尝试将不同的页面相互比较（优化之前与之后、自己的网站与竞品等），并与其他指标（加载时间，开始渲染时刻等）结合，来更好地理解这个对于描述网站性能非常有用的指标。如果你想了解更多有关 Speed Index 的信息，请参阅<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index">此链接</a>。</p><h2 id="6-收集自定义指标"><a href="#6-收集自定义指标" class="headerlink" title="6. 收集自定义指标"></a>6. 收集自定义指标</h2><p>WebPageTest 提供了大量有用的统计指标。但你知道吗？你还可以用它来收集你自定义的指标。WebPageTest 可以在测试的最后执行任意的 JavaScript 脚本并收集<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/custom-metrics">自定义指标</a>。你可以在服务器配置中静态地配置或在每个基础测试进行时配置它。</p><p>其实，自定义指标可以覆写内置指标。当你需要通过 JavaScript 验证强制让测试失败时，可以通过自定义指标得到“测试结果”。<a href="http://httparchive.org/">HTTP Archive</a> 还通过 <a href="https://github.com/HTTPArchive/httparchive/tree/master/custom_metrics">自定义指标</a> 采集了一些统计数据。</p><h2 id="5-将-WebPageTest-整合进你的-CI-测试中"><a href="#5-将-WebPageTest-整合进你的-CI-测试中" class="headerlink" title="5. 将 WebPageTest 整合进你的 CI 测试中"></a>5. 将 WebPageTest 整合进你的 CI 测试中</h2><p>如果你想在每次部署新代码时，都确保新代码不会让你在 Web 性能上的努力前功尽弃，那么 WebPageTest 可以帮上忙！你可以在页面上设置“budget”（预算），如果测试结果超过预算值则会导致测试失败。<a href="https://timkadlec.com/2013/01/setting-a-performance-budget/">Tim Kadlec</a> 创建了一个有用的 <a href="https://github.com/tkadlec/grunt-perfbudget">Grunt任务</a>，可以用 WebPagetest 的公开或私有实例对指定的 URL 执行测试。Marcel Duran 还为 NodeJS 创建了一个 <a href="https://github.com/marcelduran/webpagetest-api">WebPageTest API 包装器</a>，可以让你自定义测试的运行方式。</p><p>通过这些方法，每当更新代码时，都能检查网站性能。网页的性能并不是儿戏，而是维系网站生命的重要事项！</p><h2 id="4-你可以自定义瀑布图的显示方式"><a href="#4-你可以自定义瀑布图的显示方式" class="headerlink" title="4. 你可以自定义瀑布图的显示方式"></a>4. 你可以自定义瀑布图的显示方式</h2><p>你知道吗？WebPageTest 可以自定义瀑布图的显示方式。运行测试后，单击瀑布图像并向下滚动，可以看到一个“customize waterfall”（自定义瀑布）的链接。</p><p><img src="/images/2.jpeg" alt="2"></p><p>点击这个链接，可以自定义瀑布图的显示方式。很好用！</p><p><img src="/images/3-1.jpeg" alt="3"></p><p>如果你要在幻灯片里使用瀑布图，这个功能可让你精准地展示需要展示的部分。</p><h2 id="3-在测试历史记录中对比多个测试结果"><a href="#3-在测试历史记录中对比多个测试结果" class="headerlink" title="3. 在测试历史记录中对比多个测试结果"></a>3. 在测试历史记录中对比多个测试结果</h2><p>在测试历史记录页面中，你可以查看针对特定实例运行过的测试列表。这个页面可以让你以幻灯片的形式直观地比较多个测试。</p><p><img src="/images/4.jpeg" alt="4"></p><p>选择要进行比较的测试，就能看到一个幻灯片视图，比较所有过去运行过的测试。</p><p><img src="/images/5.jpeg" alt="5"></p><p>需要注意，在运行测试时最好对测试设置标签。这样有助于帮你在历史记录中找到对应的测试，并且在幻灯片、视频视图中显示时也会显示标签。</p><h2 id="2-你也可以为-WebPageTest-代码库做贡献"><a href="#2-你也可以为-WebPageTest-代码库做贡献" class="headerlink" title="2. 你也可以为 WebPageTest 代码库做贡献"></a>2. 你也可以为 WebPageTest 代码库做贡献</h2><p>整个 WebPageTest 的代码库都是开源的！代码库位于 <a href="https://github.com/WPO-Foundation/webpagetest">Github</a>，包括了 Web UI 和可用于在各种浏览器上运行测试的代码。Pat 提到，这个代码库使用的是非常宽松的 BSD 协议，也就是说你可以出于任何的目的（包括商业等用途）使用项目的任何部分。</p><p>如果你觉得有些东西可以让社区受益，请务必为这个非常棒的工具做出贡献！</p><h2 id="1-检查你的-JavaScript-执行是否导致性能瓶颈"><a href="#1-检查你的-JavaScript-执行是否导致性能瓶颈" class="headerlink" title="1. 检查你的 JavaScript 执行是否导致性能瓶颈"></a>1. 检查你的 JavaScript 执行是否导致性能瓶颈</h2><p>现在 JavaScript 在全世界都非常流行，这也意味着 JavaScript 的执行已经成为了妨碍浏览器性能的一个严重瓶颈。你知道吗？使用 WebPageTest，可以模拟在设备上运行网站，并得到主线程运作的详细情况。</p><p>在运行测试前，打开 Chrome 标签，然后勾选“Capture Dev Tools Timeline”（捕获开开发者工具时间轴）。</p><p><img src="/images/6.jpeg" alt="6"></p><p>在测试完成后，点击“Processing Breakdown”（处理详情）按钮，将得到主线程处理过程中的详细视图。通过展示主线程的处理过程的详细情况，可以让你更好地了解网站在真实设备上的确切运行情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结：如果你经常使用 WebPageTest，希望这篇文章能帮你了解更多关于它的内容。感谢 <a href="http://blog.patrickmeenan.com/">Pat Meenan</a> 提供信息并帮忙检查文章！</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/5c679531f265da2dc45367ab">https://juejin.im/post/5c679531f265da2dc45367ab</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;够标题党吧？既然你点进来了，那我也得说一些干货了！毫无疑问，WebPageTest 是我最喜欢的 Web 性能测试工具之一。它功能强大、完全免费，为世界各地的网页提供测试。&lt;/p&gt;
&lt;p&gt;如果你曾经用过 WebPageTest，那你应该知道它是多么的好用：只需要几下点击就能得到你网站加载的详细信息。不过，它还有一些你可能闻所未闻的功能！&lt;/p&gt;
&lt;p&gt;最近我在 Santa Clara 参加了 &lt;a href=&quot;http://conferences.oreilly.com/velocity&quot;&gt;Velocity Conference&lt;/a&gt;，偶遇了 &lt;a href=&quot;https://github.com/pmeenan&quot;&gt;Pat Meenan&lt;/a&gt;（WebPageTest 的创始人）并问了一些关于 WebPageTest 的问题。在本文中，我将列出 WebPageTest 的 10 个最酷的功能（我自己评的），&lt;del&gt;希望你还没有用过它们&lt;/del&gt;。按照钓鱼文的标准套路，本文章节的标号会从 10 开始数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://lsvih.com/categories/Translate/"/>
    
    
      <category term="Translate" scheme="https://lsvih.com/tags/Translate/"/>
    
      <category term="FrontEnd" scheme="https://lsvih.com/tags/FrontEnd/"/>
    
      <category term="Test" scheme="https://lsvih.com/tags/Test/"/>
    
  </entry>
  
</feed>
