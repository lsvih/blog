<!DOCTYPE html><html class="theme-next pisces"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0"><link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.5.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"6U6P1RGK4F",apiKey:"b14e73cdd627eabe947b5decbe14850f",indexName:"lsvih",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。什么是 JavaScript 生成器？生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 for 循环之类的迭代器有什么区别。下面是一个 fo"><meta name="keywords" content="Translate,ES6,Juejin,JavaScript,Generator,FrontEnd"><meta property="og:type" content="article"><meta property="og:title" content="什么是 JavaScript 生成器？如何使用生成器？"><meta property="og:url" content="https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/index.html"><meta property="og:site_name" content="My note"><meta property="og:description" content="在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。什么是 JavaScript 生成器？生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 for 循环之类的迭代器有什么区别。下面是一个 fo"><meta property="og:locale" content="default"><meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg"><meta property="og:updated_time" content="2018-10-28T16:13:07.667Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="什么是 JavaScript 生成器？如何使用生成器？"><meta name="twitter:description" content="在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。什么是 JavaScript 生成器？生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 for 循环之类的迭代器有什么区别。下面是一个 fo"><meta name="twitter:image" content="https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg"><link rel="canonical" href="https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>什么是 JavaScript 生成器？如何使用生成器？ | My note</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My note</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">lsvih</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">什么是 JavaScript 生成器？如何使用生成器？</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2018-06-04 16:47:00" itemprop="dateCreated datePublished" datetime="2018-06-04T16:47:00+08:00">2018-06-04</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://cdn-images-1.medium.com/max/2000/1*9XJAQFEiYvd2i1hv9tgwXA.jpeg" alt=""></p><p>在本文中，我们将了解 ECMAScript 6 中引入的生成器（Generator）。先看一看它究竟是什么，然后用几个示例来说明它的用法。</p><h3 id="什么是-JavaScript-生成器？"><a href="#什么是-JavaScript-生成器？" class="headerlink" title="什么是 JavaScript 生成器？"></a>什么是 JavaScript 生成器？</h3><p>生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。</p><p>上面的描述没法说明什么，让我们来看一些例子，解释什么是生成器，以及生成器与 <strong>for 循环</strong>之类的迭代器有什么区别。</p><p>下面是一个 <strong>for 循环</strong>的例子，它会在执行后立刻返回一些值。这段代码其实就是简单地生成了 0-5 这些数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 5; i += 1) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 它将会立刻返回 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br></pre></td></tr></table></figure><p>现在看看生成器函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function * generatorForLoop(num) &#123;</span><br><span class="line">  for (let i = 0; i &lt; num; i += 1) &#123;</span><br><span class="line">    yield console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const genForLoop = generatorForLoop(5);</span><br><span class="line"></span><br><span class="line">genForLoop.next(); // 首先 console.log - 0</span><br><span class="line">genForLoop.next(); // 1</span><br><span class="line">genForLoop.next(); // 2</span><br><span class="line">genForLoop.next(); // 3</span><br><span class="line">genForLoop.next(); // 4</span><br></pre></td></tr></table></figure><p>它做了什么？它实际上只是对上面例子中的 <strong>for 循环</strong>做了一点改动，但产生了很大的变化。这种变化是由生成器最重要的特性造成的 —— 只有在需要的时候它才会产生下一个值，而不会一次性产生所有的值。在某些情景下，这种特性十分方便。</p><h3 id="生成器语法"><a href="#生成器语法" class="headerlink" title="生成器语法"></a>生成器语法</h3><p>如何定义一个生成器函数呢？下面列出了各种可行的定义方法，不过万变不离其宗的是在函数关键词后加上一个星号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function * generator () &#123;&#125;</span><br><span class="line">function* generator () &#123;&#125;</span><br><span class="line">function *generator () &#123;&#125;</span><br><span class="line"></span><br><span class="line">let generator = function * () &#123;&#125;</span><br><span class="line">let generator = function* () &#123;&#125;</span><br><span class="line">let generator = function *() &#123;&#125;</span><br><span class="line"></span><br><span class="line">let generator = *() =&gt; &#123;&#125; // SyntaxError</span><br><span class="line">let generator = ()* =&gt; &#123;&#125; // SyntaxError</span><br><span class="line">let generator = (*) =&gt; &#123;&#125; // SyntaxError</span><br></pre></td></tr></table></figure><p>如上面的例子所示，我们并不能使用箭头函数来创建一个生成器。</p><p>下面将生成器作为方法（method）来创建。定义方法与定义函数的方式是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  *generator() &#123;&#125;</span><br><span class="line">  * generator() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  *generator() &#123;&#125;</span><br><span class="line">  * generator() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>现在让我们一起看看新的关键词 <code>yield</code>。它有些类似 <code>return</code>，但又不完全相同。<code>return</code> 会在完成函数调用后简单地将值返回，在 <code>return</code> 语句之后你无法进行任何操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withReturn(a) &#123;</span><br><span class="line">  let b = 5;</span><br><span class="line">  return a + b;</span><br><span class="line">  b = 6; // 不可能重新定义 b 了</span><br><span class="line">  return a * b; // 这儿新的值没可能返回了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">withReturn(6); // 11</span><br><span class="line">withReturn(6); // 11</span><br></pre></td></tr></table></figure><p>而 <code>yield</code> 的工作方式却不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function * withYield(a) &#123;</span><br><span class="line">  let b = 5;</span><br><span class="line">  yield a + b;</span><br><span class="line">  b = 6; // 在第一次调用后仍可以重新定义变量</span><br><span class="line">  yield a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calcSix = withYield(6);</span><br><span class="line"></span><br><span class="line">calcSix.next().value; // 11</span><br><span class="line">calcSix.next().value; // 36</span><br></pre></td></tr></table></figure><p>用 <code>yield</code> 返回的值只会返回一次，当你再次调用同一个函数的时候，它会执行至下一个 <code>yield</code> 语句处（译者注：前面的 <code>yield</code> 不再返回东西了）。</p><p>在生成器中，我们通常会在输出时得到一个对象。这个对象有两个属性：<code>value</code> 与 <code>done</code>。如你所想，<code>value</code> 为返回值，<code>done</code> 则会显示生成器是否完成了它的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 5, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; - 之后的任何调用都会返回相同的结果</span><br></pre></td></tr></table></figure><p>在生成器中，不仅可以使用 <code>yield</code>，也可以使用 <code>return</code> 来返回同样的对象。但是，在函数执行到第一个 <code>return</code> 语句的时候，生成器将结束它的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  return 2;</span><br><span class="line">  yield 3; // 到不了这个 yield 了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 2, done: true&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><h4 id="yield-委托迭代"><a href="#yield-委托迭代" class="headerlink" title="yield 委托迭代"></a>yield 委托迭代</h4><p>带星号的 <code>yield</code> 可以将它的工作委托给另一个生成器。通过这种方式，你就能将多个生成器连接在一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function * anotherGenerator(i) &#123;</span><br><span class="line">  yield i + 1;</span><br><span class="line">  yield i + 2;</span><br><span class="line">  yield i + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * generator(i) &#123;</span><br><span class="line">  yield* anotherGenerator(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = generator(1);</span><br><span class="line"></span><br><span class="line">gen.next().value; // 2</span><br><span class="line">gen.next().value; // 3</span><br><span class="line">gen.next().value; // 4</span><br></pre></td></tr></table></figure><p>在开始下一节前，我们先观察一个第一眼看上去比较奇特的行为。</p><p>下面是正常的代码，不会报出任何错误，这表明 <code>yield</code> 可以在 <code>next()</code> 方法调用后返回传递的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arr) &#123;</span><br><span class="line">  for (const i in arr) &#123;</span><br><span class="line">    yield i;</span><br><span class="line">    yield yield;</span><br><span class="line">    yield(yield);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator([0,1]);</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: &quot;0&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: &quot;A&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;A&apos;); // &#123;value: &quot;A&quot;, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: &quot;B&quot;, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: undefined, done: false&#125;</span><br><span class="line">gen.next(&apos;B&apos;); // &#123;value: &quot;B&quot;, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，你可以看到 <code>yield</code> 默认是 <code>undefined</code>，但如果我们在调用 <code>yield</code> 时传递了任何值，它就会返回我们传入的值。我们将很快利用这个特性。</p><h4 id="初始化与方法"><a href="#初始化与方法" class="headerlink" title="初始化与方法"></a>初始化与方法</h4><p>生成器是可以被复用的，但是你需要对它们进行初始化。还好初始化的方法十分简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arg = &apos;Nothing&apos;) &#123;</span><br><span class="line">  yield arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen0 = generator(); // OK</span><br><span class="line">const gen1 = generator(&apos;Hello&apos;); // OK</span><br><span class="line">const gen2 = new generator(); // 不 OK</span><br><span class="line"></span><br><span class="line">generator().next(); // 可以运行，但每次都会从头开始运行</span><br></pre></td></tr></table></figure><p>如上所示，<code>gen0</code> 与 <code>gen1</code> 不会互相影响，<code>gen2</code> 完全不会运行（会报错）。因此初始化对于保证程序流程的状态是十分重要的。</p><p>下面让我们一起看看生成器给我们提供的方法。</p><p><strong>next() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; 之后所有的 next 调用都会返回同样的输出</span><br></pre></td></tr></table></figure><p>这是最常用的方法。它每次被调用时都会返回下一个对象。在生成器工作结束时，<code>next()</code> 会将 <code>done</code> 属性设为 <code>true</code>，<code>value</code> 属性设为 <code>undefined</code>。</p><p>我们不仅可以用 <code>next()</code> 来迭代生成器，还可以用 <code>for of</code> 循环来一次得到生成器所有的值（而不是对象）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator(arr) &#123;</span><br><span class="line">  for (const el in arr)</span><br><span class="line">    yield el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator([0, 1, 2]);</span><br><span class="line"></span><br><span class="line">for (const g of gen) &#123;</span><br><span class="line">  console.log(g); // 0 -&gt; 1 -&gt; 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>但它不适用于 <code>for in</code> 循环，并且不能直接用数字下标来访问属性：<code>generator[0] = undefined</code>。</p><p><strong>return() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.return(); // &#123;value: undefined, done: true&#125;</span><br><span class="line">gen.return(&apos;Heeyyaa&apos;); // &#123;value: &quot;Heeyyaa&quot;, done: true&#125;</span><br><span class="line"></span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125; - 在 return() 之后的所有 next() 调用都会返回相同的输出</span><br></pre></td></tr></table></figure><p><code>return()</code> 将会忽略生成器中的任何代码。它会根据传值设定 <code>value</code>，并将 <code>done</code> 设为 <code>true</code>。任何在 <code>return()</code> 之后进行的 <code>next()</code> 调用都会返回 <code>done</code> 属性为 <code>true</code> 的对象。</p><p><strong>throw() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line"></span><br><span class="line">gen.throw(&apos;Something bad&apos;); // 会报错 Error Uncaught Something bad</span><br><span class="line">gen.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p><code>throw()</code> 做的事非常简单 —— 就是抛出错误。我们可以用 <code>try-catch</code> 来处理。</p><h4 id="自定义方法的实现"><a href="#自定义方法的实现" class="headerlink" title="自定义方法的实现"></a>自定义方法的实现</h4><p>由于我们无法直接访问 <code>Generator</code> 的 constructor，因此如何增加新的方法需要另外说明。下面是我的方法，你也可以用不同的方式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function * generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;constructor: GeneratorFunction, next: ƒ, return: ƒ, throw: ƒ, Symbol(Symbol.toStringTag): &quot;Generator&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 由于 Generator 不是一个全局变量，因此我们只能这么写：</span><br><span class="line">generator.prototype.__proto__.math = function(e = 0) &#123;</span><br><span class="line">  return e * Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generator.prototype.__proto__; // Generator &#123;math: ƒ, constructor: GeneratorFunction, next: ƒ, return: ƒ, throw: ƒ, …&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator();</span><br><span class="line">gen.math(1); // 3.141592653589793</span><br></pre></td></tr></table></figure><h4 id="生成器的用途"><a href="#生成器的用途" class="headerlink" title="生成器的用途"></a>生成器的用途</h4><p>在前面，我们用了已知迭代次数的生成器。但如果我们不知道要迭代多少次会怎么样呢？为了解决这个问题，需要在生成器函数中创建一个无限循环。下面以一个会返回随机数的函数为例进行演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function * randomFrom(...arr) &#123;</span><br><span class="line">  while (true)</span><br><span class="line">    yield arr[Math.floor(Math.random() * arr.length)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getRandom = randomFrom(1, 2, 5, 9, 4);</span><br><span class="line"></span><br><span class="line">getRandom.next().value; // 返回随机的一个数</span><br></pre></td></tr></table></figure><p>这是个简单的例子。下面来举一些更复杂的函数为例，我们要写一个节流（throttle）函数。如果你还不知道节流函数是什么，请参阅<a href="https://medium.com/@_jh3y/throttling-and-debouncing-in-javascript-b01cad5c8edf" target="_blank" rel="noopener">这篇文章</a>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function * throttle(func, time) &#123;</span><br><span class="line">  let timerID = null;</span><br><span class="line">  function throttled(arg) &#123;</span><br><span class="line">    clearTimeout(timerID);</span><br><span class="line">    timerID = setTimeout(func.bind(window, arg), time);</span><br><span class="line">  &#125;</span><br><span class="line">  while (true)</span><br><span class="line">    throttled(yield);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thr = throttle(console.log, 1000);</span><br><span class="line"></span><br><span class="line">thr.next(); // &#123;value: undefined, done: false&#125;</span><br><span class="line">thr.next(&apos;hello&apos;); // 返回 &#123;value: undefined, done: false&#125; ，然后 1 秒后输出 &apos;hello&apos;</span><br></pre></td></tr></table></figure><p></p><p>还有没有更好的利用生成器的例子呢？如果你了解递归，那你肯定听过<a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数列</a>。通常我们是用递归来解决这个问题的，但有了生成器后，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function * fibonacci(seed1, seed2) &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield (() =&gt; &#123;</span><br><span class="line">      seed2 = seed2 + seed1;</span><br><span class="line">      seed1 = seed2 - seed1;</span><br><span class="line">      return seed2;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fib = fibonacci(0, 1);</span><br><span class="line">fib.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 5, done: false&#125;</span><br><span class="line">fib.next(); // &#123;value: 8, done: false&#125;</span><br></pre></td></tr></table></figure><p>不再需要递归了！我们可以在需要的时候获得数列中的下一个数字。</p><h4 id="将生成器用在-HTML-上"><a href="#将生成器用在-HTML-上" class="headerlink" title="将生成器用在 HTML 上"></a>将生成器用在 HTML 上</h4><p>既然是讨论 JavaScript，那显然要用生成器来操作下 HTML。</p><p>假设有一些 HTML 块需要处理，可以使用生成器来轻松实现。（当然除了生成器之外还有很多方法可以做到）</p><p>我们只需要少许代码就能完成此需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const strings = document.querySelectorAll(&apos;.string&apos;);</span><br><span class="line">const btn = document.querySelector(&apos;#btn&apos;);</span><br><span class="line">const className = &apos;darker&apos;;</span><br><span class="line"></span><br><span class="line">function * addClassToEach(elements, className) &#123;</span><br><span class="line">  for (const el of Array.from(elements))</span><br><span class="line">    yield el.classList.add(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const addClassToStrings = addClassToEach(strings, className);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&apos;click&apos;, (el) =&gt; &#123;</span><br><span class="line">  if (addClassToStrings.next().done)</span><br><span class="line">    el.target.classList.add(className);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>仅有 5 行逻辑代码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还有更多使用生成器的方法。例如，在进行异步操作或者按需循环时生成器也非常有用。</p><p>我希望这篇文章能帮你更好地理解 JavaScript 生成器。</p><blockquote><p>掘金地址：<a href="https://juejin.im/post/5b14faf2f265da6e4d5af3b9" target="_blank" rel="noopener">https://juejin.im/post/5b14faf2f265da6e4d5af3b9</a></p></blockquote></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>lsvih</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/" title="什么是 JavaScript 生成器？如何使用生成器？">https://lsvih.com/2018/06/04/什么是-JavaScript-生成器？如何使用生成器？/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Translate/" rel="tag"># Translate</a> <a href="/tags/ES6/" rel="tag"># ES6</a> <a href="/tags/Juejin/" rel="tag"># Juejin</a> <a href="/tags/JavaScript/" rel="tag"># JavaScript</a> <a href="/tags/Generator/" rel="tag"># Generator</a> <a href="/tags/FrontEnd/" rel="tag"># FrontEnd</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/05/19/可用但最不常见的-HTML5-标签/" rel="next" title="可用但最不常见的 HTML5 标签"><i class="fa fa-chevron-left"></i> 可用但最不常见的 HTML5 标签</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/07/04/使用多重赋值与元组解包提升-Python-代码的可读性/" rel="prev" title="使用多重赋值与元组解包提升 Python 代码的可读性">使用多重赋值与元组解包提升 Python 代码的可读性 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">lsvih</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">138</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">165</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-JavaScript-生成器？"><span class="nav-number">1.</span> <span class="nav-text">什么是 JavaScript 生成器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器语法"><span class="nav-number">2.</span> <span class="nav-text">生成器语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield"><span class="nav-number">2.1.</span> <span class="nav-text">yield</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-委托迭代"><span class="nav-number">2.2.</span> <span class="nav-text">yield 委托迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化与方法"><span class="nav-number">2.3.</span> <span class="nav-text">初始化与方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义方法的实现"><span class="nav-number">2.4.</span> <span class="nav-text">自定义方法的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器的用途"><span class="nav-number">2.5.</span> <span class="nav-text">生成器的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将生成器用在-HTML-上"><span class="nav-number">2.6.</span> <span class="nav-text">将生成器用在 HTML 上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">2.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">lsvih</span></div><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.5.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>