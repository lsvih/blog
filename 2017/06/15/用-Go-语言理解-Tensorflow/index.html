<!DOCTYPE html><html class="theme-next pisces"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0"><link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.5.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"6U6P1RGK4F",apiKey:"b14e73cdd627eabe947b5decbe14850f",indexName:"lsvih",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。封装根据官方说明，Tensorflow 开发者发布"><meta name="keywords" content="Translate,juejin,python,Machine Learning,Go,Tensorflow"><meta property="og:type" content="article"><meta property="og:title" content="用 Go 语言理解 Tensorflow"><meta property="og:url" content="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/index.html"><meta property="og:site_name" content="My note"><meta property="og:description" content="Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。封装根据官方说明，Tensorflow 开发者发布"><meta property="og:locale" content="default"><meta property="og:image" content="https://lsvih.com/images/pasted-165.png"><meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79gy1fg9itnbsc7j31au06274m.jpg"><meta property="og:updated_time" content="2018-10-28T16:13:18.509Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="用 Go 语言理解 Tensorflow"><meta name="twitter:description" content="Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。封装根据官方说明，Tensorflow 开发者发布"><meta name="twitter:image" content="https://lsvih.com/images/pasted-165.png"><link rel="alternate" href="/atom.xml" title="My note" type="application/atom+xml"><link rel="canonical" href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>用 Go 语言理解 Tensorflow | My note</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4de170e51b04cee02fbdb1b7cb7a8a60";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My note</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">lsvih</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="lsvih"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">用 Go 语言理解 Tensorflow</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2017-06-15 15:41:00" itemprop="dateCreated datePublished" datetime="2017-06-15T15:41:00+08:00">2017-06-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Translate/" itemprop="url" rel="index"><span itemprop="name">Translate</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Tensorflow 并不是一个严格意义上的机器学习库，它是一个使用图来表示计算的通用计算库。它的核心功能由 C++ 实现，通过封装，能在各种不同的语言下运行。它的 Golang 版和 Python 版不同，Golang 版 Tensorflow 不仅能让你通过 Go 语言使用 Tensorflow，还能让你理解 Tensorflow 的底层实现。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>根据官方说明，Tensorflow 开发者发布了以下内容：</p><ul><li><p>C++ 源码：底层和高层的具体功能由 C ++ 源码实现，它是真正 Tensorflow 的核心。</p></li><li><p>Python 封装与Python 库：由 C++ 实现自动生成的封装版本，通过这种方式我们可以直接用 Python 来调用 C++ 函数：这也是 numpy 的核心实现方式。</p><p>Python 库通过将 Python 封装版的各种调用结合起来，组成了各种广为人知的高层 API。</p></li><li><p>Java 封装</p></li><li><p>Go 封装</p></li></ul><p>作为一名 Gopher 而非一名 java 爱好者，我对 Go 封装给予了极大的关注，希望了解其适用于何种任务。</p><blockquote><p>译注，这里说的”封装“也有说法叫做”语言界面“</p></blockquote><h2 id="Go-封装"><a href="#Go-封装" class="headerlink" title="Go 封装"></a>Go 封装</h2><p><img src="/images/pasted-165.png" alt="upload successful"></p><p>图为 Gopher（由 Takuya Ueda <a href="https://twitter.com/tenntenn" target="_blank" rel="noopener">@tenntenn</a> 创建，遵循 CC 3.0 协议）与 Tensorflow 的 Logo 结合在一起。</p><hr><p>首先要注意的是，代码维护者自己也承认了，Go API 缺少 <code>Variable</code> 支持，因此这个 API 仅用于<strong>使用</strong>训练好的模型，而<strong>不能用于</strong>进行模型训练。</p><p>在文档 <a href="https://www.tensorflow.org/versions/master/install/install_go" target="_blank" rel="noopener">Installing Tensorflow for Go</a> 中已经明确提到：</p><blockquote><p>TensorFlow 为 Go 编程提供了一些 API。这些 API 特别适合加载在 Python 中创建的模型，让其在 Go 应用 中运行。</p></blockquote><p>如果我们对训练机器学习模型没兴趣，那这个限制是 OK 的。</p><p>但是，如果你打算自己训练模型，请看下面给的建议：</p><blockquote><p>作为一名 Gopher，请让 Go 保持简洁！使用 Python 去定义、训练模型，在这之后你随时都可以用 Go 来加载训练好的模型！（意思就是他们懒得开发呗）</p></blockquote><p>简而言之，golang 版 tensorflow 可以<strong>导入与定义</strong>常数图（constant graph）。这个常数图指的是在图中没有训练过程，也没有需要训练的变量。</p><p>让我们用 Golang 深入研究 Tensorflow 吧！首先创建我们的第一个应用。</p><p>我建议读者在阅读下面的内容前，先准备好 Go 环境，以及编译、安装好 Tensorflow Go 版（编译、安装过程参考 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/go/README.md" target="_blank" rel="noopener">README</a>）。</p><h2 id="理解-Tensorflow-的结构"><a href="#理解-Tensorflow-的结构" class="headerlink" title="理解 Tensorflow 的结构"></a>理解 Tensorflow 的结构</h2><p>先复习一下什么是 Tensorflow 吧！（这是我个人的理解，和<a href="https://www.tensorflow.org/" target="_blank" rel="noopener">官网</a>的有所不同）</p><blockquote><p>TensorFlow™ 是一个采用数据流图(data flow graphs),用于数值计算的开源软件库。节点（Nodes）在图中<strong>表示</strong>数学操作，图中的线（edges）则<strong>表示</strong>在节点间相互联系的多维数据数组，即张量（tensor）。</p></blockquote><p>我们可以把 Tensorflow 看做一种类似于 SQL 的描述性语言，首先你得确定你需要什么数据，它会通过底层引擎（数据库）分析你的查询语句，检查你的句法错误和语法错误，将查询语句转换为私有语言表达式，进行优化之后运算得出计算结果。这样，它能保证将正确的结果传达给你。</p><p>因此，我们无论使用什么 API 实质上都是在描述一个图。我们将它放在 <code>Session</code> 中作为求值的起点，这样做确定了这个图将会在这个 Session 中运行。</p><p>了解这一点，我们可以试着定义一个计算操作的图，并将其放在一个 <code>Session</code> 中进行求值。</p><p><a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go" target="_blank" rel="noopener">API 文档</a>中明确告知了 <code>tensorflow</code>（简称 <code>tf</code>）包与 <code>op</code> 包中的可用方法列表。</p><p>在这个列表中我们可以看到，这两个包中包含了一切我们需要用来定义与评价图的方法。</p><p><code>tf</code> 包中包含了各种构建基础结构的函数，例如 <code>Graph</code>（图）。<code>op</code> 包是最重要的包，它包含了由 C++ 实现自动生成的绑定等功能。</p><p>现在，假设我们要计算 AAA 与 xxx 的矩阵乘法：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fg9itnbsc7j31au06274m.jpg" alt=""></p><p>我假定你们都熟悉 tensorflow 图的定义，都了解 placeholder 并知道它们的工作原理。</p><p>下面的代码是一位 Tensorflow Python 用户第一次尝试时会写的代码。让我们给这个文件取名为 <code>attempt1.go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span></span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">	x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line"></span><br><span class="line">	graph, err := root.Finalize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session</span><br><span class="line">	sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量</span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]</span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]</span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int64</span>&#123; &#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125; &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor</span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;</span><br><span class="line">		A: matrix,</span><br><span class="line">		x: column,</span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int64</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码写好了注释，我建议读者阅读上面的每一条注释。</p><p>现在，这位 Tensorflow Python 用户自我感觉良好，认为他的代码能够成功编译与运行。让我们试一试吧：</p><p><code>go run attempt1.go</code></p><p>然后他会看到：</p><p><code>panic: failed to add operation &quot;Placeholder&quot;: Duplicate node name in graph: &#39;Placeholder&#39;</code></p><p>等等，为什么会这样呢？</p><p>问题很明显。上面代码里出现了 2 个重名的“Placeholder”操作。</p><h2 id="第-1-课：node-IDs"><a href="#第-1-课：node-IDs" class="headerlink" title="第 1 课：node IDs"></a>第 1 课：node IDs</h2><p><strong>每次在我们调用方法定义一个操作的时候，不管他是否在之前被调用过，Python API 都会生成不同的节点</strong>。</p><p>所以，下面的代码没有任何问题，会返回 3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.placeholder(tf.int32, shape=())</span><br><span class="line">b = tf.placeholder(tf.int32, shape=())</span><br><span class="line">add = tf.add(a,b)</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print(sess.run(add, feed_dict=&#123;a: <span class="number">1</span>,b: <span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>我们可以验证一下这个问题，看看程序是否创建了两个不同的 placeholder 节点： <code>print(a.name, b.name)</code></p><p>它打印出 <code>Placeholder:0 Placeholder_1:0</code>。</p><p>这样就清楚了，<code>a</code> placeholder 是 <code>Placeholder:0</code> 而 <code>b</code> placeholder 是 <code>Placeholder_1:0</code>。</p><p>但是在 Go 中，上面的程序会报错，因为 <code>A</code> 与 <code>x</code> 都叫做 <code>Placeholder</code>。我们可以由此得出结论：</p><p><strong>每次我们调用定义操作的函数时，Go API 并不会自动生成新的名称</strong>。因此，它的操作名是固定的，我们没法修改。</p><h4 id="提问时间："><a href="#提问时间：" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>图中的每个节点都必须有唯一的名称。所有节点都是通过名称进行辨认。</strong></p></li><li><p>节点名称与定义操作符的名称是否相同？</p><p><strong>是的，也可说节点名称是操作符名称的最后一段。</strong></p></li></ul><p>接下来让我们修复节点名称重复的问题，来弄明白上面的第二个提问。</p><h2 id="第-2-课：作用域"><a href="#第-2-课：作用域" class="headerlink" title="第 2 课：作用域"></a>第 2 课：作用域</h2><p>正如我们所见，Python API 在定义操作时会自动创建新的名称。如果研究底层会发现，Python API 调用了 C++ <code>Scope</code> 类中的 <code>WithOpName</code> 方法。</p><p>下面是该方法的文档及特性，参考 <a href="https://github.com/tensorflow/tensorflow/blob/a5b1fb8e56ceda0ee2794ee05f5a7642157875c5/tensorflow/cc/framework/scope.h" target="_blank" rel="noopener">scope.h</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回新的作用域。所有在返回的作用域中的 op 都会被命名为</span></span><br><span class="line"><span class="comment">/// &lt;name&gt;/&lt;op_name&gt;[_&lt;suffix].</span></span><br><span class="line">Scope WithOpName(<span class="keyword">const</span> <span class="keyword">string</span>&amp; op_name) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>注意这个方法，返回一个作用域 <code>Scope</code> 来对节点进行命名，因此节点名称事实上就是作用域 <code>Scope</code>。</p><p><code>Scope</code> 就是从根 <code>/</code>（空图）追溯至 <code>op_name</code> 的<strong>完整路径</strong>。</p><p><code>WithOpName</code> 方法在我们尝试添加一个有着相同的 <code>/</code> 到 <code>op_name</code> 路径的节点时，为了避免在相同作用域下有重复的节点，会为其加上一个后缀 <code>_&lt;suffix&gt;</code>（<code>&lt;suffix&gt;</code> 是一个计数器）。</p><p>了解了以上内容，我们可以通过在 <code>type Scope</code> 中寻找 <code>WithOpName</code> 来解决重复节点名称的问题。然而，Go tf API 中没有这个方法。</p><p>如果查阅 <a href="https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope" target="_blank" rel="noopener">type Scope 的文档</a>，我们可以看到唯一能返回新 <code>Scope</code> 的方法只有 <code>SubScope(namespace string)</code>。</p><p>下面引用文档中的内容：</p><blockquote><p>SubScope 将会返回一个新的 Scope，这个 Scope 能确保所有的被加入图中的操作都被放置在 ‘namespace’ 的命名空间下。如果这个命名空间和作用域中已经存在的命名空间冲突，将会给它加上后缀。</p></blockquote><p>这种加后缀的冲突处理和 C++ 中的 <code>WithOpName</code> 方法<strong>不同</strong>，<code>WithOpName</code> 是在<strong>操作名后面</strong>加<code>suffix</code>，它们都在同样的作用域内（例如 <code>Placeholder</code> 变成 <code>Placeholder_1</code>），而 Go 的 <code>SubScope</code> 是在<strong>作用域名称后面</strong>加 <code>suffix</code>。</p><p>这将导致这两种方法会生成完全不同的图（节点在不同的作用域中了），但是它们的计算结果却是一样的。</p><p>让我们试着改一改 placeholder 定义，让它们定义两个不同的节点，然后打印 <code>Scope</code> 名称。</p><p>让我们创建 <code>attempt2.go</code> ，将下面几行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root, tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line"><span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int64, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">fmt.Println(A.Op.Name(), x.Op.Name())</span><br></pre></td></tr></table></figure><p>编译、运行： <code>go run attempt2.go</code>，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br></pre></td></tr></table></figure><h4 id="提问时间：-1"><a href="#提问时间：-1" class="headerlink" title="提问时间："></a>提问时间：</h4><ul><li><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>节点完全由其定义所在的作用域标识。这个”作用域“是我们从图的根节点追溯到指定节点的一条路径。有两种方法来定义执行同一种操作的节点：1、将其定义放在不同的作用域中（Go 风格）2、改变操作名称（我们在 C++ 中可以这么做，Python 版会自动这么做）</strong></p></li></ul><p>现在，我们已经解决了节点命名重复的问题，但是现在我们的控制台中出现了另一个问题：</p><pre><code>panic: failed to add operation &quot;MatMul&quot;: Value for attr &#39;T&#39; of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128
</code></pre><p>为什么 <code>MatMul</code> 节点的定义出错了？我们要做的仅仅是计算两个 <code>tf.int64</code> 矩阵的乘积而已！似乎 <code>MatMul</code> 偏偏不能接受 <code>int64</code> 的类型。</p><blockquote><p>Value for attr ‘T’ of int64 is not in the list of allowed values: half, float, double, int32, complex64, complex128</p></blockquote><p>上面这个列表是什么？为什么我们能计算 2 个 <code>int32</code> 矩阵的乘积却不能计算 <code>int64</code> 的乘积？</p><p>下面我们将解决这个问题。</p><h2 id="第-3-课：Tensorflow-类型系统"><a href="#第-3-课：Tensorflow-类型系统" class="headerlink" title="第 3 课：Tensorflow 类型系统"></a>第 3 课：Tensorflow 类型系统</h2><p>让我们深入研究 <a href="https://github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/core/ops/math_ops.cc#L1048" target="_blank" rel="noopener">源代码</a> 来看 C++ 是如何定义 <code>MatMul</code> 操作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_OP(<span class="string">"MatMul"</span>)</span><br><span class="line">    .Input(<span class="string">"a: T"</span>)</span><br><span class="line">    .Input(<span class="string">"b: T"</span>)</span><br><span class="line">    .Output(<span class="string">"product: T"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_a: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"transpose_b: bool = false"</span>)</span><br><span class="line">    .Attr(<span class="string">"T: &#123;half, float, double, int32, complex64, complex128&#125;"</span>)</span><br><span class="line">    .SetShapeFn(shape_inference::MatMulShape)</span><br><span class="line">    .Doc(R<span class="string">"doc(</span></span><br><span class="line"><span class="string">Multiply the matrix "</span>a<span class="string">" by the matrix "</span>b<span class="string">".</span></span><br><span class="line"><span class="string">The inputs must be two-dimensional matrices and the inner dimension of</span></span><br><span class="line"><span class="string">"</span>a<span class="string">" (after being transposed if transpose_a is true) must match the</span></span><br><span class="line"><span class="string">outer dimension of "</span>b<span class="string">" (after being transposed if transposed_b is</span></span><br><span class="line"><span class="string">true).</span></span><br><span class="line"><span class="string">*Note*: The default kernel implementation for MatMul on GPUs uses</span></span><br><span class="line"><span class="string">cublas.</span></span><br><span class="line"><span class="string">transpose_a: If true, "</span>a<span class="string">" is transposed before multiplication.</span></span><br><span class="line"><span class="string">transpose_b: If true, "</span>b<span class="string">" is transposed before multiplication.</span></span><br></pre></td></tr></table></figure><p>这几行代码为 <code>MatMul</code> 操作定义了一个接口，由 <code>REGISTER_OP</code> 宏对此操作做出了如下描述：</p><ul><li>名称: <code>MatMul</code></li><li>参数: <code>a</code>, <code>b</code></li><li>属性（可选参数）: <code>transpose_a</code>, <code>transpose_b</code></li><li>模版 <code>T</code> 支持的类型: <code>half, float, double, int32, complex64, complex128</code></li><li>输出类型: 自动识别</li><li>文档</li></ul><p>这个宏没有包含任何 C++ 代码，但是它告诉了我们<strong>当在定义一个操作的时候，即使它使用模版定义，我们也需要指定特定类型 <code>T</code> 支持的类型（或属性）列表。</strong></p><p>实际上，属性 <code>.Attr(&quot;T: {half, float, double, int32, complex64, complex128}&quot;)</code> 将 <code>T</code> 的类型限制在了这个类型列表中。<br><a href="https://www.tensorflow.org/extend/adding_an_op" target="_blank" rel="noopener">tensorflow 教程</a>中提到，当时模版 <code>T</code> 时，我们需要对所有支持的重载运算在内核进行注册。这个内核会使用 CUDA 方式引用 C/C++ 函数，进行并发执行。</p><p><code>MatMul</code> 的作者可能是出于以下 2 个原因仅支持上述类型而将 <code>int64</code> 排除在外的：</p><ol><li>疏忽：这个是有可能的，毕竟 Tensorflow 的作者也是人类呀！</li><li>为了支持不能使用 <code>int64</code> 的设备，可能这个特性的内核实现不能在各种支持的硬件上运行。</li></ol><p>回到我们的问题中，已经很清楚如何解决问题了。我们需要将 <code>MatMul</code> 支持类型的参数传给它。</p><p>让我们创建 <code>attempt3.go</code> ，将所有 <code>int64</code> 的地方都改成 <code>int32</code>。</p><p>有一点需要注意：<strong>Go 封装版 tf 有自己的一套类型，基本与 Go 本身的类型 1:1 相映射。当我们要将值传入图中时，我们必须遵循这种映射关系（例如定义 <code>tf.Int32</code> 类型的 placeholder 时要传入 <code>int32</code>）。从图中取值同理。</strong></p><p><code>*tf.Tensor</code> 类型将会返回一个张量 evaluation，它包含一个 <code>Value()</code> 方法，此方法将返回一个必须转换为正确类型的 <code>interface{}</code>（这是从图的结构了解到的）。</p><p>运行 <code>go run attempt3.go</code>，得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input/Placeholder input_1/Placeholder</span><br><span class="line">[[210] [-210]]</span><br></pre></td></tr></table></figure><p>成功了！</p><p>下面是 <code>attempt3</code> 的完整代码，你可以编译并运行它。（这是一个 Gist，如果你发现有啥可以改进的话欢迎来<a href="https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）" target="_blank" rel="noopener">https://gist.github.com/galeone/09657143df49a90536f4ac4893c64696贡献代码）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                        </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (                                            </span><br><span class="line">	<span class="string">"fmt"</span>                                       </span><br><span class="line">	tf <span class="string">"github.com/tensorflow/tensorflow/tensorflow/go"</span>                                              </span><br><span class="line">	<span class="string">"github.com/tensorflow/tensorflow/tensorflow/go/op"</span>                                              </span><br><span class="line">)                                                   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                                       </span><br><span class="line">	<span class="comment">// 第一步：创建图</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先我们需要在 Runtime 定义两个 placeholder 进行占位</span></span><br><span class="line">	<span class="comment">// 第一个 placeholder A 将会被一个 [2, 2] 的 interger 类型张量代替</span></span><br><span class="line">	<span class="comment">// 第二个 placeholder x 将会被一个 [2, 1] 的 interger 类型张量代替</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来我们要计算 Y = Ax</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图的第一个节点：让这个空节点作为图的根</span></span><br><span class="line">	root := op.NewScope()                       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个 placeholder</span></span><br><span class="line">	<span class="comment">// 在根定义域下定义两个自定义域，命名为 input。这样</span></span><br><span class="line">	<span class="comment">// 我们就能在根定义域下拥有 input/ 和 input_1/ 两个定义域了。</span></span><br><span class="line">	A := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">2</span>)))   </span><br><span class="line">	x := op.Placeholder(root.SubScope(<span class="string">"input"</span>), tf.Int32, op.PlaceholderShape(tf.MakeShape(<span class="number">2</span>, <span class="number">1</span>)))   </span><br><span class="line">	fmt.Println(A.Op.Name(), x.Op.Name())       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义接受 A 与 x 输入的 op 节点</span></span><br><span class="line">	product := op.MatMul(root, A, x)            </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次我们传递一个域给一个操作的时候，</span></span><br><span class="line">	<span class="comment">// 我们都要将操作放在在这个域下。</span></span><br><span class="line">	<span class="comment">// 如你所见，现在我们已经有了一个空作用域（由 newScope）创建。这个空作用域</span></span><br><span class="line">	<span class="comment">// 是我们图的根，我们可以用“/”表示它。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 现在让 tensorflow 按照我们的定义建立图吧。</span></span><br><span class="line">	<span class="comment">// 依据我们定义的 scope 与 op 结合起来的抽象图，程序会创建相应的常数图。</span></span><br><span class="line">	graph, err := root.Finalize()               </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="comment">// 如果我们错误地定义了图，我们必须手动修正相关定义，</span></span><br><span class="line">		<span class="comment">// 任何尝试自动处理错误的方法都是无用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 就像 SQL 查询一样，如果查询不是有效的语法，我们只能重写它。</span></span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果到这一步，说明我们的图语法上是正确的。</span></span><br><span class="line">	<span class="comment">// 现在我们可以将它放在一个 Session 中并执行它了！</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sess *tf.Session                        </span><br><span class="line">        sess, err = tf.NewSession(graph, &amp;tf.SessionOptions&#123;&#125;)                                           </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                             </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了使用 placeholder，我们需要创建传入网络的值的张量             </span></span><br><span class="line">	<span class="keyword">var</span> matrix, column *tf.Tensor               </span><br><span class="line"></span><br><span class="line">	<span class="comment">// A = [ [1, 2], [-1, -2] ]                 </span></span><br><span class="line">	<span class="keyword">if</span> matrix, err = tf.NewTensor([<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                       </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="comment">// x = [ [10], [100] ]                      </span></span><br><span class="line">	<span class="keyword">if</span> column, err = tf.NewTensor([<span class="number">2</span>][<span class="number">1</span>]<span class="keyword">int32</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;                            </span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> results []*tf.Tensor                    </span><br><span class="line">	<span class="keyword">if</span> results, err = sess.Run(<span class="keyword">map</span>[tf.Output]*tf.Tensor&#123;                                             </span><br><span class="line">		A: matrix,                          </span><br><span class="line">		x: column,                          </span><br><span class="line">	&#125;, []tf.Output&#123;product&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())                  </span><br><span class="line">	&#125;                                           </span><br><span class="line">	<span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;            </span><br><span class="line">		fmt.Println(result.Value().([][]<span class="keyword">int32</span>))                                            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提问时间：-2"><a href="#提问时间：-2" class="headerlink" title="提问时间："></a>提问时间：</h4><p>关于 Tensorflow 的架构我们学到了什么？</p><p><strong>每个操作都有自己的一组关联内核。Tensorflow 是一种强类型的描述性语言，它不仅遵循 C++ 类型规则，同时要求在 op 注册时需定义好类型才能实现其功能。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Go 来定义与处理一个图让我们能够更好地理解 Tensorflow 的底层结构。通过不断地试错，我们最终解决了这个简单的问题，一步一步地掌握了图、节点以及类型系统的知识。</p><p>如果你觉得这篇文章有用，请点个赞或者分享给别人吧~</p><blockquote><p>发布于掘金 <a href="https://juejin.im/post/59420951128fe1006a1960f8" target="_blank" rel="noopener">https://juejin.im/post/59420951128fe1006a1960f8</a></p></blockquote></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>lsvih</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/" title="用 Go 语言理解 Tensorflow">https://lsvih.com/2017/06/15/用-Go-语言理解-Tensorflow/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Translate/" rel="tag"># Translate</a> <a href="/tags/juejin/" rel="tag"># juejin</a> <a href="/tags/python/" rel="tag"># python</a> <a href="/tags/Machine-Learning/" rel="tag"># Machine Learning</a> <a href="/tags/Go/" rel="tag"># Go</a> <a href="/tags/Tensorflow/" rel="tag"># Tensorflow</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/06/11/Reinforcement-Learning-notes-1/" rel="next" title="Reinforcement Learning notes(1)"><i class="fa fa-chevron-left"></i> Reinforcement Learning notes(1)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/06/30/在html中使用背景透明的video视频/" rel="prev" title="在html中使用背景透明的video视频">在html中使用背景透明的video视频 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">lsvih</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">140</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">167</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lsvih" title="GitHub &rarr; https://github.com/lsvih" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:lsvih@qq.com" title="E-Mail &rarr; mailto:lsvih@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-封装"><span class="nav-number">2.</span> <span class="nav-text">Go 封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解-Tensorflow-的结构"><span class="nav-number">3.</span> <span class="nav-text">理解 Tensorflow 的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-1-课：node-IDs"><span class="nav-number">4.</span> <span class="nav-text">第 1 课：node IDs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#提问时间："><span class="nav-number">4.0.1.</span> <span class="nav-text">提问时间：</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#第-2-课：作用域"><span class="nav-number">5.</span> <span class="nav-text">第 2 课：作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#提问时间：-1"><span class="nav-number">5.0.1.</span> <span class="nav-text">提问时间：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-3-课：Tensorflow-类型系统"><span class="nav-number">6.</span> <span class="nav-text">第 3 课：Tensorflow 类型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#提问时间：-2"><span class="nav-number">6.0.1.</span> <span class="nav-text">提问时间：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number"></span> <span class="nav-text">总结</span></a></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-"></i> </span><span class="author" itemprop="copyrightHolder">lsvih</span></div><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.5.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.5.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>